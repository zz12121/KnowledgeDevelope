###### 1. 什么是 BASE 理论？
BASE理论是分布式系统设计的实践原则，由eBay架构师Dan Pritchett在2008年提出，作为CAP理论中一致性和可用性权衡的延伸。其核心思想是**放弃强一致性，允许系统在一定时间内处于中间状态，但最终保证数据一致**，从而获得高可用性。
- **基本可用**：指分布式系统在发生故障时，允许损失部分非核心功能的可用性，但核心功能必须保持可用。例如，电商系统在大促期间可能将用户引导至降级页面，或牺牲响应时间（如搜索接口从0.5秒延迟至2秒响应），但核心交易流程仍可运作。
- **软状态**：允许数据在同步过程中存在**中间状态**，即不同节点的数据副本可以暂时不一致。例如，MySQL主从异步复制时，从库可能短暂落后于主库，但这不影响主库提供写入服务。
- **最终一致性**：系统保证在经过一段时间的同步后，所有数据副本最终会达成一致状态。这是BASE理论的最终目标，其时间窗口取决于网络延迟、系统负载等因素。
**与ACID的对比**：BASE理论面向高并发分布式系统（如电商、社交网络），强调可用性和扩展性；而ACID适用于传统数据库事务，追求强一致性
###### 2. CAP 和 BASE 的关系是什么？
CAP定理定义了分布式系统的根本约束，而BASE理论是CAP中**AP方案的工程实践延伸**。
- **CAP定理**指出一致性、可用性、分区容错性三者不可兼得。分布式系统必须选择牺牲其中一项：
    - **CP系统**（如ZooKeeper）：保证一致性，但节点故障时可能不可用。
    - **AP系统**（如Eureka）：保证可用性，但允许数据短暂不一致。
- **BASE理论**为AP系统提供了设计范式，通过**最终一致性替代强一致性**，实现高可用。例如，在网络分区恢复后，系统通过异步同步机制逐步达到数据一致。
###### 3. 什么是最终一致性？
最终一致性是弱一致性的特殊形式，指系统在数据更新后，不保证立即一致性，但承诺**最终所有副本会达成一致**。其实现依赖异步复制和冲突解决机制。
**客户端层面的变种**：
1. **因果一致性**：有因果关系的进程必须读到最新数据（如用户A回复用户B后，B总能看到A的回复）。
2. **读己之所写**：用户总能读到自己的最新更新（如发布文章后立即查看）。
3. **会话一致性**：同一会话内保证"读己之所写"。
4. **单调读一致性**：用户每次读取的数据不会比之前更旧。
5. **单调写一致性**：同一用户的写操作按顺序执行。
**服务端层面的控制参数**：
- **N**：数据副本总数。
- **W**：写操作需成功的副本数。
- **R**：读操作需查询的副本数。
    当 **W + R > N**​ 时，可保证强一致性；若 **W + R ≤ N**，则为弱一致性（最终一致性）。
###### 4. 什么是强一致性、弱一致性？
- **强一致性**：任意时刻的读写操作都能返回最新数据，所有节点数据实时同步。实现方式包括：
    - **WARO协议**：写操作需成功更新所有副本，否则失败。
    - **Quorum机制**：定义最小读写副本数（如W=3、R=2、N=5），确保读写重叠。
        适用场景：银行转账、库存扣减等金融业务。
- **弱一致性**：更新后不承诺立即同步，系统可能返回旧数据。最终一致性是其子类，但保证了"最终一致"的结果。适用场景：社交网络点赞、消息推送等容忍延迟的场景。
**对比总结**：

|特性|强一致性|弱一致性（最终一致性）|
|---|---|---|
|数据同步|实时同步|异步同步|
|性能|低吞吐、高延迟|高吞吐、低延迟|
|场景|金融、交易|互联网应用（如电商、社交）|
###### 5. 什么是 Paxos 算法？
Paxos是分布式共识算法，用于在不可靠网络中实现节点间状态一致性。其核心角色包括：
- **Proposer**：接收客户端请求，发起提案。
- **Acceptor**：对提案进行投票表决。
- **Learner**：学习已通过的提案值。
**执行流程**：
1. **Prepare阶段**：Proposer生成全局递增的提案ID，向多数Acceptor发送Prepare请求。
2. **Promise阶段**：Acceptor收到请求后，若提案ID大于已响应的ID，则承诺不再接受更小ID的提案。
3. **Accept阶段**：Proposer收到多数Acceptor的Promise后，发送带值的Accept请求。
4. **Learn阶段**：Acceptor接受提案后，Learner同步值到所有节点。
Paxos的难点在于工程实现复杂，Multi-Paxos等优化用于提升性能。
###### 6. 什么是 Raft 算法？
Raft是Paxos的改进版，通过**分解问题**（领导选举、日志复制、安全性）提升可理解性。
**核心机制**：
1. **领导选举**：
    - 节点角色：Leader、Follower、Candidate。
    - 任期机制：每个任期最多一个Leader，通过随机超时避免选举冲突。
    - 投票规则：Follower仅投票给日志比自身新的Candidate。
2. **日志复制**：
    - Leader接收写请求，追加日志后向Follower同步。
    - 当日志复制到多数节点后，Leader提交日志并应用状态机。
3. **安全性**：
    - 仅包含已提交日志的节点可当选Leader。
    机应用日志需保证顺序性。
**Java实现参考**：如Apache Ratis库提供了Raft算法的生产级实现。
###### 7. Paxos 和 Raft 的区别是什么？

|维度|Paxos|Raft|
|---|---|---|
|**理解难度**​|理论抽象，工程实现复杂|分解为子问题，易于实现|
|**领导选举**​|无固定Leader，节点平等|强Leader机制，日志仅由Leader同步|
|**日志提交**​|允许日志空洞，需额外排序|连续提交，保证日志顺序性|
|**工程友好性**​|需大量优化才能应用|直接提供完整实现方案|
Raft通过**强Leader简化逻辑**，例如客户端请求仅由Leader处理，而Paxos允许多点写入，需额外合并冲突。
###### 8. 什么是拜占庭将军问题？
拜占庭将军问题是分布式容错领域的抽象模型，描述在**节点可能恶意篡改消息**（拜占庭错误）时，如何达成共识。
- **非拜占庭容错**：如Paxos/Raft，仅处理节点宕机或网络错误。
- **拜占庭容错**：需容忍节点作恶（如区块链中的恶意节点），通常需至少 **3f+1**​ 个节点容错f个故障节点。
    BFT算法（如PBFT）通过三阶段投票验证消息真实性，但性能开销较大。
###### 9. 什么是 ZAB 协议？
ZAB是ZooKeeper的核心共识协议，专为**主从架构**设计，保证写操作的全局顺序。
**阶段分解**：
1. **选举阶段**：节点通过Fast Leader Election机制，选择具有最新日志的节点作为Leader。
2. **发现阶段**：Follower与Leader同步最新事务ID（ZXID）。
3. **同步阶段**：Leader将未提交的日志同步给Follower，达成多数后提交。
4. **广播阶段**：Leader接收写请求，按ZXID顺序广播日志。
与Raft对比：ZAB在选举时优先考虑日志完整性，而Raft优先比较任期。
###### 10. 分布式系统中如何实现顺序一致性？
顺序一致性要求**所有节点看到相同的操作顺序**，且顺序符合程序逻辑。实现方案包括：
1. **全局有序广播**：如ZooKeeper的ZAB协议或Raft的日志复制，通过Leader序列化写请求。
2. **逻辑时钟**：使用向量时钟（Vector Clock）标记操作因果顺序，解决并发写冲突。
3. **Quorum机制**：配置W=N、R=1，确保写操作同步到所有副本，读任意副本均获最新值。
**Java实践示例**：
- 基于ZooKeeper的分布式锁，通过临时顺序节点保证操作的全局顺序。
- 数据库中间件（如ShardingSphere）通过主库同步写+从库异步读，保证同一会话内的读己之所写一致性。