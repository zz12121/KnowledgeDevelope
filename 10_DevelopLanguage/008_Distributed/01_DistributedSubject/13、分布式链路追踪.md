###### 1. 常见的链路追踪系统有哪些？
主流的开源链路追踪系统主要包括以下几类，它们均基于 Google Dapper 论文的设计理念：
- **Zipkin**：由 Twitter 开源，基于 Dapper 论文的经典实现。采用组件化设计（Collector, Storage, Query Service, UI），支持多种存储后端（如 Elasticsearch, Cassandra），通过轻量级的 `Brave`客户端库进行埋点。其设计简洁，是理解链路追踪原理的标杆。
- **SkyWalking**：国人开源，Apache 顶级项目。核心特点是**基于字节码增强的无侵入式探针**，对业务代码零修改即可实现链路、指标、拓扑图的收集。提供强大的 UI 和告警功能，在云原生和微服务领域应用广泛。
- **Jaeger**：由 Uber 开源，现为 CNCF 项目。设计上兼容 OpenTracing API，强调云原生和可扩展性，原生支持 gRPC 通信和多种存储（Cassandra, Elasticsearch）。其客户端库对 Go 和 Java 支持良好。
- **Pinpoint**：由 Naver 开源，与 SkyWalking 类似，采用基于字节码的**无侵入式**方案。其特点是将调用链（Trace）和调用栈（Profiling）深度结合，提供详细的代码级性能洞察，但架构较重，资源消耗相对较高。
- **Cat**：由美团开源，更偏向于实时应用监控平台，不仅包含链路追踪，还集成丰富的指标统计和告警功能。其客户端需要一定的代码埋点。
**选型参考**：若追求无侵入、易集成和强大的可观测性，首选 **SkyWalking**。若团队已深度使用 OpenTracing/OpenTelemetry 标准，或技术栈以 Go 为主，**Jaeger**​ 是良好选择。**Zipkin**​ 则适合作为理解原理或轻量级集成的起点。
###### 2. Zipkin 的工作原理是什么？
Zipkin 的工作流程遵循经典的 **收集-传输-存储-查询**​ 模型，其核心是 **Span**​ 的生成、传播和上报。
**1. 数据生成与传播（客户端 - Brave 库）**：
- 当请求进入服务时，`TracingFilter`（Servlet 过滤器）或类似拦截器会检查请求头（如 `X-B3-TraceId`）。如果不存在，则生成一个全局唯一的 **Trace ID**；如果存在，则说明该请求已是某个追踪的一部分，沿用该 Trace ID。
- 同时，为本次服务调用创建一个 **Span**，并生成 Span ID。通过 `Inject`操作，将 Trace ID、Span ID、Parent Span ID 等信息注入到请求的上下文（如 HTTP Headers）中，随请求传递至下游服务。
- 在服务内部，如果发起新的远程调用（如通过 RestTemplate），Brave 的拦截器（`TracingInterceptor`）会执行 `Inject`操作，将链路上下文继续传递。
- 当请求处理完成，Span 会被标记结束时间，并异步上报给 Zipkin Collector。
**2. 数据上报与处理（Zipkin 服务端）**：
- **Collector**：接收各客户端通过 HTTP 或消息队列（如 Kafka）上报的 Span 数据，进行验证和索引，然后存储。
- **Storage**：提供可插拔的存储后端，如内存（仅测试）、Elasticsearch（用于生产搜索）、Cassandra（高写入场景）。
- **Query Service**：提供 API 供 UI 查询 Trace 数据。
- **UI**：可视化展示调用链详情。
**源码角度（以 Brave 为例）**：
- `Tracer`类是核心，其 `newTrace()`或 `nextSpan()`方法负责创建或继承追踪上下文。
- `Span`接口的实现类 `RealSpan`记录了操作名称、时间戳、标签和注解。
- 传播的关键在 `TraceContext.Injector`和 `Extractor`，例如 `B3Propagation`定义了如何将上下文编码到 HTTP 头。
- 上报逻辑在 `AsyncReporter`中，它使用一个后台线程（或 `Sender`，如 `OkHttpSender`）批量将 Span 数据发送到 Zipkin 服务器。
###### 3. SkyWalking 和 Zipkin 的区别是什么？
区别主要体现在设计理念、实现机制和功能生态上。

|维度|Zipkin|SkyWalking|
|---|---|---|
|**核心设计**​|**追踪为核心**，专注于分布式调用链的收集与可视化。|**APM 系统**，以追踪为基础，集成度量指标、拓扑图、日志、告警等。|
|**埋点方式**​|**库模式/手动埋点**。依赖集成 `Brave`等客户端库，需在代码或框架配置中显式引入。对代码有侵入性。|**探针模式/无侵入**。通过 Java Agent 在 JVM 启动时进行**字节码增强**，修改类加载的字节码，自动拦截关键方法（如 HTTP 客户端、数据库驱动、Spring MVC 控制器）。业务代码零修改。|
|**数据模型**​|相对简单，核心是 **Span**。一个 Trace 由一组 Span 组成。|更丰富，引入了 **Segment**​ 概念。一个 Segment 是单个服务实例内的一次请求轨迹，包含多个 **Span**（代表一个方法栈）。这种模型更适合表达代码层级和性能剖析。|
|**上下文传播**​|通常通过 **HTTP Headers**（如 B3 格式：`X-B3-TraceId`）在服务间传递。|使用自研的 **Context Carrier**，可通过 HTTP Headers、gRPC Metadata、消息队列头等多种载体传播。|
|**性能开销**​|较低，因为埋点相对轻量。|略高，因为字节码增强会创建额外的类和方法，但经过优化，生产环境开销通常可接受（<3%）。|
|**生态系统与 UI**​|UI 相对基础，专注于链路展示。生态围绕 OpenTracing/OpenTelemetry。|UI 功能强大，提供**拓扑图**、服务/实例/端点指标仪表盘、**性能剖析**、日志关联和告警。生态更偏向于一体化的可观测性。|
|**存储与查询**​|支持多种存储，查询 API 相对直接。|默认使用 Elasticsearch 或 H2，其查询服务针对拓扑和聚合指标做了大量优化。|
**总结**：Zipkin 是经典的、专注的追踪工具，适合作为组件集成到现有监控体系中。SkyWalking 是功能全面的 APM 平台，其无侵入特性大幅降低了接入和维护成本，是目前国内微服务监控的主流选择之一。
###### 4. 什么是 TraceId 和 SpanId？
它们是链路追踪数据模型中最核心的两个标识符，用于唯一标识和串联一次完整的分布式请求。
- **TraceId**：**全局链路标识**。在一次完整的分布式业务请求中（例如，用户从前端发起一个下单请求，该请求会经过网关、订单服务、库存服务、支付服务），所有相关的调用都共享**同一个 TraceId**。它像一根绳子，将散落在各个服务中的日志和性能数据串联起来，形成一个完整的调用链。TraceId 通常在请求的入口处（如网关或第一个接收请求的服务）生成。
- **SpanId**：**跨度标识**。它代表一个**工作单元**，即服务内部处理某个操作或调用另一个服务的过程。每个 Span 都有一个唯一的 SpanId。
    - **ParentSpanId**：指向上游直接调用者的 SpanId。通过 TraceId、SpanId 和 ParentSpanId，可以构建出一棵**调用树**，清晰地展示出服务的调用层级和父子关系。
    - **RootSpan**：整个调用链的第一个 Span，其 ParentSpanId 为空。
**示例与生成规则**：
一个典型的调用链：`用户 -> 网关(A) -> 订单服务(B) -> 库存服务(C)`
- 网关A收到请求，生成 `TraceId: T1`，并创建 `SpanId: S1`（Root Span）。
- 网关A调用订单服务B，将 `T1`和 `S1`通过 HTTP Header 传递过去。
- 订单服务B收到后，创建属于本次调用的 `SpanId: S2`，并记录 `ParentSpanId: S1`。
- 订单服务B调用库存服务C，传递 `T1`和 `S2`。
- 库存服务C创建 `SpanId: S3`，记录 `ParentSpanId: S2`。
最终，通过 `T1`可以查到整个链路 `[S1 -> S2 -> S3]`，并能通过 Parent 关系还原调用树。生成算法通常使用全局唯一的随机数（如 Snowflake 算法、UUID）。
###### 5. 如何在微服务中集成链路追踪？
集成链路追踪是一个系统性工作，主要分为 **探针接入**、**上下文传播**​ 和 **后端服务部署**​ 三部分。以下以 **SkyWalking**​ 为例说明主流实践：
**1. 部署 SkyWalking 后端**：
- 部署 OAP Server（负责接收、聚合、分析数据）和 UI。
- 配置存储，通常选择 Elasticsearch。
**2. 微服务应用接入（无侵入式 - 推荐）**：
- **方式一：Java Agent 启动参数**（最常用）
    在应用启动脚本的 JAVA_OPTS 中加入 Agent：
    ```bash
    -javaagent:/path/to/skywalking-agent.jar
    -DSW_AGENT_NAME=your-service-name
    -DSW_AGENT_COLLECTOR_BACKEND_SERVICES=oap-server-host:11800
    ```
    这种方式无需修改任何应用代码和依赖，由 Agent 自动完成对主流框架（Spring Cloud, Dubbo, HttpClient, JDBC, Redis等）的埋点。
- **方式二：容器/Kubernetes 集成**
    在 Dockerfile 或 K8s 的 Pod YAML 中，将 Agent JAR 作为 Init Container 挂载，并通过环境变量配置 Agent 参数。
**3. 确保上下文传播**：
- 对于 HTTP 调用，Agent 会自动拦截并注入/提取 `sw8`等头部信息。
- 对于消息队列（如 Kafka, RocketMQ），需要确保消息头中包含链路上下文。SkyWalking Agent 已支持主流 MQ 客户端的自动增强。
- 对于非标准组件或需要手动埋点，可使用 SkyWalking 提供的 `TracingContext`API 手动创建本地 Span 或跨进程传播。
**4. 数据验证与监控**：
- 启动服务后，在 SkyWalking UI 中查看服务、实例是否注册成功。
- 发起业务请求，在 UI 的“追踪”页面查看调用链是否完整生成。
- 配置告警规则（如服务响应时间过长、错误率过高）。
**对于 Zipkin（库模式）的集成**：
1. 在每个微服务的 `pom.xml`中引入 Brave 对 Spring Cloud 的集成依赖（如 `spring-cloud-starter-sleuth`和 `spring-cloud-sleuth-zipkin`）。
2. 在配置文件中指定 Zipkin 服务器地址 (`spring.zipkin.base-url`) 和采样率。
3. Sleuth 会自动配置 Brave，为 RestTemplate, Feign, Spring MVC 等组件注入追踪逻辑，并上报数据到 Zipkin。
**核心要点**：无论选择哪种方案，关键在于保证 **TraceId 和 Span 上下文能够跨服务、跨线程、跨异步边界正确传递**。无侵入方案（SkyWalking Agent）大幅降低了维护成本，是生产环境的优先选择。