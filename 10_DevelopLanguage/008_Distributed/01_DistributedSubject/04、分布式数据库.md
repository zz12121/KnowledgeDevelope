###### 1. 什么是分库分表？
分库分表是解决单数据库性能瓶颈的分布式数据存储方案。**分库**指将数据分散到多个数据库中，**分表**指将单个表拆分为多个表。其核心目标是解决数据量过大导致的性能下降问题，通过水平或垂直拆分提升系统的扩展性和并发处理能力。实际应用中，通常结合业务场景先进行垂直拆分（按业务模块），再进行水平拆分（按数据量）。
###### 2. 垂直分库和水平分库的区别是什么？

|**维度**​|**垂直分库**​|**水平分库**​|
|---|---|---|
|**拆分依据**​|按业务模块划分（如用户库、订单库）|按数据行分布规则划分（如用户ID取模）|
|**数据特点**​|不同库的表结构不同|不同库的表结构完全一致|
|**核心目标**​|解耦业务，降低耦合度|解决单库数据量过大与高并发压力|
|**典型挑战**​|跨库关联查询复杂（需通过接口避免JOIN）|数据迁移扩容困难，跨库事务一致性难保证|
**设计取舍**：垂直分库优先在架构设计阶段实施，以业务清晰度为首要考量；水平分库则在数据量达到单库极限时作为扩展手段。
###### 3. 垂直分表和水平分表的区别是什么？

|**维度**​|**垂直分表**​|**水平分表**​|
|---|---|---|
|**拆分粒度**​|按字段（列）拆分，将宽表拆为多个窄表|按数据行拆分，将大表数据分散到多个结构相同的子表|
|**适用场景**​|表字段多，含大字段（如TEXT/BLOB）或冷热字段明显|单表数据量巨大（如千万级以上），需均衡I/O压力|
|**性能优化点**​|减少单行数据宽度，提升单页数据行数，减少IO|减小单表数据量，提升查询与索引效率|
|**带来的问题**​|需频繁进行表关联查询（JOIN），可能增加复杂度|跨表查询需合并结果，分页与排序复杂|
**Java应用中的实践**：垂直分表可通过JPA的`@SecondaryTable`或MyBatis的结果映射处理关联查询；水平分表则依赖分片键（如用户ID）路由到具体子表。
###### 4. 分库分表后如何进行分页查询？
分页查询在分片环境下是典型难题，尤其是跨多库表时。**逻辑分页**（如`LIMIT 10000, 20`）直接使用会导致性能问题。常用方案包括：
- **全局视野法**：查询每个分片，在内存中汇总排序后截取所需分页。例如查询第100页（每页20条），需每个分片返回前`100 * 20=2000`条数据，汇总后取第1981-2000条。该方法准确性高，但资源消耗随页码增大而剧增。
- **二次查询法（优化）**：首先在各分片查询当前页码范围内的数据（如第100页的20条），同时获取该页数据在各分片的边界值。然后发起第二次查询，修正数据偏移。此法可减少网络传输，但需两次查询。
- **允许精度损失**：某些业务场景可接受近似分页（如搜索引擎），通过抽样估算总量，但牺牲准确性。
**ShardingSphere的实现**：在`ShardingStatement`和`ShardingPreparedStatement`的执行逻辑中，对`LIMIT`进行改写。例如，将`LIMIT 10000, 20`改写为各分片`LIMIT 0, 10020`，然后在内存归并阶段（`OrderByStreamMergedResult`）进行排序和范围截取。
###### 5. 分库分表后如何进行排序？
排序与分页常相伴出现，核心挑战在于**全局有序**。当排序字段非分片键时，需进行**内存排序**（`MemoryMergedResult`）。
- **排序字段为分片键**：若排序顺序与分片规则一致（如按时间范围分片并按时间排序），则可直接路由到特定分片查询，效率最高。
- **排序字段非分片键**：需从各分片拉取数据，在内存中归并排序。`ShardingSphere`的`OrderByStreamMergedResult`使用堆排序（最小堆/最大堆）进行多路归并，保证在流式返回时也能高效处理。
- **性能考量**：避免`SELECT *`，尽量缩小排序数据集。若排序需求频繁，可考虑将排序字段设为分片键或使用全局索引（如Elasticsearch）。
###### 6. 什么是数据库中间件？常见的有哪些？
数据库中间件是位于应用与数据库之间的抽象层，**透明化**分库分表、读写分离等操作的复杂性。其核心价值在于让开发者像操作单库单表一样操作分布式数据库集群。可分为两大类：
- **JDBC驱动层（客户端）中间件**：
    - **代表**：ShardingSphere-JDBC（原Sharding-JDBC）、TDDL（阿里）。
    - **原理**：以JAR包形式嵌入应用，对应用代码透明，拦截JDBC操作并进行路由、改写等。性能损耗较小（通常<7%），但仅支持Java语言。
- **Proxy代理层中间件**：
    - **代表**：MyCat、ShardingSphere-Proxy、MySQL Router。
    - **原理**：独立进程部署，应用连接代理，代理再转发请求至真实数据库。支持多语言，对应用侵入性低，但增加网络跳转，性能有损耗。
**选型考量**：Java技术栈且追求性能可选JDBC驱动层；多语言异构环境或希望语言无关则选Proxy层。
###### 7. ShardingSphere 的核心功能是什么？
ShardingSphere的核心功能围绕**数据分片**和**读写分离**构建，其架构设计精巧，通过可插拔内核实现高度扩展性。
- **数据分片**：是其最核心功能。工作流程如下：
    1. **SQL解析**：使用ANTLR解析SQL，生成抽象语法树（AST），提取分片上下文（表、条件、排序等）。
    2. **SQL路由**：根据分片策略（`ShardingStrategy`）和分片键值，确定目标数据节点（`DataNode`）。支持直接路由、标准路由（含绑定表优化）和笛卡尔积路由。
    3. **SQL改写**：将逻辑SQL改写为可在真实节点执行的SQL，包括补列（如`ORDER BY`字段）、表名替换等。
    4. **SQL执行**：通过`ExecutorEngine`支持连接限制模式（OLTP，避免连接爆炸）和内存限制模式（OLAP，最大化并发），自动选择执行模式。
    5. **结果归并**：将多个数据节点的结果集进行归并，支持流式归并（如`OrderByStreamMergedResult`）和内存归并（`MemoryMergedResult`）。
- **读写分离**：透明化主从架构，根据SQL类型（DML/DQL）自动路由到主库或从库，支持负载均衡策略。
- **分布式事务**：支持XA（如Atomikos）和BASE（Seata的AT模式）事务，保证跨分片数据一致性。
- **分布式主键**：内置雪花算法（Snowflake）生成全局唯一ID，解决主键冲突问题。
###### 8. 分库分表后如何解决跨库事务问题？
跨库事务本质是**分布式事务**问题，需突破单机ACID，寻求分布式环境下的一致性保证。
- **强一致性方案（刚性事务）**：
    - **XA协议**：基于两阶段提交（2PC）。TM（事务管理器）协调多个RM（资源管理器）进行投票（Prepare）和提交（Commit）。ShardingSphere可集成Atomikos等实现。优点保证强一致，但同步阻塞，性能低，不适合高并发。
- **最终一致性方案（柔性事务）**：
    - **TCC（Try-Confirm-Cancel）**：针对每个业务操作编写Try（预留资源）、Confirm（确认执行）、Cancel（取消预留）三个接口。通过事务日志和重试机制保证最终一致。适用于核心业务，但对业务侵入性强。
    - **SAGA**：长事务解决方案，将分布式事务拆解为一系列本地事务，每个事务有对应的补偿动作。适用于业务流程长、可补偿的场景。
    - **基于消息队列**：将次要操作异步化，通过消息队列保证最终一致。例如，下单扣库存后，发送消息异步更新积分。需业务容忍延迟。
- **最佳实践**：根据业务容忍度选择。强资金相关可用XA/TCC；大多数场景可接受最终一致性，结合消息队列和补偿机制。
###### 9. 如何平滑地进行数据库迁移？
平滑迁移的核心原则是**避免停机**和**保证数据一致性**。常用**双写迁移**方案：
1. **迁移前准备**：
    - 停写前，保持旧库单写，并记录增量日志（如binlog位点）。
    - 部署新库集群（分库分表后），并保持空状态。
2. **全量迁移**：将旧库历史数据同步至新库。工具可选DataX、Canal等。需记录同步截止点。
3. **增量双写**：
    - 开启双写：应用同时向旧库和新库写入数据。
    - 对比校验：通过数据对比工具（如阿里云DTS）校验双写数据一致性，修复差异。
4. **灰度切读**：
    - 将部分非核心业务或用户的读请求切到新库，观察稳定性和性能。
    - 逐步扩大读流量比例，直至全部读请求指向新库。
5. **停旧库写**：确认新库数据完全一致且稳定后，停止向旧库写入，完成迁移。
**注意事项**：双写时需处理写失败回滚，避免数据不一致。迁移过程需可逆，备有一键回切方案。
###### 10. 什么是读写分离？如何实现？
读写分离将数据库的**写操作**（INSERT/UPDATE/DELETE）指向主库，**读操作**（SELECT）指向一个或多个从库，通过主从复制同步数据。其核心价值在于**分摊主库压力**，提升系统读吞吐量。
**实现方式**：
- **应用层实现**：在ORM框架（如MyBatis）或数据源层（Spring AbstractRoutingDataSource）根据方法注解或SQL类型动态切换数据源。
- **中间件实现**：
    - **JDBC驱动层**：如ShardingSphere，在数据源代理层自动路由。
    - **Proxy代理层**：如MyCat，应用连接代理，由代理转发。
- **数据库驱动实现**：如MySQL Connector/J的ReplicationDriver，可配置主从URL，驱动内部根据读写操作类型路由。
###### 11. 读写分离可能带来哪些问题？
- **数据同步延迟**：主从异步复制导致从库数据滞后，用户可能读不到刚写入的数据。
    - **解决方案**：
        - **写后强制读主**：对一致性要求高的读操作（如查询订单详情）指定走主库。
        - **基于位点或GTID的延迟监控**：避免从延迟过大的从库读取。
        - **半同步复制**：牺牲部分写性能，保证至少一个从库同步完成。
- **主从负载不均衡**：若读远大于写，可能导致从库负载过高。
- **从库故障**：单个从库故障影响读可用性。
    - **解决方案**：读负载均衡组件需具备故障自动剔除与恢复检测能力。
###### 12. 什么是分布式数据库？
分布式数据库是数据**物理分散**在多个网络节点，但**逻辑统一**的数据库系统。其核心特性包括：
- **数据分片**：数据按一定策略分布存储。
- **透明访问**：用户无需关心数据物理位置。
- **高可用与容错**：通过副本机制保证节点故障时数据不丢失、服务不间断。
**分类**：
- **分库分表+中间件**：如TiDB、CockroachDB，提供NewSQL特性。
- **云原生分布式数据库**：如AWS Aurora、PolarDB，计算与存储分离，共享存储池。
###### 13. NewSQL 数据库是什么？
NewSQL是兼具**NoSQL扩展性**和**传统关系型数据库ACID特性**的现代分布式数据库。其核心价值在于**无需在一致性、扩展性和可用性上做显著妥协**。
**核心特性**：
- **分布式架构**：原生支持水平扩展，自动数据分片与负载均衡。
- **强一致性**：通过Raft或Paxos等共识算法保证多副本数据强一致。
- **SQL兼容**：完整支持SQL标准与ACID事务，降低迁移成本。
- **高可用**：自动故障检测与切换，故障恢复时间短（RTO<30s）。
**代表产品**：Google Spanner、TiDB、CockroachDB。以TiDB为例，其架构分为：
- **TiDB Server**：无状态SQL计算层，处理连接与SQL解析。
- **PD（Placement Driver）**：元数据管理与调度中心。
- **TiKV**：分布式键值存储引擎，数据分片存储在Region中，通过Raft协议保证一致性。