###### 1. 什么是 TCC 事务模型？
TCC（Try-Confirm-Cancel）是一种应用层设计的柔性分布式事务模型，通过业务逻辑分解来实现最终一致性。其核心是将一个分布式事务拆分为两个阶段，共三个操作：
- **Try阶段**：完成所有业务的资源检查和预留。例如，在订单-库存场景中，Try操作可能包括：1. 冻结订单状态为“处理中”；2. 预扣库存（将可用库存减少，冻结库存增加）；3. 预扣优惠券状态。此阶段需保证所有参与者资源预留成功，否则进入Cancel。Try操作必须满足幂等性。
- **Confirm阶段**：在Try全部成功后执行，进行真正的业务提交。此操作基于Try预留的资源，必须保证最终一致性且幂等。如上例中：1. 确认订单为“已支付”；2. 清除冻结库存；3. 核销优惠券。
- **Cancel阶段**：在Try任一失败时执行，用于释放Try阶段预留的资源，也必须保证幂等。如上例中：1. 将订单状态置为“已取消”；2. 释放预扣库存（冻结库存加回可用库存）；3. 解冻优惠券。
从源码实现角度看，以主流的`seata`框架为例，TCC模式通过`@TwoPhaseBusinessAction`注解定义Try方法，并通过`BusinessActionContext`传递上下文。全局事务管理器（`DefaultCore`) 协调所有参与者，Try阶段调用`TccActionInterceptor`进行拦截并注册分支事务记录。Confirm/Cancel阶段由事务管理器根据Try结果发起调用。关键设计在于每个服务都需要实现Try、Confirm、Cancel三个方法，框架负责保证二阶段的最终调用。
###### 2. TCC 和 2PC 的区别是什么？
- **协议层次与锁定机制**：2PC（两阶段提交）是数据库或资源管理器层面的协议（如XA），通过在Prepare阶段锁定数据库行或表来保证强一致性，属于刚性事务。TCC是业务应用层模型，通过业务资源的“预留”（如状态字段）实现，不依赖数据库锁，属于柔性事务。
- **性能与阻塞**：2PC的Prepare阶段持有数据库锁直至Commit，在高并发长事务下易导致死锁和性能瓶颈。TCC的Try阶段仅进行资源预留（如设置状态），耗时短，锁竞争小，Confirm/Cancel阶段可异步执行，吞吐量更高。
- **数据一致性**：2PC追求强一致性（ACID）。TCC通过业务设计保证最终一致性，允许中间状态可见（如“处理中”）。
- **业务侵入性**：2PC对业务几乎无侵入，由资源管理器（如数据库）实现。TCC需要业务显式编写Try、Confirm、Cancel三个逻辑，侵入性强。
- **适用场景**：2PC适用于短事务、低并发、需要强一致的内部系统（如传统银行核心）。TCC适用于高并发、长业务流程的互联网场景（如电商、出行）。
###### 3. 什么是 Seata？它支持哪些事务模式？
Seata（Simple Extensible Autonomous Transaction Architecture）是阿里开源的分布式事务解决方案，提供了对业务无侵入或低侵入的事务协调能力。它支持四种主流事务模式：
1. **AT模式（Automatic Transaction）**：默认且最常用的模式。基于支持本地ACID事务的关系型数据库（如MySQL、PostgreSQL），通过拦截并解析SQL，生成前后镜像形成回滚日志（undo_log），实现自动补偿。一阶段提交本地事务并生成快照，二阶段异步删除快照（提交）或根据快照回滚（回滚）。对业务零代码侵入。
2. **TCC模式**：如前所述，需要业务实现Try、Confirm、Cancel接口。Seata的TCC框架负责管理全局事务上下文和调用二阶段方法。
3. **Saga模式**：适用于长业务流程，每个参与者提交本地事务，并通过编排（状态机）定义正向服务和补偿服务。一旦某个节点失败，则逆序调用已执行节点的补偿服务。Seata Saga通过状态机引擎（`StateMachineEngine`）执行，支持可视化编排。
4. **XA模式**：基于数据库或资源管理器对XA协议的原生支持，实现强一致性。Seata充当事务管理器（TM），协调数据库（RM）完成两阶段提交。
###### 4. AT 模式和 TCC 模式的区别是什么？
- **实现原理**：AT模式基于数据库本地事务和SQL反向补偿。在Seata中，`ConnectionProxy`拦截SQL，通过`TableMetaCache`获取元数据，并利用`UndoLogManager`在提交前生成`before image`和`after image`存入`undo_log`表。TCC模式基于业务接口的显式定义。
- **侵入性**：AT模式对业务无侵入，仅需在数据库中添加`undo_log`表并配置数据源代理。TCC需要业务代码显式实现三个接口。
- **锁机制**：AT模式一阶段提交后即释放本地数据库锁，通过全局锁（Seata的`global_lock`表）防止其他全局事务修改同一行数据。TCC通过业务资源预留（如状态字段）实现“软锁”，无数据库锁竞争。
- **适用范围**：AT模式仅适用于支持ACID事务的关系型数据库。TCC模式可适用于任何可定义预留/确认/取消语义的资源，如Redis、MQ消息、外部API调用。
- **性能与复杂度**：AT模式开发简单，但SQL解析和镜像生成有性能开销。TCC模式性能更优（无SQL解析），但业务设计复杂，需考虑空回滚、幂等、悬挂等异常处理。
###### 5. 本地消息表方案的实现原理是什么？
本地消息表（也称为事务消息表）是一种利用数据库事务和消息队列实现最终一致性的经典方案。其核心是“将分布式事务拆分为本地事务+异步消息”。
**实现原理步骤如下**：
1. **消息生产方**：
    - 在执行业务的同一个数据库事务中，向本地`transaction_message`表插入一条状态为“待发送”的消息记录。该表至少包含`id`、`biz_data`、`status`、`retry_count`等字段。
    - 业务事务提交后，通过后台定时任务扫描`status='pending'`的消息。
    - 将消息发送到消息队列（如RocketMQ/Kafka）。如果发送成功，将本地消息状态更新为“已发送”；如果失败，根据`retry_count`进行重试。
2. **消息消费方**：
    - 从消息队列消费消息。
    - 执行业务逻辑。成功后，向生产方发送一个“消费确认”消息（或调用一个确认接口）。
    - 生产方收到确认后，将本地消息状态置为“已完成”。
        **关键设计**：
    - **保证生产方本地事务与存消息的原子性**：依赖于同一个数据库事务。
    - **消息可靠投递**：通过定时任务重试和`retry_count`上限保证。
    - **幂等消费**：消费方需根据消息ID（如业务唯一键）进行判重，防止重复处理。
    - **对账补偿**：极端情况下（如消息丢失），需要额外的对账任务，根据业务数据和消息表状态进行兜底同步。
###### 6. 分布式事务的性能开销如何优化？
分布式事务的性能开销主要来源于网络通信、资源锁定、日志记录和协调过程。优化策略需结合具体模式：
1. **选择合适的模式**：
    - 对强一致性要求不高的场景，优先使用最终一致性方案（如本地消息表、Saga），避免同步阻塞。
    - 读多写少场景，可考虑AT模式，因其一阶段即提交，读操作无阻塞。
    - 高性能复杂业务，选用TCC模式，其Try阶段可快速完成，Confirm/Cancel可异步化。
2. **减少事务粒度与时长**：
    - 将大事务拆分为多个小事务，避免长事务持有锁过久。
    - 在TCC的Try阶段，仅进行轻量级资源预留，快速释放本地资源。
3. **异步化与并行化**：
    - 将非核心操作（如日志记录、通知）异步处理。
    - 在TCC/Saga模式中，若参与者无依赖，可并行调用Try阶段或正向服务。
4. **优化Seata AT模式**：
    - 关闭不必要的SQL语法解析细节日志。
    - 优化`undo_log`表索引，并定期清理已提交的历史数据。
    - 使用`Seata Server`（TC）集群并优化其与数据库（用于存储全局事务和锁信息）的连接池。
5. **减少全局锁竞争**：
    - 在Seata AT中，默认对更新操作加全局锁。可通过业务设计，减少对同一热点数据的并发更新。
    - 在TCC中，通过业务字段的状态流转替代直接的资源行锁。
6. **客户端（TM/RM）优化**：
    - 合理设置事务超时时间，避免悬挂。
    - 使用连接池管理与TC和数据库的连接。