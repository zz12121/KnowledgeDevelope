###### 1. 什么是分布式锁？
分布式锁是**用于分布式环境下并发控制的一种机制**，用于保证在分布式系统或集群模式下，一个方法或资源在同一时间只能被一个机器的一个线程执行。
**核心特性**：
- **互斥性**：在任意时刻，只有一个客户端能持有锁。
- **可重入性**：同一个线程可以多次获取同一把锁。
- **锁超时**：支持自动过期机制，防止死锁。
- **高可用**：锁服务需要高可用性，确保系统能够正常获取和释放锁。
- **容错性**：在节点故障或网络分区时，锁能够被安全释放或重新分配。
**典型应用场景**：电商秒杀系统、分布式任务调度、资源访问控制等需要保证数据一致性的场景。
###### 2. 分布式锁有哪些实现方式？
主要有三种主流实现方式：
**基于数据库的实现**
- **原理**：利用数据库的唯一约束或行锁特性
- **优点**：实现简单，依赖少
- **缺点**：性能瓶颈，存在单点故障风险
**基于Redis的实现**
- **原理**：利用Redis的原子操作和过期机制
- **优点**：性能高，实现相对简单
- **缺点**：需要处理锁超时和原子性问题
**基于ZooKeeper的实现**
- **原理**：利用临时顺序节点和Watcher机制
- **优点**：可靠性高，具备原生锁特性
- **缺点**：性能相对较低，实现复杂
###### 3. 基于 Redis 实现分布式锁需要注意什么？
**关键注意事项**：
1. **原子性操作**：避免使用`SETNX+EXPIRE`的非原子操作，应使用Redis 2.6.12+的`SET`命令：
    ```java
    // 正确的原子操作
    String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime);
    ```
2. **锁误删除问题**：释放锁时需验证持有者身份：
    ```java
    String script = 
        "if redis.call('get', KEYS[1]) == ARGV[1] then " +
        "    return redis.call('del', KEYS[1]) " +
        "else " +
        "    return 0 " +
        "end";
    Object result = jedis.eval（script, Collections.singletonList(lockKey), 
                            Collections.singletonList(requestId));
    ```
3. **锁超时问题**：业务执行时间可能超过锁超时时间，推荐使用Redisson的看门狗机制自动续期。
4. **集群环境考虑**：在主从架构下可能因异步复制导致锁丢失，可考虑RedLock算法。
###### 4. 什么是 Redlock 算法？
RedLock算法是Redis官方提出的**分布式锁算法**，用于在Redis集群环境下实现更可靠的分布式锁。
**算法步骤**：
1. 获取当前时间（毫秒精度）
2. 依次尝试从N个独立的Redis实例获取锁
3. 计算获取锁的总耗时，只有在大多数实例上获取成功，且总耗时小于锁超时时间时才认为成功
4. 如果获取失败，需要在所有实例上释放锁
**Java实现示例**：
```java
public boolean tryRedLock(String lockKey, String requestId, int expireTime) {
    int successCount = 0;
    long startTime = System.currentTimeMillis();
    
    for (RedisInstance instance : redisInstances) {
        if (acquireLock(instance, lockKey, requestId, expireTime)) {
            successCount++;
        }
    }
    
    long costTime = System.currentTimeMillis() - startTime;
    return successCount >= majorityCount && costTime < expireTime;
}
```
###### 5. 基于 ZooKeeper 实现分布式锁的原理是什么？
ZooKeeper通过**临时顺序节点和Watcher机制**实现分布式锁。
**核心原理**：
1. **临时顺序节点**：每个客户端在锁节点下创建临时顺序节点
2. **最小节点获锁**：只有序号最小的节点获得锁
3. **Watcher监听**：非最小节点监听前一个节点的删除事件
4. **自动清理**：客户端断开连接时临时节点自动删除
**Java实现关键代码**：
```java
public void lock() {
    // 创建临时顺序节点
    myZnode = zk.create(path + "/lock_", new byte[0], 
                       ZooDefs.Ids.OPEN_ACL_UNSAFE, 
                       CreateMode.EPHEMERAL_SEQUENTIAL);
    
    // 获取子节点并排序
    List<String> children = zk.getChildren(path, false);
    Collections.sort(children);
    
    // 判断是否是最小节点
    if (myZnode.equals(path + "/" + children.get(0))) {
        // 获取锁成功
        return;
    }
    
    // 监听前一个节点
    String waitNode = children.get(Collections.binarySearch(children, 
                            myZnode.substring(myZnode.lastIndexOf("/") + 1)) - 1);
    zk.exists(path + "/" + waitNode, true);
}
```
###### 6. 基于数据库实现分布式锁的方式有哪些？
**基于唯一约束**
```sql
CREATE TABLE distributed_lock (
    id INT PRIMARY KEY AUTO_INCREMENT,
    lock_key VARCHAR(64) UNIQUE,
    request_id VARCHAR(64),
    expire_time BIGINT
);
```
通过`INSERT`操作竞争锁，插入成功则获取锁。
**基于悲观锁**
```sql
SELECT * FROM distributed_lock WHERE lock_key = ? FOR UPDATE;
```
利用数据库的行锁机制，需要确保查询字段有索引。
**基于乐观锁**
通过版本号字段实现：
```sql
UPDATE distributed_lock SET version = version + 1 
WHERE lock_key = ? AND version = ?;
```
更新成功则获取锁。
###### 7. Redis 分布式锁和 ZooKeeper 分布式锁的区别是什么？

|**特性**​|**Redis分布式锁**​|**ZooKeeper分布式锁**​|
|---|---|---|
|**性能**​|高（内存操作）|相对较低（需要持久化）|
|**一致性**​|最终一致性（主从异步复制）|强一致性（ZAB协议）|
|**实现复杂度**​|相对简单|相对复杂|
|**可靠性**​|依赖Redis稳定性|高（原生支持分布式协调）|
|**锁特性**​|需要自行实现可重入、公平性|原生支持临时节点、顺序性|
|**适用场景**​|高并发、对一致性要求不极端|强一致性要求的金融场景|
###### 8. 分布式锁如何解决死锁问题？
**死锁预防策略**：
1. **设置超时时间**：为锁设置合理的过期时间，避免永久阻塞
    ```java
    // Redis设置过期时间
    jedis.setex(lockKey, expireTime, requestId);
    ```
2. **自动释放机制**：ZooKeeper的临时节点在客户端断开时自动删除
3. **锁续期机制**：使用看门狗线程定期检查并延长锁过期时间
    ```java
    // Redisson的看门狗机制
    RLock lock = redissonClient.getLock(lockKey);
    lock.lock(30, TimeUnit.SECONDS); // 看门狗会自动续期
    ```
4. **添加重试机制**：获取锁失败时进行有限次重试
###### 9. 什么是锁的可重入性？
锁的可重入性是指**同一个线程可以多次获取同一把锁而不会产生死锁**。
**实现原理**：
1. **记录持有者信息**：在锁的值中存储线程标识和重入次数
2. **重入计数**：每次重入时计数器加1，释放时减1，计数为0时真正释放锁
**Redis可重入锁实现示例**：
```java
public boolean tryReentrantLock(String lockKey, String threadId, int expireTime) {
    // 检查是否是当前线程持有锁
    String currentValue = jedis.get(lockKey);
    if (threadId.equals(currentValue)) {
        // 重入次数+1
        jedis.incr(lockKey);
        return true;
    }
    
    // 尝试获取新锁
    return "OK".equals(jedis.set(lockKey, threadId, "NX", "PX", expireTime));
}
```
**ZooKeeper可重入实现**：在节点数据中存储线程标识和重入次数，同一线程再次获取时直接增加计数。