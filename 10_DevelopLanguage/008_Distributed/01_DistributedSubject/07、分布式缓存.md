###### 1. 什么是分布式缓存？
分布式缓存是将缓存数据分散存储在多台独立的服务器节点上，构成一个逻辑统一的缓存池，通过特定的分片和路由机制提供数据访问。其核心是解决单体应用本地缓存的数据孤岛、容量受限、一致性和扩展性问题。在大型分布式系统中，分布式缓存作为独立的中间件层（如Redis Cluster、Memcached集群），通过内存级读写降低数据库负载，提升系统吞吐量。关键技术挑战包括数据分片算法（一致性哈希、哈希槽）、高可用机制（主从复制、故障自动转移）和数据一致性协议（最终一致性为主）。从源码角度看，以Redis Cluster为例，节点间通过Gossip协议维护集群状态，客户端根据`MOVED/ASK`重定向指令配合`CRC16(key) mod 16384`计算哈希槽实现路由，本质是去中心化的分片代理模式。
###### 2. Redis 和 Memcached 的区别是什么？
- **数据结构**：Redis支持String、Hash、List、Set、SortedSet、Bitmaps等复杂结构，Memcached仅支持String键值。Redis的Hash底层采用ziplist（元素少时）或dict（哈希表），SortedSet使用skiplist+dict实现范围查询与单点访问的O(logN)平衡。
- **持久化**：Redis提供RDB（内存快照）和AOF（操作日志）两种持久化机制。RDB通过`rdbSave()`fork子进程写快照，AOF根据`appendfsync`配置同步磁盘。Memcached无持久化。
- **集群模式**：Redis原生支持哨兵（Sentinel）和Cluster分片集群；Memcached需客户端实现一致性哈希分片。
- **线程模型**：Redis 6.0前为单线程Reactor模型，6.0后引入多线程处理网络IO（`io_threads`），但核心命令执行仍单线程；Memcached采用多线程模型，通过锁竞争管理全局哈希表。
- **内存管理**：Redis通过`zmalloc`封装系统分配，支持内存淘汰策略（LRU、LFU等）；Memcached使用Slab Allocation预分内存块减少碎片。
- **适用场景**：Redis适用于需要复杂操作、持久化或实时数据结构的场景；Memcached更适合作简单键值缓存。
###### 3. 什么是缓存穿透？如何解决？
缓存穿透是指查询不存在的数据，绕过缓存直接击穿到数据库，可能导致数据库压力激增。常见于恶意攻击或业务查询无效Key。
**解决方案**：
1. **布隆过滤器**：在缓存层前置布隆过滤器，通过多个哈希函数判断Key是否存在。Redis可通过`SETBIT`和`GETBIT`自实现，或使用Redisson的`RBloomFilter`。注意布隆过滤器存在误判率，需根据数据量调整哈希函数数量和位数组大小。
2. **缓存空值**：对查询结果为空的Key设置短时效缓存（如30秒），代码示例：
    ```java
    String value = redis.get(key);
    if (value == null) {
        value = db.query(key);
        if (value == null) {
            redis.setex(key, 30, "NULL"); // 设置空值标记
        }
    }
    ```
3. **接口鉴权与限流**：对非法请求进行拦截，结合监控报警机制。
###### 4. 什么是缓存击穿？如何解决？
缓存击穿是指某个热点Key过期瞬间，大量并发请求直接穿透到数据库。与缓存雪崩的区别在于击穿针对单个Key。
**解决方案**：
1. **互斥锁**：使用Redis的`SETNX`命令或分布式锁（如RedLock）保证仅一个线程回源数据库，其他线程等待重试。代码示例：
    ```java
    String data = redis.get(key);
    if (data == null) {
        if (redis.setnx(lockKey, "1", 3)) {
            try {
                data = db.query(key);
                redis.setex(key, 300, data);
            } finally {
                redis.del(lockKey);
            }
        } else {
            Thread.sleep(100);
            return getData(key); // 重试
        }
    }
    ```
2. **逻辑过期**：缓存Value中封装过期时间戳（如`{"data":obj,"expire":1690000000}`），业务线程发现过期时异步触发重建，期间返回旧数据。
3. **永不过期策略**：对热点Key不设过期时间，通过后台任务定期更新
###### 5. 什么是缓存雪崩？如何解决？
缓存雪崩是指大量缓存Key在同一时间大面积失效，或缓存集群宕机，导致所有请求涌向数据库。
**解决方案**：
1. **差异化过期时间**：对缓存Key的过期时间添加随机值，例如`redis.setex(key, 300 + random(60), value)`，避免同时失效。
2. **集群高可用**：采用Redis Cluster或哨兵模式实现故障自动转移；多级缓存架构（如本地缓存+Caffeine+Redis）。
3. **熔断降级**：通过Hystrix或Sentinel实现数据库访问熔断，失败时返回兜底数据。
4. **持久化与快速恢复**：启用Redis AOF/RDB持久化，故障重启后快速加载数据。
###### 6. 缓存更新策略有哪些？
- **Cache Aside（旁路缓存）**：先更新数据库，再删除缓存。需处理并发写可能导致的脏数据，可采用延迟双删（`db.update(); redis.del(); sleep(); redis.del()`）。
- **Read/Write Through**：缓存作为代理层，读写均经缓存。Write Through中缓存同步写数据库（如Ehcache配置`writeThrough`）；Read Through由缓存自行加载数据（Guava Cache的`CacheLoader`）。
- **Write Behind Caching**：缓存异步批量写回数据库，如Redis AOF持久化机制。风险是数据丢失。
- **定时刷新**：结合消息队列（如Kafka）监听数据库Binlog变更（Canal组件），异步刷新缓存。
###### 7. 什么是缓存预热？
缓存预热指系统上线前或重启后，主动将热点数据加载到缓存，避免首请求直接击穿数据库。实现方式：
- **静态预热**：通过启动脚本或定时任务预加载静态配置的热点Key。
- **动态预热**：监控历史访问日志，使用LRU/K-means算法识别热点数据并预加载。
    示例：Spring Boot中通过`ApplicationRunner`执行预热逻辑：
```java
@Component
public class CacheWarmUp implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) {
        List<HotData> list = db.queryHotData();
        list.forEach(data -> redis.set(data.id, data.value));
    }
}
```
###### 8. 什么是缓存降级？
缓存降级指在系统高负载或故障时，暂时关闭部分非核心缓存或直接返回降级数据，保证核心服务可用。策略包括：
- **开关降级**：配置中心动态开关缓存读取，如直接返回默认值或走兜底接口。
- **容错降级**：缓存访问超时时自动降级到数据库，并记录日志告警。
- **数据降级**：返回简化版数据（如只返回基础字段）。
###### 9. Redis 集群模式有哪些？
- **主从复制**：一主多从，主节点写，从节点读，通过`REPLCONF ACK`同步偏移量实现数据复制。
- **哨兵模式**：由Sentinel节点监控主从状态，实现自动故障转移（原理见第10题）。
- **Cluster模式**：去中心化分片集群，数据按哈希槽分布，节点间通过Gossip协议通信。
- **第三方代理模式**：如Twemproxy、Codis，由代理层处理分片和路由，Redis节点无状态。
###### 10. Redis 哨兵模式的原理是什么？
哨兵模式通过独立进程（Sentinel）监控主从节点，实现自动故障检测与转移。流程如下：
1. **监控**：每个Sentinel每10秒向主节点发送`INFO`命令获取拓扑，每1秒向其他Sentinel和Redis节点发送`PING`检测存活。
2. **主观下线**：若Sentinel在`down-after-milliseconds`内未收到有效回复，标记节点为主观下线（SDOWN）。
3. **客观下线**：当超过`quorum`数量的Sentinel认定主节点主观下线，则标记为客观下线（ODOWN）。
4. **选举Leader**：Sentinel通过Raft算法选举Leader执行故障转移。
5. **故障转移**：Leader Sentinel从从节点中选取复制偏移量最新的节点，执行`SLAVEOF NO ONE`提升为主节点，并通知其他从节点同步新主。
    源码关键：Sentinel的`sentinelTimer()`函数周期性执行检测，故障转移逻辑见`sentinelFailoverStateMachine()`状态机。
###### 11. Redis Cluster 的数据分片机制是什么？
Redis Cluster采用虚拟哈希槽分片，共16384个槽（`CLUSTER_SLOTS`）。每个节点负责部分槽，通过`CLUSTER ADDSLOTS`分配。数据路由过程：
1. 客户端计算Key的哈希槽：`slot = CRC16(key) & 16383`。
2. 若客户端缓存了槽位映射表（通过`CLUSTER SLOTS`获取），直接请求对应节点。
3. 若请求错节点，节点返回`MOVED <slot> <ip:port>`重定向指令，客户端更新映射并重试。
4. 迁移槽时，节点可能返回`ASK`重定向，客户端仅对当前命令临时请求新节点。
    槽迁移通过`CLUSTER SETSLOT <slot> IMPORTING/MIGRATING`触发，迁移过程中原节点返回`ASK`响应。源码中`getNodeByQuery()`函数处理命令路由，`clusterSendAsk()`发送ASK重定向。
###### 12. 如何保证缓存和数据库的一致性？
强一致性在分布式环境下成本极高，通常采用最终一致性方案：
1. **延迟双删**：更新数据库后，先删缓存，延迟数百毫秒再删一次（应对并发读导致的旧缓存回写）。
2. **异步监听Binlog**：通过Canal监听MySQL Binlog，解析变更后删除/更新Redis缓存。
3. **分布式事务**：使用Seata的AT模式或消息队列（如RocketMQ事务消息），但性能损耗大。
4. **版本号/时间戳**：缓存数据携带版本号，更新时比较版本，防止旧数据覆盖。
    权衡建议：读多写少场景用Cache Aside+延迟双删；写多场景可考虑Write Through+消息队列补偿。需根据业务容忍度选择策略，并监控延迟与不一致概率。