###### 1. 什么是 ZooKeeper？
ZooKeeper 是一个开源的分布式协调服务，由雅虎创建，现为 Apache 顶级项目。它旨在为分布式应用提供高性能、高可靠的一致性服务，其核心是一个基于内存的、树形结构的分布式键值存储（ZNode树）。ZooKeeper 通过其特有的 **ZAB（ZooKeeper Atomic Broadcast）协议**​ 保证集群中各节点数据的一致性。它不直接暴露复杂的原语，而是提供了一组简单的 API，使得开发者能够基于此实现更高级的分布式协调功能，如分布式锁、服务注册与发现、配置管理等。从源码角度看，其核心是 `ZooKeeperServer`类，它处理客户端连接和请求，并通过 `RequestProcessor`链（如 `PrepRequestProcessor`、`ProposalRequestProcessor`、`CommitProcessor`、`FinalRequestProcessor`）来保证请求的顺序性和原子性提交。
###### 2. ZooKeeper 的应用场景有哪些？
- **配置管理**：将全局配置信息（如数据库连接串）存储在 ZNode 上，客户端通过 Watch 机制监听节点变化，实现配置的实时动态更新。
- **命名服务**：通过创建全局唯一的路径（ZNode），作为服务的标识符，类似于 DNS。
- **分布式锁**：利用 ZNode 的**不可重复创建**特性和**顺序节点**，实现排他锁和读写锁。
- **集群管理与选主**：利用**临时节点**（Ephemeral Node）的特性，当服务实例下线时其创建的节点自动删除，可用来判断服务存活状态。通过创建指定节点（如 `/election/master`）来实现领导者选举。
- **分布式队列**：利用顺序节点（Sequential Node）的 FIFO 特性来实现简单的队列或屏障。
- **发布/订阅**：通过将数据存储在 ZNode 上，并让多个订阅者 Watch 该节点，数据变更时通知所有订阅者。
###### 3. ZooKeeper 的数据模型是怎样的？
ZooKeeper 的数据模型是一个类似文件系统的**树形层次结构**，称为 **ZNode 树**。每个节点称为一个 ZNode，是数据存储的基本单元。
- **路径**：每个 ZNode 通过唯一的路径标识，如 `/services/serviceA`。
- **数据**：每个 ZNode 可以存储少量数据（默认上限为 1MB），通常用于存储元信息或配置。
- **版本**：每个 ZNode 有一个版本号（`version`），对节点的任何数据更新或子节点变更都会使其版本号递增，用于实现乐观锁控制。
- **访问控制列表**：每个 ZNode 可以拥有一个 ACL（Access Control List），用于控制用户的访问权限。
- **子节点**：ZNode 可以拥有子节点，从而形成目录结构。与文件系统不同，ZNode 既可以像目录一样拥有子节点，也可以像文件一样存储数据
###### 4. ZooKeeper 的节点类型有哪些？
ZooKeeper 的节点类型由**持久性**和**顺序性**两个维度组合而成：
1. **持久节点**：节点创建后，除非主动删除，否则一直存在于 ZooKeeper 中。
2. **临时节点**：节点的生命周期与客户端会话绑定。当创建该节点的客户端会话失效（断开连接且 sessionTimeout 到期）时，节点会被自动删除。**临时节点不能拥有子节点**。该特性是实现服务注册和存活判断的基础。
3. **持久顺序节点**：具有持久节点特性，同时 ZooKeeper 会在其路径后附加一个单调递增的、由父节点维护的10位数字序列号（如 `/lock/lock-0000000001`）。
4. **临时顺序节点**：具有临时节点特性，同时带有顺序号。这是实现公平分布式锁的核心数据结构。
###### 5. ZooKeeper 的 Watch 机制是什么？
Watch 是 ZooKeeper 提供的一种**一次性、异步的通知机制**。客户端可以在读操作（如 `getData`、 `getChildren`、 `exists`）上设置一个 Watch，监控对应 ZNode 的变化。
- **触发事件**：当被监控的 ZNode 发生**数据变更**、**子节点列表变更**或**节点被创建/删除**时，ZooKeeper 服务端会向设置 Watch 的客户端发送一个事件通知。
- **一次性**：Watch 被触发后即失效，客户端若需持续监听，必须在收到通知后重新注册。这种设计减轻了服务端压力，但要求客户端逻辑正确处理重注册。
- **顺序保证**：Watch 事件是异步发送的，但 ZooKeeper 保证客户端看到的事件顺序与服务端发生的变更顺序严格一致。
- **源码实现**：服务端通过 `WatcherManager`管理所有的 Watch。当 `FinalRequestProcessor`处理一个会改变状态的操作时，会调用 `triggerWatch`方法，将通知事件放入 `RecvWorker`的队列，最终由 `SendWorker`发送给客户端。
###### 6. ZooKeeper 如何实现分布式锁？
以排他锁为例，常见实现方式为利用**临时顺序节点**：
1. **加锁**：所有客户端在锁节点（如 `/lock`）下创建**临时顺序子节点**（如 `/lock/lock-000001`）。
2. **判断**：客户端获取 `/lock`下所有子节点，并按序列号排序。
3. **获取锁**：如果自己创建的节点是序列号最小的节点，则成功获得锁。
4. **等待锁**：如果自己不是最小节点，则**监听（Watch）比自己序列号小的前一个节点**。
5. **锁释放**：当前一个节点被删除（即前一个持有锁的客户端释放了锁），Watch 事件触发，当前客户端被唤醒，并回到步骤2重新判断。
    **优化点**：此方案避免了“羊群效应”，每个客户端只监听其前一个节点，而不是监听锁节点或所有节点。源码层面，客户端库（如 Curator）的 `InterProcessMutex`类实现了此逻辑，其核心方法 `internalLockLoop`中包含了创建节点、排序、设置 Watch 的循环。
###### 7. ZooKeeper 如何实现服务注册与发现？
- **服务注册**：服务提供者启动时，在 ZooKeeper 的固定路径下（如 `/services/com.example.ServiceA`）创建一个**临时子节点**。节点数据通常包含服务实例的地址、端口等元信息（如 `192.168.1.1:8080`）。由于是临时节点，服务实例宕机或网络断开时，该节点会自动清除，实现了服务的自动下线。
- **服务发现**：服务消费者启动时，读取并 Watch 服务路径（如 `/services/com.example.ServiceA`）下的所有子节点，获取当前所有可用的服务实例列表。通过 Watch 机制，当子节点有增减（即服务实例上下线）时，消费者会收到通知，从而动态更新本地缓存的服务列表，实现实时发现。
###### 8. ZooKeeper 的选举机制是什么？
ZooKeeper 集群采用 **Fast Leader Election**​ 算法（ZAB 协议的一部分）进行领导者选举。其核心思想是“**数据最新且ID最大者优先**”。
1. **选举状态**：节点有 LOOKING、FOLLOWING、LEADING 三种状态。启动时均为 LOOKING。
2. **投票内容**：每张选票包含两个核心信息：**提议的领导者ID（myid）**​ 和 **该领导者所拥有的最大事务ZXID**。
3. **投票流程**：
    - 初始时，每个节点都投票给自己（`(myid, myZxid)`）。
    - 节点间相互广播选票。
    - 收到外部选票时，根据规则比较：**优先比较 ZXID，ZXID 大者胜出；若 ZXID 相同，则比较 myid，myid 大者胜出**。
    - 如果外部选票优于自身当前持有的选票，则更新自己的投票为外部选票，并重新广播。
4. **选举结束**：当某个节点收到**超过半数**的相同选票时，该选票对应的节点即被认定为 Leader，自身状态转为 FOLLOWING 或 LEADING。
    **源码体现**：选举实现在 `QuorumPeer`类中，其 `run`方法根据状态机进行切换。`FastLeaderElection`类是选举算法的核心，它维护一个投票队列 `recvqueue`，并通过 `WorkerReceiver`和 `WorkerSender`线程进行网络IO。
###### 9. etcd 和 ZooKeeper 的区别是什么？
- **一致性协议**：etcd 使用 **Raft**​ 协议，协议描述更清晰易懂。ZooKeeper 使用 **ZAB**​ 协议，两者都是强一致性协议，但 ZAB 在工程实现上更强调**顺序一致性**，为写入操作提供了全局单调递增的 ZXID。
- **数据模型与API**：etcd 提供的是**扁平的、带版本号的键值空间**，支持租约（Lease），提供更丰富的范围查询和事务操作。ZooKeeper 是**树形文件系统模型**，API相对简单。
- **Watch机制**：etcd 提供**历史事件查询**和**持续监听**（Watch 可被持久化，不丢失），且支持从某个历史版本号开始监听。ZooKeeper 的 Watch 是**一次性**的。
- **性能与扩展**：在纯键值操作场景下，etcd 的读写性能通常优于 ZooKeeper。etcd 通过租约机制集中管理大量临时键，比 ZooKeeper 为每个临时节点维护会话更节省资源。
- **生态与语言**：etcd 与 Kubernetes 深度集成，是云原生领域的标配，使用 Go 语言开发。ZooKeeper 在大数据领域（Hadoop, Kafka）应用更广，使用 Java 开发。
- **运维**：etcd 的运维相对更简单，动态成员变更（`etcdctl member add`）比 ZooKeeper 更友好。