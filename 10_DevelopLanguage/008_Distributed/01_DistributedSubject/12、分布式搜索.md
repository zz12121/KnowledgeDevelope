###### 1. 什么是 Elasticsearch？
Elasticsearch 是一个基于 Lucene 构建的开源、分布式、RESTful 的搜索和分析引擎。它本质上是一个**分布式文档存储系统**，能够近乎实时地存储、搜索和分析海量数据。它并非传统的关系型数据库，而是一个 NoSQL 数据库，其核心数据结构是 **JSON 文档**。
**核心特性**：
- **分布式与高可用**：数据自动分片，并在多个节点上复制，提供水平扩展和故障转移能力。
- **全文搜索**：基于 Apache Lucene 提供强大的全文检索功能，支持复杂的相关性评分和多种查询类型。
- **近实时**：数据从索引到可搜索通常有短暂的延迟（默认1秒），这是由其 `refresh_interval`控制的。
- **丰富的 REST API**：所有操作，从数据读写到集群管理，都可通过 HTTP RESTful API 完成。
- **生态整合**：作为 ELK/Elastic Stack 的核心，常与 Logstash（数据采集）和 Kibana（数据可视化）配合使用，广泛应用于日志分析、应用监控、站内搜索等场景。
**源码定位**：其核心是 `org.elasticsearch`包下的集群管理、节点通信模块，以及封装的 Lucene 索引和搜索功能。启动入口类是 `Bootstrap`，它初始化 `Node`，而 `Node`是单个 ES 实例的核心。
###### 2. Elasticsearch 的核心概念有哪些？
- **索引**：一组具有相似特征文档的集合，是数据的逻辑命名空间（类似于关系型数据库中的“数据库”或“表”）。每个索引由一个或多个分片组成。
- **类型**：在 7.0 版本之前，索引内部可以定义类型（类似于表中的“行”概念）。自 7.0 起已弃用，一个索引只能有一个隐含的 `_doc`类型。这是为了消除与关系模型的误导性类比。
- **文档**：索引中的基本数据单元，是一个 JSON 对象。每个文档都有一个唯一的 ID 和一组字段。
- **字段**：文档中的键值对，代表数据的属性。字段拥有明确的数据类型（如 `text`, `keyword`, `long`, `date`）。
- **映射**：类似于数据库的模式定义，它定义了索引中的字段名、数据类型以及如何索引和存储（如 `text`类型会被分析，`keyword`类型则作为整体被索引）。
- **分片**：索引被水平拆分的子集。每个分片本身是一个功能完整的 Lucene 索引。分片允许数据分布在集群的多个节点上。
- **副本**：分片的复制品，用于提供高可用性和提升读取吞吐量。副本分片从不与其主分片位于同一节点。
- **节点**：一个运行中的 Elasticsearch 实例。节点有不同的角色（主节点、数据节点、协调节点等）。
- **集群**：由一个或多个节点组成的集合，共同持有全部数据并提供联合索引与搜索能力。
###### 3. Elasticsearch 的倒排索引是什么？
倒排索引是 Elasticsearch 实现高速全文搜索的核心数据结构。它与传统数据库的“正排索引”（通过文档 ID 查找其内容）相反，是通过**内容中的词项来反向查找包含该词项的文档列表**。
**工作原理**：
1. **文档分析**：当一个文档被索引时，其文本字段（`text`类型）会被“分析器”处理，包括分词（拆分为独立的单词/词元）、归一化（转为小写）、去除停用词等。
2. **构建倒排表**：对于分析后得到的每个唯一词项，记录其出现的**文档ID列表**、在文档中的**出现频率**以及**位置信息**（用于短语查询）。
3. **结果**：最终形成一个从**词项**到**文档列表**的映射。
**示例**：
文档1：`{“content”: “The quick brown fox”}`
文档2：`{“content”: “The quick dog”}`
倒排索引（简化）：
- `the`-> [文档1, 文档2]
- `quick`-> [文档1, 文档2]
- `brown`-> [文档1]
- `fox`-> [文档1]
- `dog`-> [文档2]
**Lucene 源码角度**：在 Lucene 中，倒排索引的核心类是 `InvertedFields`。每个字段的倒排信息存储在 `TermsDictionary`中，它是一个包含所有词项的有序字典，并通过跳表、FST 等数据结构高效定位到对应的 `PostingsList`（倒排列表），其中包含了文档 ID、词频和位置信息。
###### 4. Elasticsearch 如何实现分布式？
Elasticsearch 的分布式特性是通过以下几个核心机制协同工作实现的：
1. **节点发现与集群形成**：
    - 节点启动时，通过 Zen Discovery 协议（旧版本）或基于 Raft 的选举（7.x 后主节点选举使用内置实现）来发现其他节点并加入集群。
    - 配置 `discovery.seed_hosts`指定种子节点列表。
2. **主节点选举与集群状态管理**：
    - 集群中有一个被选举出的**主节点**，负责管理集群范围的操作，如创建/删除索引、跟踪节点状态、决定分片分配。
    - 主节点将集群状态（`ClusterState`）发布给所有节点。源码中，`MasterService`负责处理使集群状态发生变化的事件。
3. **分片分配与数据路由**：
    - 索引被划分为多个分片。当文档被索引时，其路由（默认基于文档 ID 哈希）决定它属于哪个主分片。
    - 协调节点接收请求，根据路由公式 `shard_num = hash(_routing) % num_primary_shards`计算出目标分片，并将请求转发给该分片所在的节点。
    - 分片的分配由主节点决定，考虑节点负载和分片分配意识（避免副本与主分片同节点）。
4. **分布式搜索**：
    - 搜索请求被发送到任意节点（协调节点）。该节点将查询广播到所有相关分片（主分片或副本分片）。
    - 每个分片在本地执行搜索并返回结果给协调节点。
    - 协调节点合并、排序所有分片的结果，最后返回给客户端。这个过程称为 **Scatter/Gather**。
###### 5. Elasticsearch 的分片和副本机制是什么？
- **分片**：
    - **主分片**：是数据的“主”拷贝。索引中的每个文档属于且仅属于一个主分片。主分片的数量在索引创建时指定，之后**无法更改**（除非重建索引）。它决定了索引数据的最大分布粒度。
    - 分片将数据水平拆分，允许数据存储超出单节点容量，并将操作并行化到多个节点，从而提升性能和吞吐量。
- **副本**：
    - **副本分片**：是主分片的完整拷贝。每个主分片可以有零个或多个副本。
    - **作用**：
        1. **高可用**：当主分片所在节点故障时，其一个副本分片会被提升为新的主分片。
        2. **提升读取性能**：搜索和获取请求可以同时在所有副本分片上执行，实现负载均衡。
    - 副本数量可以动态调整。
**工作机制**：
- **写入**：写操作（索引、更新、删除）必须首先在主分片上成功执行，然后主分片会并行地将操作复制到其所有副本分片。只有多数副本（包括主分片）确认后，写操作才会向客户端返回成功。这通过 `wait_for_active_shards`参数控制。
- **读取**：读操作（搜索、获取）可以由主分片或任何副本分片处理。这提供了读取的伸缩性。
###### 6. 如何优化 Elasticsearch 的查询性能？
优化是一个系统性工程，需从多个层面考虑：
1. **硬件与配置优化**：
    - 使用 SSD 硬盘。
    - 为 Elasticsearch 分配足够但不过量的堆内存（通常不超过 31GB，以利用压缩指针），将剩余内存留给操作系统文件缓存。
    - 调整 `refresh_interval`（默认 1s），对于写入量大的日志场景，可以调大到 30s 以降低合并压力。
    - 适当调整 `indices.memory.index_buffer_size`（索引缓冲区大小）。
2. **索引设计优化**：
    - **合理设置分片数和副本数**：分片大小建议在 10GB-50GB 之间。过多分片会增加集群开销，过少则无法充分利用资源。
    - **使用合适的映射**：精确匹配的字段使用 `keyword`类型；仅全文搜索的字段使用 `text`类型；对于既需全文搜索又需聚合的字段，使用 `fields`多字段特性。禁用不需要索引的字段 (`index: false`)。
    - **使用索引模板**：保证新索引结构一致和优化。
3. **查询语句优化**：
    - **使用过滤器上下文**：对于不参与相关性评分的条件（如时间范围、状态），使用 `filter`上下文。其结果可以被缓存，大幅提升性能。
    - **避免深度分页**：`from + size`方式在深度分页时开销巨大。使用 `search_after`或滚动搜索 `scroll`（对于大量数据导出）。
    - **限制返回字段**：使用 `_source`过滤，只返回需要的字段。
    - **避免通配符查询前缀**：如 `*text`，这种查询效率极低。
    - **使用查询别名**：限制查询涉及的分片数。
4. **使用缓存**：
    - **节点查询缓存**：缓存查询结果。适用于过滤器聚合等重复查询。
    - **分片请求缓存**：缓存整个分片的聚合结果。在索引数据不变时非常有效。
    - **字段数据缓存**：用于排序和聚合。需注意内存消耗。
5. **监控与分析**：
    - 使用 `_search`API 的 `profile: true`参数分析查询在每个阶段的耗时。
    - 监控节点的 CPU、内存、磁盘 I/O 和 GC 情况。
###### 7. Elasticsearch 如何保证数据一致性？
Elasticsearch 遵循 **最终一致性**​ 模型，但通过其写入流程和配置参数提供了不同级别的一致性保证。
1. **写入流程与一致性保证**：
    - 写操作（索引、更新、删除）首先被记录到主分片的 **事务日志**​ 中，然后被应用到内存缓冲区。
    - 操作被同步复制到所有副本分片。复制行为由 `consistency`参数控制：
        - `one`：只需主分片成功。
        - `quorum`：（默认值）需要大多数分片副本（包括主分片）成功。公式为 `int( (primary + number_of_replicas) / 2 ) + 1`。
        - `all`：需要所有分片副本成功。
    - 只有满足一致性要求后，操作才会在客户端确认成功。
2. **近实时性与刷新**：
    - 写入内存缓冲区的文档还不能被搜索。默认每 1 秒，内存缓冲区的内容会被写入一个新的 Lucene 段（这个过程称为 **刷新**），此时文档才变得可搜索。这是“近实时”的来源。
    - `refresh_interval`可调。更长的间隔意味着更好的写入吞吐量，但搜索延迟更高。
3. **持久化与事务日志**：
    - 事务日志确保在节点崩溃时，已确认的写入不会丢失。默认每 5 秒或每次请求后，事务日志会 `fsync`到磁盘。
    - 通过 `Translog`的 `flush`操作，内存中的段会被持久化到磁盘，并清空事务日志。
4. **读取一致性**：
    - 默认情况下，读请求可能被分配到主分片或任何副本分片。由于复制是异步的，副本上的数据可能略微落后于主分片。
    - 可以通过设置 `preference`参数来控制读取的位置，例如 `_primary`表示只从主分片读取，以获得最新的数据。