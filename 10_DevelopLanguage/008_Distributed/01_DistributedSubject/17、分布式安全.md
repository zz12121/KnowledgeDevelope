###### 1. 分布式系统中常见的安全威胁有哪些？
分布式系统因其组件众多、网络通信复杂、边界模糊，面临比单体系统更严峻的安全挑战。主要威胁包括：
1. **身份认证与授权漏洞**：
    - **弱认证**：使用简单密码、默认凭证，或认证逻辑存在缺陷。
    - **权限提升/越权访问**：用户通过技术手段获取超出其权限的访问能力，如水平越权（访问他人数据）和垂直越权（获取管理员功能）。
    - **凭证泄露**：API密钥、令牌（如JWT）或会话ID被窃取或不当存储。
2. **网络与通信攻击**：
    - **中间人攻击**：攻击者在通信链路中拦截、窃听甚至篡改未加密的明文数据。
    - **重放攻击**：攻击者截获有效的请求数据包，之后重复发送以冒充合法操作。
    - **DDoS攻击**：通过海量恶意流量耗尽目标服务（如API网关、认证服务器）的资源，导致拒绝服务。
3. **数据安全威胁**：
    - **敏感数据泄露**：数据库被拖库、日志中记录敏感信息、配置文件中硬编码密码。
    - **数据篡改**：传输或存储过程中的数据被恶意修改。
    - **注入攻击**：SQL注入、NoSQL注入、命令注入等，通过未经验证的输入破坏后端逻辑。
4. **API与接口滥用**：
    - **API未受保护**：内部或管理接口暴露在公网且无认证。
    - **速率限制缺失**：导致API被爬虫或恶意程序刷取，造成资源浪费或业务损失。
5. **基础设施与配置安全**：
    - **不安全的配置**：容器镜像使用root用户、服务开放不必要的端口、使用过时且有漏洞的组件。
    - **供应链攻击**：依赖的第三方库（如Log4j）存在严重安全漏洞。
6. **分布式特有威胁**：
    - **服务间信任问题**：在零信任网络中，任何服务都不应被默认信任。缺乏服务间认证（如mTLS）可能导致内部网络被横向移动攻击。
    - **配置中心/注册中心攻击**：攻击这些核心组件可导致服务发现混乱或配置被恶意修改，影响整个系统。
防御需要建立纵深安全体系，涵盖网络隔离、传输加密、强身份认证、最小权限授权、输入校验、安全依赖管理和持续漏洞扫描。
###### 2. 什么是 OAuth 2.0？
OAuth 2.0 是一个**授权框架**，而非认证协议。它核心解决了**“安全地让第三方应用在用户授权后，代表用户访问其存储在资源服务器上的受保护资源”**的问题，而无需向第三方暴露用户的凭证（如密码）。
核心角色**：
- **资源所有者**：用户。
- **客户端**：试图访问用户资源的第三方应用。
- **授权服务器**：验证用户身份并颁发访问令牌的服务器（常与认证服务器合一）。
- **资源服务器**：存放用户受保护资源的服务器（如API服务器）。
**核心授权流程（以最安全的授权码模式为例）**：
1. 用户通过客户端访问，客户端将用户重定向到授权服务器的认证端点。
2. 用户在授权服务器上完成认证，并同意客户端请求的权限范围。
3. 授权服务器将用户重定向回客户端事先注册的重定向URI，并附上一个**授权码**。
4. 客户端在后端用授权码、自己的客户端ID和密钥，向授权服务器的令牌端点请求**访问令牌**。
5. 授权服务器验证通过后，向客户端颁发访问令牌（和可选的刷新令牌）。
6. 客户端使用访问令牌访问资源服务器的API，资源服务器通过内省或验证令牌签名来校验令牌有效性。
**其他授权模式**：
- **隐式模式**：用于纯前端应用，直接返回访问令牌（不安全，已不推荐）。
- **密码模式**：用户直接向客户端提供用户名密码，客户端用以换令牌（仅适用于高度信任的自家客户端）。
- **客户端凭证模式**：客户端代表自己而非用户，访问其拥有的资源。
**源码角度（Spring Security OAuth2）**：
授权服务器的核心配置类 `AuthorizationServerConfigurerAdapter`定义了端点、客户端详情和令牌服务。`TokenEndpoint`处理 `/oauth/token`请求。资源服务器的 `ResourceServerConfigurerAdapter`配置了受保护资源的访问规则。令牌的生成、存储和验证由 `TokenStore`实现（如 `JwtTokenStore`或 `RedisTokenStore`）。
###### 3. JWT 的工作原理是什么？
JWT 是一种**紧凑的、自包含的**令牌格式，用于在各方之间安全地传输信息作为 JSON 对象。因其可被签名（使用HMAC或RSA）或加密，信息是可信的。
**JWT 结构**：由三部分组成，用点分隔：`Header.Payload.Signature`
- **Header**：包含令牌类型（`typ: “JWT”`）和签名算法（`alg: “HS256”`或 `RS256`）。
    ```json
    { “alg”: “HS256”, “typ”: “JWT” }
    ```
- **Payload**：包含**声明**，即关于实体（通常是用户）和其他数据的语句。声明分三类：注册声明（如 `iss`签发者， `exp`过期时间）、公共声明和私有声明。
    ```json
    { “sub”: “1234567890”, “name”: “John Doe”, “iat”: 1516239022 }
    ```
- **Signature**：对编码后的Header和Payload，使用Header中指定的算法和密钥进行签名，用于验证消息在传输过程中未被篡改。
    ```
    HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)
    ```
**工作流程**：
1. **颁发**：用户认证成功后，授权服务器使用密钥创建JWT（包含用户信息和过期时间），返回给客户端。
2. **携带**：客户端在后续请求的 `Authorization`头中携带JWT：`Bearer <token>`。
3. **验证**：资源服务器收到后：
    a. 检查格式，分割三部分。
    b. 用相同的算法和密钥（或公钥，如果是非对称签名）重新计算签名，与JWT中的签名部分比对，确保未被篡改。
    c. 验证声明，如 `exp`（是否过期）、`iss`（签发者是否正确）。
**优点与注意事项**：
- **自包含**：无需像传统会话令牌那样在服务端存储状态，利于分布式系统扩展。
- **可验证**：签名保证完整性。
- **注意**：JWT一旦签发，在到期前无法主动作废（除非使用黑名单机制）。载荷是Base64编码，**明文可见**，**绝不能存放敏感信息**（如密码）。密钥管理至关重要。
**源码角度（使用 jjwt 库）**：
```java
// 创建
String jws = Jwts.builder()
    .setSubject(“Joe”)
    .signWith(SignatureAlgorithm.HS256, secretKey)
    .compact();

// 解析验证
Jws<Claims> claimsJws = Jwts.parser()
    .setSigningKey(secretKey)
    .parseClaimsJws(jws);
String subject = claimsJws.getBody().getSubject();
```
在Spring Security中，`JwtDecoder`负责解析和验证JWT，并将其转换为 `Authentication`对象。
###### 4. 如何防止分布式系统中的重放攻击？
重放攻击防御的核心是确保每个请求的**唯一性和时效性**，使攻击者无法重复使用截获的有效请求数据。
**常用防御手段**：
1. **Nonce（一次性随机数）**：
    - **原理**：客户端在请求中携带一个服务器未曾见过的随机字符串（Nonce）。服务器维护一个已使用Nonce的缓存（如Redis，设置合理的过期时间），对于新请求，校验其Nonce是否已在缓存中，若存在则拒绝，若不存在则记录并处理请求。
    - **实现**：适用于关键操作（如支付、修改密码）。Nonce可由客户端生成（UUID），也可由服务器在首次交互时下发。
2. **时间戳**：
    - **原理**：请求中携带当前时间戳。服务器收到后，检查时间戳与服务器当前时间的差值是否在可接受的窗口内（如±5分钟）。超出窗口的请求视为重放，予以拒绝。
    - **实现**：需要保证客户端和服务端时钟基本同步（可通过NTP）。常与签名结合使用，将时间戳纳入签名计算，防止篡改。
3. **序列号**：
    - **原理**：为每个客户端或会话分配一个递增的序列号。服务器记录最后处理过的序列号，只接受序列号更大的请求。
    - **实现**：更复杂，需要维护状态，并处理请求乱序到达的问题，在分布式环境下挑战较大。
4. **在协议层面集成**：
    - **OAuth 2.0**：授权码只能使用一次。访问令牌通常寿命较短，并结合刷新令牌使用。
    - **HTTPS**：使用 TLS 可以防止请求在传输过程中被截获，但无法防止合法客户端恶意重放。
5. **请求签名**：
    - **原理**：对请求的关键要素（如方法、路径、参数、时间戳、Nonce）使用客户端密钥生成签名（如HMAC）。服务器用相同规则验证签名。由于时间戳和Nonce是签名的一部分，重放的请求无法通过签名验证（时间戳过期或Nonce重复）。
    - **实现**：这是API安全常用方案。例如，AWS Signature Version 4 就采用了类似机制。
**组合策略示例（API设计）**：
每个API请求必须包含：
- `X-Timestamp`: 请求发起时的UTC时间戳。
- `X-Nonce`: 一次性随机字符串。
- `X-Signature`: 对 `方法+URI+时间戳+Nonce+请求体`用客户端密钥计算的HMAC签名。
    服务器端校验逻辑：
    1. 检查时间戳是否在允许窗口内。
    2. 检查Redis中 `clientId:nonce`是否存在，若存在则拒绝。
    3. 重新计算签名并比对，验证请求完整性。
    4. 所有检查通过后，将Nonce存入Redis（设置过期时间略大于时间戳窗口），然后处理业务。
###### 5. 什么是 API 网关的安全策略？
API网关作为所有流量入口，是实施统一安全策略的理想位置，其安全策略构成了保护后端微服务的第一道防线。
**核心安全策略**：
1. **身份认证**：
    - **统一认证**：网关集中处理认证，避免每个微服务重复实现。支持多种方式：JWT校验、OAuth 2.0/OIDC令牌内省、API Key、Basic Auth等。
    - **实现**：网关配置认证过滤器，对未携带有效凭证或凭证无效的请求直接返回401。
2. **授权**：
    - **访问控制**：基于角色、权限或声明进行粗粒度授权。例如，检查JWT中的 `scope`或 `roles`声明是否包含访问该路径所需的权限。
    - **实现**：在网关进行路径-权限的映射校验。
3. **传输安全**：
    - **强制HTTPS/TLS**：终止SSL/TLS连接，对外只暴露HTTPS，内部服务间可采用HTTP或mTLS。
4. **流量控制与防攻击**：
    - **限流**：根据IP、用户、API Key实施速率限制，防止DDoS和资源滥用。
    - **防重放**：集成Nonce或时间戳校验。
    - **Web应用防火墙**：识别并阻断常见的Web攻击（如SQL注入、XSS）。
5. **请求/响应转换与脱敏**：
    - **数据脱敏**：在响应返回给客户端前，对敏感字段（如手机号、身份证号）进行掩码处理。
    - **请求校验**：对请求大小、内容类型进行限制。
6. **审计与日志**：
    - **全量访问日志**：记录所有经过网关的请求和响应元数据（时间、客户端、路径、状态码、耗时），用于安全审计和故障排查。
**源码/配置角度（以Spring Cloud Gateway为例）**：
安全策略主要通过自定义 `GlobalFilter`或使用内置过滤器实现。
- **认证**：自定义 `AuthFilter`，从请求头提取JWT，调用 `ReactiveJwtDecoder`进行验证。
- **限流**：集成Redis，使用 `RedisRateLimiter`过滤器。
- **路径授权**：在过滤器中解析JWT的Claims，与请求路径匹配的权限规则进行比对。
```java
public class JwtAuthFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String token = extractToken(exchange.getRequest());
        return jwtDecoder.decode(token)
                .flatMap(jwt -> {
                    if (!hasRequiredRole(jwt, exchange.getRequest().getPath().toString())) {
                        return Mono.error(new ForbiddenException(“Insufficient privileges”));
                    }
                    // 将验证信息传递给下游服务
                    exchange.getAttributes().put(“jwt”, jwt);
                    return chain.filter(exchange);
                }).onErrorResume(e -> {
                    exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                    return exchange.getResponse().setComplete();
                });
    }
}
```
###### 6. 如何实现分布式系统的审计日志？
审计日志记录的是 **“谁在什么时候对什么资源做了什么操作，结果如何”**​ ，用于满足合规性、安全取证和操作追踪。在分布式系统中，实现的关键在于**全链路关联**和**集中化处理**。
**设计要点**：
1. **审计事件模型**：定义清晰的审计事件结构，至少包含：
    - **审计主体**：谁操作的（用户ID、用户名、客户端IP、服务名）。
    - **操作时间**：精确时间戳。
    - **操作类型**：增、删、改、查、登录、登出。
    - **操作对象**：对什么资源操作（资源类型，如 `Order`；资源ID，如 `order_123`）。
    - **操作详情**：变更前后的值（对于更新操作尤为重要）。
    - **操作结果**：成功/失败，失败原因。
    - **追踪标识**：**TraceId**（关联整个请求链），**SpanId**（定位具体服务）。
2. **采集与上下文传递**：
    - **AOP切面**：在服务层或DAO层方法上，通过注解和切面统一采集审计数据。这是最常用的方式。
    - **框架事件**：利用Spring的 `ApplicationEvent`发布审计事件，由监听器异步处理。
    - **上下文传递**：确保 `TraceId`和用户身份信息能跨服务、跨线程（如异步任务）正确传递。可使用 `MDC`或 `ThreadLocal`（配合 `TransmittableThreadLocal`）。
3. **存储与查询**：
    - **存储选型**：由于审计日志是写多读少、按时间范围查询的场景，适合使用时序数据库或 **Elasticsearch**。ES支持全文搜索和复杂聚合，便于调查。
    - **数据分区**：按时间（如按月）进行索引分区，平衡查询性能和管理成本。
4. **实现示例（Spring AOP + Event）**：
```java
@Aspect
@Component
public class AuditLogAspect {
    @Autowired
    private ApplicationEventPublisher eventPublisher;

    @Around(“@annotation(auditLog)”)
    public Object around(ProceedingJoinPoint pjp, AuditLog auditLog) throws Throwable {
        AuditLogEvent event = new AuditLogEvent();
        event.setOperator(getCurrentUser());
        event.setOperation(auditLog.value());
        event.setResourceId(parseResourceId(pjp.getArgs()));
        event.setTraceId(MDC.get(“traceId”)); // 从MDC获取链路ID
        event.setStartTime(System.currentTimeMillis());

        try {
            Object result = pjp.proceed();
            event.setSuccess(true);
            event.setResultDetail(serializeResult(result));
            return result;
        } catch (Exception e) {
            event.setSuccess(false);
            event.setResultDetail(e.getMessage());
            throw e;
        } finally {
            event.setEndTime(System.currentTimeMillis());
            eventPublisher.publishEvent(event); // 异步发布
        }
    }
}

@Component
public class AuditLogEventListener {
    @Async // 异步处理，不影响主流程
    @EventListener
    public void handleAuditEvent(AuditLogEvent event) {
        // 将事件持久化到Elasticsearch或数据库
        auditLogRepository.save(event);
    }
}
```
**高级考量**：
- **性能**：异步化、批量写入。
- **可靠性**：使用消息队列（如Kafka）作为审计事件的中转，确保不丢失。
- **合规性**：日志防篡改（如写入区块链或只读存储），长期保留。