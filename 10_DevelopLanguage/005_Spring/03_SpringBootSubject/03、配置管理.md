###### 1. Spring Boot 支持哪些配置文件格式?
Spring Boot支持**两种主流配置文件格式**：Properties文件和YAML文件，两者在功能上等价但语法和适用场景不同。
**核心配置文件类型：**

- **application.properties**：传统的键值对格式，使用`key=value`语法
- **application.yaml**：层次化结构格式，通过缩进表示层级关系
**辅助配置文件：**
- **bootstrap.properties/yml**：用于Spring Cloud应用，优先于application配置加载
- **application-{profile}.properties/yml**：环境特定配置文件
###### 2. application.properties 和 application.yml 的区别是什么?
两者在功能上完全等价，主要区别在于**语法结构和可读性**。
**语法对比示例：**
```properties
# application.properties
server.port=8080
spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=123456
logging.level.com.example=DEBUG
```
```yaml
# application.yml
server:
  port: 8080
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test
    username: root
    password: 123456
logging:
  level:
    com.example: DEBUG
```
**设计选择建议：**
- **简单项目**：使用properties格式，语法简单直接
- **复杂配置**：使用YAML格式，层次结构更清晰
- **团队协作**：根据团队熟悉度选择，保持项目统一性
###### 3. Spring Boot 配置文件的加载顺序是怎样的?
Spring Boot配置加载采用**分层覆盖机制**，高优先级配置会覆盖低优先级配置。
**内部配置文件加载顺序（优先级从高到低）：**
1. 当前目录下的`/config`子目录
2. 当前目录
3. 类路径下的`/config`包
4. 类路径根目录
**外部配置源加载顺序（优先级从高到低）：**
5. 命令行参数
6. JNDI属性（来自`java:comp/env`）
7. Java系统属性（`System.getProperties()`）
8. 操作系统环境变量
9. 随机属性（`random.*`）
10. Profile特定外部配置文件
11. Profile特定内部配置文件
12. 主外部配置文件
13. 主内部配置文件
14. `@PropertySource`注解指定文件
15. 默认属性
**源码机制**：`ConfigFileApplicationListener`负责配置文件加载，通过`Loader.load()`方法按顺序解析各个位置的配置文件。
###### 4. 如何实现多环境配置?
Spring Boot通过**Profile机制**实现多环境配置，核心是`spring.profiles.active`属性。
**配置文件组织：**
```
src/main/resources/
├── application.yml          # 主配置
├── application-dev.yml     # 开发环境
├── application-test.yml    # 测试环境  
└── application-prod.yml    # 生产环境
```
**激活特定环境：**
```yaml
# application.yml
spring:
  profiles:
    active: dev  # 默认开发环境
```
```bash
# 命令行激活
java -jar app.jar --spring.profiles.active=prod
```
**YAML多文档块方式：**
```yaml
# application.yml
spring:
  profiles:
    active: dev
---
spring:
  profiles: dev
server:
  port: 8080
---
spring:  
  profiles: prod
server:
  port: 80
```
###### 5. @ConfigurationProperties 注解的作用是什么?
`@ConfigurationProperties`用于**批量绑定配置属性到Java对象**，支持类型安全配置访问。
**基础使用示例：**
```yaml
# application.yml
app:
  datasource:
    url: jdbc:mysql://localhost:3306/test
    username: admin
    pool-size: 10
    timeout: 5000
```
```java
@Component
@ConfigurationProperties(prefix = "app.datasource")
@Validated
public class DataSourceProperties {
    @NotBlank
    private String url;
    
    @NotBlank
    private String username;
    
    @Min(1)
    @Max(100)
    private int poolSize;
    
    private Duration timeout;
    
    // getters/setters...
}
```
**松散绑定支持**：支持多种属性命名风格（kebab-case、camelCase、snake_case等）自动映射。
###### 6. @Value 和 @ConfigurationProperties 的区别是什么?
两者都用于配置注入，但适用场景和功能有显著差异。
**对比分析：**

|**特性**​|**@Value**​|**@ConfigurationProperties**​|
|---|---|---|
|**注入粒度**​|字段级别|类级别批量绑定|
|**松散绑定**​|不支持|支持多种命名风格|
|**数据校验**​|不支持|支持JSR-303校验|
|**复杂类型**​|有限支持|完整支持（List、Map等）|
|**适用场景**​|简单值注入|结构化配置组|
**选择建议**：简单配置使用`@Value`，复杂结构化配置使用`@ConfigurationProperties`。
###### 7. 如何读取自定义配置文件?
除了默认配置文件，Spring Boot支持**加载自定义配置文件**。
**@PropertySource方式：**
```java
@Configuration
@PropertySource(value = "classpath:custom.properties", encoding = "UTF-8")
public class CustomConfig {
    
    @Value("${custom.api.url}")
    private String apiUrl;
    
    @Value("${custom.api.key}")  
    private String apiKey;
}
```
**编程式加载：**
```java
@Bean
public static PropertySourcesPlaceholderConfigurer propertyConfig() {
    PropertySourcesPlaceholderConfigurer configurer = new PropertySourcesPlaceholderConfigurer();
    configurer.setLocations(new ClassPathResource("custom.properties"));
    configurer.setIgnoreUnresolvablePlaceholders(true);
    return configurer;
}
```
###### 8. 如何加密配置文件中的敏感信息?
敏感信息加密是**安全最佳实践**，常用Jasypt库实现。
**集成Jasypt加密：**
```yaml
# application.yml
spring:
  datasource:
    password: ENC(密文密码)
jasypt:
  encryptor:
    password: ${JASYPT_PASSWORD:defaultKey}  # 从环境变量获取密钥
```
**加密工具类：**
```java
@Component
public class EncryptionUtil {
    
    @Autowired
    private StringEncryptor encryptor;
    
    public String encrypt(String plainText) {
        return encryptor.encrypt(plainText);
    }
    
    public String decrypt(String encryptedText) {
        return encryptor.decrypt(encryptedText);
    }
}
```
###### 9. Spring Boot 如何实现配置的动态刷新?
配置动态刷新通过@RefreshScope机制**实现，无需重启应用即可更新配置。
启用动态刷新：**
```java
@RestController
@RefreshScope
public class ConfigController {
    
    @Value("${dynamic.config.value}")
    private String dynamicValue;
    
    @GetMapping("/value")
    public String getValue() {
        return dynamicValue;
    }
}
```
**手动触发刷新：**
```bash
# 发送POST请求到/actuator/refresh端点
curl -X POST http://localhost:8080/actuator/refresh
```
###### 10. Profile 的作用是什么，如何使用?
Profile是**环境隔离的核心机制**，允许为不同环境定义不同配置。
**Profile激活方式：**
```properties
# 命令行激活
--spring.profiles.active=dev,debug

# 系统属性激活  
-Dspring.profiles.active=prod

# 环境变量激活
export SPRING_PROFILES_ACTIVE=test
```
**条件化Bean配置：**
```java
@Configuration
public class DatabaseConfig {
    
    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        return new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2).build();
    }
    
    @Bean  
    @Profile("prod")
    public DataSource prodDataSource() {
        return DataSourceBuilder.create().build();
    }
}
```
###### 11. 如何在代码中动态切换 Profile?
动态Profile切换通过**ConfigurableEnvironment**实现。
**编程式切换：**
```java
@Service
public class ProfileService {
    
    @Autowired
    private ConfigurableEnvironment environment;
    
    public void switchToProfile(String profile) {
        environment.setActiveProfiles(profile);
        // 触发配置重新加载
        ((AbstractEnvironment) environment).refresh();
    }
    
    public String getActiveProfiles() {
        return String.join(",", environment.getActiveProfiles());
    }
}
```
###### 12. 外部化配置的优先级是怎样的?
外部化配置优先级遵循**由外到内、由特到普**原则。
**完整优先级列表（从高到低）：**
1. 命令行参数（`--key=value`）
2. JNDI属性（`java:comp/env`）
3. Java系统属性（`-Dkey=value`）
4. 操作系统环境变量
5. 随机属性（`random.*`）
6. 外部Profile特定配置
7. 内部Profile特定配置
8. 外部主配置
9. 内部主配置
10. `@Configuration`类上的`@PropertySource`
11. 默认属性
###### 13. 如何使用命令行参数覆盖配置?
命令行参数具有**最高优先级**，适合临时配置覆盖。
**常见覆盖场景：**
```bash
# 覆盖服务器端口
java -jar app.jar --server.port=9090

# 覆盖数据库连接
java -jar app.jar --spring.datasource.url=jdbc:mysql://prod-db:3306/app

# 激活特定Profile
java -jar app.jar --spring.profiles.active=prod

# 覆盖多个配置
java -jar app.jar --server.port=9090 --logging.level.root=DEBUG
```
###### 14. Spring Cloud Config 与 Spring Boot 配置的关系是什么?
Spring Cloud Config是**分布式配置管理方案**，扩展了Spring Boot的配置能力。
**集成关系：**
```yaml
# bootstrap.yml（Config Client配置）
spring:
  application:
    name: my-service
  cloud:
    config:
      uri: http://config-server:8888
      fail-fast: true
      retry:
        max-attempts: 6
```

**配置优先级**：远程配置中心配置 > 本地配置 > 默认配置。
###### 15. 如何实现配置文件的版本控制?
配置文件版本控制是**DevOps最佳实践**，确保配置变更可追溯。
**Git版本控制：**
```bash
# 配置文件目录结构
src/main/resources/
├── application.yml
├── application-dev.yml
└── application-prod.yml

# Git提交规范
git commit -m "feat(config): 更新数据库配置
- 增加连接池参数
- 调整超时时间"
```
**配置迁移管理：**
```yaml
# 使用DB版本管理（如Flyway/Liquibase）
spring:
  flyway:
    locations: classpath:db/migration
    baseline-on-migrate: true
```