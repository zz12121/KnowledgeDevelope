###### 1. Spring Boot 如何进行单元测试?
Spring Boot单元测试基于**JUnit 5框架**和**Spring TestContext框架**构建，通过自动配置机制提供完整的测试支持。其核心设计哲学是"约定优于配置"，通过丰富的测试注解和工具类简化测试代码编写。
**单元测试完整流程如下：**
**1. 添加测试依赖**（Maven配置）：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```
该依赖会传递引入JUnit 5、Mockito、AssertJ、JSONPath等测试相关库，形成完整的测试工具链。
**2. 创建测试类结构**：
测试类应位于`src/test/java`目录，包名与主代码保持一致。基础测试类结构如下：
```java
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest  // 启用Spring Boot测试支持
class ApplicationTests {
    
    @Test
    void contextLoads() {
        // 基础上下文加载测试
    }
}
```
**3. 测试配置分层**：
Spring Boot支持不同粒度的测试配置，通过特定注解实现测试隔离：
- **全应用测试**：`@SpringBootTest`- 加载完整应用上下文
- **Web层测试**：`@WebMvcTest`- 仅加载Web相关组件
- **数据层测试**：`@DataJpaTest`- 仅配置JPA相关组件
- **JSON测试**：`@JsonTest`- 仅配置JSON序列化组件
这种分层设计确保测试的**精准性和执行效率**。
**4. 测试执行与断言**：
Spring Boot整合AssertJ提供流式断言API，大大提升测试可读性：
```java
@Test
void testServiceMethod() {
    String result = myService.processData("input");
    
    // AssertJ流式断言
    assertThat(result)
        .isNotNull()
        .startsWith("processed")
        .hasSize(10);
}
```
**5. 测试生命周期管理**：
通过JUnit 5的`@BeforeEach`、`@AfterEach`等注解管理测试资源：
```java
@SpringBootTest
class ServiceTest {
    
    @Autowired
    private DataSource dataSource;
    
    @BeforeEach
    void setUp() {
        // 每个测试方法执行前初始化测试数据
    }
    
    @AfterEach  
    void tearDown() {
        // 清理测试数据
    }
}
```
通过这一完整流程，Spring Boot为开发者提供了企业级的单元测试基础设施。
###### 2. @SpringBootTest 注解的作用是什么?
`@SpringBootTest`是Spring Boot测试体系的**核心注解**，其本质是一个组合注解，元注解包含`@BootstrapWith`和`@ExtendWith`，用于启动Spring应用上下文并启用自动配置。
**源码级作用机制**：
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(SpringBootTestContextBootstrapper.class)  // 引导测试上下文
@ExtendWith(SpringExtension.class)  // 集成JUnit 5
public @interface SpringBootTest {
    // 关键配置属性
    WebEnvironment webEnvironment() default WebEnvironment.MOCK;
    Class<?>[] classes() default {};
    String[] properties() default {};
}
```
**核心功能详解**：
**1. 应用上下文加载**：
`@SpringBootTest`通过`SpringBootTestContextBootstrapper`引导Spring应用上下文的创建过程。默认情况下，它会从`@SpringBootApplication`注解的主类开始，执行与真实应用相同的组件扫描和自动配置流程。
**2. Web环境配置**：
通过`webEnvironment`属性支持四种不同的Web测试环境：
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class IntegrationTest {
    @LocalServerPort
    private int port;  // 注入随机端口号
    
    @Test
    void fullIntegrationTest() {
        // 在真实服务器环境下测试
    }
}
```
- **MOCK**（默认）：模拟Servlet环境，不启动实际服务器
- **RANDOM_PORT**：启动嵌入式服务器并随机分配端口
- **DEFINED_PORT**：使用配置文件中定义的端口
- **NONE**：不提供Web环境
**3. 配置定制能力**：
支持通过属性覆盖和指定配置类来定制测试环境：
```java
@SpringBootTest(
    properties = {
        "spring.datasource.url=jdbc:h2:mem:testdb",
        "server.port=8080"
    },
    classes = {TestConfig.class, MainApplication.class}
)
class CustomConfigTest {
    // 使用特定配置的测试
}
```
**4. 上下文缓存优化**：
Spring TestContext框架会**缓存应用上下文**，相同配置的测试类共享同一个Spring上下文，避免重复初始化带来的性能开销。可通过`@DirtiesContext`注解强制刷新缓存。
**与其它测试注解的协同关系**：
`@SpringBootTest`是**最重量级**的测试注解，适用于集成测试场景。对于切片测试，应优先选择更轻量级的注解如`@WebMvcTest`（Web层测试）或`@DataJpaTest`（数据层测试）以提高测试执行速度。
###### 3. 如何进行 Mock 测试（Mockito）?
Mock测试是单元测试的**核心手段**，通过模拟依赖对象的行为来实现测试隔离。Spring Boot与Mockito深度集成，提供`@MockBean`和`@SpyBean`注解来简化Mock对象的管理。
**Mockito集成原理**：
Spring Boot通过`MockitoPostProcessor`后置处理器实现Mock对象的自动注入。当检测到`@MockBean`注解时，该处理器会创建Mockito mock对象并注册到Spring上下文中，替换同类型的现有bean。
**基础Mock测试流程**：
**1. 手动创建Mock对象**：
```java
@Test
void testWithManualMock() {
    // 创建依赖对象的Mock实例
    UserRepository mockRepo = Mockito.mock(UserRepository.class);
    
    // 配置Mock行为
    when(mockRepo.findById(1L)).thenReturn(Optional.of(new User("test")));
    
    // 注入被测试对象
    UserService service = new UserService(mockRepo);
    
    // 执行测试并验证
    User result = service.getUser(1L);
    assertThat(result.getName()).isEqualTo("test");
    
    // 验证交互行为
    verify(mockRepo).findById(1L);
}
```
**2. 使用注解驱动Mock**（推荐方式）：
```java
@ExtendWith(MockitoExtension.class)  // 启用Mockito支持
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;  // 创建Mock对象
    
    @InjectMocks
    private UserService userService;  // 自动注入Mock依赖
    
    @Test
    void getUser_shouldReturnUser() {
        // 给定-Mock配置
        User mockUser = new User("John");
        when(userRepository.findById(1L)).thenReturn(Optional.of(mockUser));
        
        // 当-执行测试方法
        User result = userService.getUser(1L);
        
        // 那么-验证结果
        assertThat(result).isEqualTo(mockUser);
    }
}
```
**3. Spring Boot增强的Mock支持**：
```java
@SpringBootTest
class ServiceIntegrationTest {
    
    @MockBean  // Spring管理的Mock，会自动替换上下文中的Bean
    private ExternalService externalService;
    
    @Autowired
    private MainService mainService;  // 会自动注入Mock后的依赖
    
    @Test
    void testWithMockBean() {
        when(externalService.callApi()).thenReturn("mocked response");
        
        String result = mainService.processWithExternal();
        
        assertThat(result).contains("mocked");
    }
}
```
**高级Mock技术**：
**1. 行为验证**：
```java
@Test
void verifyInteractions() {
    userService.getUser(1L);
    
    // 验证方法调用次数
    verify(userRepository, times(1)).findById(1L);
    
    // 验证无其他交互
    verifyNoMoreInteractions(userRepository);
}
```
**2. 异常模拟**：
```java
@Test
void testExceptionScenario() {
    when(userRepository.findById(999L))
        .thenThrow(new RuntimeException("User not found"));
    
    assertThatThrownBy(() -> userService.getUser(999L))
        .isInstanceOf(RuntimeException.class)
        .hasMessage("User not found");
}
```
**3. 参数匹配器**：
```java
@Test
void testWithArgumentMatchers() {
    // 使用灵活的参数匹配
    when(userRepository.findById(anyLong())).thenReturn(defaultUser);
    when(userRepository.findByEmail(eq("test@example.com"))).thenReturn(user);
    
    // 自定义参数匹配器
    when(userRepository.findByAge(argThat(age -> age > 18))).thenReturn(adults);
}
```
通过合理的Mock测试，可以显著提升单元测试的**执行速度和可靠性**，实现真正的测试隔离
###### 4. 如何测试 Controller 层?
Controller层测试主要验证HTTP接口的**请求映射、参数绑定、响应生成**等Web相关功能。Spring Boot提供`@WebMvcTest`注解进行专注的Web层测试。
**测试体系架构**：
Controller测试基于**Spring MVC Test框架**，核心组件是`MockMvc`，它模拟Servlet容器环境，无需启动实际Web服务器即可测试Controller行为。
**基础测试配置**：
**1. 切片测试配置**（推荐方式）：
```java
@WebMvcTest(UserController.class)  // 仅加载Web相关组件
class UserControllerTest {
    
    @Autowired
    private MockMvc mockMvc;  // 自动配置的MockMvc实例
    
    @MockBean
    private UserService userService;  // 模拟Service层依赖
    
    @Test
    void getUser_shouldReturnUser() throws Exception {
        // 配置Mock行为
        User mockUser = new User(1L, "John");
        when(userService.getUser(1L)).thenReturn(mockUser);
        
        // 执行GET请求并验证响应
        mockMvc.perform(get("/users/1")  // 模拟HTTP GET
                .accept(MediaType.APPLICATION_JSON))
            .andDo(print())  // 打印详细请求/响应信息
            .andExpect(status().isOk())  // 验证状态码
            .andExpect(content().contentType(MediaType.APPLICATION_JSON))
            .andExpect(jsonPath("$.id").value(1))  // JSON路径断言
            .andExpect(jsonPath("$.name").value("John"));
    }
}
```
**2. 完整上下文测试**：
```java
@SpringBootTest(webEnvironment = WebEnvironment.MOCK)
@AutoConfigureMockMvc  // 自动配置MockMvc
class UserControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    void contextLoads() {
        // 完整集成测试
    }
}
```
**进阶测试场景**：
**1. 请求参数测试**：
```java
@Test
void testRequestParameters() throws Exception {
    mockMvc.perform(get("/users")
            .param("page", "0")  // 查询参数
            .param("size", "20")
            .header("Authorization", "Bearer token123")  // 请求头
            .cookie(new Cookie("session", "abc123")))  // Cookie
        .andExpect(status().isOk());
}
```
**2. 请求体测试**：
```java
@Test
void createUser_shouldReturnCreated() throws Exception {
    String userJson = """
        {
            "name": "John",
            "email": "john@example.com"
        }
        """;
    
    mockMvc.perform(post("/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content(userJson))  // JSON请求体
        .andExpect(status().isCreated())
        .andExpect(header().string("Location", containsString("/users/")));
}
```
**3. 异常处理测试**：
```java
@Test
void getUser_notFound_shouldReturn404() throws Exception {
    when(userService.getUser(999L))
        .thenThrow(new UserNotFoundException("User not found"));
    
    mockMvc.perform(get("/users/999"))
        .andExpect(status().isNotFound())
        .andExpect(jsonPath("$.error").value("USER_NOT_FOUND"));
}
```
**4. 会话和安全测试**：
```java
@Test
void testWithSecurityContext() throws Exception {
    mockMvc.perform(get("/profile")
            .with(SecurityMockMvcRequestPostProcessors
                .user("admin").roles("ADMIN")))  // 模拟认证用户
        .andExpect(status().isOk());
}
```
**测试验证要点**：
- **HTTP状态码**：验证正确的响应状态
- **响应内容**：验证JSON/XML响应体结构
- **头部信息**：验证Location、Content-Type等头部
- **业务逻辑**：验证业务数据处理正确性
- **异常处理**：验证异常转换和错误响应
通过`MockMvc`的流式API，可以构建**表达力强且维护性好**的Controller测试代码。
###### 5. 如何测试 Service 层?
Service层测试关注**业务逻辑的正确性**，通常需要模拟外部依赖（如Repository、第三方服务）来实现测试隔离。测试策略根据复杂度可分为纯单元测试和集成测试两种模式。
**测试策略选择**：
- **纯单元测试**：使用Mockito单独测试Service逻辑，适合业务逻辑复杂的场景
- **集成测试**：使用`@DataJpaTest`或`@SpringBootTest`进行部分或完整集成测试，适合验证数据访问逻辑
**纯单元测试示例**：
```java
@ExtendWith(MockitoExtension.class)
class UserServiceUnitTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private EmailService emailService;
    
    @InjectMocks
    private UserServiceImpl userService;  // 注入Mock依赖
    
    @Test
    void createUser_shouldSaveUserAndSendEmail() {
        // 给定-测试数据准备
        UserCreateRequest request = new UserCreateRequest("John", "john@example.com");
        User savedUser = new User(1L, "John", "john@example.com");
        
        // 配置Mock行为
        when(userRepository.save(any(User.class))).thenReturn(savedUser);
        doNothing().when(emailService).sendWelcomeEmail(anyString());
        
        // 当-执行测试方法
        User result = userService.createUser(request);
        
        // 那么-验证结果和交互
        assertThat(result.getId()).isNotNull();
        verify(userRepository).save(any(User.class));  // 验证保存调用
        verify(emailService).sendWelcomeEmail("john@example.com");  // 验证邮件发送
        verifyNoMoreInteractions(userRepository, emailService);  // 验证无多余交互
    }
    
    @Test
    void createUser_duplicateEmail_shouldThrowException() {
        UserCreateRequest request = new UserCreateRequest("John", "duplicate@example.com");
        
        when(userRepository.existsByEmail("duplicate@example.com")).thenReturn(true);
        
        assertThatThrownBy(() -> userService.createUser(request))
            .isInstanceOf(DuplicateEmailException.class)
            .hasMessage("邮箱已存在");
            
        verify(userRepository, never()).save(any(User.class));  // 验证未调用保存
    }
}
```
**集成测试示例**：
```java
@DataJpaTest  // 仅配置JPA相关组件，使用内存数据库
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class UserServiceIntegrationTest {
    
    @Autowired
    private TestEntityManager entityManager;  // JPA测试工具
    
    @Autowired
    private UserRepository userRepository;
    
    private UserService userService;
    
    @BeforeEach
    void setUp() {
        userService = new UserServiceImpl(userRepository);
    }
    
    @Test
    void createUser_shouldPersistUser() {
        UserCreateRequest request = new UserCreateRequest("John", "john@example.com");
        
        User result = userService.createUser(request);
        
        // 验证数据库中的实际状态
        User persisted = entityManager.find(User.class, result.getId());
        assertThat(persisted.getName()).isEqualTo("John");
        assertThat(persisted.getEmail()).isEqualTo("john@example.com");
    }
}
```
**事务性测试控制**：
```java
@SpringBootTest
@Transactional  // 测试后自动回滚
class UserServiceTxTest {
    
    @Autowired
    private UserService userService;
    
    @Test
    void testWithinTransaction() {
        User user = userService.createUser(new UserCreateRequest("Test", "test@example.com"));
        
        // 事务内数据可见性验证
        assertThat(userService.getUser(user.getId())).isPresent();
    }
    // 测试方法结束后自动回滚，数据库状态恢复
}
```
**异步服务测试**：
```java
@Test
void processAsync_shouldComplete() {
    CompletableFuture<String> future = userService.processAsync("data");
    
    // 异步结果验证
    assertThat(future)
        .succeedsWithin(5, TimeUnit.SECONDS)
        .isEqualTo("processed_data");
}
```
Service层测试应重点关注**业务规则验证**、**异常场景覆盖**和**组件集成正确性**，通过合理的测试策略确保业务逻辑的可靠性。
###### 6. 如何测试 Repository 层?
Repository层测试主要验证**数据访问逻辑的正确性**，包括CRUD操作、查询方法、事务管理等。Spring Boot通过`@DataJpaTest`注解提供专门的数据层测试支持。
**测试环境配置**：
```java
@DataJpaTest  // 自动配置内存数据库、JPA等基础设施
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)  // 可选：使用真实数据库
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class UserRepositoryTest {
    
    @Autowired
    private TestEntityManager entityManager;  // JPA测试工具类
    
    @Autowired  
    private UserRepository userRepository;  // 被测试的Repository
    
    private User testUser;
    
    @BeforeEach
    void setUp() {
        testUser = entityManager.persistFlushFind(new User("John", "john@example.com"));
    }
}
```
**核心测试场景**：
**1. 基础CRUD操作测试**：
```java
@Test
void save_shouldPersistUser() {
    User newUser = new User("Alice", "alice@example.com");
    
    User saved = userRepository.save(newUser);
    
    assertThat(saved.getId()).isNotNull();
    assertThat(saved.getCreatedAt()).isNotNull();  // 审计字段验证
}

@Test
void findById_shouldReturnUser() {
    Optional<User> found = userRepository.findById(testUser.getId());
    
    assertThat(found).isPresent();
    assertThat(found.get().getName()).isEqualTo("John");
}

@Test
void update_shouldModifyUser() {
    testUser.setName("John Updated");
    
    User updated = userRepository.save(testUser);
    
    assertThat(updated.getName()).isEqualTo("John Updated");
}

@Test
void delete_shouldRemoveUser() {
    userRepository.delete(testUser);
    
    assertThat(userRepository.findById(testUser.getId())).isEmpty();
}
```
**2. 自定义查询方法测试**：
```java
@Test
void findByEmail_shouldReturnUser() {
    Optional<User> found = userRepository.findByEmail("john@example.com");
    
    assertThat(found).isPresent();
    assertThat(found.get().getId()).isEqualTo(testUser.getId());
}

@Test
void existsByEmail_shouldReturnTrue() {
    boolean exists = userRepository.existsByEmail("john@example.com");
    
    assertThat(exists).isTrue();
}

@Test
void countByActive_shouldReturnCount() {
    long activeCount = userRepository.countByActiveTrue();
    
    assertThat(activeCount).isEqualTo(1);
}
```
**3. 复杂查询测试**：
```java
@Test
void findActiveUsersCreatedAfter_shouldReturnFilteredList() {
    // 准备测试数据
    User inactiveUser = new User("Inactive", "inactive@example.com");
    inactiveUser.setActive(false);
    entityManager.persist(inactiveUser);
    
    // 执行复杂查询
    List<User> activeUsers = userRepository.findActiveUsersCreatedAfter(
        LocalDateTime.now().minusDays(1));
    
    assertThat(activeUsers).hasSize(1);
    assertThat(activeUsers.get(0).isActive()).isTrue();
}
```
**事务和回滚测试**：
```java
@DataJpaTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)  // 禁用事务
class UserRepositoryTxTest {
    
    @Test
    void saveWithoutTransaction_shouldWork() {
        User user = new User("NoTx", "notx@example.com");
        
        User saved = userRepository.save(user);
        
        // 显式刷新并验证持久化
        entityManager.flush();
        assertThat(entityManager.find(User.class, saved.getId())).isNotNull();
    }
}
```
**测试数据初始化**：
```java
@Sql("/test-data/users.sql")  // 使用SQL脚本初始化数据
@Test
void testWithSqlData() {
    List<User> users = userRepository.findAll();
    assertThat(users).hasSize(5);  // 验证脚本数据
}

@SqlGroup({
    @Sql(scripts = "/test-data/cleanup.sql", executionPhase = BEFORE_TEST_METHOD),
    @Sql(scripts = "/test-data/setup.sql", executionPhase = BEFORE_TEST_METHOD)
})
@Test
void testWithSqlGroup() {
    // 测试方法
}
```
Repository测试确保数据访问层的**正确性和可靠性**，为上层服务提供稳定的数据访问基础。
###### 7. 如何进行集成测试?
集成测试验证**多个组件协同工作**的正确性，关注模块间的接口契约和数据流。Spring Boot通过`@SpringBootTest`结合真实或模拟的外部依赖提供完整的集成测试支持。
**完整应用集成测试**：
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class ApplicationIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;  // 支持真实HTTP调用
    
    @LocalServerPort
    private int serverPort;  // 注入随机端口
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void fullWorkflow_shouldWork() {
        // 准备测试数据
        User user = new User("Integration", "integration@example.com");
        User saved = userRepository.save(user);
        
        // 通过HTTP调用验证完整流程
        ResponseEntity<User> response = restTemplate.getForEntity(
            "http://localhost:" + serverPort + "/users/{id}", 
            User.class, saved.getId());
        
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().getName()).isEqualTo("Integration");
    }
}
```
**外部服务集成测试**：
```java
@SpringBootTest
@Testcontainers  // 使用Testcontainers启动真实依赖
class ExternalServiceIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13");
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
    
    @Test
    void testWithRealDatabase() {
        // 使用真实PostgreSQL测试
    }
}
```
**消息队列集成测试**：
```java
@SpringBootTest
@Import(TestRabbitConfiguration.class)
class MessageQueueIntegrationTest {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @Autowired
    private MessageListener messageListener;
    
    @Test
    void messageFlow_shouldWork() throws InterruptedException {
        String testMessage = "Test message";
        
        rabbitTemplate.convertAndSend("test.exchange", "test.routing", testMessage);
        
        // 等待消息处理
        await().atMost(5, TimeUnit.SECONDS)
            .untilAsserted(() -> {
                assertThat(messageListener.getLastMessage()).isEqualTo(testMessage);
            });
    }
}
```
**REST客户端集成测试**：
```java
@SpringBootTest(webEnvironment = WebEnvironment.DEFINED_PORT)
@RestClientTest(ExternalApiClient.class)
@Import(TestRestTemplateConfiguration.class)
class RestClientIntegrationTest {
    
    @Autowired
    private ExternalApiClient apiClient;
    
    @MockBean
    private RestTemplateBuilder restTemplateBuilder;
    
    @Test
    void externalApiCall_shouldWork() {
        // 配置模拟的REST响应
        setupMockServerResponse();
        
        ExternalData result = apiClient.fetchData("123");
        
        assertThat(result).isNotNull();
    }
}
```
集成测试确保系统在**真实或接近真实的环境**中正常工作，是发布前的重要验证环节。
###### 8. 如何测试异步方法?
异步方法测试需要特殊处理**异步执行时序**和**结果获取**。Spring Boot提供`@Async`支持与相应的测试工具。
**CompletableFuture异步测试**：
```java
@SpringBootTest
class AsyncServiceTest {
    
    @Autowired
    private AsyncUserService asyncUserService;
    
    @Test
    void processAsync_shouldComplete() {
        CompletableFuture<String> future = asyncUserService.processAsync("data");
        
        // 阻塞等待结果并验证
        assertThat(future)
            .succeedsWithin(5, TimeUnit.SECONDS)  // 超时控制
            .isEqualTo("processed_data");
    }
    
    @Test
    void processAsync_exception_shouldFail() {
        CompletableFuture<String> future = asyncUserService.processAsync("error");
        
        assertThat(future)
            .failsWithin(5, TimeUnit.SECONDS)
            .withThrowableOfType(ExecutionException.class)
            .withCauseInstanceOf(BusinessException.class);
    }
}
```
**@Async方法测试**：
```java
@SpringBootTest
class AsyncAnnotationTest {
    
    @Autowired
    private AsyncService asyncService;
    
    @SpyBean
    private TaskExecutor taskExecutor;  // 监视异步执行器
    
    @Test
    void asyncMethod_shouldExecuteInSeparateThread() throws InterruptedException {
        CompletableFuture<String> future = asyncService.asyncMethod("test");
        
        // 验证异步执行
        verify(taskExecutor, timeout(1000)).execute(any(Runnable.class));
        
        String result = future.get(2, TimeUnit.SECONDS);
        assertThat(result).isEqualTo("processed_test");
    }
}
```
**事件监听异步测试**：
```java
@SpringBootTest
class AsyncEventListenerTest {
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    @SpyBean
    private UserEventListener eventListener;
    
    @Test
    void asyncEvent_shouldBeProcessed() {
        UserCreatedEvent event = new UserCreatedEvent(new User("John", "john@example.com"));
        
        eventPublisher.publishEvent(event);
        
        // 验证异步事件处理
        verify(eventListener, timeout(5000)).handleUserCreated(event);
    }
}
```
**响应式编程测试**（Reactor）：
```java
@SpringBootTest
class ReactiveServiceTest {
    
    @Autowired
    private ReactiveUserService reactiveUserService;
    
    @Test
    void fluxOperation_shouldEmitItems() {
        Flux<String> result = reactiveUserService.getUsers();
        
        StepVerifier.create(result)  // Reactor测试工具
            .expectNext("user1", "user2", "user3")
            .verifyComplete();
    }
    
    @Test
    void monoOperation_shouldEmitSingle() {
        Mono<User> result = reactiveUserService.findUser(1L);
        
        StepVerifier.create(result)
            .assertNext(user -> assertThat(user.getName()).isEqualTo("John"))
            .verifyComplete();
    }
}
```
异步测试确保异步逻辑的**正确性和可靠性**，避免并发相关问题。