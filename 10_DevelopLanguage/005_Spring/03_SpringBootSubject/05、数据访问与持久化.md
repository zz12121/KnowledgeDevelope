###### 1. Spring Boot 如何集成 MyBatis?
Spring Boot通过`mybatis-spring-boot-starter`提供了**开箱即用**的MyBatis集成方案，其核心是基于自动配置机制。
**源码级集成原理：**
`MybatisAutoConfiguration`是自动配置的核心类，通过`@ConditionalOnClass`注解检测类路径下存在`SqlSessionFactory`和`DataSource`时自动生效：
```java
@Configuration
@ConditionalOnClass({SqlSessionFactory.class, SqlSessionFactoryBean.class})
@EnableConfigurationProperties(MybatisProperties.class)
@AutoConfigureAfter(DataSourceAutoConfiguration.class)
public class MybatisAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
        // 创建SqlSessionFactoryBean并配置数据源
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);
        return sessionFactory.getObject();
    }
}
```
**完整集成步骤：**
1. **添加依赖**（核心starter）：
```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.3.1</version>
</dependency>
```
1. **配置数据源和MyBatis参数**：
```yaml
# application.yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver

mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.example.entity
  configuration:
    map-underscore-to-camel-case: true
    cache-enabled: true
```
1. **配置Mapper扫描**（二选一）：
```java
// 方式1：启动类添加@MapperScan
@SpringBootApplication
@MapperScan("com.example.mapper")
public class Application { }

// 方式2：每个Mapper接口添加@Mapper注解
@Mapper
public interface UserMapper {
    User selectById(Long id);
}
```
1. **XML映射文件编写**：
```xml
<!-- src/main/resources/mapper/UserMapper.xml -->
<mapper namespace="com.example.mapper.UserMapper">
    <select id="selectById" resultType="User">
        SELECT * FROM user WHERE id = #{id}
    </select>
</mapper>
```
###### 2. Spring Boot 如何集成 JPA?
Spring Data JPA通过**Repository抽象层**极大简化了数据访问代码，基于Hibernate实现。
**自动配置核心**：`JpaRepositoriesAutoConfiguration`负责自动化配置，检测到`EntityManagerFactory`和`PlatformTransactionManager`时激活。
**集成步骤详解：**
1. **添加starter依赖**：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```
1. **JPA配置**：
```yaml
spring:
  jpa:
    hibernate:
      ddl-auto: update  # 开发环境可用，生产建议用validate
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
        format_sql: true
```
1. **实体类定义**（ORM映射）：
```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String username;
    
    // 关联关系示例
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    private List<Order> orders = new ArrayList<>();
}
```
1. **Repository接口定义**：
```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // 方法名自动推导查询
    List<User> findByUsernameContaining(String keyword);
    
    // 分页查询
    Page<User> findByAgeGreaterThan(int age, Pageable pageable);
    
    // 自定义查询
    @Query("SELECT u FROM User u WHERE u.email LIKE %:email%")
    List<User> findByEmailPattern(@Param("email") String email);
}
```
###### 3. MyBatis 和 JPA 的区别是什么?
两者代表了**不同的持久层设计哲学**，从源码架构到应用场景都有显著差异。

|**维度**​|**MyBatis**​|**Spring Data JPA**​|
|---|---|---|
|**设计理念**​|SQL映射框架，SQL可控性第一|ORM框架，面向对象第一|
|**SQL控制**​|完全掌控，手动编写优化SQL|自动生成，可通过@Query自定义|
|**学习曲线**​|平缓，熟悉SQL即可上手|陡峭，需掌握JPA规范、实体状态管理|
|**开发效率**​|CRUD需手动编码，复杂SQL高效|简单CRUD零编码，派生查询高效|
|**性能调优**​|直接优化SQL语句，精准控制|需理解Hibernate缓存、懒加载机制|
|**适用场景**​|复杂报表、遗留系统、高性能要求|快速原型、领域驱动设计、标准CRUD|
**源码架构差异**：
- **MyBatis**：通过`SqlSessionTemplate`管理会话，`MapperProxy`实现接口动态代理
- **JPA**：基于`EntityManager`持久化上下文，`SimpleJpaRepository`提供默认实现
**选择建议**：需要精细控制SQL或处理复杂查询用MyBatis；追求开发效率且对象模型复杂用JPA。
###### 4. 如何配置多数据源?
多数据源配置需要**手动定义多个DataSource Bean**并明确指定其使用范围。
**核心配置示例：**
1. **主数据源配置**：
```java
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
    basePackages = "com.example.primary.repository",
    entityManagerFactoryRef = "primaryEntityManagerFactory",
    transactionManagerRef = "primaryTransactionManager"
)
public class PrimaryDataSourceConfig {
    
    @Bean
    @Primary
    @ConfigurationProperties("spring.datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    @Primary
    public LocalContainerEntityManagerFactoryBean primaryEntityManagerFactory(
            EntityManagerFactoryBuilder builder) {
        return builder
            .dataSource(primaryDataSource())
            .packages("com.example.primary.entity")
            .persistenceUnit("primary")
            .build();
    }
}
```
1. **次数据源配置**：
```java
@Configuration
@EnableJpaRepositories(
    basePackages = "com.example.secondary.repository",
    entityManagerFactoryRef = "secondaryEntityManagerFactory", 
    transactionManagerRef = "secondaryTransactionManager"
)
public class SecondaryDataSourceConfig {
    
    @Bean
    @ConfigurationProperties("spring.datasource.secondary")
    public DataSource secondaryDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    public LocalContainerEntityManagerFactoryBean secondaryEntityManagerFactory(
            EntityManagerFactoryBuilder builder) {
        return builder
            .dataSource(secondaryDataSource())
            .packages("com.example.secondary.entity")
            .persistenceUnit("secondary")
            .build();
    }
}
```
1. **配置文件**：
 ```yaml
spring:
  datasource:
    primary:
      url: jdbc:mysql://localhost:3306/primary_db
      username: user1
      password: pass1
    secondary:
      url: jdbc:mysql://localhost:3306/secondary_db  
      username: user2
      password: pass2
 ```
###### 5. Spring Boot 默认使用的数据库连接池是什么?
Spring Boot 2.x及以上版本**默认使用HikariCP**作为数据库连接池，这是因其**高性能和轻量级**特性。
**自动配置源码分析**：
`DataSourceConfiguration`中根据条件选择连接池实现：
```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(HikariDataSource.class)
@ConditionalOnMissingBean(DataSource.class)
@ConditionalOnProperty(name = "spring.datasource.type", havingValue = "com.zaxxer.hikari.HikariDataSource", matchIfMissing = true)
static class Hikari {
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.hikari")
    HikariDataSource dataSource(DataSourceProperties properties) {
        return properties.initializeDataSourceBuilder().type(HikariDataSource.class).build();
    }
}
```
**HikariCP优势特性**：
- **并发优化**：使用`ConcurrentBag`实现无锁连接获取
- **字节码优化**：通过Javassist字节码技术减少方法调用开销
- **智能清理**：自动回收泄漏连接，避免连接池耗尽
###### 6. HikariCP 的优势是什么?
HikariCP的**高性能源于极简设计和算法优化**，相比传统连接池有显著优势。
**源码级性能优化：**
1. **无锁设计**：`ConcurrentBag`采用ThreadLocal和CopyOnWriteArray结合，减少锁竞争：
```java
public class ConcurrentBag<T> implements AutoCloseable {
    // 使用ThreadLocal存储当前线程可用的连接
    private final ThreadLocal<List<Object>> threadList;
    // 无锁的共享连接队列
    private final CopyOnWriteArrayList<T> sharedList;
}
```
1. **字节码优化**：对关键方法使用Javassist进行字节码增强，减少动态分派开销。
2. **配置优化建议**：
```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20           # CPU核心数 * 2 + 1
      minimum-idle: 5                 # 与maximum-pool-size相同
      connection-timeout: 30000       # 连接获取超时
      idle-timeout: 600000            # 连接空闲超时
      max-lifetime: 1800000           # 连接最大生命周期
      leak-detection-threshold: 60000 # 泄漏检测阈值
```
###### 7. 如何实现数据库读写分离?
读写分离通过**抽象路由数据源**实现，根据操作类型路由到主从数据库。
**基于AbstractRoutingDataSource的实现：**
1. **定义路由键上下文**：
```java
public class DatabaseContextHolder {
    private static final ThreadLocal<DatabaseType> context = new ThreadLocal<>();
    
    public static void setDatabaseType(DatabaseType type) {
        context.set(type);
    }
    
    public static DatabaseType getDatabaseType() {
        return context.get() == null ? DatabaseType.MASTER : context.get();
    }
}
```
2. **实现动态路由数据源**：
```java
public class ReadWriteRoutingDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return DatabaseContextHolder.getDatabaseType();
    }
}
```
3. **AOP切面自动路由**：
```java
@Aspect
@Component
public class ReadWriteDataSourceAspect {
    
    @Around("@annotation(readOnly) || @within(readOnly)")
    public Object routeDataSource(ProceedingJoinPoint joinPoint, ReadOnly readOnly) throws Throwable {
        try {
            // 只读操作路由到从库
            if (readOnly != null) {
                DatabaseContextHolder.setDatabaseType(DatabaseType.SLAVE);
            }
            return joinPoint.proceed();
        } finally {
            DatabaseContextHolder.clear();
        }
    }
}
```
###### 8. Spring Boot 如何集成 Redis?
Spring Boot通过`spring-boot-starter-data-redis`提供**Redis自动配置**，基于Lettuce客户端。
**自动配置核心**：`RedisAutoConfiguration`自动配置`RedisTemplate`和`StringRedisTemplate`。
**集成步骤：**
1. **添加依赖**：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```
2. **配置连接参数**：
```yaml
spring:
  redis:
    host: localhost
    port: 6379
    password: 123456
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: -1ms
```
3. **自定义RedisTemplate配置**：
```java
@Configuration
public class RedisConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        
        // 使用Jackson2序列化
        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);
        template.setDefaultSerializer(serializer);
        
        return template;
    }
}
```
###### 9. 如何使用 Redis 实现缓存?
Spring Cache抽象层提供**统一的缓存访问接口**，通过注解驱动缓存操作。
**缓存配置示例：**
```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))  // 缓存30分钟
            .disableCachingNullValues();       // 不缓存null值
            
        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}
```
**服务层缓存应用：**
```java
@Service
public class UserService {
    
    @Cacheable(value = "users", key = "#id")
    public User getUserById(Long id) {
        // 只有缓存不存在时才会执行方法体
        return userRepository.findById(id);
    }
    
    @CachePut(value = "users", key = "#user.id")
    public User updateUser(User user) {
        // 更新数据库并同步更新缓存
        return userRepository.save(user);
    }
    
    @CacheEvict(value = "users", key = "#id")
    public void deleteUser(Long id) {
        // 删除数据库记录并清除缓存
        userRepository.deleteById(id);
    }
}
```
###### 10. @Cacheable、@CachePut、@CacheEvict 的作用是什么?
这三个注解是Spring Cache抽象层的**核心操作注解**，分别对应缓存的不同生命周期阶段。
**源码级执行机制：**
Spring通过`CacheInterceptor`拦截注解方法，在`invoke`方法中实现缓存逻辑：
```java
public class CacheInterceptor extends CacheAspectSupport implements MethodInterceptor {
    
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // 1. 检查方法上的缓存注解
        CacheOperationContext context = getOperationContext(invocation.getMethod());
        
        // 2. 根据注解类型执行相应缓存逻辑
        if (context.isCacheable()) {
            return executeCacheable(invocation, context);
        } else if (context.isCachePut()) {
            return executeCachePut(invocation, context);
        } else if (context.isCacheEvict()) {
            return executeCacheEvict(invocation, context);
        }
    }
}
```
**详细注解对比：**

|**注解**​|**执行时机**​|**使用场景**​|**源码关键逻辑**​|
|---|---|---|---|
|**@Cacheable**​|方法执行前检查缓存|查询操作，缓存不存在时执行方法|`CacheAspectSupport.executeCacheable()`|
|**@CachePut**​|方法执行后更新缓存|增改操作，始终执行方法并更新缓存|`CacheAspectSupport.executeCachePut()`|
|**@CacheEvict**​|方法执行后清理缓存|删除操作，清理指定缓存|`CacheAspectSupport.executeCacheEvict()`|
**高级缓存配置示例：**
```java
// 条件缓存：仅当id大于100时缓存
@Cacheable(value = "users", key = "#id", condition = "#id > 100")
public User getUserConditional(Long id) {
    return userRepository.findById(id);
}

// 多键值缓存清理
@CacheEvict(value = "users", allEntries = true)
public void refreshAllUsers() {
    // 清理users缓存空间的所有条目
}

// 组合注解：先清理再更新
@Caching(
    evict = {@CacheEvict(value = "user-list", allEntries = true)},
    put = {@CachePut(value = "users", key = "#user.id")}
)
public User updateUserWithListEvict(User user) {
    return userRepository.save(user);
}
```
###### 11. Spring Boot 如何实现分布式事务?
###### 12. @Transactional 注解的使用和注意事项是什么?
###### 13. 事务传播行为有哪些?
###### 14. 如何解决事务失效问题?
###### 15. Spring Boot 如何集成 MongoDB?
###### 16. Spring Boot 如何集成 Elasticsearch?
###### 17. 如何实现数据库迁移（Flyway/Liquibase）?
###### 18. 如何优化数据库查询性能?
###### 19. 如何实现数据库连接池监控?
###### 20. Spring Data JPA 的常用注解有哪些?