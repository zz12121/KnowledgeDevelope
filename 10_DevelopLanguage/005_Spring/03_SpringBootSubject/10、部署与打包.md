###### 1. Spring Boot 支持哪些打包方式?
Spring Boot 提供了**灵活的打包机制**，主要支持以下打包方式：
**核心打包格式**：
- **可执行JAR包**（默认）：包含嵌入式服务器和所有依赖的fat jar，可直接通过`java -jar`命令运行
- **传统WAR包**：符合Java EE标准的Web应用归档，需要部署到外部Servlet容器
- **Docker镜像**：容器化打包方式，提供环境一致性和隔离性
- **分层JAR包**（Spring Boot 2.3+）：优化Docker镜像构建，分离依赖、资源和应用代码
**构建工具支持**：
```xml
<!-- Maven 配置示例 -->
<packaging>jar</packaging>  <!-- 或 war -->

<!-- Gradle 配置示例 -->
plugins {
    id 'org.springframework.boot' version '2.7.0'
    id 'java'
}

jar {
    enabled = true
}
```
**高级打包特性**：
- **瘦身JAR**：通过`spring-boot-thin-launcher`创建依赖外部化的轻量级包
- **原生镜像**：使用GraalVM生成原生可执行文件，极大提升启动速度
- **多模块项目打包**：支持复杂的模块化项目结构打包
###### 2. JAR 和 WAR 的区别是什么?
JAR和WAR是Java应用的两种基本打包格式，在Spring Boot中有显著差异：
**架构差异对比**：

|**特性**​|**可执行JAR**​|**传统WAR**​|
|---|---|---|
|**服务器**​|内嵌Tomcat/Jetty/Undertow|需要外部Servlet容器（Tomcat/JBoss等）|
|**部署方式**​|`java -jar app.jar`独立运行|部署到容器webapps目录，由容器管理生命周期|
|**依赖管理**​|所有依赖打包到BOOT-INF/lib目录|依赖通常由容器提供或放在WEB-INF/lib|
|**启动速度**​|较快（内嵌服务器优化）|依赖容器启动时间|
|**资源占用**​|每个应用独立服务器实例|多应用共享容器资源|
|**适用场景**​|微服务、云原生、独立应用|传统企业级部署、遗留系统集成|
**结构差异源码级分析**：
```java
// 可执行JAR结构（通过jar tf app.jar查看）
spring-boot-app.jar
├── META-INF/
│   └── MANIFEST.MF          # 主类为JarLauncher
├── BOOT-INF/
│   ├── classes/             # 应用类文件
│   └── lib/                 # 所有依赖JAR
└── org/springframework/boot/loader/
    └── JarLauncher.class    # Spring Boot类加载器

// 传统WAR结构
app.war
├── META-INF/
├── WEB-INF/
│   ├── classes/             # 应用类文件
│   ├── lib/                 # 依赖JAR
│   └── web.xml              # 部署描述符（可选）
└── 静态资源（JS/CSS/HTML）
```
**选择策略**：
- **选择JAR**：微服务架构、容器化部署、需要快速启动和独立运行的场景
- **选择WAR**：传统企业环境、已有Servlet容器投资、需要与其它Java EE组件集成
###### 3. 如何将 Spring Boot 应用打包成可执行 JAR?
**Maven配置详解**：
```xml
<project>
    <!-- 指定打包方式 -->
    <packaging>jar</packaging>
    
    <!-- 继承Spring Boot父POM（推荐） -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.0</version>
    </parent>
    
    <build>
        <plugins>
            <!-- 核心：Spring Boot Maven插件 -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <executable>true</executable>  <!-- 生成可执行脚本 -->
                    <layers>
                        <enabled>true</enabled>   <!-- 启用分层优化 -->
                    </layers>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <!-- repackage目标重新打包为可执行JAR -->
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```
**非父POM继承的配置方式**：
```xml
<!-- 依赖管理方式引入 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.7.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```
**打包命令与流程**：
```bash
# 清理并打包（跳过测试）
mvn clean package -DskipTests

# 生成的可执行JAR位于target目录
java -jar target/myapp-0.0.1-SNAPSHOT.jar

# 可执行脚本功能（Linux/Mac）
chmod +x target/myapp-0.0.1-SNAPSHOT.jar
./target/myapp-0.0.1-SNAPSHOT.jar
```
**Gradle配置**：
```groovy
plugins {
    id 'org.springframework.boot' version '2.7.0'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    id 'java'
}

bootJar {
    enabled = true
    layered {
        enabled = true
    }
}

// 打包命令：./gradlew bootJar
```
**分层优化原理**：
Spring Boot 2.3+引入了分层概念，将JAR内部分为：
- **dependencies**：变更频率低的依赖库
- **spring-boot-loader**：Spring Boot加载器代码
- **snapshot-dependencies**：快照依赖
- **application**：应用代码和资源
这种分层优化Docker镜像构建，只需在代码变更时重建应用层。
###### 4. 如何将 Spring Boot 应用部署到 Tomcat?
**WAR包配置转换步骤**：
**1. 修改pom.xml配置**：
```xml
<!-- 更改打包方式 -->
<packaging>war</packaging>

<dependencies>
    <!-- Web Starter依赖 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <!-- 排除内嵌Tomcat -->
        <exclusions>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-tomcat</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    
    <!-- 提供Servlet API -->
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>4.0.1</version>
        <scope>provided</scope>
    </dependency>
</dependencies>

<!-- 配置Maven WAR插件 -->
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-war-plugin</artifactId>
            <version>3.3.1</version>
            <configuration>
                <warName>myapp</warName>
                <failOnMissingWebXml>false</failOnMissingWebXml>
            </configuration>
        </plugin>
    </plugins>
</build>
```
**2. 修改启动类**：
```java
@SpringBootApplication
public class Application extends SpringBootServletInitializer {
    
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        // 外部容器启动入口
        return builder.sources(Application.class);
    }
    
    public static void main(String[] args) {
        // 保留main方法，支持java -jar方式启动
        SpringApplication.run(Application.class, args);
    }
}
```
**3. 外部Tomcat配置**：
```xml
<!-- conf/server.xml 配置 -->
<Context path="/myapp" docBase="myapp">
    <Environment name="spring.profiles.active" value="prod" type="java.lang.String"/>
</Context>
```
**4. 部署流程**：
```bash
# 打包生成WAR
mvn clean package -DskipTests

# 部署到Tomcat
cp target/myapp.war $TOMCAT_HOME/webapps/

# 启动Tomcat
$TOMCAT_HOME/bin/startup.sh

# 访问应用
http://localhost:8080/myapp
```
**注意事项**：
- 确保Tomcat版本与Spring Boot兼容（通常Tomcat 8.5+）
- 应用路径由WAR文件名决定（myapp.war对应路径/myapp）
- 静态资源需要放在src/main/webapp目录下
- 日志配置需要适配外部Tomcat的日志系统。
###### 5. 如何使用 Docker 部署 Spring Boot 应用?
**基础Docker部署方案**：
**Dockerfile多阶段构建**：
```dockerfile
# 第一阶段：构建应用
FROM maven:3.8.6-openjdk-17 AS builder
WORKDIR /app
COPY pom.xml .
# 依赖缓存优化
RUN mvn dependency:go-offline -B
COPY src ./src
RUN mvn clean package -DskipTests

# 第二阶段：运行环境
FROM openjdk:17-jre-slim
WORKDIR /app

# 创建非root用户增强安全
RUN groupadd -r spring && useradd -r -g spring spring
USER spring

# 复制构建结果
COPY --from=builder --chown=spring:spring /app/target/*.jar app.jar

# JVM优化参数
ENV JAVA_OPTS="-Xmx512m -Xms256m -XX:+UseG1GC"

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

EXPOSE 8080
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar /app/app.jar"]
```
**构建和运行命令**：
```bash
# 构建Docker镜像
docker build -t my-spring-app:1.0.0 .

# 运行容器
docker run -d -p 8080:8080 \
  -e "SPRING_PROFILES_ACTIVE=prod" \
  --name my-app \
  my-spring-app:1.0.0

# 查看日志
docker logs -f my-app
```
**高级Docker特性**：
```dockerfile
# 使用Spring Boot分层JAR优化
COPY --from=builder /app/target/*.jar app.jar
RUN java -Djarmode=layertools -jar app.jar extract

# 分层的Dockerfile
FROM openjdk:17-jre-slim
COPY --from=builder /app/dependencies/ ./
COPY --from=builder /app/spring-boot-loader/ ./
COPY --from=builder /app/snapshot-dependencies/ ./
COPY --from=builder /app/application/ ./
ENTRYPOINT ["java", "org.springframework.boot.loader.JarLauncher"]
```
**生产级最佳实践**：
- 使用特定版本的基础镜像，避免`latest`标签
- 多阶段构建减少镜像大小
- 非root用户运行增强安全性
- 合理配置JVM内存参数
- 设置资源限制和健康检查
###### 6. 如何编写 Dockerfile?
**生产级Dockerfile详解**：
```dockerfile
# 使用官方OpenJDK运行时作为父镜像
FROM openjdk:17-jdk-slim as builder

# 设置工作目录
WORKDIR /app

# 复制Maven配置文件
COPY pom.xml .
COPY mvnw .
COPY .mvn .mvn

# 下载依赖（利用Docker缓存层）
RUN chmod +x mvnw && ./mvnw dependency:go-offline -B

# 复制源代码
COPY src ./src

# 打包应用（使用分层构建）
RUN ./mvnw clean package -DskipTests && \
    java -Djarmode=layertools -jar target/*.jar extract

# 生产阶段
FROM openjdk:17-jre-slim

# 安装必要的系统包
RUN apt-get update && \
    apt-get install -y --no-install-recommends curl && \
    rm -rf /var/lib/apt/lists/*

# 创建应用用户
RUN groupadd -r spring && useradd -r -g spring spring
USER spring

# 设置工作目录
WORKDIR /application

# 从构建阶段复制分层内容
COPY --from=builder --chown=spring:spring /app/dependencies/ ./
COPY --from=builder --chown=spring:spring /app/spring-boot-loader/ ./
COPY --from=builder --chown=spring:spring /app/snapshot-dependencies/ ./
COPY --from=builder --chown=spring:spring /app/application/ ./

# 环境变量配置
ENV SPRING_PROFILES_ACTIVE=prod \
    JAVA_OPTS="-Xmx512m -Xms256m -XX:+UseG1GC -Djava.security.egd=file:/dev/./urandom"

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# 启动命令
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS org.springframework.boot.loader.JarLauncher"]
```
**.dockerignore文件**：
```gitignore
# 忽略不必要的文件，加速构建
**/target/
**/.git/
**/.idea/
**/*.iml
**/node_modules/
Dockerfile
README.md
```
**多环境Docker配置**：
```dockerfile
# 开发环境配置
FROM openjdk:17 as development
ENV SPRING_PROFILES_ACTIVE=dev
ENTRYPOINT ["./mvnw", "spring-boot:run"]

# 生产环境配置  
FROM openjdk:17-jre-slim as production
COPY --from=development /app/target/*.jar app.jar
ENTRYPOINT ["java", "-jar", "/app.jar"]
```
**构建优化技巧**：
```bash
# 并行构建加速
docker build --parallel .

# 构建参数传递
docker build --build-arg JAR_FILE=target/*.jar -t myapp .

# 多平台构建
docker buildx build --platform linux/amd64,linux/arm64 -t myapp .
```
###### 7. 如何使用 Docker Compose 编排多个服务?
**完整微服务编排示例**：
```yaml
version: '3.8'

services:
  # Spring Boot主应用
  app-service:
    build: 
      context: .
      target: development  # 开发环境构建
    image: my-spring-app:1.0.0
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - SPRING_DATASOURCE_URL=jdbc:mysql://mysql-db:3306/appdb
      - SPRING_REDIS_HOST=redis-cache
    ports:
      - "8080:8080"
    depends_on:
      mysql-db:
        condition: service_healthy
      redis-cache:
        condition: service_started
    networks:
      - app-network
    volumes:
      - ./logs:/app/logs  # 日志持久化
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # MySQL数据库
  mysql-db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: rootpass
      MYSQL_DATABASE: appdb
      MYSQL_USER: appuser
      MYSQL_PASSWORD: apppass
    volumes:
      - mysql-data:/var/lib/mysql
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      timeout: 20s
      retries: 10

  # Redis缓存
  redis-cache:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis-data:/data
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  # Nginx反向代理
  nginx-proxy:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app-service
    networks:
      - app-network

volumes:
  mysql-data:
  redis-data:

networks:
  app-network:
    driver: bridge
```
**多环境Compose配置**：
**docker-compose.override.yml（开发环境）**：
```yaml
version: '3.8'

services:
  app-service:
    build: 
      context: .
      target: development
    environment:
      - SPRING_PROFILES_ACTIVE=dev
      - SPRING_DEVTOOLS_RESTART_ENABLED=true
    volumes:
      - ./src:/app/src  # 代码热部署
      - ./logs:/app/logs
    stdin_open: true
    tty: true
```
**docker-compose.prod.yml（生产环境）**：
```yaml
version: '3.8'

services:
  app-service:
    image: my-registry.com/myapp:${TAG:-latest}
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-Xmx1g -Xms512m
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '0.5'
        reservations:
          memory: 512M
          cpus: '0.25'
    restart: unless-stopped
```
**管理和运维命令**：
```bash
# 开发环境启动
docker-compose up -d

# 生产环境启动
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs -f app-service

# 水平扩展
docker-compose up -d --scale app-service=3

# 环境变量文件支持
echo "TAG=1.2.0" > .env
docker-compose up -d
```
###### 8. 如何部署到 Kubernetes?
**完整的K8s部署清单**：
**Deployment配置**：
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: spring-boot-app
  labels:
    app: spring-boot-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: spring-boot-app
  template:
    metadata:
      labels:
        app: spring-boot-app
    spec:
      containers:
      - name: app
        image: my-registry.com/spring-app:1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "k8s"
        - name: JAVA_OPTS
          value: "-Xmx512m -Xms256m"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 5
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
      volumes:
      - name: config-volume
        configMap:
          name: app-config
---
apiVersion: v1
kind: Service
metadata:
  name: spring-boot-service
spec:
  selector:
    app: spring-boot-app
  ports:
  - port: 80
    targetPort: 8080
  type: LoadBalancer
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: spring-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: spring-boot-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```
**ConfigMap和Secret配置**：
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  application.yml: |
    server:
      port: 8080
    spring:
      datasource:
        url: jdbc:mysql://mysql-service:3306/appdb
      redis:
        host: redis-service
        port: 6379
---
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
data:
  database-password: cGFzc3dvcmQxMjM=  # base64编码
  api-key: YXBpLWtleS1zZWNyZXQ=
```
**Ingress路由配置**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: spring-app-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: app.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: spring-boot-service
            port:
              number: 80
```
**部署和管理命令**：
```bash
# 应用配置
kubectl apply -f deployment.yaml

# 滚动更新
kubectl set image deployment/spring-boot-app app=my-registry.com/spring-app:2.0.0

# 查看状态
kubectl get pods,svc,ingress

# 日志查看
kubectl logs -l app=spring-boot-app -f

# 端口转发（本地访问）
kubectl port-forward svc/spring-boot-service 8080:80
```
###### 9. 如何实现应用的灰度发布?
**基于Kubernetes的灰度发布策略**：
**蓝绿部署**：
```yaml
# blue-deployment.yaml（当前版本）
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-blue
  labels:
    version: blue
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
      version: blue
  template:
    metadata:
      labels:
        app: myapp
        version: blue
    spec:
      containers:
      - name: app
        image: myapp:v1.0.0
        ports:
        - containerPort: 8080
---
# green-deployment.yaml（新版本）
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-green
  labels:
    version: green
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
      version: green
  template:
    metadata:
      labels:
        app: myapp
        version: green
    spec:
      containers:
      - name: app
        image: myapp:v2.0.0
        ports:
        - containerPort: 8080
```
**金丝雀发布**：
```yaml
# 基于权重的流量切分
apiVersion: flagger.app/v1beta1
kind: Canary
metadata:
  name: myapp
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp
  service:
    port: 8080
  analysis:
    interval: 1m
    threshold: 5
    iterations: 10
    metrics:
    - name: request-success-rate
      threshold: 99
    - name: request-duration
      threshold: 500
  canaryAnalysis:
    stepWeight: 10
    maxWeight: 50
```
**基于Header的路由**：
```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: myapp-vs
spec:
  hosts:
  - myapp.example.com
  http:
  - match:
    - headers:
        canary:
          exact: "true"
    route:
    - destination:
        host: myapp
        subset: canary
  - route:
    - destination:
        host: myapp
        subset: stable
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: myapp
spec:
  host: myapp
  subsets:
  - name: stable
    labels:
      version: stable
  - name: canary
    labels:
      version: canary
```
###### 10. 如何实现应用的蓝绿部署?
**完整的蓝绿部署方案**：
**Service流量切换**：
```yaml
# service.yaml - 通过selector版本标签控制流量
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
spec:
  selector:
    app: myapp
    version: blue  # 控制当前活跃版本
  ports:
  - port: 80
    targetPort: 8080
```
**自动化蓝绿切换脚本**：
```bash
#!/bin/bash
# blue-green-deploy.sh

CURRENT_VERSION=$(kubectl get svc myapp-service -o jsonpath='{.spec.selector.version}')
if [ "$CURRENT_VERSION" = "blue" ]; then
    NEW_VERSION="green"
    OLD_VERSION="blue"
else
    NEW_VERSION="blue"
    OLD_VERSION="green"
fi

echo "当前运行版本: $CURRENT_VERSION"
echo "开始部署新版本: $NEW_VERSION"

# 部署新版本
kubectl apply -f deployment-$NEW_VERSION.yaml

# 等待新版本就绪
kubectl rollout status deployment/myapp-$NEW_VERSION --timeout=300s

if [ $? -eq 0 ]; then
    # 切换Service流量
    kubectl patch service myapp-service -p \
    "{\"spec\":{\"selector\":{\"version\":\"$NEW_VERSION\"}}}"
    
    echo "流量已切换到 $NEW_VERSION 版本"
    
    # 保留旧版本一段时间以便快速回滚
    sleep 300
    kubectl scale deployment/myapp-$OLD_VERSION --replicas=0
    
    echo "蓝绿部署完成"
else
    echo "新版本部署失败，保持当前版本运行"
    exit 1
fi
```
**数据库迁移策略**：
```sql
-- 向前兼容的数据库迁移
-- 新增字段允许NULL，避免版本切换时schema不兼容
ALTER TABLE users ADD COLUMN new_feature_flag VARCHAR(50) NULL;

-- 回滚时安全的迁移脚本
START TRANSACTION;
-- 应用变更
ALTER TABLE orders ADD COLUMN processed_by VARCHAR(100) NULL;
-- 保留回滚能力
COMMIT;
```