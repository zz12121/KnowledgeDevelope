###### 1. 如何解决循环依赖问题?
循环依赖是指两个或多个Bean相互依赖形成闭环，Spring通过**三级缓存机制**解决部分循环依赖问题，但构造器注入的循环依赖无法解决。
**Spring三级缓存源码机制：**
```java
public class DefaultSingletonBeanRegistry {
    // 一级缓存：完整Bean实例
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
    // 二级缓存：早期Bean引用（未完成属性注入）
    private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);
    // 三级缓存：ObjectFactory工厂对象
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);

    protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
            synchronized (this.singletonObjects) {
                singletonObject = this.earlySingletonObjects.get(beanName);
                if (singletonObject == null && allowEarlyReference) {
                    ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                    if (singletonFactory != null) {
                        // 从三级缓存获取早期引用
                        singletonObject = singletonFactory.getObject();
                        this.earlySingletonObjects.put(beanName, singletonObject);
                        this.singletonFactories.remove(beanName);
                    }
                }
            }
        }
        return singletonObject;
    }
}
```
**解决方案对比：**

|**方案**​|**实现方式**​|**适用场景**​|**优缺点**​|
|---|---|---|---|
|**@Lazy注解**​|`@Autowired @Lazy private ServiceB serviceB;`|简单的循环依赖|简单但可能延迟问题发现|
|**Setter注入**​|使用setter方法而非构造器注入|多数循环依赖场景|Spring推荐方式|
|**重构设计**​|提取公共逻辑到第三方Bean|复杂的依赖关系|彻底解决，但重构成本高|
|**事件驱动**​|使用ApplicationEvent解耦|需要松耦合的场景|架构清晰，但复杂度高|
**最佳实践示例：**
```java
// 使用Setter注入解决循环依赖
@Service
public class UserService {
    private OrderService orderService;
    
    @Autowired
    public void setOrderService(OrderService orderService) {
        this.orderService = orderService;
    }
}

@Service  
public class OrderService {
    private UserService userService;
    
    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
}
```
###### 2. 如何解决端口占用问题?
端口占用是常见的启动故障，需要**系统级排查和配置调整**。
**排查命令大全：**
```bash
# 检查端口占用情况（Linux/Mac）
lsof -i :8080
# 或使用netstat
netstat -tulpn | grep 8080
# Windows系统
netstat -ano | findstr 8080

# 杀死占用进程
kill -9 <PID>
# Windows
taskkill /PID <PID> /F
```
**Spring Boot配置解决方案：**
```yaml
# application.yml - 动态端口配置
server:
  port: 0  # 随机端口，适合微服务
  # 或指定特定端口
  port: ${PORT:8080}  # 环境变量优先，默认8080

# 多环境配置
---
spring:
  profiles: dev
server:
  port: 8080
---
spring:
  profiles: test  
server:
  port: 8081
---
spring:
  profiles: prod
server:
  port: 80
```
**编程式解决方案：**
```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(Application.class);
        // 动态设置端口
        app.setDefaultProperties(Collections.singletonMap("server.port", "0"));
        app.run(args);
    }
}
```
###### 3. 如何解决类加载冲突?
类加载冲突通常由**依赖版本不一致或JAR包重复**引起。
**冲突检测工具使用：**
```bash
# Maven依赖树分析
mvn dependency:tree -Dverbose
# 查看冲突详情
mvn dependency:tree -Dincludes=com.google.guava:guava

# Gradle依赖分析
gradle dependencies --configuration compileClasspath
```
**依赖排除解决方案：**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```
**类加载器调试：**
```java
public class ClassLoaderDebug {
    public static void debugClassLoading() {
        // 查看当前类加载器
        System.out.println("当前类加载器: " + ClassLoaderDebug.class.getClassLoader());
        
        // 查看类加载器层次
        ClassLoader loader = ClassLoaderDebug.class.getClassLoader();
        while (loader != null) {
            System.out.println("→ " + loader);
            loader = loader.getParent();
        }
        
        // 检查类来源
        String className = "com.example.SomeClass";
        Resource resource = ClassLoaderDebug.class.getClassLoader()
                .getResource(className.replace('.', '/') + ".class");
        System.out.println("类文件位置: " + resource);
    }
}
```
###### 4. 如何定位 Bean 注入失败问题?
Bean注入失败需要**系统化排查Bean生命周期**的每个阶段。
**排查流程图：**
```
Bean注入失败 → 检查Bean定义 → 检查依赖关系 → 检查配置条件 → 查看详细日志
```
**诊断工具和技巧：**
```java
@Component
public class BeanInjectionDiagnoser implements ApplicationContextAware {
    private ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.context = applicationContext;
    }

    public void diagnoseInjectionFailure() {
        // 检查所有Bean定义
        String[] beanNames = context.getBeanDefinitionNames();
        Arrays.sort(beanNames);
        for (String beanName : beanNames) {
            BeanDefinition beanDefinition = ((ConfigurableApplicationContext) context)
                    .getBeanFactory().getBeanDefinition(beanName);
            System.out.println("Bean: " + beanName + ", Type: " + beanDefinition.getBeanClassName());
        }

        // 检查特定Bean的依赖
        try {
            Object bean = context.getBean("problematicBean");
            System.out.println("Bean创建成功: " + bean);
        } catch (Exception e) {
            System.out.println("Bean创建失败: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```
**条件化配置检查：**
```java
@Configuration
@ConditionalOnClass(DataSource.class)
@ConditionalOnProperty(name = "spring.datasource.url")
public class DataSourceAutoConfiguration {
    // 只有条件满足时才会配置
}
```
###### 5. 如何查看自动配置报告?
自动配置报告帮助理解Spring Boot的**配置决策过程**。
**启用和查看报告：**
```properties
# application.properties
debug=true
# 或使用特定端点
management.endpoints.web.exposure.include=conditions

# 也可以通过程序方式
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(Application.class);
        app.setAdditionalProfiles("debug");
        app.run(args);
    }
}
```
**报告分析示例：**
```
=========================
AUTO-CONFIGURATION REPORT
=========================

Positive matches:
-----------------
   DataSourceAutoConfiguration matched:
      - @ConditionalOnClass found classes: javax.sql.DataSource, org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType (OnClassCondition)
      - @ConditionalOnProperty (spring.datasource.url) found property: url (OnPropertyCondition)

Negative matches:
-----------------
   RabbitAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required classes: com.rabbitmq.client.Channel (OnClassCondition)
```
**自定义条件报告：**
```java
@Component
public class CustomConditionReport implements ApplicationListener<ApplicationReadyEvent> {
    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        ConfigurableApplicationContext context = event.getApplicationContext();
        ConditionEvaluationReport report = ConditionEvaluationReport.get(context.getBeanFactory());
        
        Map<String, ConditionEvaluationReport.ConditionAndOutcomes> outcomes = report.getConditionAndOutcomesBySource();
        outcomes.forEach((source, conditionAndOutcomes) -> {
            System.out.println("Source: " + source);
            conditionAndOutcomes.forEach(conditionAndOutcome -> {
                System.out.println("  Condition: " + conditionAndOutcome.getCondition().getClass().getName());
                System.out.println("  Outcome: " + conditionAndOutcome.getOutcome());
            });
        });
    }
}
```
###### 6. 如何开启 Debug 日志?
Debug日志提供**详细的内部执行信息**，是问题排查的关键工具。
**日志配置详解：**
```yaml
# application.yml
logging:
  level:
    # Spring框架相关日志
    org.springframework: DEBUG
    org.springframework.boot: DEBUG
    org.springframework.web: DEBUG
    # 数据访问层日志
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
    # 自定义包日志
    com.example: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %logger{36} - %msg%n"
  file:
    name: logs/debug.log
```
**编程式日志配置：**
```java
@Configuration
@Slf4j
public class LoggingConfig {
    
    @PostConstruct
    public void setupLogging() {
        // 动态设置日志级别
        LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
        Logger rootLogger = loggerContext.getLogger("org.springframework");
        ((ch.qolog.core.Logger) rootLogger).setLevel(Level.DEBUG);
        
        // 添加自定义Appender
        ch.qolog.core.Logger myLogger = loggerContext.getLogger("com.example");
        myLogger.setLevel(Level.DEBUG);
    }
    
    @Bean
    public ApplicationListener<ApplicationReadyEvent> logStartupInfo() {
        return event -> {
            log.debug("应用启动完成，开始输出Debug日志");
            // 记录系统状态信息
            log.debug("JVM内存: {}/{}", 
                Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory(),
                Runtime.getRuntime().totalMemory());
        };
    }
}
```
###### 7. 如何进行远程调试?
远程调试允许**实时诊断生产环境问题**。
**JVM调试参数配置：**
```bash
# 启动远程调试
java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 \
     -jar application.jar

# 或者使用标准参数
java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005 \
     -jar application.jar
```
**IDE调试配置（IntelliJ IDEA）：**
1. **创建Remote JVM Debug配置**
2. **设置调试参数：**
    - Host: 目标服务器IP
    - Port: 5005（与JVM参数一致）
    - Transport: Socket
**Spring Boot特定调试配置：**
```yaml
# application-dev.yml - 开发环境专用
spring:
  devtools:
    remote:
      secret: mydebugsecret
    restart:
      enabled: true

logging:
  level:
    org.springframework.boot.devtools: DEBUG
```
**安全调试实践：**
```yaml
@Component
public class DebugSecurityMonitor {
    private static final Logger log = LoggerFactory.getLogger(DebugSecurityMonitor.class);
    
    @EventListener
    public void monitorDebugSession(ApplicationEnvironmentPreparedEvent event) {
        ConfigurableEnvironment env = event.getEnvironment();
        boolean debugEnabled = env.getProperty("debug", Boolean.class, false);
        boolean remoteDebug = env.getProperty("spring.devtools.remote.secret") != null;
        
        if (debugEnabled || remoteDebug) {
            log.warn("调试模式已启用 - 生产环境安全风险!");
            // 可以发送警报或采取其他安全措施
        }
    }
}
```
###### 8. 如何解决 OOM 问题?
OOM问题需要**内存分析和JVM调优**相结合。
**内存分析工具链：**

|**工具**​|**用途**​|**使用场景**​|
|---|---|---|
|**jmap**​|堆转储分析|离线内存分析|
|**jstat**​|实时GC监控|运行时性能监控|
|**VisualVM**​|图形化分析|开发环境问题定位|
|**Eclipse MAT**​|深度内存分析|内存泄漏根因分析|
**JVM参数优化：**
```bash
# OOM时自动生成堆转储
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/path/to/dumps
-XX:OnOutOfMemoryError="kill -9 %p"

# 内存参数调优
-Xmx4g -Xms4g           # 堆内存大小
-XX:NewRatio=2          # 新生代老年代比例
-XX:SurvivorRatio=8     # Eden与Survivor比例
-XX:+UseG1GC           # 使用G1垃圾收集器
-XX:MaxGCPauseMillis=200  # 最大GC停顿时间
```
**内存泄漏检测代码：**
```java
@Component
public class MemoryLeakDetector {
    private final Map<String, byte[]> memoryPool = new HashMap<>();
    
    @Scheduled(fixedRate = 60000)  // 每分钟检测一次
    public void detectMemoryLeak() {
        Runtime runtime = Runtime.getRuntime();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        long maxMemory = runtime.maxMemory();
        
        double usageRatio = (double) usedMemory / maxMemory;
        
        if (usageRatio > 0.8) {
            // 内存使用超过80%，触发警告
            System.gc();  // 建议Full GC
            
            // 记录内存快照
            log.warn("内存使用率过高: {}%", String.format("%.2f", usageRatio * 100));
            log.warn("建议检查是否存在内存泄漏");
        }
    }
    
    public void simulateLeak() {
        // 模拟内存泄漏
        for (int i = 0; i < 1000; i++) {
            memoryPool.put("key" + i, new byte[1024 * 1024]);  // 1MB
        }
    }
}
```
###### 9. 如何解决 CPU 占用过高问题?
CPU过高通常由**死循环、频繁GC或算法效率**引起。
**CPU问题排查流程：**
```bash
# 1. 定位高CPU进程
top -H -p <PID>

# 2. 将线程ID转换为十六进制
printf "%x\n" <线程ID>

# 3. 获取线程堆栈
jstack <PID> > thread_dump.txt
# 在thread_dump.txt中搜索十六进制线程ID
```
**线程分析工具：**
```java
@Component
public class ThreadMonitor {
    private static final Logger log = LoggerFactory.getLogger(ThreadMonitor.class);
    
    @Scheduled(fixedRate = 30000)
    public void monitorThreads() {
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        long[] threadIds = threadBean.getAllThreadIds();
        
        for (long threadId : threadIds) {
            ThreadInfo threadInfo = threadBean.getThreadInfo(threadId);
            if (threadInfo != null) {
                long cpuTime = threadBean.getThreadCpuTime(threadId);
                if (cpuTime > 10_000_000_000L) {  // 10秒CPU时间
                    log.warn("高CPU线程: {} - CPU时间: {}ms", 
                            threadInfo.getThreadName(), cpuTime / 1_000_000);
                    log.warn("堆栈跟踪: {}", Arrays.toString(threadInfo.getStackTrace()));
                }
            }
        }
    }
    
    public void diagnoseHighCPU() {
        // 创建CPU密集型任务监控
        ExecutorService executor = Executors.newFixedThreadPool(1);
        Future<?> future = executor.submit(() -> {
            // 模拟高CPU任务
            while (!Thread.currentThread().isInterrupted()) {
                // 业务逻辑
            }
        });
        
        // 超时控制
        try {
            future.get(5, TimeUnit.SECONDS);
        } catch (TimeoutException e) {
            future.cancel(true);
            log.error("任务执行超时，可能存在CPU问题");
        } catch (Exception e) {
            log.error("任务执行异常", e);
        }
    }
}
```
###### 10. 如何排查接口响应慢的问题?
接口响应慢需要**全链路性能分析**。
**性能监控配置：**
```yaml
# 应用性能监控
management:
  endpoints:
    web:
      exposure:
        include: metrics,httptrace
  metrics:
    export:
      prometheus:
        enabled: true
    distribution:
      percentiles-histogram:
        http.server.requests: true
      sla:
        http.server.requests: 100ms, 500ms, 1s

# 数据库监控
spring:
  jpa:
    properties:
      hibernate:
        generate_statistics: true
```
**链路追踪实现：**
```java
@Aspect
@Component
@Slf4j
public class PerformanceMonitorAspect {
    
    @Around("@within(org.springframework.web.bind.annotation.RestController)")
    public Object monitorApiPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        String methodName = joinPoint.getSignature().toShortString();
        
        try {
            Object result = joinPoint.proceed();
            long duration = System.currentTimeMillis() - startTime;
            
            if (duration > 1000) {  // 超过1秒记录警告
                log.warn("接口响应慢: {} - {}ms", methodName, duration);
            }
            
            // 记录指标
            Metrics.counter("api.requests", "method", methodName).increment();
            Metrics.timer("api.duration", "method", methodName).record(duration, TimeUnit.MILLISECONDS);
            
            return result;
        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            log.error("接口执行异常: {} - {}ms", methodName, duration, e);
            throw e;
        }
    }
}
```
###### 11. 如何解决数据库连接池耗尽问题?
连接池耗尽需要**连接管理和监控**。
**连接池配置优化：**
```yaml
# HikariCP连接池配置
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      leak-detection-threshold: 60000
      pool-name: MyApplicationPool
```
**连接泄漏检测：**
```java
@Component
@Slf4j
public class ConnectionPoolMonitor {
    
    @Autowired
    private DataSource dataSource;
    
    @Scheduled(fixedRate = 60000)  // 每分钟监控一次
    public void monitorConnectionPool() {
        if (dataSource instanceof HikariDataSource) {
            HikariDataSource hikariDataSource = (HikariDataSource) dataSource;
            HikariPoolMXBean pool = hikariDataSource.getHikariPoolMXBean();
            
            int activeConnections = pool.getActiveConnections();
            int idleConnections = pool.getIdleConnections();
            int totalConnections = activeConnections + idleConnections;
            int maxConnections = hikariDataSource.getMaximumPoolSize();
            
            log.info("连接池状态: {}/{} (活跃/空闲)", activeConnections, idleConnections);
            
            if (activeConnections >= maxConnections * 0.8) {
                log.warn("连接池使用率超过80%，可能存在泄漏");
            }
            
            // 检测长时间活跃连接
            if (activeConnections > 0) {
                log.debug("当前活跃连接数: {}", activeConnections);
            }
        }
    }
    
    public void diagnoseConnectionLeak() {
        try (Connection connection = dataSource.getConnection()) {
            // 执行连接测试
            boolean valid = connection.isValid(5);
            if (!valid) {
                log.error("数据库连接无效");
            }
            
            // 检查数据库状态
            try (Statement statement = connection.createStatement();
                 ResultSet rs = statement.executeQuery("SELECT 1")) {
                if (rs.next()) {
                    log.info("数据库连接正常");
                }
            }
        } catch (SQLException e) {
            log.error("数据库连接异常", e);
        }
    }
}
```
###### 12. 如何处理线程死锁问题?
线程死锁需要**死锁检测和预防机制**。
**死锁检测代码：**
```java
@Component
@Slf4j
public class DeadlockDetector {
    
    @Scheduled(fixedRate = 30000)
    public void detectDeadlock() {
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        long[] threadIds = threadBean.findDeadlockedThreads();
        
        if (threadIds != null) {
            log.error("检测到死锁，涉及线程: {}", threadIds.length);
            
            ThreadInfo[] threadInfos = threadBean.getThreadInfo(threadIds);
            for (ThreadInfo threadInfo : threadInfos) {
                log.error("死锁线程: {}", threadInfo.getThreadName());
                log.error("等待锁: {}", threadInfo.getLockName());
                log.error("被线程持有: {}", threadInfo.getLockOwnerName());
                
                // 打印堆栈跟踪
                for (StackTraceElement element : threadInfo.getStackTrace()) {
                    log.error("    at {}", element);
                }
            }
            
            // 可以选择重启应用或采取其他恢复措施
        }
    }
    
    public void simulateDeadlock() {
        Object lock1 = new Object();
        Object lock2 = new Object();
        
        Thread thread1 = new Thread(() -> {
            synchronized (lock1) {
                log.info("Thread1 持有 lock1");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                synchronized (lock2) {
                    log.info("Thread1 持有 lock2");
                }
            }
        });
        
        Thread thread2 = new Thread(() -> {
            synchronized (lock2) {
                log.info("Thread2 持有 lock2");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                synchronized (lock1) {
                    log.info("Thread2 持有 lock1");
                }
            }
        });
        
        thread1.start();
        thread2.start();
    }
}
```
**死锁预防最佳实践：**
```java
@Service
public class ThreadSafeService {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    
    // 按固定顺序获取锁，避免死锁
    public void safeOperation() {
        Object firstLock = System.identityHashCode(lock1) < System.identityHashCode(lock2) ? lock1 : lock2;
        Object secondLock = firstLock == lock1 ? lock2 : lock1;
        
        synchronized (firstLock) {
            synchronized (secondLock) {
                // 业务逻辑
                performOperation();
            }
        }
    }
    
    // 使用超时机制
    public void timeoutLockOperation() {
        try {
            if (tryLockWithTimeout(lock1, 5, TimeUnit.SECONDS)) {
                try {
                    if (tryLockWithTimeout(lock2, 5, TimeUnit.SECONDS)) {
                        performOperation();
                    }
                } finally {
                    unlock(lock2);
                }
            }
        } finally {
            unlock(lock1);
        }
    }
    
    private boolean tryLockWithTimeout(Object lock, long timeout, TimeUnit unit) {
        // 实现超时获取锁逻辑
        return true;
    }
    
    private void unlock(Object lock) {
        // 释放锁
    }
    
    private void performOperation() {
        // 业务操作
    }
}
```