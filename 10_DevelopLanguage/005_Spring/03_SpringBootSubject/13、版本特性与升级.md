###### 1. Spring Boot 2.x 有什么新特性?
Spring Boot 2.x 是一个重大版本升级，引入了许多现代化特性，主要基于 Spring Framework 5 和 Java 8，旨在提升性能、响应式支持和云原生适配。以下是关键新特性及源码级解析：
- **响应式编程支持**：
    Spring Boot 2.x 通过 Spring WebFlux 提供了完整的响应式栈，基于 Project Reactor 实现非阻塞 I/O。核心类 `WebFluxAutoConfiguration`在检测到类路径存在 `Reactor`依赖时自动配置响应式服务器（如 Netty）。例如，控制器方法可返回 `Mono`或 `Flux`类型：
    ```java
    @RestController
    public class ReactiveController {
        @GetMapping("/flux")
        public Flux<String> getFluxData() {
            return Flux.just("A", "B", "C").delayElements(Duration.ofSeconds(1));
        }
    }
    ```
    源码中，`WebFluxConfigurationSupport`会初始化 `DispatcherHandler`用于处理请求，其 `handle()`方法通过 `ReactiveAdapterRegistry`适配响应式类型 。
- **HTTP/2 支持**：
    内嵌服务器（Tomcat 8.5+、Jetty、Undertow）支持 HTTP/2，需在配置中启用。例如，在 `application.yml`中：
    ```yaml
    server:
      http2:
        enabled: true
    ```
    源码层面，Tomcat 的 `Http2Protocol`类通过 `UpgradeProtocol`接口实现协议升级 。
- **配置属性绑定改进**：
    引入了 `@ConfigurationPropertiesBinding`和 `ConfigurationProperties`的独立 API，支持属性来源追踪。例如，使用 `Binder`类编程式绑定：
    ```java
    Binder binder = Binder.get(environment);
    ServerProperties props = binder.bind("server", ServerProperties.class).get();
    ```
    源码中，`ConfigurationPropertiesBindingPostProcessor`负责处理绑定逻辑，通过 `ConfigurationPropertySource`解析属性源 。
- **Actuator 增强**：
    端点统一暴露在 `/actuator`路径下，并集成 Micrometer 用于指标收集。例如，健康检查端点 `/actuator/health`返回结构化 JSON，包含组件状态。源码中，`HealthEndpointAutoConfiguration`配置 `HealthContributorRegistry`聚合健康指标 。
- **默认依赖升级**：
    - 连接池从 Tomcat Pool 切换到 HikariCP（通过 `HikariDataSourceConfiguration`自动配置）。
    - 模板引擎升级为 Thymeleaf 3（性能提升 50%+），由 `ThymeleafAutoConfiguration`处理 。
    - 支持 Kotlin 1.2+，提供 `runApplication`扩展函数 。
- **Quartz 调度支持**：
    通过 `spring-boot-starter-quartz`提供自动化配置，`QuartzAutoConfiguration`基于 `SchedulerFactoryBean`创建调度器，并支持持久化到数据库 。
###### 2. Spring Boot 2.x 与 1.x 有什么区别?

| **维度**​          | **Spring Boot 1.x**​                   | **Spring Boot 2.x**​                                          | **源码级差异**​                                                                        |
| ---------------- | -------------------------------------- | ------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| **JDK 要求**​      | JDK 6+                                 | JDK 8+（依赖 `java.time`API）                                     | `SpringApplication`启动时校验 JDK 版本，通过 `JavaVersion`类检测 。                             |
| **Spring 框架**​   | Spring 4.x                             | Spring 5.x（支持响应式编程）                                           | `WebFluxAutoConfiguration`替换了部分 `WebMvcAutoConfiguration`的逻辑 。                    |
| **配置属性**​        | 通过 `@ConfigurationProperties`绑定，缺乏来源追踪 | 引入 `PropertyMapper`API 和属性来源显示                                | 在 `ConfigurationPropertiesReportEndpoint`中可查看属性绑定来源 。                             |
| **内嵌服务器**​       | Tomcat 7.x/8.x                         | Tomcat 8.5+（支持 HTTP/2）                                        | `TomcatWebServer`类在初始化时通过 `ProtocolHandler`配置 HTTP/2 。                            |
| **数据源配置**​       | 默认使用 Tomcat JDBC Pool                  | 默认使用 HikariCP                                                 | `DataSourceConfiguration`中根据条件选择连接池实现 。                                           |
| **Actuator 端点**​ | 端点分散（如 `/health`直接暴露）                  | 统一在 `/actuator`下，需显式启用                                        | `EndpointAutoConfiguration`使用 `PathMapper`映射端点路径 。                                |
| **循环依赖处理**​      | 默认允许                                   | 2.6.0 起默认禁止（需设置 `spring.main.allow-circular-references=true`） | `AbstractAutowireCapableBeanFactory`的 `setAllowCircularReferences(false)`控制 <br>。 |
###### 3. Spring Boot 哪个版本禁止循环依赖?
Spring Boot **从 2.6.0 版本开始默认禁止循环依赖**。若检测到循环依赖（如 Bean A 依赖 Bean B，同时 Bean B 依赖 Bean A），启动时会抛出 `BeanCurrentlyInCreationException`，并提示设置 `spring.main.allow-circular-references=true`临时解决 。
**源码机制**：
在 `AbstractAutowireCapableBeanFactory`的 `doCreateBean`方法中，早期暴露 Bean 的逻辑受 `allowCircularReferences`字段控制。当该字段为 `false`时，不会将未初始化的 Bean 引用放入三级缓存（`singletonFactories`），导致循环依赖无法解决：
```java
// 源码片段
protected void doCreateBean(String beanName, RootBeanDefinition mbd, Object[] args) {
    boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && 
                                      isSingletonCurrentlyInCreation(beanName));
    if (earlySingletonExposure) {
        addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
    }
    // 初始化逻辑...
}
```
Spring Boot 2.6+ 通过 `SpringApplication`的 `setAllowCircularReferences(false)`禁用此机制，鼓励代码重构 。
###### 4. Spring Boot 3.x 有什么新特性?
Spring Boot 3.x 基于 Spring Framework 6，面向 Java 17 和 Jakarta EE 9+，主要特性包括：
- **Java 17 最低要求**：
    利用 Records、Sealed Classes 等新特性。源码中，`SpringApplication`启动时通过 `Runtime.version()`校验 Java 版本 。
- **Jakarta EE 迁移**：
    包名从 `javax.*`改为 `jakarta.*`（如 `jakarta.servlet.HttpServlet`）。迁移涉及 Spring Data、Spring Security 等模块，例如 JPA 的 `@Entity`注解改为 `jakarta.persistence.Entity`。
- **GraalVM Native Image 支持**：
    通过 `spring-boot-starter-native`支持将应用编译为原生可执行文件，减少启动时间和内存占用。源码中，`AotProcessing`类在编译时生成反射配置 。
- **改进的自动配置注册**：
    自动配置类从 `META-INF/spring.factories`迁移到 `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`文件，格式更简洁 。
- **增强的安全特性**：
    OAuth2 支持更简化，例如 `OAuth2AuthorizationServerConfiguration`提供默认配置 。
###### 5. Spring Boot 3.x 与 2.x 有什么区别?

|**维度**​|**Spring Boot 2.x**​|**Spring Boot 3.x**​|**关键差异**​|
|---|---|---|---|
|**Java 版本**​|JDK 8+|JDK 17+|3.x 利用 JDK 17 的模块化特性，如 `jdk.incubator.vector`用于向量计算 。|
|**EE 规范**​|Java EE (javax)|Jakarta EE 9+ (jakarta)|包名变更导致兼容性断裂，需更新导入语句 。|
|**原生编译**​|需手动配置 GraalVM|原生支持 Native Image|`SpringApplication`新增 `AotApplication`类处理原生编译 。|
|**依赖管理**​|Spring Framework 5.x|Spring Framework 6.x|移除过时的 API，如 `JdbcTemplate`的某些方法 。|
|**配置属性**​|沿用 `spring.factories`|推荐 `AutoConfiguration.imports`|`SpringFactoriesLoader`同时支持新旧格式 。|
###### 6. 如何从 Spring Boot 2.x 升级到 3.x?
升级需遵循系统化步骤，重点关注兼容性：
1. **环境准备**：
    - 升级 JDK 到 17+。
    - 更新 IDE 和构建工具（Maven/Gradle）以支持新版本。
2. **依赖迁移**：
    - 更新 Spring Boot 父 POM 版本至 3.x：
        ```xml
        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>3.0.0</version>
        </parent>
        ```
    - 替换 Jakarta EE 依赖：例如 `javax.servlet:javax.servlet-api`改为 `jakarta.servlet:jakarta.servlet-api`。
3. **代码适配**：
    - 修改包导入：将 `javax.persistence`改为 `jakarta.persistence`。
    - 更新配置属性：部分属性在 3.x 中废弃（如 `server.servlet`调整为 `server.http`）。
    - 测试循环依赖：因 3.x 延续 2.6+ 的循环依赖禁止策略，需重构代码 。
4. **原生编译支持**：
    - 添加 Native Image 插件：
        ```xml
        <plugin>
            <groupId>org.graalvm.buildtools</groupId>
            <artifactId>native-maven-plugin</artifactId>
        </plugin>
        ```
    - 使用 `mvn spring-boot:build-image`构建原生镜像 。
5. **测试与验证**
    - 利用 `@SpringBootTest`进行集成测试。
    - 使用 Actuator 端点检查健康状态。
###### 7. Jakarta EE 与 Java EE 的区别是什么?
Jakarta EE 是 Java EE 的演进版本，主要区别如下：
- **命名空间变更**：
    Java EE 使用 `javax.*`包（如 `javax.servlet.HttpServlet`），而 Jakarta EE 使用 `jakarta.*`（如 `jakarta.servlet.HttpServlet`）。这是因 Oracle 将 Java EE 捐赠给 Eclipse 基金会后，需避免商标冲突 。
- **功能增强**：
    Jakarta EE 9+ 引入了对 MicroProfile 的更好支持（如容错、配置管理），并简化了安全配置。例如，JPA 的 `EntityManager`在 Jakarta EE 中支持更灵活的缓存机制 。
- **兼容性影响**：
    代码从 Java EE 迁移到 Jakarta EE 需修改导入语句，但 API 基本保持一致。Spring Boot 3.x 仅支持 Jakarta EE，导致与旧版本不兼容 。
###### 8. GraalVM Native Image 的优势是什么?
GraalVM Native Image 将 Java 应用编译为原生可执行文件，具有以下优势：
- **启动速度提升**：
    原生应用启动时间从秒级降至毫秒级（如 Spring Boot 应用从 5 秒减到 0.1 秒）。源码中，通过排除 JVM 解释器，直接生成机器码 。
- **内存占用降低**：
    无需 JVM 堆内存管理，内存占用减少 50%+。例如，原生镜像使用 `SubstrateVM`进行垃圾回收，优化内存布局 。
- **云原生适配**：
    更适合容器化部署，镜像体积更小（仅包含必要依赖）。Spring Boot 的 `NativeImageProcessor`在编译时通过静态分析移除未使用的代码路径 。
- **局限性**：
    不支持动态类加载、反射需显式配置（通过 `reflect-config.json`）。Spring Boot 3.x 的 `@NativeHint`注解可简化配置 。