###### 1. 如何实现自定义 Starter?
Spring Boot自定义Starter基于**自动配置机制**和**约定优于配置**原则，通过几个核心组件实现功能模块的即插即用。
**核心架构组成**：
- **自动配置类**：使用`@Configuration`和`@Conditional`系列注解控制Bean的创建条件
- **配置属性类**：通过`@ConfigurationProperties`绑定外部化配置
- **spring.factories/AutoConfiguration.imports**：注册自动配置类
- **条件注解**：根据类路径、Bean存在性等条件决定是否启用配置
**实现步骤详解**：
**1. 项目结构设计**
创建Maven多模块项目，分离自动配置与Starter依赖管理：
```
my-starter-parent/
├── my-spring-boot-autoconfigure  # 自动配置核心
└── my-spring-boot-starter        # 依赖聚合器
```
**2. 自动配置模块实现**
```xml
<!-- autoconfigure模块pom.xml -->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-autoconfigure</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-configuration-processor</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```
**配置属性绑定**：
```java
@ConfigurationProperties(prefix = "my.service")
public class MyServiceProperties {
    private String prefix = "Hello";
    private String suffix = "!";
    private boolean enabled = true;
    // getters and setters
}
```
**自动配置类**（核心）：
```java
@Configuration
@EnableConfigurationProperties(MyServiceProperties.class)
@ConditionalOnClass(MyService.class)  // 类路径存在MyService时生效
@ConditionalOnProperty(prefix = "my.service", name = "enabled", matchIfMissing = true)
public class MyServiceAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean  // 容器中不存在MyService时创建
    public MyService myService(MyServiceProperties properties) {
        return new MyService(properties.getPrefix(), properties.getSuffix());
    }
    
    @Bean
    @ConditionalOnWebApplication  // 仅Web环境生效
    public MyServiceController myServiceController() {
        return new MyServiceController();
    }
}
```
**3. 注册配置类**
Spring Boot 2.7+推荐使用`AutoConfiguration.imports`：
```properties
# src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
com.example.autoconfigure.MyServiceAutoConfiguration
```
传统方式（兼容旧版本）：
```properties
# src/main/resources/META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.autoconfigure.MyServiceAutoConfiguration
```
**4. Starter模块（依赖聚合）**
```xml
<!-- starter模块pom.xml -->
<dependencies>
    <dependency>
        <groupId>com.example</groupId>
        <artifactId>my-spring-boot-autoconfigure</artifactId>
        <version>1.0.0</version>
    </dependency>
</dependencies>
```
**5. 条件装配深度解析**
条件注解是Starter智能自动配置的核心：
```java
@Configuration
@ConditionalOnClass(DataSource.class)  // 类路径条件
@ConditionalOnBean(DataSource.class)   // Bean存在条件  
@ConditionalOnExpression("${my.service.enabled:true}")  // SpEL表达式
@ConditionalOnJava(JavaVersion.ELEVEN)  // JVM版本条件
@ConditionalOnResource(resources = "classpath:my-config.properties")  // 资源条件
public class AdvancedAutoConfiguration {
    // 复杂条件装配
}
```
**6. 测试自定义Starter**
```java
@SpringBootTest
class MyServiceTest {

    @Autowired(required = false)
    private MyService myService;

    @Test
    void serviceAutoConfigured() {
        assertThat(myService).isNotNull();
        assertThat(myService.greet("World")).isEqualTo("Hello World!");
    }
}
```
**源码级自动配置机制**：
Spring Boot通过`SpringFactoriesLoader`加载`META-INF/spring.factories`中注册的自动配置类。在`SpringApplication.run()`方法执行时，会触发`EnableAutoConfigurationImportSelector`选择并实例化所有符合条件的自动配置类，这一过程基于Spring框架的`@Import`机制和条件判断系统。
###### 2. 如何实现 SPI 扩展机制?
SPI（Service Provider Interface）是Java提供的服务发现机制，Spring Boot在此基础上发展了更强大的`spring.factories`机制。
**Java标准SPI实现**：
**1. 定义服务接口**
```java
public interface LoggerPlugin {
    void log(String message);
    boolean supports(String type);
}
```
**2. 实现服务提供者**
```java
public class FileLogger implements LoggerPlugin {
    @Override
    public void log(String message) {
        // 文件日志实现
    }
    
    @Override
    public boolean supports(String type) {
        return "file".equals(type);
    }
}

public class ConsoleLogger implements LoggerPlugin {
    @Override
    public void log(String message) {
        // 控制台日志实现
    }
    
    @Override
    public boolean supports(String type) {
        return "console".equals(type);
    }
}
```
**3. 注册服务提供者**
在`META-INF/services/`目录创建以接口全限定名命名的文件：
```java
# META-INF/services/com.example.LoggerPlugin
com.example.FileLogger
com.example.ConsoleLogger
```
**4. 服务加载与使用**
```java
public class LoggerFactory {
    public static LoggerPlugin getLogger(String type) {
        ServiceLoader<LoggerPlugin> loaders = ServiceLoader.load(LoggerPlugin.class);
        for (LoggerPlugin logger : loaders) {
            if (logger.supports(type)) {
                return logger;
            }
        }
        throw new IllegalArgumentException("No logger found for type: " + type);
    }
}
```
**Spring Boot的SPI增强机制**：
**1. Spring Factories SPI**
Spring Boot通过`META-INF/spring.factories`文件扩展了SPI机制，支持更多类型的扩展：
```properties
# 自动配置扩展
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.MyAutoConfiguration

# 应用监听器扩展  
org.springframework.context.ApplicationListener=\
com.example.MyApplicationListener

# 环境后处理器扩展
org.springframework.boot.env.EnvironmentPostProcessor=\
com.example.MyEnvironmentPostProcessor
```
**2. 自定义Spring Factories扩展**
```java
// 定义扩展点接口
public interface MyExtension {
    void extend(ConfigurableApplicationContext context);
}

// 实现扩展
public class DatabaseExtension implements MyExtension {
    @Override
    public void extend(ConfigurableApplicationContext context) {
        // 扩展逻辑
    }
}
```
**注册扩展实现**：
```properties
# META-INF/spring.factories
com.example.MyExtension=\
com.example.DatabaseExtension
```
**加载扩展实现**：
```java
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MyApp.class);
        
        // 加载自定义扩展
        List<MyExtension> extensions = SpringFactoriesLoader.loadFactories(
            MyExtension.class, getClass().getClassLoader());
            
        app.addInitializers(context -> {
            extensions.forEach(ext -> ext.extend(context));
        });
        
        app.run(args);
    }
}
```
**3. 自动配置SPI深度解析**
Spring Boot的自动配置本质上是基于SPI机制的扩展：
```java
// SpringFactoriesLoader的核心加载逻辑
public final class SpringFactoriesLoader {
    public static <T> List<T> loadFactories(Class<T> factoryType, 
                                           @Nullable ClassLoader classLoader) {
        // 加载所有META-INF/spring.factories中的配置
        List<String> factoryNames = loadFactoryNames(factoryType, classLoader);
        // 实例化并排序
        return instantiateFactories(factoryNames, classLoader);
    }
}
```
**4. 自定义Starter中的SPI应用**
在自定义Starter中，可以利用SPI机制实现插件化架构：
```properties
# 在Starter中定义扩展点
com.example.plugin.PaymentProvider=\
com.example.plugin.AlipayProvider,\
com.example.plugin.WechatPayProvider
```
**SPI机制的优势**：
- **解耦**：服务接口与实现分离
- **可扩展**：新增实现无需修改框架代码
- **动态发现**：运行时自动发现所有可用实现
###### 3. Spring Boot 的事件机制是怎样的?
Spring Boot的事件机制基于**观察者模式**，通过`ApplicationEvent`、`ApplicationListener`和`ApplicationEventPublisher`实现应用内部组件间的解耦通信。
**事件体系核心组件**：
**1. 事件类型层次结构**
```java
// Spring内置核心事件
ApplicationEvent
├── ApplicationContextEvent
│   ├── ContextRefreshedEvent     // 容器刷新完成
│   ├── ContextStartedEvent        // 容器启动
│   ├── ContextStoppedEvent        // 容器停止
│   └── ContextClosedEvent         // 容器关闭
└── SpringApplicationEvent
    ├── ApplicationStartingEvent           // 应用启动开始
    ├── ApplicationEnvironmentPreparedEvent // 环境准备完成
    ├── ApplicationPreparedEvent           // 应用准备完成
    ├── ApplicationStartedEvent            // 应用启动完成
    ├── ApplicationReadyEvent              // 应用准备就绪
    └── ApplicationFailedEvent             // 应用启动失败
```
**2. 事件发布与监听流程**
```java
// 事件发布序列
applicationEventPublisher.publishEvent(new MyEvent(this, data))
    → ApplicationEventMulticaster.multicastEvent(event)
        → 遍历所有ApplicationListener
        → 条件匹配检查
        → 同步/异步执行监听器
```
**3. 内置事件详解**
**应用启动事件序列**：
```java
@SpringBootApplication
public class EventDemoApplication {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(EventDemoApplication.class);
        
        // 添加事件监听器
        app.addListeners(
            new ApplicationStartingEventListener(),
            new ApplicationReadyEventListener()
        );
        
        app.run(args);
    }
}

// 启动事件监听
@Component
public class ApplicationStartingEventListener implements ApplicationListener<ApplicationStartingEvent> {
    @Override
    public void onApplicationEvent(ApplicationStartingEvent event) {
        // 最早触发的事件，此时Bean工厂还未初始化
        System.out.println("应用开始启动...");
    }
}

// 就绪事件监听
@Component
public class ApplicationReadyEventListener implements ApplicationListener<ApplicationReadyEvent> {
    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        // 应用完全启动，可以接收请求
        System.out.println("应用启动完成，可以处理请求");
    }
}
```
**4. 事件机制源码解析**
**事件多播器核心实现**：
```java
public class SimpleApplicationEventMulticaster implements ApplicationEventMulticaster {
    @Nullable
    private Executor taskExecutor;  // 异步执行器
    
    @Override
    public void multicastEvent(ApplicationEvent event) {
        multicastEvent(event, resolveDefaultEventType(event));
    }
    
    @Override
    public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
        // 获取所有匹配的监听器
        Collection<ApplicationListener<?>> listeners = getApplicationListeners(event, eventType);
        
        // 遍历执行监听器
        for (ApplicationListener<?> listener : listeners) {
            Executor executor = getTaskExecutor();
            if (executor != null) {
                // 异步执行
                executor.execute(() -> invokeListener(listener, event));
            } else {
                // 同步执行
                invokeListener(listener, event);
            }
        }
    }
}
```
**5. 事件广播机制**
**监听器获取逻辑**：
```java
protected Collection<ApplicationListener<?>> getApplicationListeners(
        ApplicationEvent event, ResolvableType eventType) {
    
    // 缓存机制提升性能
    Object cacheKey = new ListenerCacheKey(eventType, sourceType);
    return this.retrieverCache.get(cacheKey, () -> {
        // 检索匹配的监听器
        return retrieveApplicationListeners(eventType, sourceType, new CachingProvider());
    });
}
```
**6. 事件机制的应用场景**
**应用初始化配置**：
```java
@Component
public class DatabaseInitializer implements ApplicationListener<ApplicationReadyEvent> {
    
    @Autowired
    private DataSource dataSource;
    
    @Override
    @Transactional
    public void onApplicationEvent(ApplicationReadyEvent event) {
        // 应用启动完成后初始化数据库
        initializeReferenceData();
    }
}
```
**特性总结**：
- **同步/异步支持**：通过`@Async`和`Executor`配置实现异步事件处理
- **条件过滤**：监听器可以通过条件表达式选择性接收事件
- **事务绑定**：事件监听可以参与当前事务（同步模式下）
- **有序执行**：通过`@Order`注解控制监听器执行顺序
###### 4. 如何自定义事件和监听器?
**自定义事件：继承 `ApplicationEvent`基类。
```java
public class UserRegisteredEvent extends ApplicationEvent {
    private final String username;
    private final String email;
    
    public UserRegisteredEvent(Object source, String username, String email) {
        super(source);
        this.username = username;
        this.email = email;
    }
    // getters
}
```
**实现监听器：两种方式实现监听器：
1. **实现 ApplicationListener 接口**：
```java
@Component
public class UserRegisteredListener implements ApplicationListener<UserRegisteredEvent> {
    @Override
    public void onApplicationEvent(UserRegisteredEvent event) {
        // 处理用户注册逻辑，如发送邮件
        System.out.println("User registered: " + event.getUsername());
    }
}
```
1. **使用 @EventListener 注解**（推荐）：
```java
@Component
public class EmailNotificationListener {
    
    @EventListener
    @Async // 支持异步处理
    public void handleUserRegistered(UserRegisteredEvent event) {
        // 发送欢迎邮件
        System.out.println("Sending email to: " + event.getEmail());
    }
    
    @EventListener(condition = "#event.email != null")
    public void handleValidEmail(UserRegisteredEvent event) {
        // 使用SpEL条件判断
    }
}
```
**异步事件处理：**
1. 在配置类上添加 `@EnableAsync`开启异步支持
2. 在监听器方法上添加 `@Async`注解
3. 可自定义 `TaskExecutor`控制线程池行为
**事件发布：**
```java
@Service
public class UserService {
    private final ApplicationEventPublisher publisher;
    
    public UserService(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }
    
    public void registerUser(String username, String email) {
        // 用户注册逻辑...
        // 发布事件
        UserRegisteredEvent event = new UserRegisteredEvent(this, username, email);
        publisher.publishEvent(event);
    }
}
```
###### 5. 如何实现条件装配?
条件装配通过 `@Conditional`系列注解实现，控制Bean的创建条件。
**常用条件注解：**
- `@ConditionalOnClass`：类路径下存在指定类时生效
- `@ConditionalOnMissingBean`：容器中不存在指定Bean时生效
- `@ConditionalOnProperty`：配置属性满足条件时生效
- `@ConditionalOnWebApplication`：Web应用环境下生效
- `@ConditionalOnExpression`：SpEL表达式为true时生效
**自定义条件装配：**
1. **实现 Condition 接口**：
```java
public class DatabaseTypeCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        // 从注解获取属性
        Map<String, Object> attributes = metadata.getAnnotationAttributes(
            ConditionalOnDatabaseType.class.getName());
        String requiredDbType = (String) attributes.get("value");
        
        // 从环境获取实际配置
        String actualDbType = context.getEnvironment()
            .getProperty("app.database.type");
            
        return requiredDbType.equalsIgnoreCase(actualDbType);
    }
}
```
1. **定义自定义条件注解**：
```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Conditional(DatabaseTypeCondition.class)
public @interface ConditionalOnDatabaseType {
    String value();
}
```
1. **使用自定义条件**：
```java
@Configuration
public class DatabaseConfig {
    
    @Bean
    @ConditionalOnDatabaseType("mysql")
    public DataSource mysqlDataSource() {
        // 创建MySQL数据源
        return new MysqlDataSource();
    }
    
    @Bean
    @ConditionalOnProperty(name = "app.cache.enabled", havingValue = "true")
    public CacheManager cacheManager() {
        // 仅当app.cache.enabled=true时创建
        return new RedisCacheManager();
    }
}
```
**源码层面的条件判断逻辑：**
- `ConditionEvaluator`负责评估所有条件注解
- `ConditionContext`提供环境、bean工厂等上下文信息
- `AnnotatedTypeMetadata`提供注解元数据访问
- 在Bean定义注册阶段进行条件判断，不满足条件的Bean不会被注册
###### 6. 如何使用 @Import 导入配置?
`@Import`注解用于导入一个或多个配置类，实现配置的模块化。
**基本用法：**
```java
@Configuration
@Import({DatabaseConfig.class, CacheConfig.class})
public class AppConfig {
    // 主配置类
}
```
**导入多种配置类型：**
1. **普通配置类**：
```java
@Configuration
public class DatabaseConfig {
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }
}
```
1. **实现 ImportSelector**：动态选择导入的配置类。
```java
public class FeatureImportSelector implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        List<String> imports = new ArrayList<>();
        
        // 根据条件动态选择要导入的配置
        if (isCacheEnabled()) {
            imports.add(CacheConfig.class.getName());
        }
        if (isAsyncEnabled()) {
            imports.add(AsyncConfig.class.getName());
        }
        
        return imports.toArray(new String[0]);
    }
}
```
2. **实现 ImportBeanDefinitionRegistrar**：直接注册Bean定义。
```java
public class CustomBeanRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(
            AnnotationMetadata importingClassMetadata,
            BeanDefinitionRegistry registry) {
        
        // 直接注册Bean定义
        RootBeanDefinition beanDefinition = new RootBeanDefinition(CustomService.class);
        registry.registerBeanDefinition("customService", beanDefinition);
    }
}
```
**组合使用：**
```java
@Configuration
@Import({FeatureImportSelector.class, CustomBeanRegistrar.class})
public class AppConfig {
    // 导入选择器和注册器
}
```
**源码层面的导入过程：**
- `ConfigurationClassPostProcessor`处理 `@Import`注解
- 根据导入类型分别调用 `ImportSelector.selectImports()`或 `ImportBeanDefinitionRegistrar.registerBeanDefinitions()`
- 递归处理导入的配置类，确保所有依赖配置都被处理
###### 7. ImportSelector 和 ImportBeanDefinitionRegistrar 的区别是什么?
两者都是 `@Import`注解的高级用法，但在功能和粒度上有所不同。
**ImportSelector：**
- **用途**：根据条件动态选择要导入的配置类
- **返回值**：返回要导入的配置类的全限定名数组
- **抽象级别**：类级别，导入整个配置类
- **使用场景**：基于环境、配置属性等条件启用或禁用特定模块
```java
public class ProfileBasedSelector implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        // 根据激活的profile选择配置
        if (isDevProfileActive()) {
            return new String[] {DevConfig.class.getName()};
        } else {
            return new String[] {ProdConfig.class.getName()};
        }
    }
}
```
**ImportBeanDefinitionRegistrar：**
- **用途**：直接注册Bean定义到容器中
- **操作对象**：直接操作 `BeanDefinitionRegistry`
- **抽象级别**：Bean级别，更细粒度的控制
- **使用场景**：需要编程式注册Bean、条件复杂的Bean注册
```java
public class CustomServiceRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(
            AnnotationMetadata importingClassMetadata,
            BeanDefinitionRegistry registry) {
        
        // 检查条件
        if (registry.containsBeanDefinition("requiredBean")) {
            // 直接注册Bean定义
            BeanDefinitionBuilder builder = BeanDefinitionBuilder
                .rootBeanDefinition(CustomService.class);
            builder.addPropertyReference("dependency", "dependentBean");
            
            registry.registerBeanDefinition("customService", 
                builder.getBeanDefinition());
        }
    }
}
```
**关键区别点：**

|特性|ImportSelector|ImportBeanDefinitionRegistrar|
|---|---|---|
|抽象级别|类级别|Bean级别|
|返回值|类名数组|无返回值|
|控制粒度|粗粒度（整个配置类）|细粒度（单个Bean定义）|
|使用复杂度|相对简单|相对复杂|
|灵活性|基于现有配置类|可编程式创建Bean定义|
**源码层面的差异：**
- `ImportSelector`结果由 `ConfigurationClassParser`处理，递归解析导入的配置类
- `ImportBeanDefinitionRegistrar`直接操作 `BeanDefinitionRegistry`，跳过配置类解析阶段
- 两者都通过 `ConfigurationClassPostProcessor`触发执行
###### 8. 如何实现 BeanPostProcessor?
`BeanPostProcessor`是Spring容器扩展点，在Bean初始化前后进行自定义处理。
**基本实现：**
```java
@Component
public class CustomBeanPostProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        // 在init-method之前调用
        if (bean instanceof Validatable) {
            ((Validatable) bean).validate();
        }
        return bean; // 可以返回包装后的Bean
    }
    
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        // 在init-method之后调用
        if (bean instanceof Cacheable) {
            return createCacheProxy(bean);
        }
        return bean;
    }
}
```
**实际应用场景：**
1. **日志监控**：
```java
@Component
public class LoggingBeanPostProcessor implements BeanPostProcessor {
    private static final Logger logger = LoggerFactory.getLogger(LoggingBeanPostProcessor.class);
    
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        // 为Service类创建日志代理
        if (bean.getClass().getAnnotation(Service.class) != null) {
            return Proxy.newProxyInstance(
                bean.getClass().getClassLoader(),
                bean.getClass().getInterfaces(),
                (proxy, method, args) -> {
                    long start = System.currentTimeMillis();
                    try {
                        logger.info("Executing method: {}", method.getName());
                        return method.invoke(bean, args);
                    } finally {
                        long duration = System.currentTimeMillis() - start;
                        logger.info("Method {} executed in {}ms", method.getName(), duration);
                    }
                });
        }
        return bean;
    }
}
```
1. **注解处理**：
```java
@Component
public class InjectConfigProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        Class<?> clazz = bean.getClass();
        // 处理字段上的自定义注解
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Encrypted.class)) {
                field.setAccessible(true);
                try {
                    String original = (String) field.get(bean);
                    String encrypted = encrypt(original);
                    field.set(bean, encrypted);
                } catch (IllegalAccessException e) {
                    throw new RuntimeException("Field encryption failed", e);
                }
            }
        }
        return bean;
    }
}
```
**源码层面的执行顺序：**
1. Bean实例化（构造函数）
2. 属性注入（依赖注入）
3. `BeanPostProcessor.postProcessBeforeInitialization()`
4. 初始化方法（`@PostConstruct`、`InitializingBean`、自定义init-method）
5. `BeanPostProcessor.postProcessAfterInitialization()`
6. Bean完全初始化，可被使用
**注意事项：**
- `BeanPostProcessor`需要注册为Spring Bean才会生效
- 多个处理器可通过 `Ordered`接口或 `@Order`注解控制执行顺序
- 避免在处理器中执行耗时操作，影响应用启动速度
###### 9. 如何实现 BeanFactoryPostProcessor?
`BeanFactoryPostProcessor`用于在Bean定义加载后、实例化前修改Bean定义，是容器级别的扩展点。
**基本实现：**
```java
@Component
public class CustomBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        // 获取Bean定义
        BeanDefinition beanDefinition = beanFactory.getBeanDefinition("dataSource");
        
        // 修改属性值
        MutablePropertyValues properties = beanDefinition.getPropertyValues();
        properties.add("url", "jdbc:mysql://localhost:3306/mydb");
        properties.add("username", "admin");
        
        // 动态注册新的Bean定义
        if (!beanFactory.containsBeanDefinition("newService")) {
            RootBeanDefinition newBeanDef = new RootBeanDefinition(NewService.class);
            beanFactory.registerBeanDefinition("newService", newBeanDef);
        }
    }
}
```
**实际应用场景：**
1. **配置属性动态替换**：
```java
@Component
public class PropertyPlaceholderProcessor implements BeanFactoryPostProcessor {
    
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        ConfigurableEnvironment env = (ConfigurableEnvironment) beanFactory.getBean(ConfigurableEnvironment.class);
        
        for (String beanName : beanFactory.getBeanDefinitionNames()) {
            BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
            String originalClassName = beanDef.getBeanClassName();
            
            // 替换占位符
            if (originalClassName != null && originalClassName.contains("${")) {
                String resolvedClassName = env.resolvePlaceholders(originalClassName);
                beanDef.setBeanClassName(resolvedClassName);
            }
        }
    }
}
```
1. **条件化Bean定义注册**：
```java
@Component
public class FeatureToggleProcessor implements BeanFactoryPostProcessor, EnvironmentAware {
    
    private Environment environment;
    
    @Override
    public void setEnvironment(Environment environment) {
        this.environment = environment;
    }
    
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        // 根据特性开关启用或禁用Bean
        boolean cacheEnabled = environment.getProperty("feature.cache.enabled", Boolean.class, false);
        
        if (!cacheEnabled) {
            // 禁用缓存相关的Bean
            disableBean(beanFactory, "cacheManager");
        }
        
        // 根据环境动态注册Bean
        if (environment.acceptsProfiles("cluster")) {
            registerClusterBeans(beanFactory);
        }
    }
    
    private void disableBean(ConfigurableListableBeanFactory beanFactory, String beanName) {
        if (beanFactory.containsBeanDefinition(beanName)) {
            BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
            beanDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); // 标记为基础设施角色
        }
    }
}
```
**与 BeanPostProcessor 的关键区别：**

|特性|BeanFactoryPostProcessor|BeanPostProcessor|
|---|---|---|
|执行时机|Bean定义加载后，实例化前|Bean实例化过程中|
|操作对象|BeanDefinition（元数据）|Bean实例（对象）|
|影响范围|容器级别，影响所有Bean|单个Bean实例级别|
|使用场景|修改Bean定义、条件注册|增强Bean功能、代理|
**源码层面的执行过程：**
1. `AbstractApplicationContext.refresh()`中调用 `invokeBeanFactoryPostProcessors()`
2. 优先执行 `BeanDefinitionRegistryPostProcessor`（扩展接口）
3. 按顺序执行所有 `BeanFactoryPostProcessor`
4. 处理器通过 `ConfigurableListableBeanFactory`访问和修改Bean定义
###### 10. 如何实现自定义注解?
自定义注解通过元编程扩展Java语言功能，在Spring中广泛用于声明式编程。
**创建自定义注解：**
```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME) // 运行时保留，可通过反射读取
@Documented
@Component // 元注解，使注解本身被组件扫描
public @interface CustomService {
    String value() default "";        // 属性定义
    boolean enabled() default true;    // 带默认值的属性
    String[] tags() default {};        // 数组属性
}
```
**注解处理器实现：**
1. **使用 BeanPostProcessor 处理注解**：
```java
@Component
public class CustomServiceProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        // 检查类级别的注解
        CustomService annotation = bean.getClass().getAnnotation(CustomService.class);
        if (annotation != null && annotation.enabled()) {
            // 处理注解逻辑
            processCustomService(bean, annotation);
        }
        return bean;
    }
    
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        // 处理方法级别的注解
        for (Method method : bean.getClass().getMethods()) {
            if (method.isAnnotationPresent(CustomService.class)) {
                CustomService annotation = method.getAnnotation(CustomService.class);
                processAnnotatedMethod(bean, method, annotation);
            }
        }
        return bean;
    }
}
```
1. **使用 AOP 处理注解**：
```java
@Aspect
@Component
public class CustomServiceAspect {
    
    @Around("@annotation(customService)")
    public Object handleCustomService(ProceedingJoinPoint joinPoint, CustomService customService) throws Throwable {
        String serviceName = customService.value();
        boolean enabled = customService.enabled();
        
        if (!enabled) {
            throw new ServiceDisabledException("Service " + serviceName + " is disabled");
        }
        
        // 执行前处理
        long start = System.currentTimeMillis();
        try {
            return joinPoint.proceed();
        } finally {
            // 执行后处理
            long duration = System.currentTimeMillis() - start;
            System.out.println(serviceName + " executed in " + duration + "ms");
        }
    }
}
```
**实际应用示例：**
1. **审计日志注解**：
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AuditLog {
    String action();           // 操作类型
    String module() default ""; // 模块名称
    Level level() default Level.INFO; // 日志级别
    
    enum Level { INFO, WARN, ERROR }
}

// 处理器
@Aspect
@Component
public class AuditLogAspect {
    @Autowired
    private AuditService auditService;
    
    @AfterReturning("@annotation(auditLog)")
    public void auditSuccess(JoinPoint joinPoint, AuditLog auditLog) {
        auditService.log(auditLog.action(), auditLog.module(), 
            getCurrentUser(), System.currentTimeMillis(), "SUCCESS");
    }
    
    @AfterThrowing(pointcut = "@annotation(auditLog)", throwing = "ex")
    public void auditFailure(JoinPoint joinPoint, AuditLog auditLog, Exception ex) {
        auditService.log(auditLog.action(), auditLog.module(),
            getCurrentUser(), System.currentTimeMillis(), "FAILED: " + ex.getMessage());
    }
}
```
1. **缓存注解**：
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomCache {
    String key();              // 缓存key
    long ttl() default 300;    // 存活时间（秒）
    boolean refresh() default false; // 是否强制刷新
}

// 处理器
@Aspect
@Component
public class CacheAspect {
    @Autowired
    private CacheManager cacheManager;
    
    @Around("@annotation(cacheConfig)")
    public Object handleCache(ProceedingJoinPoint joinPoint, CustomCache cacheConfig) throws Throwable {
        String cacheKey = generateKey(joinPoint, cacheConfig.key());
        Cache cache = cacheManager.getCache("default");
        
        if (!cacheConfig.refresh()) {
            // 尝试从缓存获取
            Cache.ValueWrapper cached = cache.get(cacheKey);
            if (cached != null) {
                return cached.get();
            }
        }
        
        // 执行方法并缓存结果
        Object result = joinPoint.proceed();
        cache.put(cacheKey, result, cacheConfig.ttl());
        return result;
    }
}
```
**注解的元注解机制：**
- `@Target`：指定注解可应用的目标（类、方法、字段等）
- `@Retention`：指定注解保留策略（SOURCE、CLASS、RUNTIME）
- `@Documented`：包含在Javadoc中
- `@Inherited`：允许子类继承父类的注解
###### 11. 如何使用 AOP 实现切面编程?
AOP（Aspect-Oriented Programming）通过切面将横切关注点模块化，Spring AOP基于代理模式实现。
**启用AOP支持：**
```java
@Configuration
@EnableAspectJAutoProxy(proxyTargetClass = true) // 启用AspectJ自动代理
@ComponentScan("com.example")
public class AppConfig {
}
```
**定义切面：**
```java
@Aspect
@Component
public class LoggingAspect {
    
    // 定义切点：匹配Service层所有方法
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceLayer() {}
    
    // 定义切点：匹配带有特定注解的方法
    @Pointcut("@annotation(com.example.annotation.Auditable)")
    public void auditableMethod() {}
    
    // 前置通知
    @Before("serviceLayer()")
    public void logBefore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        logger.info("Entering method: {} with args: {}", methodName, Arrays.toString(args));
    }
    
    // 后置通知（无论是否异常都执行）
    @After("serviceLayer()")
    public void logAfter(JoinPoint joinPoint) {
        logger.info("Exiting method: {}", joinPoint.getSignature().getName());
    }
    
    // 返回后通知
    @AfterReturning(pointcut = "serviceLayer()", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        logger.info("Method {} returned: {}", joinPoint.getSignature().getName(), result);
    }
    
    // 异常通知
    @AfterThrowing(pointcut = "serviceLayer()", throwing = "ex")
    public void logAfterThrowing(JoinPoint joinPoint, Exception ex) {
        logger.error("Exception in method: {}", joinPoint.getSignature().getName(), ex);
    }
    
    // 环绕通知（最强大的通知类型）
    @Around("serviceLayer()")
    public Object measurePerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();
        try {
            return joinPoint.proceed(); // 执行目标方法
        } finally {
            long duration = System.currentTimeMillis() - start;
            logger.info("Method {} executed in {} ms", 
                joinPoint.getSignature().getName(), duration);
        }
    }
}
```
**切点表达式语法：**
- `execution([修饰符] 返回类型 [类名].方法名(参数) [异常])`：匹配方法执行
- `within(包名..*)`：匹配包内所有类
- `this(类型)`：匹配代理对象类型
- `target(类型)`：匹配目标对象类型
- `args(参数类型)`：匹配参数类型
- `@annotation(注解类型)`：匹配带有注解的方法
- `@within(注解类型)`：匹配带有注解的类中的方法
**实际应用场景：**
1. **事务管理**：
```java
@Aspect
@Component
public class TransactionAspect {
    
    @Autowired
    private PlatformTransactionManager transactionManager;
    
    @Around("@annotation(transactional)")
    public Object manageTransaction(ProceedingJoinPoint joinPoint, Transactional transactional) throws Throwable {
        TransactionDefinition definition = new DefaultTransactionDefinition();
        TransactionStatus status = transactionManager.getTransaction(definition);
        
        try {
            Object result = joinPoint.proceed();
            transactionManager.commit(status);
            return result;
        } catch (Exception ex) {
            transactionManager.rollback(status);
            throw ex;
        }
    }
}
```
1. **安全控制**：
```java
@Aspect
@Component
public class SecurityAspect {
    
    @Autowired
    private SecurityContext securityContext;
    
    @Before("@annotation(requiresPermission)")
    public void checkPermission(JoinPoint joinPoint, RequiresPermission requiresPermission) {
        String permission = requiresPermission.value();
        if (!securityContext.hasPermission(permission)) {
            throw new AccessDeniedException("Permission denied: " + permission);
        }
    }
    
    @Before("execution(* com.example.service.AdminService.*(..))")
    public void checkAdminAccess(JoinPoint joinPoint) {
        if (!securityContext.isAdmin()) {
            throw new AccessDeniedException("Admin access required");
        }
    }
}
```
**AOP代理机制：**
- **JDK动态代理**：基于接口代理，要求目标类实现接口
- **CGLIB代理**：基于子类代理，可代理普通类
- Spring优先使用JDK动态代理，未实现接口时使用CGLIB
###### 12. 如何实现动态代理?
动态代理在运行时创建代理对象，实现对目标方法的增强，Spring AOP基于此机制实现。
**JDK动态代理（基于接口）：**
```java
public class JdkDynamicProxyHandler implements InvocationHandler {
    private final Object target; // 目标对象
    
    public JdkDynamicProxyHandler(Object target) {
        this.target = target;
    }
    
    // 创建代理实例
    public static Object createProxy(Object target) {
        return Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            new JdkDynamicProxyHandler(target)
        );
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 前置处理
        System.out.println("Before method: " + method.getName());
        
        // 执行目标方法
        Object result = method.invoke(target, args);
        
        // 后置处理
        System.out.println("After method: " + method.getName());
        return result;
    }
}

// 使用示例
UserService realService = new UserServiceImpl();
UserService proxyService = (UserService) JdkDynamicProxyHandler.createProxy(realService);
proxyService.saveUser(user); // 会触发invoke方法
```
**CGLIB动态代理（基于子类）：**
```java
public class CglibProxyInterceptor implements MethodInterceptor {
    
    public Object createProxy(Class<?> targetClass) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(targetClass); // 设置父类
        enhancer.setCallback(this); // 设置回调
        return enhancer.create(); // 创建代理实例
    }
    
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        // 前置处理
        System.out.println("Before method: " + method.getName());
        
        // 执行目标方法（注意使用MethodProxy避免递归调用）
        Object result = proxy.invokeSuper(obj, args);
        
        // 后置处理
        System.out.println("After method: " + method.getName());
        return result;
    }
}

// 使用示例（不需要实现接口）
UserService realService = new UserService(); // 普通类
UserService proxyService = (UserService) new CglibProxyInterceptor().createProxy(UserService.class);
```
**实际应用：**
1. **远程方法调用（RPC）代理**：
```java
public class RpcClientProxy implements InvocationHandler {
    private final String serviceUrl;
    
    public RpcClientProxy(String serviceUrl) {
        this.serviceUrl = serviceUrl;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 构建RPC请求
        RpcRequest request = new RpcRequest();
        request.setClassName(method.getDeclaringClass().getName());
        request.setMethodName(method.getName());
        request.setParameterTypes(method.getParameterTypes());
        request.setParameters(args);
        
        // 发送网络请求
        RpcResponse response = sendRequest(serviceUrl, request);
        
        if (response.hasError()) {
            throw response.getError();
        }
        return response.getResult();
    }
    
    public static <T> T createProxy(Class<T> interfaceClass, String serviceUrl) {
        return (T) Proxy.newProxyInstance(
            interfaceClass.getClassLoader(),
            new Class[]{interfaceClass},
            new RpcClientProxy(serviceUrl)
        );
    }
}
```
1. **缓存代理**：
```java
public class CacheProxy implements InvocationHandler {
    private final Object target;
    private final Map<Method, Cache> caches = new ConcurrentHashMap<>();
    
    public CacheProxy(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 检查是否有@Cacheable注解
        Cacheable cacheable = method.getAnnotation(Cacheable.class);
        if (cacheable == null) {
            return method.invoke(target, args);
        }
        
        String cacheKey = generateCacheKey(method, args);
        Cache cache = getCache(method, cacheable);
        
        // 尝试从缓存获取
        Object cached = cache.get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        // 执行方法并缓存结果
        Object result = method.invoke(target, args);
        cache.put(cacheKey, result, cacheable.ttl());
        return result;
    }
}
```
**动态代理的底层原理：**
- JDK动态代理使用 `java.lang.reflect.Proxy`和 `InvocationHandler`
- 生成代理类的字节码，实现目标接口
- 通过反射调用目标方法，InvocationHandler处理调用逻辑
- CGLIB使用ASM框架直接操作字节码，生成目标类的子类
###### 13. JDK 动态代理和 CGLIB 代理的区别是什么?
两者都是实现动态代理的技术，但在实现机制和应用场景上有显著差异。
**技术对比：**

|特性|JDK动态代理|CGLIB代理|
|---|---|---|
|实现基础|基于接口|基于继承|
|代理目标|必须实现接口|普通类（final类除外）|
|性能|调用反射方法，相对较慢|直接调用方法，相对较快|
|生成方式|Proxy.newProxyInstance()|Enhancer.create()|
|依赖|JDK内置，无需额外依赖|需要CGLIB库|
|限制|只能代理接口方法|不能代理final方法/类|
|生成的类|Proxy0,Proxy1...|TargetClassEnhancerByCGLIB...|
**源码层面的差异：**
1. **JDK动态代理生成过程**：
```java
// Proxy.java 中的关键方法
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h) {
    // 1. 检查接口合法性
    final Class<?>[] intfs = interfaces.clone();
    
    // 2. 获取或生成代理类
    Class<?> cl = getProxyClass0(loader, intfs);
    
    // 3. 通过反射创建实例
    final Constructor<?> cons = cl.getConstructor(constructorParams);
    return cons.newInstance(new Object[]{h});
}
```
1. **CGLIB代理生成过程**：
```java
// Enhancer.java 中的关键方法
public Object create() {
    // 1. 验证类不是final
    validate();
    
    // 2. 设置回调类型
    setCallbackTypes(filteredTypes);
    
    // 3. 使用ASM生成字节码
    Object result = super.create(key);
    
    return result;
}
```
**性能测试对比：**
```java
public class ProxyPerformanceTest {
    public static void main(String[] args) {
        int iterations = 1000000;
        
        // JDK代理测试
        UserService jdkProxy = (UserService) Proxy.newProxyInstance(
            UserService.class.getClassLoader(),
            new Class[]{UserService.class},
            new JdkProxyHandler(new UserServiceImpl())
        );
        
        long jdkStart = System.currentTimeMillis();
        for (int i = 0; i < iterations; i++) {
            jdkProxy.getUser(i);
        }
        long jdkTime = System.currentTimeMillis() - jdkStart;
        
        // CGLIB代理测试
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserServiceImpl.class);
        enhancer.setCallback(new CglibProxyInterceptor());
        UserService cglibProxy = (UserService) enhancer.create();
        
        long cglibStart = System.currentTimeMillis();
        for (int i = 0; i < iterations; i++) {
            cglibProxy.getUser(i);
        }
        long cglibTime = System.currentTimeMillis() - cglibStart;
        
        System.out.println("JDK Proxy: " + jdkTime + "ms");
        System.out.println("CGLIB Proxy: " + cglibTime + "ms");
    }
}
```
**Spring中的选择策略：**
```java
// DefaultAopProxyFactory.java
public AopProxy createAopProxy(AdvisedSupport config) {
    if (config.isOptimize() || config.isProxyTargetClass() || 
        hasNoUserSuppliedProxyInterfaces(config)) {
        Class<?> targetClass = config.getTargetClass();
        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
            return new JdkDynamicAopProxy(config);
        }
        return new ObjenesisCglibAopProxy(config); // 使用CGLIB
    } else {
        return new JdkDynamicAopProxy(config); // 使用JDK代理
    }
}
```
**选择建议：**
- 目标对象实现了接口 → 优先选择JDK动态代理
- 目标对象未实现接口 → 必须使用CGLIB代理
- 追求最佳性能 → CGLIB代理（但注意final限制）
- 需要代理接口中的特定方法 → JDK动态代理
- Spring Boot 2.x开始默认使用CGLIB代理
###### 14. 如何实现响应式编程（WebFlux）?
Spring WebFlux是响应式编程在Web层面的实现，基于Reactor库和Netty运行时。
**核心依赖：**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
```
**响应式Repository：**
```java
@Repository
public interface UserRepository extends ReactiveCrudRepository<User, String> {
    Flux<User> findByAgeGreaterThan(int age); // 返回多个结果
    Mono<User> findByUsername(String username); // 返回单个结果
}
```
**响应式Service：**
```java
@Service
public class UserService {
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public Flux<User> getAllUsers() {
        return userRepository.findAll()
            .delayElements(Duration.ofMillis(100)) // 非阻塞延迟
            .doOnNext(user -> log.info("Processing user: {}", user));
    }
    
    public Mono<User> getUserById(String id) {
        return userRepository.findById(id)
            .switchIfEmpty(Mono.error(new UserNotFoundException(id)));
    }
    
    public Mono<User> createUser(User user) {
        return userRepository.save(user)
            .doOnSuccess(u -> log.info("Created user: {}", u));
    }
    
    public Flux<User> streamUsers() {
        return userRepository.findAll()
            .take(Duration.ofSeconds(10)) // 限制流时间
            .onBackpressureBuffer(1000); // 背压处理
    }
}
```
**响应式Controller：**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    // 传统响应式端点
    @GetMapping
    public Flux<User> getAllUsers() {
        return userService.getAllUsers();
    }
    
    @GetMapping("/{id}")
    public Mono<User> getUserById(@PathVariable String id) {
        return userService.getUserById(id);
    }
    
    @PostMapping
    public Mono<User> createUser(@RequestBody Mono<User> userMono) {
        return userService.createUser(userMono);
    }
    
    // Server-Sent Events (SSE) 流式端点
    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<User> streamUsers() {
        return userService.streamUsers();
    }
    
    // 函数式端点（RouterFunction）
    @Bean
    public RouterFunction<ServerResponse> userRoutes() {
        return route()
            .GET("/api/v2/users", this::getAllUsersHandler)
            .GET("/api/v2/users/{id}", this::getUserByIdHandler)
            .POST("/api/v2/users", this::createUserHandler)
            .build();
    }
    
    private Mono<ServerResponse> getAllUsersHandler(ServerRequest request) {
        return ServerResponse.ok()
            .contentType(MediaType.APPLICATION_JSON)
            .body(userService.getAllUsers(), User.class);
    }
}
```
**响应式WebClient：**
```java
@Service
public class ExternalServiceClient {
    private final WebClient webClient;
    
    public ExternalServiceClient(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder
            .baseUrl("https://api.external.com")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }
    
    public Mono<ExternalUser> fetchExternalUser(String userId) {
        return webClient.get()
            .uri("/users/{id}", userId)
            .retrieve()
            .onStatus(HttpStatus::isError, response -> 
                Mono.error(new ExternalServiceException("External API error"))
            )
            .bodyToMono(ExternalUser.class)
            .timeout(Duration.ofSeconds(5))
            .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)));
    }
    
    public Flux<ExternalUser> streamExternalUsers() {
        return webClient.get()
            .uri("/users/stream")
            .accept(MediaType.TEXT_EVENT_STREAM)
            .retrieve()
            .bodyToFlux(ExternalUser.class);
    }
}
```
**背压处理策略：**
```java
@Service
public class BackpressureService {
    
    public Flux<Integer> handleBackpressure() {
        return Flux.range(1, 1000000)
            .onBackpressureBuffer(1000) // 缓冲策略
            .onBackpressureDrop(dropped -> log.warn("Dropped: {}", dropped)) // 丢弃策略
            .onBackpressureLatest() // 最新值策略
            .concatMap(i -> processItem(i), 10); // 控制并发数
    }
    
    private Mono<String> processItem(Integer item) {
        return Mono.fromCallable(() -> "Processed: " + item)
            .subscribeOn(Schedulers.boundedElastic()); // 指定调度器
    }
}
```
###### 15. WebFlux 与传统 MVC 的区别是什么?
WebFlux和MVC代表了两种不同的编程范式，在架构、性能和适用场景上存在显著差异。
**架构对比：**

|特性|Spring MVC (阻塞式)|Spring WebFlux (非阻塞式)|
|---|---|---|
|编程模型|命令式、同步|响应式、异步|
|并发模型|每个请求一个线程（线程池）|事件循环（少量线程）|
|阻塞处理|支持阻塞I/O操作|完全非阻塞，避免线程等待|
|资源消耗|线程数量随请求增加而增加|固定数量线程处理大量请求|
|性能特点|低并发下响应快，高并发资源消耗大|高并发下资源利用更高效|
|适用场景|传统CRUD、计算密集型任务|I/O密集型、高并发、实时流处理|
**线程模型对比：**
1. **Spring MVC线程模型**：
```java
@RestController
public class TraditionalController {
    @GetMapping("/data")
    public String getData() {
        // 每个请求占用一个线程直到完成
        // 线程在数据库查询期间被阻塞
        String data = databaseService.queryData(); // 阻塞操作
        return processData(data);
    }
}
// 线程池配置
@Configuration
@EnableAsync
public class ThreadConfig {
    @Bean
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(20);
        executor.setMaxPoolSize(100);
        executor.setQueueCapacity(50);
        return executor;
    }
}
```
1. **WebFlux线程模型**：
```java
@RestController
public class ReactiveController {
    @GetMapping("/data")
    public Mono<String> getData() {
        // 请求线程立即返回，仅注册回调
        // 数据库查询完成后在事件循环线程处理
        return databaseService.reactiveQueryData() // 非阻塞操作
            .map(this::processData)
            .subscribeOn(Schedulers.boundedElastic()); // 指定执行上下文
    }
}
```
**错误处理对比：**
1. **MVC错误处理**：
```java
@ControllerAdvice
public class MvcExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception ex) {
        // 同步错误处理
        ErrorResponse error = new ErrorResponse("Error occurred", ex.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
```
1. **WebFlux错误处理**：
```java
@Component
public class WebFluxExceptionHandler extends AbstractErrorWebExceptionHandler {
    
    @Override
    protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {
        return RouterFunctions.route(RequestPredicates.all(), this::renderErrorResponse);
    }
    
    private Mono<ServerResponse> renderErrorResponse(ServerRequest request) {
        // 响应式错误处理
        return Mono.fromSupplier(() -> getErrorAttributes(request, ErrorAttributeOptions.defaults()))
            .flatMap(attributes -> ServerResponse.status(getHttpStatus(attributes))
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(attributes));
    }
}
```
**测试对比：**
1. **MVC测试**：
```java
@SpringBootTest
@AutoConfigureTestDatabase
class MvcControllerTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    void testGetData() {
        ResponseEntity<String> response = restTemplate.getForEntity("/data", String.class);
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).contains("expected data");
    }
}
```
1. **WebFlux测试**：
```java
@SpringBootTest
@AutoConfigureWebTestClient
class WebFluxControllerTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Test
    void testGetData() {
        webTestClient.get().uri("/data")
            .exchange()
            .expectStatus().isOk()
            .expectBody(String.class)
            .value(body -> assertThat(body).contains("expected data"));
    }
    
    @Test
    void testStreamData() {
        webTestClient.get().uri("/stream")
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.TEXT_EVENT_STREAM_VALUE)
            .returnResult(String.class)
            .getResponseBody()
            .take(3) // 取前3个元素
            .as(StepVerifier::create)
            .expectNext("data1", "data2", "data3")
            .verifyComplete();
    }
}
```
**选择建议：**
**选择Spring MVC当：**
- 团队熟悉命令式编程范式
- 应用主要是计算密集型任务
- 需要与大量阻塞式库集成
- 项目时间紧张，需要快速开发
**选择WebFlux当：**
- 需要处理大量并发连接（如实时通信）
- 应用主要是I/O密集型任务
- 需要实现实时数据流处理
- 团队有响应式编程经验
- 需要与响应式数据源（如MongoDB、Cassandra）集成
**混合使用策略：**
```java
@Configuration
public class HybridConfig {
    
    // MVC和WebFlux可以共存
    @RestController
    public class HybridController {
        
        // 传统阻塞端点
        @GetMapping("/blocking")
        public String blockingEndpoint() {
            return blockingService.getData();
        }
        
        // 响应式非阻塞端点
        @GetMapping("/reactive")
        public Mono<String> reactiveEndpoint() {
            return reactiveService.getData();
        }
    }
}
```