###### 1. Spring Boot Actuator 是什么?
Spring Boot Actuator 是 Spring Boot 提供的**生产级特性模块**，专门用于应用程序的监控和管理。它通过一组内置的 RESTful 端点（endpoints）暴露应用的内部状态信息，帮助开发者和运维人员实时了解应用的运行状况。
**核心价值**：
- **健康监控**：检查数据库、磁盘空间等关键组件的状态
- **指标收集**：采集 JVM 内存使用、GC 情况、HTTP 请求统计等运行时指标
- **操作控制**：支持动态修改日志级别、优雅关闭应用等管理操作
- **集成扩展**：通过 Micrometer 框架与 Prometheus、Grafana 等监控系统无缝集成
**源码级实现机制**：
Actuator 基于 Spring 的条件化配置和自动装配机制。在 `spring-boot-actuator-autoconfigure`包中，`EndpointAutoConfiguration`类负责端点的自动配置。每个端点都对应一个具体的 `Endpoint`实现类，例如 `HealthEndpoint`处理健康检查，`MetricsEndpoint`处理指标收集。
###### 2. Actuator 有哪些常用端点?
Actuator 提供了丰富的内置端点，以下是核心端点分类说明：

|**端点类别**​|**端点路径**​|**功能描述**​|**生产环境建议**​|
|---|---|---|---|
|**健康检查**​|`/actuator/health`|应用健康状态（数据库、磁盘等）|必须开放|
|**指标监控**​|`/actuator/metrics`|JVM 和系统性能指标|推荐开放|
|**环境信息**​|`/actuator/env`|环境变量和配置属性|受限访问|
|**Bean信息**​|`/actuator/beans`|Spring 容器中所有 Bean|调试时开放|
|**配置属性**​|`/actuator/configprops`|`@ConfigurationProperties`配置|调试时开放|
|**线程信息**​|`/actuator/threaddump`|线程堆栈快照|故障排查时开放|
|**映射关系**​|`/actuator/mappings`|URL 路径映射信息|调试时开放|
|**日志控制**​|`/actuator/loggers`|查看和动态修改日志级别|受限访问|
**配置示例**（application.yml）：
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,info,prometheus
      base-path: /monitor
  endpoint:
    health:
      show-details: always
      show-components: always
```
###### 3. 如何自定义健康检查指示器?
自定义健康检查通过实现 `HealthIndicator`接口或继承 `AbstractHealthIndicator`类实现。
**数据库连接健康检查示例**：
```java
@Component
public class DatabaseHealthIndicator extends AbstractHealthIndicator {
    
    private final DataSource dataSource;
    
    public DatabaseHealthIndicator(DataSource dataSource) {
        this.dataSource = dataSource;
    }
    
    @Override
    protected void doHealthCheck(Health.Builder builder) throws Exception {
        if (isDatabaseConnected()) {
            builder.up()
                   .withDetail("database", "MySQL")
                   .withDetail("validationQuery", "SELECT 1")
                   .withDetail("responseTime", checkResponseTime() + "ms");
        } else {
            builder.down()
                   .withDetail("error", "数据库连接失败")
                   .withException(new ConnectionException("无法建立数据库连接"));
        }
    }
    
    private boolean isDatabaseConnected() {
        try (Connection conn = dataSource.getConnection()) {
            return conn.isValid(5);
        } catch (SQLException e) {
            return false;
        }
    }
}
```
**第三方API健康检查**：
```java
@Component
public class ExternalApiHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        try {
            RestTemplate restTemplate = new RestTemplate();
            ResponseEntity<String> response = restTemplate.getForEntity(
                "https://api.external-service.com/health", String.class);
            
            if (response.getStatusCode().is2xxSuccessful()) {
                return Health.up()
                    .withDetail("service", "external-api")
                    .withDetail("status", response.getBody())
                    .build();
            } else {
                return Health.down()
                    .withDetail("service", "external-api")
                    .withDetail("status", response.getStatusCodeValue())
                    .build();
            }
        } catch (Exception e) {
            return Health.outOfService()
                .withDetail("service", "external-api")
                .withException(e)
                .build();
        }
    }
}
```
**健康状态聚合原理**：
Spring Boot 通过 `HealthAggregator`聚合多个健康指示器的结果。默认实现 `SimpleStatusAggregator`按照严重程度排序（DOWN > OUT_OF_SERVICE > UP > UNKNOWN），返回最严重的状态。
###### 4. 如何集成 Prometheus 和 Grafana?
**Prometheus 集成步骤**：
1. **添加依赖**：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```
2. **配置暴露端点**：
```yaml
management:
  endpoints:
    web:
      exposure:
        include: prometheus,health,metrics
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
      environment: ${spring.profiles.active}
```
3. **Prometheus 配置**（prometheus.yml）：
 ```yaml
scrape_configs:
  - job_name: 'spring-boot-app'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['localhost:8080']
    scrape_interval: 15s
    metrics_path: /actuator/prometheus
 ```
**Grafana 仪表板配置**：
1. **添加 Prometheus 数据源**
2. **导入 Spring Boot 监控仪表板**（ID: 6756）
3. **关键监控指标**：
    - `jvm_memory_used_bytes`：JVM 内存使用
    - `jvm_gc_pause_seconds`：GC 停顿时间
    - `http_server_requests_seconds`：HTTP 请求延迟
    - `tomcat_threads_busy_threads`：Tomcat 繁忙线程数
**自定义业务指标**：
```java
@Service
public class OrderMetricsService {
    
    private final Counter orderCounter;
    private final Timer orderProcessingTimer;
    
    public OrderMetricsService(MeterRegistry registry) {
        orderCounter = Counter.builder("orders.total")
            .description("Total number of orders")
            .tag("type", "online")
            .register(registry);
            
        orderProcessingTimer = Timer.builder("orders.processing.time")
            .description("Order processing time")
            .register(registry);
    }
    
    public void recordOrder(Order order) {
        orderCounter.increment();
        Timer.Sample sample = Timer.start();
        
        // 处理订单逻辑
        processOrder(order);
        
        sample.stop(orderProcessingTimer);
    }
}
```
###### 5. 如何实现应用性能监控（APM）?
**Spring Boot 与 Micrometer 集成**：
Micrometer 为 Java 应用提供指标收集的通用 API，支持多种监控系统。
**关键性能指标收集**：
```java
@Configuration
public class MetricsConfig {
    
    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config().commonTags(
            "application", "user-service",
            "region", "us-east-1",
            "instance", InetAddress.getLocalHost().getHostName()
        );
    }
    
    @Bean
    public TimedAspect timedAspect(MeterRegistry registry) {
        return new TimedAspect(registry);
    }
}
```
**方法级性能监控**：
```java
@Service
public class UserService {
    
    @Timed(value = "user.service.find.by.id", description = "根据ID查询用户时间")
    @Counted(value = "user.service.find.by.id.count", description = "根据ID查询用户次数")
    public User findUserById(Long id) {
        return userRepository.findById(id);
    }
    
    @Timed(value = "user.service.search", description = "用户搜索时间")
    @Counted(value = "user.service.search.count", description = "用户搜索次数")
    public List<User> searchUsers(String keyword) {
        return userRepository.findByUsernameContaining(keyword);
    }
}
```
**分布式追踪集成**（Spring Cloud Sleuth）：
```yaml
spring:
  sleuth:
    sampler:
      probability: 1.0
    zipkin:
      base-url: http://zipkin-server:9411
```
###### 6. 如何实现日志管理（Logback/Log4j2）?
**Logback 配置优化**：
```xml
<configuration>
    <property name="LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"/>
    
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application.%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>
            <maxHistory>30</maxHistory>
            <maxFileSize>100MB</maxFileSize>
        </rollingPolicy>
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="FILE"/>
    </root>
</configuration>
```
**Log4j2 异步日志配置**：
```xml
<Configuration status="WARN">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </Console>
        
        <Async name="Async" bufferSize="1024">
            <AppenderRef ref="Console"/>
        </Async>
    </Appenders>
    
    <Loggers>
        <Logger name="com.example" level="DEBUG" additivity="false">
            <AppenderRef ref="Async"/>
        </Logger>
    </Loggers>
</Configuration>
```
###### 7. 如何实现日志分级输出?
**Actuator 动态日志级别管理**：
通过 `/actuator/loggers`端点可以动态调整日志级别。
**API 调用示例**：
```bash
# 查看当前日志级别
curl http://localhost:8080/actuator/loggers/com.example.service

# 动态修改为 DEBUG 级别
curl -X POST -H "Content-Type: application/json" \
-d '{"configuredLevel": "DEBUG"}' \
http://localhost:8080/actuator/loggers/com.example.service
```
**编程式日志级别控制**：
```java
@Service
public class LogLevelService {
    
    private final LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
    
    public void setLogLevel(String packageName, Level level) {
        loggerContext.getLogger(packageName).setLevel(level);
    }
    
    public Map<String, String> getLogLevels() {
        return loggerContext.getLoggerList().stream()
            .collect(Collectors.toMap(
                Logger::getName,
                logger -> Optional.ofNullable(logger.getLevel())
                                .map(Level::toString)
                                .orElse("INHERITED")
            ));
    }
}
```
**条件化日志配置**：
```yaml
logging:
  level:
    com.example.service: INFO
    org.springframework.web: DEBUG
    org.hibernate.SQL: WARN
  group:
    business: com.example.service,com.example.repository
    technical: org.springframework,org.hibernate
```
###### 8. 如何实现日志集中收集（ELK）?
**Logstash 配置**：
```ruby
input {
    tcp {
        port => 5000
        codec => json_lines
    }
}

filter {
    grok {
        match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:loglevel} %{GREEDYDATA:message}" }
    }
    
    date {
        match => [ "timestamp", "ISO8601" ]
    }
}

output {
    elasticsearch {
        hosts => ["elasticsearch:9200"]
        index => "spring-boot-logs-%{+YYYY.MM.dd}"
    }
}
```
**Spring Boot 与 Logstash 集成**：
```xml
<dependency>
    <groupId>net.logstash.logback</groupId>
    <artifactId>logstash-logback-encoder</artifactId>
    <version>6.6</version>
</dependency>
```
**Logback 配置**：
```xml
<appender name="LOGSTASH" class="net.logstash.logback.appender.LogstashTcpSocketAppender">
    <destination>logstash:5000</destination>
    <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
        <providers>
            <timestamp/>
            <logLevel/>
            <loggerName/>
            <threadName/>
            <mdc/>
            <message/>
            <stackTrace/>
        </providers>
    </encoder>
</appender>
```
###### 9. 如何实现应用优雅关闭?
**Actuator Shutdown 端点配置**：
```yaml
management:
  endpoint:
    shutdown:
      enabled: true
  endpoints:
    web:
      exposure:
        include: shutdown
```
**优雅关闭配置**：
```yaml
server:
  shutdown: graceful  # Spring Boot 2.3+ 支持
  
spring:
  lifecycle:
    timeout-per-shutdown-phase: 30s
```
**自定义关闭钩子**：
```java
@Component
public class GracefulShutdown implements ApplicationListener<ContextClosedEvent> {
    
    private final ThreadPoolTaskExecutor taskExecutor;
    private final DataSource dataSource;
    
    @Override
    public void onApplicationEvent(ContextClosedEvent event) {
        // 1. 停止接收新请求
        stopAcceptingNewRequests();
        
        // 2. 等待进行中的请求完成
        awaitOngoingRequestsCompletion(30);
        
        // 3. 关闭线程池
        taskExecutor.shutdown();
        
        // 4. 关闭数据库连接池
        closeDataSource();
        
        // 5. 其他资源清理
        cleanupResources();
    }
    
    private void awaitOngoingRequestsCompletion(int timeoutSeconds) {
        try {
            if (!taskExecutor.getThreadPoolExecutor().awaitTermination(timeoutSeconds, TimeUnit.SECONDS)) {
                // 强制关闭
                taskExecutor.getThreadPoolExecutor().shutdownNow();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```
###### 10. 如何实现应用健康检查与自动重启?
**Kubernetes 健康检查配置**：
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  template:
    spec:
      containers:
      - name: user-service
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 10
          failureThreshold: 3
          
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 5
          successThreshold: 1
```
**自定义就绪性检查**：
```java
@Component
public class DatabaseReadinessHealthIndicator implements HealthIndicator {
    
    private final DataSource dataSource;
    private volatile boolean ready = false;
    
    @EventListener(ApplicationReadyEvent.class)
    public void setReady() {
        this.ready = true;
    }
    
    @Override
    public Health health() {
        if (!ready) {
            return Health.outOfService()
                .withDetail("reason", "应用启动中")
                .build();
        }
        
        try (Connection conn = dataSource.getConnection()) {
            if (conn.isValid(5)) {
                return Health.up().build();
            } else {
                return Health.down().withDetail("error", "数据库连接无效").build();
            }
        } catch (SQLException e) {
            return Health.down(e).build();
        }
    }
}
```
**Spring Boot 2.3+ 就绪性状态管理**：
```java
@Component
public class ReadinessStateChecker {
    
    private final ApplicationEventPublisher eventPublisher;
    
    public void setReady() {
        AvailabilityChangeEvent.publish(eventPublisher, this, ReadinessState.ACCEPTING_TRAFFIC);
    }
    
    public void setUnready() {
        AvailabilityChangeEvent.publish(eventPublisher, this, ReadinessState.REFUSING_TRAFFIC);
    }
}
```