###### 1. 如何设计一个高可用的微服务架构?
高可用微服务架构需要从多维度构建容错能力。以下是核心设计要点：
**服务治理与容错**
- **服务注册发现**：采用Eureka/Consul等注册中心，客户端缓存服务列表避免注册中心单点故障。Eureka的Peer-to-Peer复制模式支持跨机房同步，通过`@EnableEurekaServer`配置自我保存机制。
- **熔断降级**：Hystrix/Ressilience4j实现断路器模式。源码中`HystrixCommand`封装调用逻辑，当错误率超过阈值（默认50%）进入OPEN状态，直接执行`getFallback()`方法。
- **负载均衡**：Ribbon通过`IRule`接口支持轮询/权重策略，结合`ServerListRefreshThread`动态更新健康实例。
**数据高可用**
```java
// 分布式事务Saga模式示例
@Saga
public class OrderSaga {
    @StartSaga
    @Compensating
    public void createOrder(Order order) {
        // 1. 冻结库存
        // 2. 扣减账户
        // 3. 失败时触发补偿事务[2](@ref)
    }
}
```
- **数据库分片**：ShardingSphere通过`HintManager`实现单元化路由，按用户ID分片确保数据局部性。
- **缓存策略**：Redis集群采用CRC16分片，通过`CLUSTER FAILOVER`实现故障转移。设置`stale-if-error`参数支持故障时返回旧数据。
**架构层高可用**
- **异地多活**：单元化部署下，通过GSLB实现流量调度。ZK集群跨机房部署Observer节点降低延迟。
- **监控体系**：APM工具捕获B3传播的TraceID，`Brave`组件在MDC中记录调用链，结合Metrics暴露`/actuator/prometheus`端点。
###### 2. 如何实现秒杀系统?
秒杀系统核心在于**削峰填谷**和**库存精准控制**。
**流量削峰**
- **静态化分离**：将商品详情页缓存在CDN，通过`Nginx proxy_cache`设置`stale-while-revalidate`减少回源。
- **队列缓冲**：RocketMQ接收秒杀请求，`DefaultMQPushConsumer`顺序消费。队列深度监控触发`VelocityLimiter`限流。
- **验证机制**：前置图形验证码，通过`Kaptcha`组件生成，提交时验证`nonce`防重。
 **库存扣减**
```java
// Redis Lua原子扣减脚本
String script = 
  "if redis.call('exists', KEYS[1]) == 1 then " +
  "local stock = tonumber(redis.call('get', KEYS[1])); " +
  "if stock > 0 then " +
  "redis.call('decr', KEYS[1]); " +
  "return 1; end; end; return 0;";
Long result = redisTemplate.execute(
  new DefaultRedisScript<>(script, Long.class),
  Arrays.asList("sec_kill:" + productId));
```
- **防超卖**：MySQL更新时使用`update stock set count=count-1 where id=? and count>0`，通过`@Version`乐观锁控制并发。
**系统保护**
- **分层校验**：网关层`SentinelFilter`实现QPS限流，业务层通过`RateLimiter.create(1000)`控制并发。
- **弹性扩容**：Kubernetes配置`HPA`基于CPU指标自动扩缩，`kubectl scale deployment seckill --replicas=10`即时扩容。
###### 3. 如何实现分布式任务调度?
分布式任务调度需解决**触发一致性**和**执行可靠性**问题。
**调度中心**
- **时间轮算法**：`HashedWheelTimer`实现精准触发，任务放入`TimerTaskList`避免频繁GC。
- **分片策略**：`ElasticJob`通过`JobShardingStrategy`按IP哈希分片，支持故障节点分片转移。
**执行器设计**
```java
// XXL-Job执行器示例
@XxlJob("orderTimeoutJob")
public ReturnT<String> orderTimeout(String param) {
    // 1. 获取分片参数
    int shardIndex = XxlJobHelper.getShardIndex();
    // 2. 查询超时订单
    // 3. 更新状态
    return ReturnT.SUCCESS;
}
```
- **幂等控制**：通过`UPDATE task SET status='processing' WHERE id=? AND status='pending'`确保唯一执行。
 **容错机制**
- **故障转移**：Quartz的`JobStore`持久化触发记录，备用调度器通过`SELECT FOR UPDATE`获取锁。
- **监控告警**：通过`Micrometer`统计`task.execute.counter`，异常时推送告警到钉钉。
###### 4. 如何实现电商订单系统?
订单系统核心是**状态机**和**数据一致性**。
**订单状态流转**
```java
// 状态机引擎
public enum OrderState {
    PENDING {
        @Override
        public void pay(Order order) {
            // 校验库存
            order.setState(PAID);
        }
    },
    PAID {
        @Override
        public void deliver(Order order) {
            // 生成发货单
            order.setState(DELIVERED);
        }
    }// 更多状态[5](@ref)
}
```
- **逆向流程**：退货单独立生成，通过`OrderReverseService`处理退款逻辑。
**数据分片**
- **分库分表**：按用户ID分片，`userId % 64`映射到具体表。历史订单归档到ClickHouse。
- **读写分离**：`AbstractRoutingDataSource`实现动态数据源，写库同步到读库延迟监控。
**性能优化**
- **异步处理**：订单支付成功后，通过`@Async`异步发送积分。
- **缓存策略**：订单查询走Redis，设置`@Cacheable(key = "'order:'+#id")`，库存缓存防止超卖。
###### 5. 如何实现支付系统集成?
支付系统重点在**渠道路由**和**资金安全**。
**支付网关**
- **渠道路由**：`PaymentChannelRouter`根据银行列表权重选择最优渠道，支持`CircuitBreaker`熔断不可用渠道。
- **签名验证**：`RSAWithSHA256`生成签名，通过`Security.addProvider(new BouncyCastleProvider())`加载证书。
 **事务管理**
```java
// TCC事务示例
@Compensable(confirmMethod = "confirm", cancelMethod = "cancel")
public void tryDeduct(Account account, BigDecimal amount) {
    // 冻结资金
    accountService.freeze(account, amount);
}
public void confirmDeduct(Account account, BigDecimal amount) {
    // 实际扣款
    accountService.deduct(account, amount);
}
```
- **对账系统**：每日定时下载渠道账单，通过`AlibabaEasyExcel`解析并与系统订单比对。
**风控系统**
- **规则引擎**：Drools规则检测异常行为，如单小时交易频次超限。
- **数据加密**：持卡人信息通过`AES/GCM/NoPadding`加密，密钥存储于HSM。
###### 6. 如何实现短信验证码功能?
短信验证码需关注**防攻击**和**可靠性**。
**安全防护**
- **频率控制**：`RedisTemplate.opsForValue().setIfAbsent(phone, "1", 1, TimeUnit.MINUTES)`防止频繁发送。
- **漏洞防护**：图形验证码校验后方可发送短信，避免接口被恶意调用。
 **服务集成**
```java
// 短信服务抽象
@Service
public class SmsService {
    @Autowired
    private SmsProviderRouter router;
    
    public void sendCode(String phone, String code) {
        // 1. 校验频率
        // 2. 轮询选择供应商
        // 3. 异步发送
        CompletableFuture.runAsync(() -> router.send(phone, code));
    }
}
```
- **降级策略**：主流供应商不可用时自动切换备用渠道，支持语音验证码降级。
###### 7. 如何实现邮件发送功能?
邮件系统需处理**模板化**和**批量发送**。
**模板引擎**
- **Thymeleaf集成**：`TemplateEngine.process("welcome.html", context)`生成个性化内容，支持国际化。
- **附件处理**：`MimeMessageHelper.addAttachment()`添加附件，大文件采用`FileSystemResource`避免内存溢出。
 **发送队列**
```java
// 邮件队列消费者
@JmsListener(destination = "mail.queue")
public void sendMail(MailMessage message) {
    try {
        javaMailSender.send(mimeMessage -> {
            // 设置收件人/主题/内容
        });
    } catch (MailException e) {
        // 重试逻辑
        message.retry();
        jmsTemplate.convertAndSend("mail.retry.queue", message);
    }
}
```
- **退避策略**：失败邮件采用`ExponentialBackOff`重试，间隔时间递增。
###### 8. 如何实现文件存储（本地/OSS）?
文件存储需统一**抽象接口**并支持**多云策略**。
**存储抽象**
```java
public interface FileService {
    String upload(File file, String key);
    InputStream download(String key);
}

@Service
@Profile("local")
public class LocalFileService implements FileService {
    @Value("${file.upload.path}")
    private String path;
    
    @Override
    public String upload(File file, String key) {
        Path target = Paths.get(path, key);
        Files.copy(file.toPath(), target, StandardCopyOption.REPLACE_EXISTING);
        return target.toString();
    }
}

@Service
@Profile("prod")
public class OssFileService implements FileService {
    @Autowired
    private OSS ossClient;
    
    @Override
    public String upload(File file, String key) {
        ossClient.putObject("my-bucket", key, file);
        return ossClient.generatePresignedUrl(//生成链接).toString();
    }
}
```
- **权限控制**：OSS通过`Policy`设置临时访问令牌，支持精细化的权限管理。
**性能优化**
- **分块上传**：大文件采用`TransferManager.uploadFile()`分块上传，支持断点续传。
- **CDN加速**：静态文件上传后触发CDN刷新，通过`URLConnection`预拉取热点资源。
###### 9. 如何实现数据导入导出（Excel/CSV）?
数据导入导出需解决**内存溢出**和**格式兼容**问题。
**流式处理**
```java
// EasyExcel流式读取
public class ExcelListener extends AnalysisEventListener<User> {
    @Override
    public void invoke(User data, AnalysisContext context) {
        // 分批处理
        if (list.size() >= 1000) {
            userService.batchInsert(list);
            list.clear();
        }
    }
}

// 导出示例
public void export(HttpServletResponse response) {
    response.setContentType("application/vnd.ms-excel");
    try (ServletOutputStream out = response.getOutputStream()) {
        ExcelWriter writer = EasyExcel.write(out).build();
        WriteSheet sheet = EasyExcel.writerSheet(0, "数据").head(User.class).build();
        writer.write(dataList, sheet);
        writer.finish();
    }
}
```
- **内存映射**：`FileChannel.map()`实现零拷贝读取，避免大文件加载OOM。
 **校验机制**
- **数据验证**：Apache BeanValidation校验字段格式，`@Pattern(regexp="^1\\d{10}$")`验证手机号。
- **异常处理**：`BindingResult`捕获解析错误，记录失败行号便于重新导入。
###### 10. 如何实现全文搜索功能?
全文搜索核心是**倒排索引**和**相关性计算**。
**索引设计**
```java
// Elasticsearch数据模型
@Document(indexName = "products")
public class Product {
    @Id
    private String id;
    
    @Field(type = FieldType.Text, analyzer = "ik_max_word")
    private String name;
    
    @Field(type = FieldType.Keyword)
    private String category;
}

// 搜索服务
@Service
public class ProductSearchService {
    @Autowired
    private ElasticsearchRestTemplate template;
    
    public List<Product> search(String keyword) {
        NativeSearchQuery query = new NativeSearchQueryBuilder()
            .withQuery(QueryBuilders.matchQuery("name", keyword))
            .withHighlightFields(new HighlightBuilder.Field("name"))
            .build();
        return template.search(query, Product.class).getContent();
    }
}
```
- **分词策略**：IK Analyzer配置自定义词典，支持同义词扩展。
 **性能优化**
- **索引预热**：冷数据索引通过`_forcemerge`合并段文件，提升查询速度。
- **缓存机制**：`Filter`查询结果缓存，利用`bitset`快速交集计算。