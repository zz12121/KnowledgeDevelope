###### 1. 什么是分布式事务？
分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于**不同的分布式系统的不同节点之上**，且属于不同的应用，需要保证这些操作要么全部成功，要么全部失败。
**核心特征**：与传统本地事务相比，分布式事务的核心挑战在于需要**跨网络、跨进程、跨数据库**保证ACID特性。在分布式系统中，数据和服务被拆分到不同的节点上，传统的单机事务机制已无法满足需求。
**技术本质**：分布式事务通过特定的协议和算法，协调多个独立资源管理器（如数据库、消息队列等）的行为，确保在分布式环境下仍然能够维持数据的一致性状态。
###### 2. 为什么需要分布式事务？
随着微服务架构和分布式系统的普及，单一数据库已无法满足业务需求，主要驱动因素包括：
**业务场景需求**：
- **跨库操作**：如银行转账涉及两个不同数据库的账户更新
- **微服务调用**：电商下单需要订单服务、库存服务、支付服务协同工作
- **数据分片**：大数据量下的分库分表，同一业务可能涉及多个分片
**架构演进需求**：
- **系统解耦**：服务拆分后需要保证跨服务数据一致性
- **性能扩展**：单一数据库成为瓶颈，需要水平扩展
- **技术异构**：不同服务可能使用不同的数据库技术
###### 3. CAP 理论是什么？
CAP理论是分布式系统设计的**基础理论**，由Eric Brewer提出，指出在分布式系统中，**一致性(Consistency)、可用性(Availability)、分区容错性(Partition Tolerance)**​ 三个特性不可兼得。
核心内容**：
- **一致性(C)**：所有节点在同一时间的数据完全一致
- **可用性(A)**：每个请求都能得到响应，不会出现错误或超时
- **分区容错性(P)**：系统在遇到网络分区时仍能继续运作
**实践意义**：由于网络分区不可避免，实际只能在C和A之间权衡。CP系统保证强一致性（如ZooKeeper），AP系统保证高可用性（如Eureka）。
###### 4. BASE 理论是什么？
BASE理论是对CAP理论中AP方向的扩展，强调**最终一致性**而非强一致性。
**核心概念**：
- **Basically Available（基本可用）**：系统出现故障时，允许损失部分可用性
- **Soft state（软状态）**：允许系统存在中间状态，且该状态不会影响系统整体可用性
- **Eventually consistent（最终一致性）**：经过一段时间后，系统最终能够达到一致状态
**与ACID对比**：ACID强调强一致性，BASE强调高可用性，适用于对一致性要求不高的互联网场景。
###### 5. 分布式事务的解决方案有哪些？
分布式事务解决方案可分为**强一致性**和**最终一致性**两大类：
**强一致性方案**：
- **两阶段提交(2PC)**：基于XA协议的标准解决方案
- **三阶段提交(3PC)**：2PC的改进版，减少阻塞时间
- **Seata XA模式**：基于数据库XA协议的实现
**最终一致性方案**：
- **TCC模式**：通过Try-Confirm-Cancel业务逻辑实现
- **Saga模式**：通过长事务拆分和补偿机制实现
- **本地消息表**：基于消息队列的最终一致性方案
- **最大努力通知**：适合对一致性要求不高的场景
###### 6. 什么是两阶段提交（2PC）？
2PC是分布式事务的**经典协议**，通过两个阶段协调多个资源管理器的事务操作。
**阶段一：准备阶段**
```java
// 协调者向所有参与者发送prepare请求
public boolean prepare() {
    for (Participant participant : participants) {
        if (!participant.canCommit()) {
            return false; // 有任何参与者准备失败则中止事务
        }
    }
    return true;
}
```
**阶段二：提交阶段**
```java
// 根据准备阶段结果决定提交或回滚
public void commitOrRollback(boolean allPrepared) {
    if (allPrepared) {
        for (Participant participant : participants) {
            participant.commit(); // 全部准备成功则提交
        }
    } else {
        for (Participant participant : participants) {
            participant.rollback(); // 任何失败则回滚
        }
    }
}
```
**优缺点**：
- **优点**：强一致性保证，对业务侵入小
- **缺点**：同步阻塞、单点故障、数据不一致风险
###### 7. 什么是三阶段提交（3PC）？
3PC是2PC的改进版，通过**引入超时机制和预提交阶段**减少阻塞问题。
**三个阶段**：
1. **CanCommit**：询问参与者是否具备执行条件
2. **PreCommit**：预提交，执行事务操作但不提交
3. **DoCommit**：正式提交或回滚
**改进点**：
- **减少阻塞**：参与者超时后自动提交，避免长时间阻塞
- **增强容错**：协调者故障时参与者能自动处理
**局限性**：实现复杂，网络分区时仍可能数据不一致。
###### 8. 什么是 TCC？
TCC是一种**业务层分布式事务解决方案**，通过Try-Confirm-Cancel三个阶段实现最终一致性。
**三个阶段**：
- **Try**：资源检查和预留，如冻结账户金额
- **Confirm**：确认执行，使用预留资源完成业务操作
- **Cancel**：补偿回滚，释放预留资源
**代码实现**：
```java
public class TccTransferService {
    // Try阶段：资源预留
    public boolean tryTransfer(String from, String to, BigDecimal amount) {
        // 检查账户余额并冻结转账金额
        accountService.freezeAmount(from, amount);
        // 创建待确认交易记录
        transactionService.prepareTransaction(from, to, amount);
        return true;
    }
    
    // Confirm阶段：确认执行
    public boolean confirmTransfer() {
        // 扣除冻结金额
        accountService.debitFrozenAmount();
        // 确认交易记录
        transactionService.confirm();
        return true;
    }
    
    // Cancel阶段：补偿回滚
    public boolean cancelTransfer() {
        // 解冻金额
        accountService.unfreezeAmount();
        // 取消交易记录
        transactionService.cancel();
        return true;
    }
}
```
**适用场景**：对一致性要求较高且能接受一定复杂性的业务场景。
###### 9. 什么是 Saga？
Saga模式适用于**长事务场景**，将分布式事务拆分为一系列本地事务，每个事务都有对应的补偿操作。
**实现方式**：
- **编排式(Choreography)**：通过事件驱动，无中心协调器
- **编导式(Orchestration)**：由Saga协调器集中控制流程
**补偿机制**：
```java
public class OrderSaga {
    // 正向操作
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        inventoryClient.reduceStock(order.getProductId(), order.getQuantity());
        paymentClient.createPayment(order.getId(), order.getAmount());
    }
    
    // 补偿操作
    @Transactional
    public void compensateOrder(Long orderId) {
        paymentClient.cancelPayment(orderId);
        inventoryClient.compensateStock(order.getProductId(), order.getQuantity());
        orderRepository.updateStatus(orderId, "CANCELLED");
    }
}
```
**优缺点**：
- **优点**：避免长时间资源锁定，适合长事务
- **缺点**：补偿操作实现复杂，难以保证原子性
###### 10. 什么是本地消息表？
本地消息表是**基于消息队列的最终一致性方案**，将业务操作和消息发送放在同一个本地事务中。
**实现原理**：
1. **事务发起方**在本地事务中执行业务操作并记录消息表
2. **定时任务**扫描消息表，将未发送的消息投递到消息队列
3. **消息消费者**处理消息并确保业务操作执行
4. **幂等性保证**：消费者通过去重表避免重复处理
**源码示例**：
```java
@Service
public class LocalMessageService {
    @Transactional
    public void processWithMessage(BusinessRequest request) {
        // 1. 执行业务操作
        businessService.process(request);
        
        // 2. 在同一事务中记录消息
        messageRepository.save(new Message(request.getId(), "ORDER_CREATED"));
    }
    
    @Scheduled(fixedRate = 5000)
    public void sendMessages() {
        // 3. 定时发送未处理的消息
        List<Message> pendingMessages = messageRepository.findPendingMessages();
        for (Message message : pendingMessages) {
            messageQueue.send(message);
            messageRepository.updateStatus(message.getId(), "SENT");
        }
    }
}
```
###### 11. 什么是 Seata？
Seata是阿里巴巴开源的**一站式分布式事务解决方案**，支持AT、TCC、Saga、XA等多种模式。
**设计目标**：
- **业务无侵入**：AT模式无需业务改造
- **高性能**：基于全局锁优化，减少性能损耗
- **高可用**：支持集群部署，故障自动切换
- **多语言**：支持Java、Go、Python等多种语言
**核心价值**：提供了简单易用的API，降低了分布式事务的实现门槛。
###### 12. Seata 的事务模式有哪些（AT、TCC、Saga、XA）？
Seata支持四种主要的事务模式，适应不同业务场景：
**AT模式（Auto Transaction）**：
- **原理**：基于SQL解析自动生成回滚日志
- **优点**：对业务代码零侵入，使用简单
- **缺点**：需要全局锁，性能有一定影响
**TCC模式**：
- **原理**：通过Try、Confirm、Cancel业务逻辑实现
- **优点**：性能较好，无全局锁
- **缺点**：业务侵入性强，需要实现三个接口
**Saga模式**：
- **原理**：长事务拆分，通过状态机驱动
- **优点**：适合业务流程长的场景
- **缺点**：需要实现补偿操作
**XA模式**：
- **原理**：基于数据库XA协议
- **优点**：强一致性保证
- **缺点**：资源锁定时间长，性能较差
###### 13. Seata 的工作原理是什么？
Seata通过**全局事务ID和分支事务协调**实现分布式事务管理。
**事务流程**：
1. **TM开启全局事务**：生成全局唯一的XID
2. **RM注册分支事务**：业务方法执行时向TC注册分支
3. **TC协调事务状态**：根据各分支执行结果决定提交或回滚
4. **生成反向SQL**：AT模式下自动生成回滚日志
**源码核心**：
```java
// 全局事务拦截器
public class GlobalTransactionalInterceptor implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // 1. 获取或创建全局事务
        GlobalTransaction tx = GlobalTransactionContext.getCurrentOrCreate();
        
        try {
            // 2. 开启全局事务
            tx.begin(timeout, name);
            
            // 3. 执行业务方法
            Object result = invocation.proceed();
            
            // 4. 提交事务
            tx.commit();
            return result;
        } catch (Exception e) {
            // 5. 回滚事务
            tx.rollback();
            throw e;
        }
    }
}
```
###### 14. Seata 的三大角色是什么（TC、TM、RM）？
Seata架构包含三个核心组件，各司其职：
**Transaction Coordinator（TC）**：
- **职责**：事务协调器，维护全局事务和分支事务的状态
- **部署**：独立服务，支持集群部署确保高可用
- **功能**：驱动全局事务的提交或回滚
**Transaction Manager（TM）**：
- **职责**：事务管理器，定义全局事务边界
- **位置**：集成在业务应用中
- **功能**：开启、提交或回滚全局事务
**Resource Manager（RM）**：
- **职责**：资源管理器，管理分支事务处理的资源
- **位置**：集成在业务应用中
- **功能**：向TC注册分支事务，报告分支状态
###### 15. 如何选择合适的分布式事务解决方案？
选择分布式事务方案需综合考虑**业务场景、一致性要求、性能需求**等因素：
**强一致性场景**：
- **金融核心交易**：XA模式或TCC模式
- **资金结算**：2PC或Seata XA模式
- **要求**：数据必须强一致，可接受性能损失
**最终一致性场景**：
- **电商订单**：Saga模式或本地消息表
- **库存管理**：TCC模式或最大努力通知
- **要求**：允许短暂不一致，追求系统可用性
**长业务流程**：
- **保险理赔**：Saga模式
- **工作流审批**：基于状态机的Saga
- **要求**：避免长时间资源锁定
**高性能要求**：
- **秒杀活动**：本地消息表+异步处理
- **实时交易**：TCC模式
- **要求**：低延迟，高吞吐量
**技术选型矩阵**：

|**方案**​|**一致性**​|**性能**​|**复杂度**​|**适用场景**​|
|---|---|---|---|---|
|**2PC/XA**​|强一致|低|低|传统银行、金融核心|
|**TCC**​|最终一致|高|高|电商、互联网金融|
|**Saga**​|最终一致|中|中|长业务流程、微服务|
|**本地消息表**​|最终一致|高|中|异步消息场景