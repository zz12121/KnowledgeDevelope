###### 1. 微服务架构中的安全问题有哪些？
微服务架构在带来敏捷性、可扩展性等优势的同时，也引入了传统单体应用所不具备的复杂安全挑战。这些安全问题可归结为三大核心风险和多个攻击面 。
**三大核心风险：**
- **数据泄露风险**：这是微服务架构下最显著的风险。由于服务被拆解，内部API数量激增，**攻击面显著扩大**。风险主要来源于：（1）应用自身的API漏洞；（2）**密钥管理不规范**，如将密钥硬编码在代码中；（3）服务间通信**未加密或加密强度不足**，导致传输中的数据被窃取 。
- **未授权访问风险**：微服务的动态性和数量之多使得权限配置变得极其复杂。风险源于：（1）服务本身存在的未授权访问漏洞；（2）**访问权限配置错误**，在复杂的服务映射关系中，一个服务的权限配置错误可能被攻击者利用，从而横向渗透整个系统 。
- **拒绝服务（DoS）风险**：攻击者可以利用（1）应用漏洞（如ReDoS正则表达式拒绝服务）或（2）通过CC攻击等方式，使某个关键服务的资源（CPU、内存、网络）耗尽，从而导致系统级联故障，整个应用不可用 。
**主要攻击面与防护思路：**
为了更清晰地理解，下表总结了微服务架构的主要攻击面及对应的防护策略核心 。

|攻击面|安全风险|核心防护策略|
|---|---|---|
|**API网关**​|南北向流量入口，易受DDoS、注入攻击|**WAF（Web应用防火墙）、限流、认证**​|
|**服务间通信**​|东西向流量被窃听、篡改，中间人攻击|**mTLS（双向TLS）加密、服务身份认证**​|
|**服务网格**​|复杂的路由和策略配置错误导致安全漏洞|**Istio/Linkerd 授权策略，零信任网络**​|
|**配置中心**​|敏感配置信息（如密钥）泄露|**配置加密、最小权限访问控制**​|
|**认证授权服务**​|身份令牌被伪造，权限提升|**JWT签名验证、OAuth 2.0 安全流程**|
###### 2. 什么是 OAuth 2.0？
OAuth 2.0 是一个**行业标准的授权协议（RFC 6749）**，其核心目标是**解决第三方应用在不需要获取用户密码的情况下，获得对用户资源的有限访问权限的问题**​ 。
简单来说，它解决了“**授权**”问题。例如，你允许一个微信扫码登录的网站获取你的微信头像和昵称，但决不允许它知道你的微信密码。OAuth 2.0 通过引入一个**授权层（Authorization Layer）**​ 和**访问令牌（Access Token）**​ 来实现这一机制 。
核心角色包括：**
- **资源所有者 (Resource Owner)**：通常是终端用户。
- **客户端 (Client)**：希望访问用户资源的第三方应用。
- **授权服务器 (Authorization Server)**：验证用户身份并颁发令牌的服务器（例如微信的OAuth服务器）。
- **资源服务器 (Resource Server)**：存放用户资源的服务器（例如存放微信头像的服务器）。
###### 3. OAuth 2.0 的授权模式有哪些？
OAuth 2.0 提供了多种授权模式（或称流程）以适应不同的应用场景 。
1. **授权码模式 (Authorization Code Grant)**：这是**最常用、最安全**的模式，适用于有后端的Web应用。流程分为两步：先通过前端频道获取一个授权码，再通过安全的后端频道用授权码换取Access Token。这避免了令牌暴露给前端浏览器。
2. **隐式模式 (Implicit Grant)**：适用于纯前端应用（如单页应用SPA），但**安全性较低**。授权服务器直接将Access Token返回给前端。此模式已被PKCE扩展的授权码模式所取代，不推荐在新项目中使用。
3. **密码模式 (Resource Owner Password Credentials Grant)**：用户直接将用户名和密码交给客户端，客户端用它来换取Token。这**仅适用于高度信任的客户端**（例如同一公司内部的应用），因为用户需要向第三方暴露密码，违背OAuth初衷。
4. **客户端凭证模式 (Client Credentials Grant)**：适用于**机器对机器（M2M）的认证**，没有用户参与。客户端使用自己的身份（Client ID和Secret）直接向授权服务器申请Token，用于访问受保护的自身资源或后端API 。
5. **刷新令牌 (Refresh Token)**：严格来说不是一种独立的授权模式，而是一种配套机制。当Access Token过期后，客户端可以使用Refresh Token来获取新的Access Token，而无需用户再次登录，提升了用户体验。
###### 4. 什么是 JWT？
JWT是一个**开放标准（RFC 7519）**，用于在各方之间安全地传输信息作为JSON对象。这个信息是**经过数字签名**的，因此可以被验证和信任 。
JWT的**核心价值在于实现无状态的认证授权**。它是一串自包含的令牌，自身就包含了所有需要的用户声明（Claims），服务器无需在会话中保存用户状态，非常适合微服务架构和RESTful API。
一个JWT令牌由三部分组成，用点（.）分隔：`Header.Payload.Signature`。
- **Header**：通常由两部分组成，令牌类型（即"JWT"）和签名算法（如HMAC SHA256或RSA）。
- **Payload**：包含声明（Claims）。声明是关于实体（通常是用户）和其他数据的语句。常见的声明有：用户ID（`sub`）、过期时间（`exp`）、签发者（`iss`）等。
- **Signature**：用于验证消息在传递过程中没有被篡改。签名部分的生成需要Base64Url编码后的Header、Payload、一个密钥（Secret）和Header中指定的签名算法。
###### 5. JWT 的工作原理是什么？
JWT的工作流程是一个典型的**基于令牌的认证**流程 ：
1. **认证**：用户使用凭证（如用户名密码）登录。
2. **令牌签发**：认证服务器验证凭证有效后，创建一个JWT（包含用户信息并签名）返回给客户端。
3. **令牌携带**：客户端在后续请求的`Authorization`头中携带JWT（例如 `Bearer <token>`）。
4. **令牌验证**：资源服务器收到请求后，**验证JWT的签名**以确保其未被篡改，并**检查有效期**等声明。验证通过后，即认为请求已认证。
5. **授权与响应**：资源服务器从JWT的Payload中解析出用户身份和权限，进行业务逻辑处理并返回结果。
**源码层面的签名验证**（以Java `java-jwt`库为例）：
```java
// 验证JWT
try {
    Algorithm algorithm = Algorithm.HMAC256("your-secret"); // 使用相同的密钥和算法
    JWTVerifier verifier = JWT.require(algorithm)
        .withIssuer("auth-server") // 验证签发者
        .build();
    
    DecodedJWT jwt = verifier.verify("received.jwt.token"); // 验证签名和过期时间
    String userId = jwt.getSubject(); // 安全地获取用户信息
} catch (JWTVerificationException exception){
    // 签名无效或令牌过期
}
```
**关键点**：验证的核心是**签名**。服务器使用预先约定好的密钥或非对称密钥对中的公钥，按照Header声明的算法重新计算签名，并与JWT中的签名进行比对。任何对Header或Payload的篡改都会导致签名验证失败。
###### 6. JWT 与 Session 的区别是什么？
这是**无状态**和**有状态**认证架构的根本区别。

|特性|JWT（无状态）|Session（有状态）|
|---|---|---|
|**状态存储**​|**服务端无状态**，所有信息存储在令牌本身。|**服务端有状态**，需要在服务器端（内存、Redis等）存储Session数据。|
|**扩展性**​|**极佳**，天然适合分布式系统和微服务，无需考虑Session同步问题。|**较差**，在集群环境下需要实现Session复制或集中存储（如Redis集群），有复杂度。|
|**性能**​|每次请求需解析和验证JWT，有计算开销，但避免了网络IO（查询Session存储）。|需要根据Session ID查询后端存储，产生网络IO，但验证过程简单。|
|**跨域支持**​|**良好**，可轻松用于跨域场景（CORS）和多个应用间传递用户上下文（单点登录）。|**困难**，默认依赖Cookie，在跨域场景下需要额外处理。|
|**安全性**​|令牌一旦签发，在有效期内无法主动废止（除非借助黑名单机制，这又引入了状态）。|可随时在服务端使特定Session失效，控制力强。|
|**数据承载**​|**自包含**，可将常用信息（如用户ID、角色）直接放入Payload，减少数据库查询。|通常只存储一个Session ID，用户信息需要额外查询。|
**选择建议**：**微服务架构和原生云应用首选JWT**，因其无状态特性简化了架构。对于需要**强会话控制**（如能立即踢用户下线）的传统Web应用，Session方案可能更直接。
###### 7. 什么是单点登录（SSO）？
单点登录是一种**身份认证方案**，允许用户使用**同一套凭证（如用户名密码）登录多个互信的应用系统**。用户只需在**一个中心认证服务**登录一次，即可访问所有具有权限的系统，无需重复登录 。
**核心思想是“一处登录，处处访问”**。它通过将认证功能从各个应用中剥离出来，集中到一个独立的认证中心来实现。这大大提升了用户体验和系统安全性（密码只在最安全的地方输入一次）。
###### 8. 说说 OAuth 2.0 与单点登录的区别？
这是一个常见的混淆点。OAuth 2.0 和 SSO 解决的是**不同但相关**的问题。

|维度|OAuth 2.0|单点登录 (SSO)|
|---|---|---|
|**核心目标**​|**解决授权问题**：**“第三方应用能否访问我在某处的资源？”**​|**解决认证问题**：**“这个用户是不是我们系统内部已知的用户？”**​|
|**应用场景**​|**跨服务授权**。例如，用微信登录知乎，允许滴滴使用你的微信头像。|**系统内部通行**。例如，登录了公司内网的OA系统后，可直接访问CRM、ERP等系统，无需再次输入密码。|
|**信任关系**​|发生在**不同信任域**之间。资源所有者、客户端、授权服务器/资源服务器通常不属于同一组织。|发生在**同一信任域**内部。所有应用都信任同一个认证中心。|
|**身份信息**​|客户端通常不关心用户是谁，只关心**是否有权限访问API/资源**。|应用系统明确知道**登录的用户身份**是谁。|
|**技术实现**​|常使用**JWT**作为Access Token，因为它是自包含的，便于资源服务器验证。|常用**SAML**（企业级）或基于**Cookie**的共享（简单SSO，如子域名间）实现。|

**关系**：在现代身份体系中，OAuth 2.0 常被**用作实现SSO的一种手段**。例如，OpenID Connect (OIDC) 协议在OAuth 2.0之上构建了一个认证层，专门用于实现SSO。你可以理解为：OAuth 2.0 提供了授权的框架，而OIDC利用这个框架标准化了用户身份的传递，从而实现了SSO。
###### 9. 什么是 Spring Security？
Spring Security 是一个功能强大且**高度可定制**的**身份认证和访问控制框架**，是保护基于Spring的应用程序的事实标准。它的核心设计目标是**对每一层Web请求进行细粒度的安全控制**。
**核心原理：过滤器链（Filter Chain）**
Spring Security 的本质是一个由多个**过滤器（Filter）**​ 组成的责任链。一个HTTP请求到达应用后，会依次经过这个过滤器链的处理，最终才能到达你的`@RestController`或`@Controller`。这些过滤器各司其职：
- `SecurityContextPersistenceFilter`：在请求开始时建立`SecurityContext`（安全上下文），请求结束后清理它。
- `UsernamePasswordAuthenticationFilter`：处理表单登录（用户名/密码认证）。
- `FilterSecurityInterceptor`：**最终的决策者**，根据配置的权限规则，决定是允许访问还是抛出异常。
**核心组件：**
- `AuthenticationManager`：认证管理的入口点。
- `ProviderManager`：`AuthenticationManager`的主要实现，委托给一系列`AuthenticationProvider`来完成具体认证逻辑（如从数据库校验用户）。
- `UserDetailsService`：核心接口，用于根据用户名加载用户信息。开发者通常需要实现这个接口。
- `SecurityContextHolder`：持有当前已认证用户的信息（`Authentication`对象）。
###### 10. Spring Security 与 Shiro 的区别是什么？

|特性|Spring Security|Apache Shiro|
|---|---|---|
|**生态整合**​|**与Spring生态无缝集成**，是Spring Boot官方首选安全框架。|相对轻量，不依赖Spring，可独立于任何容器或框架运行。|
|**功能范围**​|**极其丰富**，从Web安全到方法级安全、领域对象安全（ACL），支持OAuth 2.0、SAML等。|**核心功能齐全**，涵盖认证、授权、会话管理、加密，但高级特性（如OAuth 2.0）需要插件或自行实现。|
|**学习曲线**​|**陡峭**，概念繁多（DelegatingFilterProxy, SecurityFilterChain等），配置复杂但功能强大。|**平缓**，API设计直观，易于理解和上手。|
|**灵活性**​|**高**，但因其高度抽象和自动化，定制化开发需要对框架有较深理解。|**非常高**，结构简单清晰，定制化相对容易。|
|**适用场景**​|**中大型、复杂的企业级项目**，特别是基于Spring技术栈且需要全面安全解决方案的项目。|**轻量级应用**或需要与非Spring项目（如Servlet应用）集成的场景。|
**选型建议**：对于标准的Spring Boot微服务项目，**Spring Security是更自然、更强大的选择**。如果项目非常小且技术栈简单，或者团队对Spring生态不熟，Shiro的轻量级可能是一个优势。
###### 11. 微服务架构中如何实现统一鉴权？
在微服务架构中，**统一鉴权**的目标是确保所有服务都遵循一套中心化的、一致的规则来验证请求者的身份。主流模式是 **“网关集中认证，服务分散授权”**。
**核心模式：API网关模式**
1. **网关作为安全边界**：所有外部请求必须首先通过API网关。网关作为系统的**统一入口**，负责执行严格的认证。
2. **网关处完成认证**：在网关层集成OAuth 2.0 / JWT验证功能。对于每个进入的请求，网关执行以下操作：
    - 检查请求是否携带有效的JWT（在`Authorization`头中）。
    - **验证JWT的签名**（使用授权服务器提供的公钥或密钥）、有效期和签发者。
    - 如果令牌无效或过期，直接返回`401 Unauthorized`。
3. **向下游传递用户上下文**：认证通过后，网关将解析出的用户信息（如用户ID、角色）以**透明令牌**的形式（例如放在HTTP头 `X-User-Info`中）转发给背后的微服务。**切勿直接传递原始JWT**，以防敏感信息泄露和重放攻击。更安全的做法是传递一个能代表此次会话的、不透明的令牌，下游服务可凭此令牌向认证中心查询用户信息。
**技术实现（Spring Cloud Gateway + Spring Security）：**
```java
// 网关全局过滤器，实现JWT验证
@Component
public class JwtAuthenticationFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String token = extractJwtFromRequest(exchange.getRequest());
        if (token == null) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        try {
            // 1. 验证JWT签名和有效期
            Claims claims = Jwts.parser().setSigningKey(publicKey).parseClaimsJws(token).getBody();
            // 2. 将用户信息添加到请求头，传递给下游服务
            ServerHttpRequest mutatedRequest = exchange.getRequest().mutate()
                    .header("X-User-ID", claims.getSubject())
                    .header("X-User-Roles", (String) claims.get("roles"))
                    .build();
            return chain.filter(exchange.mutate().request(mutatedRequest).build());
        } catch (JwtException e) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
    }
    // ... extractJwtFromRequest 和 getOrder 方法实现
}
```
###### 12. 微服务架构中如何实现权限控制？
在统一鉴权确定了“用户是谁”之后，权限控制要解决“用户能做什么”的问题。这通常在**各个微服务内部**完成，实现细粒度的访问控制。
**核心模式：RBAC（基于角色的访问控制）**
这是最常用的模型，其核心是 **User -> Role -> Permission**​ 的映射。权限（Permission）是资源（如API端点`/api/users`）和操作（如`GET`, `POST`）的组合。
**技术实现：Spring Security Method-Level Security**
在服务内部，使用注解在方法级别进行声明式控制。
1. **启用方法级安全**：
    ```java
    @Configuration
    @EnableGlobalMethodSecurity(prePostEnabled = true) // 启用@PreAuthorize等注解
    public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
    }
    ```
2. **在Service或Controller方法上使用注解**：
    ```java
    @RestController
    @RequestMapping("/api/orders")
    public class OrderController {
    
        @DeleteMapping("/{id}")
        // 只有拥有'ORDER_DELETE'权限的管理员或订单所有者本人可以删除
        @PreAuthorize("hasAuthority('ORDER_DELETE') or @permissionService.isOrderOwner(authentication, #id)")
        public ResponseEntity<Void> deleteOrder(@PathVariable Long id) {
            orderService.delete(id);
            return ResponseEntity.ok().build();
        }
    
        @GetMapping
        // 只有角色为'ADMIN'的用户可以访问
        @PreAuthorize("hasRole('ADMIN')")
        public List<Order> getAllOrders() {
            return orderService.findAll();
        }
    }
    ```
    
**高级模式：ABAC（基于属性的访问控制）**
对于更复杂的场景（如“允许项目经理查看其所在项目且状态为‘进行中’的所有文档”），RBAC显得力不从心。此时可采用ABAC，其决策基于**主体（用户）、资源、环境、操作**的属性。Spring Security通过`AccessDecisionVoter`和`@PreAuthorize`结合SpEL表达式可以实现简单的ABAC。
**服务网格集成**：
在现代架构（如Istio服务网格）中，部分粗粒度的权限控制（如服务A能否调用服务B）可以下沉到**基础设施层**。通过在Istio中定义`AuthorizationPolicy`，可以实现基于JWT声明或服务身份的服务间访问控制，实现**零信任安全模型**​ 。