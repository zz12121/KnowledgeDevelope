###### 1. 微服务架构中的监控体系包括哪些方面？
微服务监控体系需要从**五个层级**构建全方位的监控能力：
**基础设施监控**：最底层监控，涵盖网络设备、交换机、路由器等硬件设施的流量、丢包率、错包率和连接数等核心指标，确保底层硬件稳定性。
**系统层监控**：监控物理机、虚拟机、操作系统级别的CPU使用率、内存占用率、磁盘IO和网络带宽等系统核心指标。
**应用层监控**：与服务紧密相关，包括URL访问性能、调用次数、响应延迟、服务错误率、SQL执行情况（特别是慢SQL）、缓存命中率以及每个服务的QPS等。
**业务监控**：关注核心业务指标，如电商网站的用户登录、注册、下单、支付等业务交易情况，为运营决策提供数据支持。
**端用户体验监控**：监控用户通过浏览器、客户端使用应用时的性能体验、错误情况、地域分布和运营商连接质量等。
###### 2. 什么是 Spring Boot Actuator？
Spring Boot Actuator是Spring Boot的子项目，为Spring Boot应用提供**生产级监控和管理功能**。它通过一组RESTful端点暴露应用的内部状态，帮助开发者和运维人员实时了解应用的健康状况、性能指标和配置信息。
**核心价值**在于将监控能力标准化，通过简单的依赖引入即可获得丰富的监控端点，无需重复造轮子。其架构基于**端点(Endpoint)**​ 机制，每个端点代表一类管理信息。
**源码层面的核心接口**：
```java
// 端点核心接口
public interface Endpoint<T> {
    T invoke();
    boolean isEnabled();
}

// 健康检查核心接口
public interface HealthIndicator {
    Health health();
}
```
###### 3. Spring Boot Actuator 的常用端点有哪些？
Actuator提供了丰富的内置端点，以下是核心端点及其功能：

|端点路径|HTTP方法|功能描述|生产环境建议|
|---|---|---|---|
|`/actuator/health`|GET|应用健康状态（数据库、磁盘等）|开放，用于负载均衡检查|
|`/actuator/metrics`|GET|JVM、内存、线程等性能指标|受限访问，敏感信息较多|
|`/actuator/info`|GET|应用基本信息（版本、描述）|开放，用于版本确认|
|`/actuator/env`|GET|环境变量、配置属性|受限访问，包含敏感配置|
|`/actuator/beans`|GET|Spring容器中所有Bean信息|开发环境使用，生产关闭|
|`/actuator/loggers`|GET/POST|查看和动态调整日志级别|受限访问，用于调试|
|`/actuator/threaddump`|GET|JVM线程快照分析|故障排查时使用|
**配置示例**：
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
      base-path: /manage  # 自定义监控路径
  endpoint:
    health:
      show-details: always
      show-components: always
```
###### 4. 什么是 Spring Boot Admin？
Spring Boot Admin是一个**社区项目**，用于管理和监控Spring Boot应用程序，提供友好的UI界面集中查看所有微服务的健康状态和监控指标。
**与Actuator的关系**：Admin作为**监控聚合平台**，通过收集各个微服务实例的Actuator端点数据，提供统一的监控视图。它本身不产生监控数据，而是Actuator数据的消费者和展示器。
**核心架构角色**：
- **Admin Server**：中央监控服务器，聚合各应用监控数据
- **Admin Client**：集成在业务应用中，注册到Admin Server
###### 5. Spring Boot Admin 的功能有哪些？
Spring Boot Admin提供以下核心监控功能：
**应用状态监控**：实时显示所有注册应用的UP/DOWN状态，支持批量重启和状态通知。
**详细健康信息**：展示健康检查的详细信息，包括数据库连接、磁盘空间、缓存状态等依赖组件的健康状况。
**性能指标可视化**：集成Metrics指标，以图表形式展示JVM内存使用率、线程数、HTTP请求统计等。
**环境配置查看**：安全地查看和管理各个应用的环境变量、配置属性、系统属性等信息。
**日志级别动态调整**：支持运行时动态修改应用的日志级别，无需重启服务。
**JMX管理**：提供Web界面操作JMX Bean，简化JMX监控和管理操作。
###### 6. 什么是 Prometheus？
Prometheus是一款开源的**系统监控和警报工具包**，最初由SoundCloud开发，现在已成为Cloud Native Computing Foundation的毕业项目。
**核心特性**：
- **多维数据模型**：基于键值对的时间序列数据模型
- **强大的查询语言**：PromQL支持灵活的数据查询和聚合
- **拉取模式采集**：通过HTTP协议主动从目标拉取指标数据
- **自治模式**：不依赖分布式存储，单个节点自治
**与Micrometer集成**（源码层面）：
```java
// Micrometer与Prometheus集成
@Bean
public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
    return registry -> {
        if (registry instanceof PrometheusMeterRegistry) {
            ((PrometheusMeterRegistry) registry).config().commonTags(
                "application", "user-service"
            );
        }
    };
}
```
###### 7. 什么是 Grafana？
Grafana是一个开源的**度量分析和可视化平台**，可以将多种数据源的数据转化为直观的图表和警报。
**核心功能定位**：
- **多数据源支持**：支持Prometheus、InfluxDB、Elasticsearch等30多种数据源
- **丰富的可视化**：提供图表、仪表盘、热图等多种可视化组件
- **灵活的仪表盘**：支持拖拽式创建和共享监控仪表盘
- **警报和通知**：基于规则的警报机制，支持多种通知方式
###### 8. 如何使用 Prometheus 和 Grafana 监控微服务？
**架构部署流程**：
**1. 应用侧配置**（Micrometer + Prometheus）：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```
```yaml
management:
  endpoints:
    web:
      exposure:
        include: prometheus,health,metrics
  metrics:
    export:
      prometheus:
        enabled: true
```
**2. Prometheus配置**（抓取目标）：
```yaml
scrape_configs:
  - job_name: 'user-service'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['localhost:8080']
        labels:
          application: 'user-service'
          environment: 'production'
```
**3. Grafana配置**（数据源和仪表盘）：
- 添加Prometheus数据源
- 导入Spring Boot监控仪表盘（ID：4701）
- 配置业务自定义指标面板
**数据流架构**：微服务应用 → Micrometer指标收集 → Prometheus拉取存储 → Grafana可视化展示。
###### 9. 什么是健康检查？
健康检查是监控系统通过**预定义规则**定期检测应用组件可用性的机制，确保应用实例能够正常处理请求。
**Spring Boot健康检查实现**：
```java
@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    private final DataSource dataSource;
    
    @Override
    public Health health() {
        try (Connection conn = dataSource.getConnection()) {
            // 执行简单查询检查数据库连接
            if (isConnectionValid(conn)) {
                return Health.up()
                    .withDetail("database", "Connected")
                    .withDetail("timestamp", System.currentTimeMillis())
                    .build();
            }
        } catch (Exception e) {
            return Health.down(e)
                .withDetail("database", "Connection failed")
                .build();
        }
        return Health.unknown().build();
    }
}
```
**Kubernetes集成**（生产级健康检查）：
```yaml
livenessProbe:
  httpGet:
    path: /actuator/health/liveness
    port: 8080
  initialDelaySeconds: 60
  periodSeconds: 30

readinessProbe:
  httpGet:
    path: /actuator/health/readiness  
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 15
```
###### 10. 微服务的日志收集方案有哪些？
**ELK Stack方案**（最主流）：
- **Elasticsearch**：分布式搜索和分析引擎，存储日志数据
- **Logstash**：日志收集和处理管道，支持多种输入输出
- **Kibana**：日志查询和可视化平台
**架构演进**：传统方案基于Filebeat + Logstash + Elasticsearch，现代方案采用Fluentd + Elasticsearch的云原生组合。
**生产环境配置示例**：
```yaml
# Logstash配置模板
input {
  beats {
    port => 5044
  }
}

filter {
  grok {
    match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:loglevel} %{GREEDYDATA:message}" }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "microservice-logs-%{+YYYY.MM.dd}"
  }
}
```
**日志追踪集成**（与Sleuth/Zipkin整合）：
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>
```
###### 11. ELK 是什么？
ELK是**三个开源项目的缩写**，构成完整的日志管理解决方案：
**Elasticsearch**：分布式、RESTful风格的搜索和分析引擎，负责日志数据的存储、搜索和分析。
**Logstash**：服务器端数据处理管道，同时从多个来源采集数据，转换后发送到Elasticsearch等"存储库"。
**Kibana**：为Elasticsearch提供可视化Web界面，用于日志搜索、分析和仪表盘展示。
**现代演进**：当前ELK Stack已发展为**Elastic Stack**，包含Beats数据采集器等新组件，形成更完整的可观测性平台。
###### 12. 微服务的性能监控指标有哪些？
微服务性能监控需要涵盖**四个维度**的关键指标：
**JVM性能指标**：
- 内存使用：堆内存、非堆内存、各内存池使用率
- GC情况：GC次数、GC耗时、各代GC统计
- 线程状态：活动线程数、死锁检测、线程状态分布
**HTTP请求指标**：
- QPS/TPS：每秒请求数/事务数
- 响应时间：平均响应时间、P95/P99响应时间
- 错误率：HTTP状态码分布（4xx、5xx错误比例）
**数据库连接指标**：
- 连接池：活动连接数、空闲连接数、等待连接数
- SQL性能：慢SQL检测、SQL执行时间、事务提交回滚统计
**缓存性能指标**：
- 命中率：缓存命中率、穿透率
- 响应时间：缓存操作平均耗时
- 内存使用：缓存内存占用情况
**自定义业务指标**（Micrometer实现）：
```java
@Component
public class OrderMetrics {
    private final Counter orderCounter;
    private final Timer orderTimer;
    
    public OrderMetrics(MeterRegistry registry) {
        orderCounter = Counter.builder("order.count")
            .description("订单创建数量")
            .tag("type", "business")
            .register(registry);
            
        orderTimer = Timer.builder("order.process.time")
            .description("订单处理时间")
            .register(registry);
    }
    
    public void recordOrder(Order order) {
        orderCounter.increment();
        // 计时处理
        orderTimer.record(() -> processOrder(order));
    }
}
```