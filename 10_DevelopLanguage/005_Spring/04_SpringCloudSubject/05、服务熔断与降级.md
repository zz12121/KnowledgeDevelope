###### 1. 什么是服务雪崩？
服务雪崩是分布式系统中典型的**级联故障**现象。当系统中一个服务提供者不可用，导致服务调用者资源耗尽，进而将故障扩散到整个系统，最终导致系统崩溃。
**服务雪崩的产生过程遵循以下时序：**
```
服务A依赖服务B → B出现故障（如响应慢） → A调用B的线程大量阻塞 → A线程池耗尽 → A对外服务能力下降 → 依赖A的服务C出现连锁反应 → 故障在整个系统扩散
```
**源码层面的根本原因**在于**同步阻塞调用模型**。以Tomcat线程池为例，当所有工作线程都在等待下游服务响应时，新请求无法被处理：
```java
// 典型的同步调用模式 - 线程被阻塞直到响应返回
@RestController
public class ServiceA {
    public String callServiceB() {
        // 所有线程可能阻塞在这行代码上
        return restTemplate.getForObject("http://service-b/api", String.class);
    }
}
```
**触发服务雪崩的具体场景包括**：
- **大流量冲击**：突发高并发超出系统处理能力
- **缓存击穿**：热点key失效导致请求直接访问数据库
- **程序BUG**：如无限循环、内存泄漏等
- **依赖服务故障**：下游服务响应缓慢或不可用
- **硬件故障**：服务器、网络等基础设施问题
###### 2. 什么是服务熔断？
服务熔断源于电路熔断器的思想，是**快速失败**的容错机制。当检测到依赖服务故障达到阈值时，熔断器自动开启，在指定时间内所有请求直接失败，不再访问实际服务。
**熔断器的核心状态机实现**：
```java
public class CircuitBreaker {
    private enum State { CLOSED, OPEN, HALF_OPEN }
    
    public Response invoke(Request request) {
        if (state == State.OPEN) {
            // 熔断开启期，直接返回失败，避免资源浪费
            return fallback.apply(request);
        }
        
        if (state == State.HALF_OPEN) {
            // 半开状态，允许少量试探请求
            return trialInvoke(request);
        }
        
        // 正常调用，监控成功/失败率
        return normalInvoke(request);
    }
}
```
**熔断器的核心参数**：
- **失败阈值**：触发熔断的失败率比例（默认通常50%）
- **熔断时间窗口**：熔断器保持OPEN状态的时间
- **最小请求数**：在统计窗口内至少需要多少请求才触发计算
###### 3. 什么是服务降级？
服务降级是**有策略的暂时放弃非核心功能**，保障核心业务可用性的措施。当系统资源不足或特定服务不可用时，降级机制提供兜底方案。
**降级策略分类**：
1. **功能降级**：关闭非核心功能，如商品详情页隐藏推荐模块
2. **数据降级**：返回缓存数据或默认值，如查询失败时返回本地缓存
3. **写操作降级**：异步化处理，如评论提交后先缓存再异步持久化
**降级配置示例**：
```properties
# 降级开关配置
feature.recommend.enabled=false
feature.promotion.fallback=true
```
###### 4. 熔断与降级的区别是什么？

|**维度**​|**服务熔断**​|**服务降级**​|
|---|---|---|
|**触发原因**​|依赖服务故障（如高错误率）|系统资源整体不足|
|**目标范围**​|针对单个依赖服务的故障隔离|系统整体负载保护，保障核心业务|
|**实现层次**​|通常框架层面自动处理（如Hystrix）|需要业务层面设计降级策略|
|**状态变化**​|有明确的状态机（开/关/半开）|通常是静态配置或手动开关|
|**作用时效**​|临时性，依赖服务恢复后自动关闭|可持续到系统压力缓解|
###### 5. 什么是 Hystrix？
Hystrix是Netflix开源的**延迟和容错库**，通过隔离、熔断等机制防止复杂分布式系统出现级联故障。它是微服务架构中最早成熟的容错解决方案。
**Hystrix的核心设计目标**：
- **防止单个依赖耗尽所有容器（如Tomcat）线程**
- **快速失败而非排队等待**
- **提供降级逻辑作为备用方案**
- **近实时监控和配置变更**
###### 6. Hystrix 的工作原理是什么？
Hystrix采用**命令模式**封装依赖调用，通过`HystrixCommand`实现完整的容错逻辑。
**执行流程源码分析**：
```java
public class UserQueryCommand extends HystrixCommand<User> {
    private final String userId;
    
    public UserQueryCommand(String userId) {
        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("UserService"))
                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
                        .withCircuitBreakerEnabled(true)
                        .withCircuitBreakerErrorThresholdPercentage(50)
                        .withExecutionTimeoutInMilliseconds(1000)));
        this.userId = userId;
    }
    
    @Override
    protected User run() throws Exception {
        // 主业务逻辑 - 调用外部服务
        return userService.getUser(userId);
    }
    
    @Override
    protected User getFallback() {
        // 降级逻辑 - 主逻辑失败时执行
        return User.defaultUser(userId);
    }
}

// 使用示例
User user = new UserQueryCommand("123").execute();
```
**Hystrix执行流程的8个关键步骤**：
1. **命令构造**：创建HystrixCommand或HystrixObservableCommand对象
2. **命令执行**：调用execute()、queue()或observe()方法
3. **缓存检查**：如果启用缓存，先检查缓存中是否有结果
4. **熔断器检查**：判断电路是否打开，如打开直接进入降级逻辑
5. **线程池/信号量检查**：判断资源是否可用
6. **业务逻辑执行**：调用run()方法执行实际业务
7. **结果缓存**：如启用缓存，将结果存入缓存
8. **健康统计**：更新成功、失败、超时等指标
###### 7. Hystrix 的熔断器状态机有哪些状态？
Hystrix熔断器采用**三状态自动机**实现：
```
失败超阈值/超时
CLOSED ───────────────────▶ OPEN
  │ │                      │  │
  │ │  定时器到期           │  │
  │ └──────────────────────┘  │
  │         试探请求成功        │
  └─────────────────────────────┘ HALF_OPEN
```
**状态转换详解**：
- **CLOSED（关闭）**：正常状态，请求正常通过
- **OPEN（打开）**：失败率超过阈值，所有请求被短路，直接执行fallback
- **HALF_OPEN（半开）**：熔断器开启一段时间后，允许部分请求尝试访问
**状态转换的源码实现**：
```java
public class HystrixCircuitBreaker {
    public boolean allowRequest() {
        if (forceOpen) return false;
        if (forceClosed) return true;
        
        // 检查失败率是否达到阈值
        return !isOpen() || allowSingleTest();
    }
    
    private boolean allowSingleTest() {
        // 半开状态下的试探逻辑
        long circuitOpenTime = circuitOpened.get();
        return circuitOpenTime != -1 && 
               System.currentTimeMillis() > circuitOpenTime + sleepWindow;
    }
}
```
###### 8. Hystrix 的隔离策略有哪些？
Hystrix提供两种隔离策略，防止依赖服务故障扩散：
**线程池隔离（默认）**
```java
// 线程池隔离配置
HystrixThreadPoolProperties.Setter()
    .withCoreSize(10)                    // 核心线程数
    .withMaxQueueSize(5)                // 队列大小
    .withQueueSizeRejectionThreshold(5) // 队列拒绝阈值
```
**优势**：
- **完全隔离**：每个依赖服务使用独立线程池
- **超时控制**：支持异步调用和超时控制
- **流量排队**：支持排队和拒绝策略
**信号量隔离**
```java
// 信号量隔离配置
HystrixCommandProperties.Setter()
    .withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)
    .withExecutionIsolationSemaphoreMaxConcurrentRequests(20)
```
**优势**：
- **轻量级**：无线程切换开销，性能更高
- **简单控制**：通过计数器控制并发数
###### 9. Hystrix 的线程池隔离和信号量隔离的区别？

|**特性**​|**线程池隔离**​|**信号量隔离**​|
|---|---|---|
|**资源开销**​|较高（线程创建、上下文切换）|较低（仅计数器）|
|**超时支持**​|支持|不支持|
|**异步支持**​|支持|不支持|
|**适用场景**​|网络调用、外部服务依赖|高频调用、内部逻辑|
|**隔离程度**​|完全隔离|有限隔离|
**选择建议**：
- **外部服务调用、数据库查询**​ → 使用线程池隔离
- **内存计算、快速本地服务**​ → 使用信号量隔离
###### 10. 什么是 Sentinel？
Sentinel是阿里巴巴开源的**面向分布式服务架构的流量控制组件**，以流量为切入点，提供流量控制、熔断降级、系统自适应保护等功能。
**Sentinel的核心特性**：
- **丰富的流量控制场景**：支持QPS、线程数、冷启动等多种控制策略
- **可视化监控**：提供实时监控接口和Dashboard
- **扩展性强**：支持自定义规则管理和扩展点
- **生产环境验证**：经过阿里双十一大促验证
###### 11. Sentinel 与 Hystrix 的区别是什么？

| **维度**​   | **Hystrix**​ | **Sentinel**​     |
| --------- | ------------ | ----------------- |
| **设计理念**​ | 容错库，关注服务调用容错 | 流量控制组件，关注流量规律和控制  |
| **隔离机制**​ | 线程池/信号量隔离    | 基于并发线程数的流量控制      |
| **规则配置**​ | 代码/注解配置为主    | 支持动态规则配置和持久化      |
| **监控能力**​ | 简单的指标聚合      | 丰富的实时监控和Dashboard |
| **扩展性**​  | 相对固定         | 高度可扩展，支持自定义SPI    |
| **熔断策略**​ | 基于错误率的熔断     | 支持慢调用比例、错误率等多种策略  |
**演进趋势**：Hystrix已进入维护模式，Sentinel因其更丰富的流量控制功能和更好的性能成为主流选择。
###### 12. Sentinel 的核心概念有哪些（资源、规则、上下文）？
 **资源（Resource）**
资源是Sentinel保护的核心实体，可以是任何需要保护的逻辑：
```java
// 定义资源
try (Entry entry = SphU.entry("getUserInfo")) {
    // 受保护的业务逻辑
    return userService.getUser(userId);
} catch (BlockException ex) {
    // 处理被流控的逻辑
    return "服务暂时不可用";
}
```
**规则（Rule）**
规则定义了资源的具体保护策略，包括：
- **流控规则（FlowRule）**：控制流量行为
- **降级规则（DegradeRule）**：控制服务降级
- **系统规则（SystemRule）**：控制系统负载
 **上下文（Context）**
上下文包含调用的元数据信息，如调用链、调用来源等，用于更精细化的控制。
###### 13. Sentinel 的流控规则有哪些？
Sentinel提供多种流控规则，满足不同场景需求：
**QPS流控**
```java
// 配置QPS流控规则
List<FlowRule> rules = new ArrayList<>();
FlowRule rule = new FlowRule();
rule.setResource("getUserInfo");
rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
rule.setCount(100); // 每秒最多100次调用
rules.add(rule);
FlowRuleManager.loadRules(rules);
```
**并发线程数控制**
```java
// 控制并发线程数
rule.setGrade(RuleConstant.FLOW_GRADE_THREAD);
rule.setCount(50); // 最多50个并发线程
```
**高级流控模式**
- **关联流控**：当关联资源超过阈值时，限流当前资源
- **链路流控**：针对具体调用链路进行精细控制
- **预热模式**：冷启动时逐步增加流量阈值
- **排队等待**：超过阈值时排队等待，而不是直接拒绝
###### 14. Sentinel 的降级规则有哪些？
Sentinel降级规则基于多种指标实现服务熔断：
**慢调用比例降级**
```java
// 当响应时间超过500ms的请求比例超过50%时触发降级
DegradeRule rule = new DegradeRule();
rule.setResource("slowService");
rule.setGrade(RuleConstant.DEGRADE_GRADE_RT);
rule.setCount(500);    // 响应时间阈值(ms)
rule.setTimeWindow(10); // 熔断时间(s)
rule.setRtSlowRequestAmount(5); // 触发熔断的最小请求数
rule.setSlowRatioThreshold(0.5); // 慢调用比例阈值
```
**异常比例降级**
```java
// 当异常比例超过50%时触发降级
rule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO);
rule.setCount(0.5);    // 异常比例阈值
```
**异常数降级**
```java
// 当异常数超过10个时触发降级
rule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT);
rule.setCount(10);     // 异常数阈值
```
###### 15. Sentinel 的热点参数限流是什么？
热点参数限流是**对频繁访问的热点参数进行特殊限流**的策略，防止热点数据过度消耗系统资源。
**实现原理**：
```java
// 热点参数限流配置
ParamFlowRule rule = new ParamFlowRule("hotResource")
    .setParamIdx(0)    // 参数索引（0表示第一个参数）
    .setCount(100);    // 热点参数限流阈值

// 对特定参数值单独设置限流
ParamFlowItem item = new ParamFlowItem().setObject("hotKey")
    .setClassType(Integer.class.getName())
    .setCount(10);     // 该热点key的特殊阈值
rule.setParamFlowItemList(Collections.singletonList(item));
```
**使用场景**：
- **热点商品ID**：防止某个热门商品被过度访问
- **频繁用户**：对高频访问用户进行特殊限制
- **地域参数**：对特定地域的请求进行流量控制