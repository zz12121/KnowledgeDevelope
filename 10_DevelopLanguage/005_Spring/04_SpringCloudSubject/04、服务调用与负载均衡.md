###### 1. 说说微服务之间是如何独立通讯的？
微服务通信主要有**同步调用**和**异步消息**两种模式，根据业务场景选择合适方式。
 **同步通信模式**
- **RESTful HTTP**：最常用的同步通信方式，基于HTTP协议，使用JSON/XML格式
```java
// Spring Cloud中使用RestTemplate进行同步调用
User user = restTemplate.getForObject("http://user-service/users/1", User.class);
```
- **RPC框架**：如gRPC、Dubbo，提供像本地调用一样的远程调用体验
```java
// Dubbo RPC调用示例
@Reference
private UserService userService; // 透明远程调用
```
**异步通信模式**
- **消息队列**：通过Kafka、RabbitMQ等实现服务解耦
- **事件驱动**：服务间通过发布/订阅模式进行异步通信
**设计考量**：同步调用简单直接但存在耦合风险；异步消息解耦性好但需处理消息可靠性。
###### 2. SpringCloud 有几种调用接口方式？
Spring Cloud提供了三种主要的服务调用方式：
**RestTemplate + @LoadBalanced**
```java
@Bean
@LoadBalanced // 启用负载均衡
public RestTemplate restTemplate() {
    return new RestTemplate();
}
// 使用服务名而非IP调用
String result = restTemplate.getForObject("http://service-name/api", String.class);
```
**DiscoveryClient 动态获取服务实例**
```java
@Autowired
private DiscoveryClient discoveryClient;

public void callService() {
    List<ServiceInstance> instances = discoveryClient.getInstances("service-name");
    // 手动实现负载均衡逻辑
    ServiceInstance instance = instances.get(0); 
    String url = "http://" + instance.getHost() + ":" + instance.getPort() + "/api";
}
```
**Feign 声明式客户端**（推荐方式）
```java
@FeignClient(name = "user-service")
public interface UserServiceClient {
    @GetMapping("/users/{id}")
    User getUser(@PathVariable("id") Long id);
}
// 直接注入使用
@Autowired
private UserServiceClient userServiceClient;
```
###### 3. 什么是 RestTemplate？
RestTemplate是Spring框架提供的**同步HTTP客户端工具类**，用于消费RESTful Web服务。
**核心特性**
- 封装了HTTP连接管理，简化REST API调用
- 支持常见的HTTP方法：GET、POST、PUT、DELETE等
- 可配置消息转换器，支持JSON/XML等数据格式
**源码结构分析**
```java
// RestTemplate的核心执行方法
public class RestTemplate {
    protected <T> T doExecute(URI url, HttpMethod method, RequestCallback requestCallback,
                              ResponseExtractor<T> responseExtractor) throws RestClientException {
        // 创建请求工厂
        ClientHttpRequest request = createRequest(url, method);
        // 执行请求并处理响应
        return execute(url, method, requestCallback, responseExtractor);
    }
}
```
###### 4. RestTemplate 的常用方法有哪些？
RestTemplate提供了一系列针对不同HTTP方法的便捷API：
**GET请求**
```java
// 获取对象
User user = restTemplate.getForObject("http://api/users/1", User.class);
// 获取ResponseEntity包含状态和头信息
ResponseEntity<User> response = restTemplate.getForEntity("http://api/users/1", User.class);
```
**POST请求**
```java
// 提交对象，返回结果
User createdUser = restTemplate.postForObject("http://api/users", user, User.class);
// 提交并获取位置头信息
URI location = restTemplate.postForLocation("http://api/users", user);
```
**PUT/DELETE请求**
```java
// 更新资源
restTemplate.put("http://api/users/1", user);
// 删除资源
restTemplate.delete("http://api/users/1");
```
**exchange通用方法**
```java
// 支持自定义请求头和HTTP方法
ResponseEntity<User> response = restTemplate.exchange(
    "http://api/users/1", HttpMethod.GET, httpEntity, User.class);
```
###### 5. 什么是 Ribbon？
Ribbon是Netflix开源的**客户端负载均衡器**，在微服务架构中解决服务调用的负载分配问题。
**核心功能**
- 从注册中心获取服务列表
- 基于策略从多个实例中选择一个
- 检测实例健康状况，自动剔除故障节点
**在Spring Cloud中的集成**
```java
@Configuration
public class RibbonConfig {
    @Bean
    @LoadBalanced // 关键注解，启用Ribbon负载均衡
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```
###### 6. Ribbon 底层实现原理
Ribbon通过**拦截器机制**和**负载均衡算法**实现客户端负载均衡。
**拦截器机制源码分析**
```java
public class LoadBalancerInterceptor implements ClientHttpRequestInterceptor {
    private LoadBalancerClient loadBalancer;
    
    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, 
                                       ClientHttpRequestExecution execution) throws IOException {
        URI originalUri = request.getURI();
        String serviceName = originalUri.getHost(); // 从URL中提取服务名
        
        // 使用Ribbon客户端执行负载均衡调用
        return this.loadBalancer.execute(serviceName, 
            this.requestFactory.createRequest(request, body, execution));
    }
}
```
 **负载均衡执行流程**
1. **提取服务名**：从URL（如`http://user-service/api`）中解析`user-service`
2. **获取服务列表**：从注册中心查询`user-service`的所有健康实例
3. **选择实例**：根据配置的负载策略选择一个实例
4. **重构请求**：将服务名替换为实际IP:Port，发送请求
5. **故障转移**：如请求失败，自动重试其他实例
###### 7. Ribbon 的负载均衡策略有哪些？
Ribbon提供多种负载均衡策略，满足不同场景需求：
**基础策略**
- **轮询策略（RoundRobinRule）**：按顺序循环选择服务实例
- **随机策略（RandomRule）**：随机从服务器列表中选择
- **重试策略（RetryRule）**：先按轮询策略获取服务，如获取失败则在指定时间内重试
**高级策略**
- **最低并发策略（BestAvailableRule）**：选择并发请求数最小的服务器
- **可用过滤策略（AvailabilityFilteringRule）**：先过滤故障实例，再选择并发较小的实例
- **响应时间加权策略（WeightedResponseTimeRule）**：根据平均响应时间计算权重，响应越快被选中的概率越高
**配置示例**
```yaml
# 为特定服务配置负载均衡策略
user-service:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
```
###### 8. 如何自定义 Ribbon 的负载均衡策略？
可以通过实现`IRule`接口创建自定义负载均衡策略。
**自定义策略实现**
```java
public class MyLoadBalancingRule extends AbstractLoadBalancerRule {
    @Override
    public Server choose(Object key) {
        ILoadBalancer loadBalancer = getLoadBalancer();
        List<Server> allServers = loadBalancer.getAllServers();
        
        // 自定义选择逻辑：优先选择配置高的服务器
        List<Server> highConfigServers = filterHighConfigServers(allServers);
        if (!highConfigServers.isEmpty()) {
            return selectRandom(highConfigServers);
        }
        return selectRandom(allServers);
    }
    
    @Override
    public void setLoadBalancer(ILoadBalancer lb) { /*...*/ }
    @Override
    public ILoadBalancer getLoadBalancer() { /*...*/ }
}
```
**注册自定义策略**
```java
@Configuration
public class RibbonConfiguration {
    @Bean
    public IRule myLoadBalancingRule() {
        return new MyLoadBalancingRule();
    }
}
```
###### 9. Ribbon 的饥饿加载是什么？
Ribbon默认采用**懒加载**机制，首次请求时才会初始化负载均衡客户端，可能导致首次请求较慢。**饥饿加载**在应用启动时立即初始化指定服务的负载均衡器。
**配置饥饿加载**
```yaml
ribbon:
  eager-load:
    enabled: true
    clients: user-service,order-service,product-service
```
**源码实现原理**
```java
public class RibbonAutoConfiguration {
    @Bean
    public RibbonApplicationContextInitializer ribbonApplicationContextInitializer() {
        return new RibbonApplicationContextInitializer(springClientFactory(), 
            ribbonEagerLoadProperties.getClients());
    }
}
```
###### 10. Nginx 与 Ribbon 的区别
Nginx和Ribbon虽然都实现负载均衡，但属于不同层面的解决方案：

|**对比维度**​|**Nginx**​|**Ribbon**​|
|---|---|---|
|**负载均衡位置**​|服务端负载均衡|客户端负载均衡|
|**技术类型**​|独立的反向代理服务器|嵌入应用中的客户端库|
|**服务发现**​|需配合Consul等或静态配置|直接集成Eureka等注册中心|
|**配置方式**​|配置文件+重载|代码配置+注解|
|**性能影响**​|增加网络跳转，有单点风险|客户端直接调用，延迟更低|
|**适用场景**​|南北流量（外部到内部）|东西流量（内部服务间）|
###### 11. 为什么需要负载均衡？常见的负载均衡算法有哪些？
**为什么需要负载均衡？**
负载均衡是分布式系统的基石，其核心必要性在于：
1. **高可用性**：通过将请求分发到多个服务实例，避免单点故障。当某个实例宕机时，负载均衡器能自动将其剔除，确保服务整体可用。
2. **扩展性与性能**：当单个实例无法承受压力时，可以通过水平扩展（增加实例数）来提升系统整体处理能力。负载均衡将流量合理分摊，充分利用集群资源，避免某些实例过载而其他实例空闲，从而提升系统吞吐量和响应速度。
3. **可维护性**：便于进行灰度发布、版本升级等运维操作。可以先从负载均衡池中摘掉部分实例进行升级，然后再重新加入，实现平滑升级。
**常见的负载均衡算法**
算法主要分为静态和动态两大类。

|算法名称|原理|优点|缺点|适用场景|
|---|---|---|---|---|
|**轮询 (Round Robin)**​|将请求按顺序依次分配给每个服务器。|实现简单，请求分配绝对均衡。|不考虑服务器性能差异和当前负载。|服务器硬件配置和性能接近的场景。|
|**加权轮询 (Weighted Round Robin)**​|在轮询基础上，为性能高的服务器分配更高权重，使其处理更多请求。|考虑了服务器性能差异。|权重是静态的，无法反映实时负载变化。|服务器性能差异明显的场景。|
|**随机 (Random)**​|从服务器列表中随机选择一个来处理请求。|实现简单。|请求分配不够精确，可能不够均匀。|无特殊要求的简单场景。|
|**加权随机 (Weighted Random)**​|在随机选择基础上，权重高的服务器被随机选中的概率更高。|考虑了服务器性能差异。|分配不够精确。|服务器性能差异明显的场景。|
|**最少连接 (Least Connections)**​|将新请求分配给当前处理连接数最少的服务器。|动态分配，考虑了服务器的实时负载。|实现复杂，需要维护和追踪每个服务器的连接数。|处理时间长短不一的场景，如长连接、文件传输。|
|**哈希/源地址哈希 (Hash)**​|根据客户端IP或请求参数计算哈希值，相同哈希值的请求总是落到同一台服务器。|能实现会话保持 (Session Persistence)。|服务器列表变更时，会导致大量请求被重新路由，可能引发"雪崩"。|需要会话保持的场景，如用户登录状态。|
|**一致性哈希 (Consistent Hash)**​|哈希算法的改良，当服务器增加或减少时，仅重定位少量请求，避免雪崩效应。|具有良好的单调性，适应节点动态变化|
###### 12. 什么是客户端负载均衡和服务端负载均衡？
这是一个核心架构区别，具体对比如下：

|对比维度|服务端负载均衡|客户端负载均衡|
|---|---|---|
|**架构位置**​|独立的硬件设备（如F5）或软件（如Nginx、HAProxy），位于客户端和服务端之间。|**逻辑嵌入在客户端应用程序内部**，作为其一个组件或库（如Ribbon、Spring Cloud LoadBalancer）。|
|**工作原理**​|客户端向负载均衡器发送请求，负载均衡器根据策略将请求转发给后端某个服务实例。|**客户端从注册中心（如Nacos）获取服务实例列表**，然后在本地根据负载均衡算法直接选择一个实例发起调用。|
|**请求路径**​|`客户端 -> 负载均衡器 -> 服务实例`（两次网络跳转）。|`客户端 -> 服务实例`（直接连接，一次跳转）。|
|**优点**​|- **对客户端透明**，客户端无需关心服务发现和负载逻辑。  <br>- **功能强大**，可集成SSL卸载、安全防护（WAF）、限流等高级功能。|- **网络开销小**，延迟更低。  <br>- **去中心化**，无单点故障风险，架构更弹性。  <br>- **策略灵活**，不同客户端可配置不同策略。|
|**缺点**​|- **存在单点风险**，负载均衡器本身需要高可用集群。  <br>- **可能成为性能瓶颈**。|- **客户端复杂度高**，需要集成相关组件。  <br>- **负载均衡策略分散**，难统一管理和更新。|
|**典型组件**​|Nginx, HAProxy, F5。|Ribbon, Spring Cloud LoadBalancer, Dubbo内置的负载均衡。|
|**适用场景**​|南北流量（外部用户访问集群入口）、API网关。|东西流量（微服务内部之间的调用）。|
###### 13. 什么是 Netflix Feign？它的优点是什么？
**Netflix Feign**​ 是一个声明式的、基于注解的HTTP客户端，其核心目标是**简化远程服务调用**，让调用远程方法像调用本地方法一样简单。
**它的主要优点包括：**
1. **声明式接口定义**：通过Java接口和注解（如`@RequestMapping`）配置HTTP请求，极大地简化了HTTP客户端的开发，代码更简洁、可读性更强。
2. **与Ribbon无缝集成**：Feign默认集成了Ribbon，天生具备客户端负载均衡能力，无需额外编码。
3. **简化开发**：开发者无需使用`RestTemplate`及其繁琐的参数拼接，只需定义接口即可。
4. **易于维护**：将服务调用契约集中在接口中，便于管理和维护。
###### 14. 说说 Feign 实现原理
Feign的核心原理是**动态代理**和**注解处理**。
1. **启动阶段 - 接口动态代理创建**：
    - 当应用启动时，Feign的组件（如`@EnableFeignClients`）会扫描所有被`@FeignClient`注解的接口。
    - 通过JDK动态代理（或CGLIB），为这些接口生成代理对象，并注册到Spring容器中。
    - **源码层面**：`FeignClientFactoryBean`是这个过程的核心类，它的`getObject()`方法负责返回代理实例。
2. **调用阶段 - 代理对象拦截执行**：
    - 当你在代码中调用Feign接口的方法时，实际上调用的是代理对象的方法。
    - 代理对象会拦截方法调用，并执行以下关键步骤：
        a. **方法元数据解析**：由`Contract`组件解析接口方法上的注解（如`@GetMapping`），提取出HTTP方法类型、URL路径、参数等信息，构建一个`RequestTemplate`（请求模板）。
        b. **参数编码**：由`Encoder`和`QueryMapEncoder`将方法参数应用到`RequestTemplate`上，生成完整的HTTP请求信息。
        c. **负载均衡与请求发送**：将`RequestTemplate`交给`Client`接口的实现去执行。这个`Client`通常是集成了Ribbon的`LoadBalancerFeignClient`。
        d. **响应解码**：收到HTTP响应后，由`Decoder`组件将响应体解码成方法声明的返回类型。
###### 15. Feign 是如何实现负载均衡的？
Feign通过集成**Ribbon**实现负载均衡，关键在于`LoadBalancerFeignClient`。
**详细流程如下：**
1. 当Feign代理对象需要发送请求时，会调用`LoadBalancerFeignClient.execute()`方法。
2. `LoadBalancerFeignClient`会从`RequestTemplate`中提取服务名（如`"user-service"`）。
3. 它并不直接发送请求，而是**委托给Ribbon**：调用`RibbonLoadBalancerClient.execute(String serviceId, ...)`。
4. Ribbon的负载均衡器（`ILoadBalancer`）根据服务名从注册中心（如Eureka）获取服务实例列表（`List<Server>`）。
5. Ribbon根据配置的负载均衡规则（`IRule`，如轮询、随机），从实例列表中选择一个目标实例（`Server`）。
6. `LoadBalancerFeignClient`获取到选中的具体实例的URL（如`http://192.168.1.101:8080`），然后使用其内部的一个"真正"的HTTP客户端（默认是`Client.Default`，基于`HttpURLConnection`）向该地址发送请求。
7. 整个过程对Feign的核心逻辑是透明的，Feign只关心契约定义，Ribbon负责路由选择。
###### 16. Feign 的性能优化方法有哪些？
- **替换HTTP客户端**：默认的`HttpURLConnection`性能一般，通常替换为更高效的客户端。
    - **OKHttp**：支持连接池和多路复用，能有效减少TCP握手次数。
    - **Apache HttpClient**：功能强大，配置灵活，同样支持连接池。
    ```yaml
    # 在依赖中引入OKHttp，Feign会自动切换
    feign:
      okhttp:
        enabled: true
      httpclient:
        enabled: false
    ```
- **配置连接池**：使用HTTP客户端时，务必配置连接池参数，如最大连接数、超时时间等，避免频繁创建和销毁连接。
    ```yaml
    # 使用OKHttp或HttpClient时的配置示例
    feign:
      client:
        config:
          default:
            connectTimeout: 5000   # 连接超时时间
            readTimeout: 5000      # 读取超时时间
            loggerLevel: basic
    # 如果使用HttpClient，还可以配置连接池
    httpclient:
      max-connections: 200        # 最大连接数
      max-connections-per-route: 50 # 每个路由的最大连接数
    ```
- **开启GZIP压缩**：在服务提供方和Feign客户端都开启GZIP压缩，减少网络传输量。
    ```yaml
    feign:
      compression:
        request:
          enabled: true
          mime-types: text/xml,application/xml,application/json
          min-request-size: 2048
        response:
          enabled: true
    ```
- **使用日志级别**：在生产环境中，避免使用`FULL`等详细日志级别，以减少日志输出带来的性能开销。
###### 17. Feign 与 RestTemplate 的区别是什么？

|特性|RestTemplate|Feign|
|---|---|---|
|**编程模型**​|**模板化**，需要手动拼接URL、参数，代码冗余且易错。|**声明式**，通过接口和注解定义，代码简洁直观。|
|**集成度**​|需要显式地使用`@LoadBalanced`注解并结合`DiscoveryClient`才能实现负载均衡。|**原生集成**了Ribbon和负载均衡，开箱即用。|
|**可读性与维护性**​|HTTP请求细节散落在代码中，契约不清晰，维护成本高。|将服务调用契约集中定义在接口中，**可读性和可维护性极佳**。|
|**默认配置**​|相对简单，很多功能需要自行封装。|提供了丰富的默认配置和扩展点（如编码器、解码器、拦截器），功能更全面。|
**结论**：Feign在易用性、可维护性和与Spring Cloud生态的集成度上全面优于`RestTemplate`，是现代微服务开发的首选。
###### 18. Ribbon 和 Feign 的区别？
这是一个常见的理解误区。Ribbon和Feign**不是竞争关系，而是协作关系**。

|组件|核心职责|定位|
|---|---|---|
|**Ribbon**​|**客户端负载均衡**。负责从服务列表中根据规则选择一个目标实例。|**基础设施层**，是负载均衡能力的提供者。|
|**Feign**​|**声明式的HTTP客户端**。旨在简化远程服务调用的编码工作。|**应用层**，是负载均衡能力的使用者。|
**关系**：Feign是一个"上层建筑"，它专注于如何更优雅地描述和发起HTTP调用。而Ribbon是一个"底层基础"，它专注于解决"选择哪个实例"的问题。Feign通过集成Ribbon，将两者能力结合，最终实现了既声明式又具备负载均衡的远程调用。
###### 19. Ribbon 和 Feign 调用服务的区别
从代码层面看，调用方式的区别非常明显：
**使用Ribbon + RestTemplate：**
```java
// 1. 需要配置 @LoadBalanced 的 RestTemplate
@Bean
@LoadBalanced
public RestTemplate restTemplate() {
    return new RestTemplate();
}

// 2. 在Service中注入并使用，需要手动拼接URL
@Service
public class OrderService {
    @Autowired
    private RestTemplate restTemplate;

    public User getUser(Long userId) {
        // 使用服务名，而不是具体IP。Ribbon会拦截请求并做负载均衡。
        return restTemplate.getForObject("http://user-service/users/{id}", User.class, userId);
    }
}
```
**使用Feign：**
```java
// 1. 定义声明式接口
@FeignClient(name = "user-service")
public interface UserServiceClient {
    @GetMapping("/users/{id}")
    User getUser(@PathVariable("id") Long userId);
}

// 2. 在Service中直接注入接口，像调用本地方法一样使用
@Service
public class OrderService {
    @Autowired
    private UserServiceClient userServiceClient; // 直接注入Feign客户端

    public User getUser(Long userId) {
        return userServiceClient.getUser(userId); // 调用远程服务
    }
}
```
Feign的方式无疑更加简洁和类型安全。
###### 20. openFeign 是什么？
**OpenFeign**​ 是 **Spring Cloud 对 Netflix Feign 的增强和封装**，将其无缝集成到Spring Cloud生态系统中。Netflix Feign项目已经进入维护模式，而OpenFeign是当前Spring Cloud中活跃的、推荐使用的版本。
**核心增强包括：**
- **与Spring MVC注解集成**：OpenFeign使用Spring MVC的注解（`@RequestMapping`, `@PathVariable`等），而不是Feign原生的注解，降低了学习成本。
- **支持Spring Cloud 负载均衡**：集成了Spring Cloud LoadBalancer（用于替代Ribbon），提供负载均衡能力。
- **与Spring Cloud 断路器集成**：更容易与Sentinel或Resilience4j等熔断组件集成。
- **自动化配置**：通过`@EnableFeignClients`注解即可自动扫描和配置Feign客户端。
###### 21. Feign 和 openFeign 有什么区别？
可以近似理解为 **"原生Feign"**​ 和 **"Spring Cloud 定制版Feign"**​ 的区别。

|特性|Netflix Feign|OpenFeign (Spring Cloud)|
|---|---|---|
|**注解支持**​|使用Feign原生的注解（如`@RequestLine`）。|**支持Spring MVC注解**（如`@RequestMapping`），对Spring开发者更友好。|
|**集成度**​|需要自行配置与Spring Cloud其他组件的集成。|**深度集成Spring Cloud生态**（服务发现、配置、负载均衡、熔断）。|
|**活跃度**​|已进入维护模式。|**持续活跃更新**，是Spring Cloud官方的一部分。|
**结论**：在Spring Cloud技术栈中，我们使用的都是**OpenFeign**。
###### 22. openFeign 底层内部使用什么通信协议？
OpenFeign的底层通信协议是 **HTTP/HTTPS**。
- **默认实现**：OpenFeign默认使用Java标准库的`HttpURLConnection`作为HTTP客户端来发送请求。
- **可替换性**：如前所述，可以通过引入依赖轻松替换为更高效的HTTP客户端，如OKHttp或Apache HttpClient。但无论底层客户端如何变化，其通信协议始终是HTTP/HTTPS，是一种**基于文本的、应用层的通信协议**。
###### 23. 如何开启 openFeign 日志增强？
OpenFeign的日志级别分为四种：`NONE`（无，默认）、`BASIC`（仅请求方法、URL、响应状态码、执行时间）、`HEADERS`（基础信息+请求/响应头）、`FULL`（全部信息）。
**开启步骤：**
1. **配置类中指定日志级别**：为特定的Feign客户端接口配置日志级别。
    ```java
    @Configuration
    public class FeignConfig {
        @Bean
        Logger.Level feignLoggerLevel() {
            return Logger.Level.FULL; // 在开发或排查问题时使用FULL
        }
    }
    ```
2. **在`application.yml`中启用日志**：由于Feign日志输出量较大，默认不会打印到日志系统（如Logback），需要显式配置。
    ```yaml
    logging:
      level:
        # 将你的Feign客户端接口所在包路径设置为DEBUG级别
        com.yourcompany.service.UserServiceClient: DEBUG
    ```
###### 24. openFeign 如何熔断降级？
OpenFeign通过与熔断器（如Sentinel或Hystrix）集成来实现熔断降级。这里以Sentinel为例（Hystrix已不推荐在新版本中使用）。
**1. 引入依赖**：
```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```
**2. 配置开启Sentinel对Feign的支持**：
```yaml
feign:
  sentinel:
    enabled: true
```
**3. 编写降级逻辑类**（实现Feign客户端接口）：
```java
/**
 * UserServiceClient的降级处理类
 * 必须实现@FeignClient标记的接口，并声明为Spring的Component
 */
@Component
public class UserServiceFallback implements UserServiceClient {
    @Override
    public User getUser(Long userId) {
        // 这里是降级逻辑，例如返回一个默认用户或提示信息
        return new User(-1L, "默认用户", "服务暂时不可用");
    }
}
```
**4. 在Feign客户端上指定降级类**：
```java
@FeignClient(name = "user-service", fallback = UserServiceFallback.class) // 指定降级类
public interface UserServiceClient {
    @GetMapping("/users/{id}")
    User getUser(@PathVariable("id") Long userId);
}
```

当`user-service`调用连续失败达到阈值，熔断器会打开，后续所有请求将不再尝试调用远程服务，而是直接执行`UserServiceFallback.getUser()`方法，实现服务降级，防止雪崩效应。
###### 25. Nacos 中的负载均衡底层是如何实现的？
Nacos本身作为注册中心，其**客户端**（如集成在服务消费者中的Nacos Client）实现了负载均衡的能力。在Spring Cloud Alibaba生态中，这种能力通常通过`Ribbon`（或`Spring Cloud LoadBalancer`）与Nacos的集成来实现。
**底层实现要点：**
1. **服务列表获取与监听**：Nacos客户端（`NacosServiceDiscovery`）会从Nacos Server订阅并定时拉取指定服务的健康实例列表，并缓存在本地。当服务实例上下线时，Nacos Server会主动推送变更通知，保证客户端列表的实时性。
2. **基于权重的负载均衡算法**：Nacos的核心优势之一是支持**基于权重的负载均衡**。Nacos Server可以管理每个服务实例的权重（通过控制台或API动态调整），权重越高，被选中的概率越大。其客户端（如`NacosRule`，是Ribbon的`IRule`接口的一个实现）在选择实例时，会依据权重进行计算。
3. **集群优先与权重结合**：Nacos还支持集群（Cluster）概念。`NacosRule`的策略通常是：
    - **优先同集群实例**：优先选择与消费者在同一个集群（Cluster）内的服务提供者实例。
    - **基于权重随机**：在同集群内，再根据实例的权重进行随机选择。这有效地将流量引导到同一区域内，降低网络延迟，并实现了细粒度的流量控制。
**源码层面**，核心是`NacosRule`类，其`choose`方法实现了上述的负载均衡逻辑。而`Ribbon`的`ZoneAvoidanceRule`等标准规则也同样适用。