###### 1. 什么是分布式链路追踪？
分布式链路追踪是用于**分析和监控分布式系统**的技术，特别适用于微服务架构。它通过记录请求在分布式系统中流转的完整路径，将一次分布式请求还原成调用链路，实现请求的全程追踪和可视化 。
**核心思想**源于Google的Dapper论文，主要包含两个关键概念：**追踪（Trace）**​ 和**跨度（Span）**​ 。Trace代表从客户端发起请求到收到响应的完整过程，Span则代表请求流经的每个服务节点的一次调用过程 。
**技术本质**是通过唯一的TraceID将分散在不同服务中的日志信息串联起来，形成完整的调用链视图。在微服务架构中，一个外部请求可能需要多个服务协同处理，链路追踪为这种复杂交互提供了清晰的"DNA序列"，让开发人员能够像调试单体应用一样管理分布式系统 。
###### 2. 为什么需要链路追踪？
随着微服务架构的普及，系统复杂性急剧增加，传统监控手段已无法满足需求。需要链路追踪的核心原因包括：
**故障定位困难**：在分布式系统中，一个请求可能涉及多个服务，当出现问题时，传统日志分析需要人工关联多个服务的日志，效率极低。链路追踪通过TraceID快速定位问题服务，将故障平均修复时间（MTTR）降低70%以上 。
**性能分析瓶颈**：无法准确识别系统中的性能瓶颈。通过Span的耗时统计，可以精确分析每个服务的处理时间，找出性能热点 。
**依赖关系不清晰**：随着服务数量增加，服务间的依赖关系变得复杂，难以理清调用关系。链路追踪可以自动生成服务依赖图，帮助架构优化 。
**事务追踪复杂**：分布式事务涉及多个服务，传统方式难以追踪完整的事务生命周期。链路追踪提供了完整的事务流转视图 。
###### 3. 什么是 Spring Cloud Sleuth？
Spring Cloud Sleuth是Spring Cloud生态系统中的**分布式链路追踪解决方案**，为微服务调用链提供自动化的追踪支持 。
**核心定位**是作为链路追踪器，与Zipkin配合使用，其中Sleuth负责生成和传播追踪数据，Zipkin负责数据分析和可视化 。Sleuth采用无侵入式设计，通过简单的依赖引入即可自动集成到Spring Boot应用中，无需修改业务代码 。
**核心功能**包括：
- **自动追踪ID生成**：为每个请求生成唯一的TraceID和SpanID
- **上下文传播**：通过HTTP头、消息头等方式自动传播追踪信息
- **组件集成**：支持Spring MVC、WebFlux、RestTemplate、Feign等常用组件
- **日志集成**：通过MDC机制将TraceID注入日志，便于日志关联
###### 4. Spring Cloud Sleuth 的工作原理是什么？
Sleuth通过**自动配置和拦截器机制**实现分布式追踪，核心工作原理如下：
**追踪信息生成**：当请求进入系统时，Sleuth的`TraceFilter`或对应的Web框架拦截器会检查请求头是否包含追踪信息。如果没有，则生成新的TraceID和Root Span；如果存在，则继承现有的追踪上下文 
**追踪信息传播**：在服务间调用时，Sleuth通过`TraceInterceptor`拦截出站请求，自动将追踪信息添加到请求头中。对于HTTP调用，使用B3标准格式的头部信息：
```http
X-B3-TraceId: 0af7651916cd43dd8448eb211c80319c
X-B3-SpanId: 0af7651916cd43dd
X-B3-ParentSpanId: 0000000000000000
```
**异步上下文传递**：对于异步操作，Sleuth使用`LazyTraceExecutor`等包装器，确保Trace上下文在不同线程间正确传递。这基于SLF4J的MDC机制和Spring的`ThreadLocal`实现 。
**数据报告**：收集的Span数据通过`ZipkinSender`异步报告给Zipkin服务器，采用HTTP或消息队列方式传输，避免阻塞业务线程 。
###### 5. Sleuth 的核心概念有哪些（Trace、Span）？
**Trace（追踪）**：代表一次完整的请求链路，包含唯一的TraceID。例如，用户下单请求从网关开始，经过认证服务、订单服务、库存服务等，这些调用共同构成一个Trace 。
**Span（跨度）**：Trace中的基本工作单元，代表一个服务内部的具体操作。每个Span包含：
- SpanID：当前Span的唯一标识
- ParentSpanID：父Span的标识，用于构建调用树
- Name：操作名称（如方法名或API路径）
- Timestamp：开始时间戳
- Duration：持续时间
- Tags：键值对标签，用于记录附加信息
**Annotation（注解）**：记录特定时间点的事件，主要用于时序分析：
- cs（Client Send）：客户端发送请求
- sr（Server Receive）：服务端接收请求
- ss（Server Send）：服务端发送响应
- cr（Client Receive）：客户端接收响应
**Baggage（行李）**：跨服务传递的自定义数据，存储在SpanContext中，会在整个Trace中传递，但会影响性能，需谨慎使用 。
###### 6. 什么是 Zipkin？
Zipkin是Twitter开源的**分布式追踪系统**，致力于收集服务的定时数据，以解决微服务架构中的延迟问题 。它基于Google Dapper论文实现，提供数据的收集、存储、查找和展现功能 。
**核心价值**在于提供了可视化的追踪控制台，让开发者可以通过Web前端轻松收集和分析数据，例如用户每次请求服务的处理时间等，方便监测系统中存在的瓶颈 。Zipkin分为服务端和客户端，客户端集成在微服务中收集数据，服务端负责数据聚合和展示 。
###### 7. Zipkin 如何与 Spring Cloud 集成？
Zipkin与Spring Cloud的集成主要通过Sleuth完成，具体步骤如下：
**依赖配置**：在微服务项目中添加Sleuth和Zipkin依赖：
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zipkin</artifactId>
</dependency>
```
**配置设置**：在application.yml中配置Zipkin服务器地址和采样率：
```yaml
spring:
  zipkin:
    base-url: http://localhost:9411
  sleuth:
    sampler:
      probability: 1.0 # 采样率，1.0表示100%采集 [8](@ref)
```
**数据流流程**：
1. 应用启动时，Sleuth自动配置追踪组件
2. 请求到达时，Sleuth生成追踪数据并注入MDC
3. 服务间调用时，通过HTTP头自动传播追踪上下文
4. Span数据异步批量发送到Zipkin服务器
5. Zipkin进行数据存储和索引，提供Web界面查询
###### 8. Zipkin 的架构组件有哪些？
Zipkin采用模块化设计，包含四个核心组件：
**Collector（收集器）**：负责接收从各个微服务发送过来的追踪数据，进行验证和存储前处理。支持HTTP和Kafka等多种数据接收方式 。
**Storage（存储器）**：提供可插拔的存储后端支持：
- In-Memory：默认存储，适用于测试环境，重启后数据丢失
- MySQL：关系型存储，适合中小规模部署
- Elasticsearch：分布式搜索引擎，支持大规模数据存储和快速查询
- Cassandra：分布式NoSQL数据库，适合高吞吐量场景
**Query Service（查询服务）**：提供RESTful API用于查询追踪数据，支持按TraceID、服务名、时间范围等条件查询 。
**Web UI（用户界面）**：基于浏览器的可视化界面，提供依赖图、时间线瀑布图等可视化组件，支持追踪数据的交互式探索 。
###### 9. 链路追踪的采样策略有哪些？
采样是平衡追踪开销和数据完整性的关键机制，常用策略包括：
**恒定采样（Constant Sampling）**：按固定比例采样，如1%或10%。配置简单，但无法适应流量波动 。
**速率限制采样（Rate Limiting Sampling）**：限制每秒采样的Trace数量，避免高流量时过度采样。如每秒最多采样100个Trace 。
**自适应采样（Adaptive Sampling）**：根据系统负载和历史数据动态调整采样率，在保证数据代表性的同时控制开销 。
**针对性采样（Targeted Sampling）**：对特定重要路径或异常请求进行全量采样，确保关键业务的可观测性 。
在Sleuth中，采样器通过`Sampler`接口实现，可以自定义采样逻辑：
```java
@Bean 
public Sampler customSampler() {
    return new Sampler() {
        @Override
        public boolean isSampled(TraceContext traceContext) {
            // 自定义采样逻辑
            return Math.random() < 0.5; // 50%采样率
        }
    };
}
```
###### 10. SkyWalking 与 Zipkin 的区别是什么？

|**特性维度**​|**Zipkin**​|**SkyWalking**​|
|---|---|---|
|**数据模型**​|基于Dapper的树形模型|扩展的图形模型，支持批处理和复杂依赖|
|**接入方式**​|依赖SDK集成，代码侵入性较高|基于Java Agent字节码增强，真正无侵入|
|**功能范围**​|专注于分布式追踪|集成追踪、指标、日志的完整APM系统|
|**扩展性**​|组件相对固定，扩展性有限|插件化架构，支持多种组件自动追踪|
|**UI功能**​|界面相对简单，专注于链路展示|功能丰富的仪表盘，支持拓扑图、性能矩阵等|
|**存储支持**​|支持Memory、MySQL、ES、Cassandra|原生支持ES、H2、MySQL等|
|**社区生态**​|成熟稳定，但发展相对缓慢|活跃的Apache项目，快速迭代|
**技术选型建议**：对于Spring Cloud技术栈且主要需要基本链路追踪的场景，Zipkin+Sleuth组合足够使用。如果需要完整的APM能力、对代码无侵入有要求，或存在批处理等复杂场景，SkyWalking是更好的选择 。