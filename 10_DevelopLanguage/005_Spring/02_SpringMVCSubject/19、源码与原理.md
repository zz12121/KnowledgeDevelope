###### 1. DispatcherServlet 的源码分析
DispatcherServlet 是 SpringMVC 的**前端控制器**，作为整个框架的请求处理中枢，其设计体现了经典的责任链模式。从其继承体系来看：`HttpServlet`→ `HttpServletBean`→ `FrameworkServlet`→ `DispatcherServlet`。
**核心初始化过程**在 `initStrategies()`方法中实现，该方法会在 WebApplicationContext 刷新时回调：
```java
protected void initStrategies(ApplicationContext context) {
    initMultipartResolver(context);      // 文件上传解析器
    initLocaleResolver(context);         // 本地化解析器
    initThemeResolver(context);          // 主题解析器
    initHandlerMappings(context);        // 处理器映射器
    initHandlerAdapters(context);        // 处理器适配器
    initHandlerExceptionResolvers(context); // 异常解析器
    initRequestToViewNameTranslator(context); // 视图名转换器
    initViewResolvers(context);          // 视图解析器
    initFlashMapManager(context);        // FlashMap管理器
}
```
**请求处理核心流程**在 `doDispatch()`方法中：
```java
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    
    try {
        // 1. 检查并处理文件上传请求
        processedRequest = checkMultipart(request);
        
        // 2. 获取处理执行链（包含处理器和拦截器）
        mappedHandler = getHandler(processedRequest);
        if (mappedHandler == null) {
            noHandlerFound(processedRequest, response);
            return;
        }
        
        // 3. 获取处理器适配器
        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
        
        // 4. 执行拦截器preHandle方法
        if (!mappedHandler.applyPreHandle(processedRequest, response)) {
            return;
        }
        
        // 5. 实际处理器执行（核心业务逻辑）
        ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
        
        // 6. 执行拦截器postHandle方法
        mappedHandler.applyPostHandle(processedRequest, response, mv);
        
        // 7. 处理渲染结果
        processDispatchResult(processedRequest, response, mappedHandler, mv, null);
    } catch (Exception ex) {
        processDispatchResult(processedRequest, response, mappedHandler, null, ex);
    }
}
```
###### 2. HandlerMapping 的实现原理是什么?
HandlerMapping 负责建立**请求URL与处理器方法的映射关系**，其核心接口只有一个方法：
```java
public interface HandlerMapping {
    HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;
}
```
**实现层次结构**主要分为两个分支：
- **AbstractUrlHandlerMapping**：基于URL路径映射到Controller类级别
- **AbstractHandlerMethodMapping**：基于方法级别的精细映射（现代SpringMVC主流方式）
**RequestMappingHandlerMapping 的工作流程**：
1. **初始化阶段**：通过 `detectHandlerMethods()`方法扫描所有带有 `@Controller`注解的Bean
2. **映射注册**：将每个带有 `@RequestMapping`的方法封装为 `HandlerMethod`对象，并建立映射关系
3. **请求匹配**：通过 `lookupHandlerMethod()`方法查找最佳匹配的处理器方法
**源码关键实现**：
```java
protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {
    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
    this.mappingRegistry.acquireReadLock();
    try {
        // 查找最佳匹配的处理器方法
        HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);
        return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null);
    } finally {
        this.mappingRegistry.releaseReadLock();
    }
}
```
###### 3. HandlerAdapter 的实现原理是什么?
HandlerAdapter 是**处理器执行策略**的抽象，解决了不同类型处理器统一调用的问题。
**核心接口设计**：
```java
public interface HandlerAdapter {
    boolean supports(Object handler); // 是否支持该处理器
    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;
    long getLastModified(HttpServletRequest request, Object handler);
}
```
**主要实现类及其作用**：
- **RequestMappingHandlerAdapter**：处理基于 `@RequestMapping`注解的方法（最常用）
- **SimpleControllerHandlerAdapter**：处理实现 Controller 接口的处理器
- **HttpRequestHandlerAdapter**：处理 HttpRequestHandler 接口的实现
**RequestMappingHandlerAdapter 的核心执行流程**：
```java
public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    return handleInternal(request, response, (HandlerMethod) handler);
}

protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
    // 1. 参数解析和数据绑定
    // 2. 执行处理器方法
    // 3. 返回值处理
}
```
###### 4. 参数解析器的工作原理是什么?
参数解析器通过 **HandlerMethodArgumentResolver**​ 接口实现，采用责任链模式处理各种类型的参数。
**核心接口**：
```java
public interface HandlerMethodArgumentResolver {
    boolean supportsParameter(MethodParameter parameter); // 是否支持该参数
    Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
                          NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception;
}
```
**常见参数解析器实现**：
- **RequestParamMethodArgumentResolver**：处理 `@RequestParam`注解
- **PathVariableMethodArgumentResolver**：处理 `@PathVariable`注解
- **RequestBodyArgumentResolver**：处理 `@RequestBody`注解
- **ModelAttributeMethodProcessor**：处理 `@ModelAttribute`注解
**执行流程**在 `InvocableHandlerMethod`中实现：
```java
public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
    // 获取方法参数值
    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
    
    // 通过反射调用目标方法
    return doInvoke(args);
}
```
###### 5. 返回值处理器的工作原理是什么?
返回值处理器通过 **HandlerMethodReturnValueHandler**​ 接口实现，统一处理各种类型的返回值。
**核心接口**：
```java
public interface HandlerMethodReturnValueHandler {
    boolean supportsReturnType(MethodParameter returnType); // 是否支持该返回类型
    void handleReturnValue(Object returnValue, MethodParameter returnType,
                          ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;
}
```
**重要实现类**：
- **ModelAndViewMethodReturnValueHandler**：处理 ModelAndView 返回值
- **ViewNameMethodReturnValueHandler**：处理视图名称字符串
- **RequestResponseBodyMethodProcessor**：处理 `@ResponseBody`注解的方法
**@ResponseBody 的处理机制**：
```java
public void handleReturnValue(Object returnValue, MethodParameter returnType,
                             ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
    // 标记请求已处理
    mavContainer.setRequestHandled(true);
    
    // 使用 HttpMessageConverter 进行消息转换
    writeWithMessageConverters(returnValue, returnType, webRequest);
}
```
###### 6. SpringMVC 的九大组件是什么?
SpringMVC 的九大组件构成了完整的Web请求处理体系，通过 `initStrategies()`方法初始化：
1. **MultipartResolver**：文件上传解析器，将 multipart 请求转换为 `MultipartHttpServletRequest`
2. **LocaleResolver**：本地化解析器，支持国际化处理
3. **ThemeResolver**：主题解析器，支持UI主题切换
4. **HandlerMapping**：处理器映射器，建立请求与处理器的映射关系
5. **HandlerAdapter**：处理器适配器，统一不同类型处理器的执行方式
6. **HandlerExceptionResolver**：异常解析器，统一处理执行过程中抛出的异常
7. **RequestToViewNameTranslator**：视图名转换器，当处理器未返回视图名时生成默认视图名
8. **ViewResolver**：视图解析器，将逻辑视图名解析为具体视图实现
9. **FlashMapManager**：Flash属性管理器，用于重定向时的参数传递
**组件协同工作流程**：
- 请求进入 DispatcherServlet 后，首先由 HandlerMapping 查找对应的处理器
- HandlerAdapter 负责执行处理器，期间使用参数解析器进行数据绑定
- 执行完成后，返回值处理器对结果进行处理
- 如果发生异常，由 HandlerExceptionResolver 统一处理
- 最终通过 ViewResolver 进行视图渲染