###### 1. SpringMVC 的性能优化方法有哪些?
SpringMVC的性能优化是一个系统工程，需要从**请求处理链路**的多个环节进行深度优化。以下是从源码角度分析的核心优化策略。
**1. 优化HandlerMapping匹配效率（核心瓶颈）**
SpringMVC处理请求时，最大的性能损耗来源于**HandlerMethod的查找过程**。当使用RESTful风格（特别是带有`@PathVariable`）时，性能问题尤为突出。
**源码级问题分析：**
```java
// 在AbstractHandlerMethodMapping中查找处理器的核心逻辑
public class AbstractHandlerMethodMapping<T> extends AbstractHandlerMapping {
    protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {
        String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
        
        // 问题点：先尝试直接匹配，失败后遍历所有映射进行Ant路径匹配
        List<T> directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);
        if (directPathMatches == null || directPathMatches.isEmpty()) {
            // 性能瓶颈：需要遍历所有注册的映射进行模式匹配
            addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request);
        }
    }
}
```
当URL中包含路径变量（如`/users/{id}`）时，无法通过直接匹配找到处理器，必须进行**全量映射遍历**，使用`AntPathMatcher`进行复杂的模式匹配，时间复杂度从O(1)退化到O(n)。
**优化方案：自定义映射策略**
```java
// 方案1：实现基于唯一标识符的O(1)查找
public class CustomHandlerMapping extends RequestMappingHandlerMapping {
    private final Map<String, HandlerMethod> handlerMethodMap = new ConcurrentHashMap<>();
    
    @Override
    protected HandlerMethod getHandlerInternal(HttpServletRequest request) {
        // 从请求头获取唯一服务标识，避免路径匹配
        String serviceId = request.getHeader("X-Service-Id");
        if (StringUtils.hasText(serviceId)) {
            HandlerMethod handler = handlerMethodMap.get(serviceId);
            if (handler != null) return handler;
        }
        // 降级到默认匹配逻辑
        return super.getHandlerInternal(request);
    }
    
    @Override
    protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {
        super.registerHandlerMethod(handler, method, mapping);
        // 建立服务标识与处理器的映射
        String serviceId = mapping.getName(); // 使用@RequestMapping的name属性
        if (StringUtils.hasText(serviceId)) {
            handlerMethodMap.put(serviceId, createHandlerMethod(handler, method));
        }
    }
}
```
**2. 启用异步处理提升吞吐量**
对于IO密集型操作，使用异步处理可以**显著提升线程池利用率**，避免阻塞请求线程。
```java
@RestController
public class AsyncController {
    
    @GetMapping("/async-data")
    public Callable<ResponseEntity<Data>> getAsyncData() {
        return () -> {
            // 在异步线程中执行，释放容器线程
            Data data = expensiveService.calculateExpensiveData();
            return ResponseEntity.ok(data);
        };
    }
    
    @GetMapping("/deferred-result")
    public DeferredResult<ResponseEntity<Data>> getDeferredResult() {
        DeferredResult<ResponseEntity<Data>> deferredResult = new DeferredResult<>(5000L);
        
        // 外部事件触发结果设置（如消息队列、定时任务）
        eventPublisher.registerCallback(data -> {
            deferredResult.setResult(ResponseEntity.ok(data));
        });
        
        deferredResult.onTimeout(() -> {
            deferredResult.setErrorResult(ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT).build());
        });
        
        return deferredResult;
    }
}
```
**3. 合理配置组件参数**
```java
@Configuration
public class WebMvcOptimizationConfig implements WebMvcConfigurer {
    
    // 优化视图解析缓存
    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setCache(true); // 生产环境开启缓存
        resolver.setCacheLimit(100); // 设置缓存大小
        return resolver;
    }
    
    // 静态资源缓存优化
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/static/**")
                .addResourceLocations("classpath:/static/")
                .setCacheControl(CacheControl.maxAge(30, TimeUnit.DAYS));
    }
    
    // 文件上传配置优化
    @Bean
    public MultipartResolver multipartResolver() {
        CommonsMultipartResolver resolver = new CommonsMultipartResolver();
        resolver.setMaxUploadSize(10485760); // 10MB
        resolver.setMaxInMemorySize(40960);   // 40KB后写入磁盘
        return resolver;
    }
}
```
**4. 应用级别缓存策略**
```java
@Service
public class UserService {
    
    @Cacheable(value = "users", key = "#id", unless = "#result == null")
    public User getUserById(Long id) {
        // 数据库查询，结果自动缓存
        return userRepository.findById(id);
    }
    
    @CacheEvict(value = "users", key = "#user.id")
    public void updateUser(User user) {
        userRepository.update(user);
    }
}
```

通过这些优化措施，特别是解决HandlerMapping匹配的性能瓶颈，可以显著提升SpringMVC应用的处理能力。
###### 2. 如何避免重复提交?
防止重复提交是Web应用的关键需求，以下是基于**Token机制**和**业务层面**的完整解决方案。
**1. Token机制实现（推荐方案）**
Token机制的核心思想是**一次一证**，每次表单生成唯一令牌，提交后立即失效。
**自定义防重提交注解：**
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PreventDuplicateSubmit {
    String key() default "";          // 业务标识key
    int expireTime() default 3;       // 令牌过期时间（秒）
    String message() default "请勿重复提交";
}
```
**拦截器实现核心逻辑：**
```java
@Component
public class DuplicateSubmitInterceptor extends HandlerInterceptorAdapter {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, Object handler) throws Exception {
        
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            Method method = handlerMethod.getMethod();
            
            PreventDuplicateSubmit annotation = method.getAnnotation(PreventDuplicateSubmit.class);
            if (annotation != null) {
                String tokenKey = buildTokenKey(request, annotation);
                String clientToken = request.getHeader("X-Submit-Token");
                
                if (!isValidToken(tokenKey, clientToken)) {
                    throw new DuplicateSubmitException(annotation.message());
                }
                // 验证通过，立即删除令牌
                redisTemplate.delete(tokenKey);
            }
        }
        return true;
    }
    
    private String buildTokenKey(HttpServletRequest request, PreventDuplicateSubmit annotation) {
        String sessionId = request.getSession().getId();
        String key = StringUtils.hasText(annotation.key()) ? 
            annotation.key() : request.getRequestURI();
        return "submit:token:" + sessionId + ":" + key;
    }
    
    private boolean isValidToken(String tokenKey, String clientToken) {
        if (!StringUtils.hasText(clientToken)) return false;
        
        String serverToken = (String) redisTemplate.opsForValue().get(tokenKey);
        return clientToken.equals(serverToken);
    }
}
```
**令牌生成接口：**
```java
@RestController
public class TokenController {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @GetMapping("/token")
    public ResponseEntity<TokenResponse> generateToken(HttpServletRequest request) {
        String token = UUID.randomUUID().toString();
        String sessionId = request.getSession().getId();
        String tokenKey = "submit:token:" + sessionId + ":" + request.getRequestURI();
        
        // 令牌3秒有效
        redisTemplate.opsForValue().set(tokenKey, token, Duration.ofSeconds(3));
        
        return ResponseEntity.ok(new TokenResponse(token));
    }
}
```
**前端集成示例：**
```html
<script>
// 获取提交令牌
async function getSubmitToken() {
    const response = await fetch('/token');
    const data = await response.json();
    return data.token;
}

// 提交表单
async function submitForm(formData) {
    const token = await getSubmitToken();
    
    const response = await fetch('/submit', {
        method: 'POST',
        headers: {
            'X-Submit-Token': token,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(formData)
    });
    
    if (response.status === 400) {
        alert('请勿重复提交');
        return;
    }
    // 处理正常响应
}
</script>
```
**2. 业务层面防重（兜底方案）**
```java
@Service
public class OrderService {
    
    @PreventDuplicateSubmit(key = "'order:' + #orderDTO.uniqueId")
    public Order createOrder(OrderDTO orderDTO) {
        // 幂等性检查（数据库层面）
        Order existing = orderRepository.findByUniqueId(orderDTO.getUniqueId());
        if (existing != null) {
            return existing; // 返回已存在的订单
        }
        
        // 创建新订单
        return orderRepository.save(Order.fromDTO(orderDTO));
    }
}
```
**3. 前端防重辅助**
```javascript
// 按钮防重复点击
function preventDuplicateClick(button) {
    button.disabled = true;
    button.textContent = '提交中...';
    
    // 3秒后恢复
    setTimeout(() => {
        button.disabled = false;
        button.textContent = '提交';
    }, 3000);
}
```
这种多层次防重方案确保了即使在网络延迟、用户重复点击等场景下，系统也能保持数据一致性。
###### 3. 如何实现请求幂等性?
幂等性是分布式系统设计的核心要求，确保**同一操作执行多次产生的结果与执行一次相同**。
**1. 基于Token的幂等性实现**
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
    String key() default "";          // 幂等键表达式
    long expireTime() default 3600;   // 令牌过期时间
    String message() default "重复请求";
}

@Component
public class IdempotentAspect {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Around("@annotation(idempotent)")
    public Object checkIdempotent(ProceedingJoinPoint joinPoint, Idempotent idempotent) throws Throwable {
        String idempotentKey = generateKey(joinPoint, idempotent);
        
        // 使用SETNX原子操作
        Boolean success = redisTemplate.opsForValue()
            .setIfAbsent(idempotentKey, "processing", Duration.ofSeconds(idempotent.expireTime()));
        
        if (Boolean.FALSE.equals(success)) {
            throw new IdempotentException(idempotent.message());
        }
        
        try {
            return joinPoint.proceed();
        } finally {
            // 可选：根据业务需求决定是否保留令牌
            // redisTemplate.delete(idempotentKey);
        }
    }
    
    private String generateKey(ProceedingJoinPoint joinPoint, Idempotent idempotent) {
        // 支持SpEL表达式，如: 'order:' + #orderNo
        if (StringUtils.hasText(idempotent.key())) {
            Expression expression = parser.parseExpression(idempotent.key());
            String dynamicKey = expression.getValue(context, String.class);
            return "idempotent:" + dynamicKey;
        }
        
        // 默认key：方法签名+参数hash
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        String method = signature.getMethod().toString();
        String argsHash = DigestUtils.md5Hex(Arrays.toString(joinPoint.getArgs()));
        return "idempotent:" + method + ":" + argsHash;
    }
}
```
**2. 数据库层面幂等性控制**
```java
@Entity
@Table(name = "orders")
public class Order {
    @Id
    private String id;
    
    @Column(unique = true)  // 数据库唯一约束
    private String orderNo;
    
    @Enumerated(EnumType.STRING)
    private OrderStatus status;
    
    // 乐观锁版本控制
    @Version
    private Long version;
    
    public enum OrderStatus {
        CREATED, PROCESSING, COMPLETED, FAILED
    }
    
    // 状态机校验确保幂等
    public void updateStatus(OrderStatus newStatus) {
        if (this.status == newStatus) {
            return; // 相同状态直接返回
        }
        
        if (!isValidTransition(this.status, newStatus)) {
            throw new IllegalStateException("无效状态转换");
        }
        
        this.status = newStatus;
    }
}
```
**3. 分布式锁实现集群幂等**
```java
@Service
public class DistributedIdempotentService {
    
    @Autowired
    private RedissonClient redissonClient;
    
    public <T> T executeWithIdempotent(String key, Supplier<T> supplier, long expireTime) {
        RLock lock = redissonClient.getLock("idempotent:lock:" + key);
        
        try {
            // 尝试获取锁，避免并发执行
            if (lock.tryLock(0, expireTime, TimeUnit.SECONDS)) {
                // 检查是否已处理
                if (isRequestProcessed(key)) {
                    return getPreviousResult(key);
                }
                
                markRequestProcessing(key);
                T result = supplier.get();
                saveRequestResult(key, result);
                return result;
            }
            throw new IdempotentException("系统繁忙，请重试");
        } finally {
            lock.unlock();
        }
    }
}
```
**4. HTTP幂等性最佳实践**
```java
@RestController
public class IdempotentController {
    
    // GET：天然幂等，适合查询
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    // PUT：幂等更新
    @PutMapping("/users/{id}")
    public User updateUser(@PathVariable Long id, @RequestBody User user) {
        user.setId(id); // 确保ID一致性
        return userService.update(user);
    }
    
    // DELETE：幂等删除
    @DeleteMapping("/users/{id}")
    public void deleteUser(@PathVariable Long id) {
        userService.deleteById(id); // 多次删除结果相同
    }
    
    // POST非幂等，需要额外控制
    @PostMapping("/orders")
    @Idempotent(key = "'order:' + #orderDTO.uniqueId", expireTime = 3600)
    public Order createOrder(@RequestBody OrderDTO orderDTO) {
        return orderService.createOrder(orderDTO);
    }
}
```
通过多层次幂等性保障，可以构建出健壮的分布式系统，有效应对网络重试、客户端重复提交等场景。
###### 4. SpringMVC 的最佳实践有哪些?
SpringMVC的最佳实践涵盖**配置优化、架构设计、代码规范**等多个维度，以下是基于生产环境经验的总结。
**1. 配置与架构最佳实践**
```java
@Configuration
@EnableWebMvc
public class WebMvcBestPracticeConfig implements WebMvcConfigurer {
    
    // 统一异常处理
    @Override
    public void configureHandlerExceptionResolvers(
            List<HandlerExceptionResolver> resolvers) {
        resolvers.add(0, new CustomExceptionResolver());
    }
    
    // 日期时间格式化统一配置
    @Override
    public void addFormatters(FormatterRegistry registry) {
        DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
        registrar.setUseIsoFormat(true);
        registrar.registerFormatters(registry);
    }
    
    // 静态资源优化
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("/public/", "classpath:/static/")
                .setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));
    }
    
    // 跨域配置
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("https://trusted-domain.com")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```
**2. 控制器层最佳实践**
```java
@Validated
@RestController
@RequestMapping("/api/v1")  // API版本化
public class UserController {
    
    // 使用明确的HTTP方法注解
    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUser(@PathVariable @Min(1) Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);  // 明确的状态码返回
    }
    
    // 参数验证与错误处理
    @PostMapping("/users")
    public ResponseEntity<User> createUser(@Valid @RequestBody UserCreateDTO dto) {
        User user = userService.create(dto);
        URI location = ServletUriComponentsBuilder.fromCurrentRequest()
                .path("/{id}").buildAndExpand(user.getId()).toUri();
        
        return ResponseEntity.created(location).body(user);  // 201 Created
    }
    
    // 分页查询标准化
    @GetMapping("/users")
    public PageResponse<User> getUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(required = false) String sort) {
        
        Pageable pageable = PageRequest.of(page, size, Sort.by(parseSort(sort)));
        return userService.findUsers(pageable);
    }
}
```
**3. 全局异常处理标准化**
```java
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {
    
    private final Logger logger = LoggerFactory.getLogger(getClass());
    
    // 业务异常处理
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
        logger.warn("业务异常: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse("BUSINESS_ERROR", ex.getMessage()));
    }
    
    // 数据验证异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            MethodArgumentNotValidException ex) {
        
        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .collect(Collectors.toList());
        
        return ResponseEntity.badRequest()
                .body(new ErrorResponse("VALIDATION_ERROR", errors));
    }
    
    // 系统异常
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleSystemException(Exception ex) {
        logger.error("系统异常: ", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorResponse("SYSTEM_ERROR", "系统繁忙，请稍后重试"));
    }
}
```
**4. 性能与安全最佳实践**
```java
@Component
public class SecurityBestPractices {
    
    // SQL注入防护（使用MyBatis参数绑定）
    @Select("SELECT * FROM users WHERE id = #{id}")  // 使用#{}而非${}
    User findById(@Param("id") Long id);
    
    // XSS防护
    @Bean
    public FilterRegistrationBean<XssFilter> xssFilter() {
        FilterRegistrationBean<XssFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new XssFilter());
        registration.addUrlPatterns("/*");
        return registration;
    }
}

// 请求日志记录（AOP实现）
@Aspect
@Component
@Slf4j
public class RequestLogAspect {
    
    @Around("@within(org.springframework.web.bind.annotation.RestController)")
    public Object logRequest(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        
        try {
            Object result = joinPoint.proceed();
            long cost = System.currentTimeMillis() - startTime;
            
            log.info("请求处理完成: {} - {}ms", 
                    joinPoint.getSignature().getName(), cost);
            return result;
        } catch (Exception ex) {
            log.error("请求处理异常: {}", joinPoint.getSignature().getName(), ex);
            throw ex;
        }
    }
}
```
**5. 测试最佳实践**
```java
@SpringBootTest
@AutoConfigureTestDatabase
class UserControllerTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    void shouldGetUserById() {
        ResponseEntity<User> response = restTemplate
                .getForEntity("/api/v1/users/1", User.class);
        
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().getName()).isNotNull();
    }
    
    @Test
    void shouldReturn404WhenUserNotFound() {
        ResponseEntity<ErrorResponse> response = restTemplate
                .getForEntity("/api/v1/users/999", ErrorResponse.class);
        
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
    }
}
```