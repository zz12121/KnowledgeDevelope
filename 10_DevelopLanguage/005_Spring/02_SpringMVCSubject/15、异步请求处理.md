###### 1. SpringMVC 如何支持异步请求?
SpringMVC对异步请求的支持建立在**Servlet 3.0规范**的异步处理能力之上，并通过**分层架构**和**回调机制**实现了完整的异步处理解决方案。
**核心架构层次：**

1. **Servlet容器层配置**：必须在web.xml或Servlet初始化器中启用异步支持
```xml
<web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee">
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <async-supported>true</async-supported>  <!-- 关键配置 -->
    </servlet>
</web-app>
```
1. **Spring MVC配置层**：通过`@EnableWebMvc`或XML配置异步支持参数
```java
@Configuration
@EnableWebMvc
public class AsyncConfig implements WebMvcConfigurer {
    @Override
    public void configureAsyncSupport(AsyncSupportConfigurer configurer) {
        configurer.setDefaultTimeout(30000L);  // 默认超时30秒
        configurer.setTaskExecutor(taskExecutor());  // 自定义线程池
    }
    
    @Bean
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(50);
        return executor;
    }
}
```
1. **控制器层实现**：支持返回`Callable`、`DeferredResult`、`WebAsyncTask`等异步类型
**源码级支持机制：**
Spring MVC通过`WebAsyncManager`作为异步处理的核心管理器，在`DispatcherServlet`的`doDispatch`方法中实现异步检测和处理：
```java
public class DispatcherServlet extends FrameworkServlet {
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) {
        // 检查是否启动异步处理
        if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
            return;  // 已启动异步处理，直接返回
        }
        
        // 正常同步处理流程...
    }
}
```
当控制器返回异步类型时，`RequestMappingHandlerAdapter`会通过相应的`HandlerMethodReturnValueHandler`实现类（如`CallableMethodReturnValueHandler`、`DeferredResultMethodReturnValueHandler`）来启动异步处理流程。
###### 2. Callable 和 DeferredResult 的作用是什么?
`Callable`和`DeferredResult`是Spring MVC异步处理的**两种核心编程模型**，虽然目标相同（实现异步响应），但在控制机制和适用场景上有重要差异。
**Callable - 内部线程池模型**
```java
@RestController
public class AsyncController {
    
    @GetMapping("/async/callable")
    public Callable<String> handleWithCallable() {
        return new Callable<String>() {
            @Override
            public String call() throws Exception {
                // 在Spring管理的线程池中执行
                Thread.sleep(2000);  // 模拟耗时操作
                return "Callable result after 2 seconds";
            }
        };
    }
}
```
**源码执行流程：**
1. 控制器返回`Callable`对象
2. `CallableMethodReturnValueHandler`检测到返回类型，调用`WebAsyncManager.startCallableProcessing()`
3. Spring使用配置的`TaskExecutor`在新线程中执行`Callable.call()`方法
4. 执行完成后，Spring将结果重新分派回DispatcherServlet进行后续处理
**DeferredResult - 外部事件驱动模型**
```java
@RestController
public class AsyncController {
    private final Queue<DeferredResult<String>> resultQueue = new ConcurrentLinkedQueue<>();
    
    @GetMapping("/async/deferred")
    public DeferredResult<String> handleWithDeferred() {
        DeferredResult<String> deferredResult = new DeferredResult<>(5000L, "Timeout result");
        
        // 设置回调
        deferredResult.onTimeout(() -> {
            deferredResult.setErrorResult("Operation timeout");
        });
        
        deferredResult.onCompletion(() -> {
            resultQueue.remove(deferredResult);
        });
        
        resultQueue.add(deferredResult);
        return deferredResult;
    }
    
    // 外部事件触发结果设置
    @PostMapping("/trigger")
    public String triggerResult(@RequestParam String data) {
        for (DeferredResult<String> result : resultQueue) {
            result.setResult("Processed: " + data);
        }
        return "Triggered all deferred results";
    }
}
```
**核心差异对比：**

|**特性**​|**Callable**​|**DeferredResult**​|
|---|---|---|
|**控制权**​|Spring管理线程执行|应用代码控制结果设置|
|**执行线程**​|Spring配置的TaskExecutor|任意线程（包括外部系统线程）|
|**适用场景**​|内部耗时任务|外部事件响应（消息队列、长时间轮询）|
|**超时控制**​|通过WebAsyncTask包装|内置超时机制|
|**结果来源**​|当前应用内部计算|跨应用、跨线程事件|
**设计价值**：`DeferredResult`实现了**请求线程与结果生产线程的完全解耦**，特别适合需要跨系统协作的异步场景。
###### 3. @Async 注解在 SpringMVC 中的应用是什么?
`@Async`注解在Spring MVC中主要用于**方法级别的异步执行**，但与控制器异步处理属于不同层次的概念。需要注意的是，`@Async`通常用于Service层业务方法的异步化，而非直接替代控制器的异步处理。
**正确使用模式：**
```java
@Service
public class BusinessService {
    
    @Async  // 在Service层实现方法异步执行
    public CompletableFuture<String> processData(String data) {
        // 模拟耗时业务处理
        try {
            Thread.sleep(3000);
            return CompletableFuture.completedFuture("Processed: " + data);
        } catch (InterruptedException e) {
            return CompletableFuture.completedFuture("Error occurred");
        }
    }
}

@RestController
public class AsyncIntegrationController {
    
    @Autowired
    private BusinessService businessService;
    
    @GetMapping("/async/service")
    public CompletableFuture<String> handleAsyncService() {
        // 组合使用：控制器异步 + Service异步
        return businessService.processData("test data");
    }
}
```
**配置要求：**
```java
@Configuration
@EnableAsync  // 启用@Async支持
public class AsyncConfig {
    
    @Bean
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        return executor;
    }
}
```
**与控制器异步的层次关系：**
- **控制器异步**（Callable/DeferredResult）：解决HTTP请求线程阻塞问题，提升服务器吞吐量
- **Service异步**（@Async）：实现业务方法后台执行，优化内部任务处理
两者可以独立使用，也可以组合使用实现更复杂的异步场景。
###### 4. 异步请求处理的原理是什么?
Spring MVC异步请求处理的原理基于**Servlet 3.0异步规范**和**Spring的任务执行框架**，通过**请求-响应分离**和**结果回调**机制实现。
**完整处理流程源码分析：**
**阶段一：异步处理启动**
```java
// 在RequestMappingHandlerAdapter中
public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter {
    
    protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
                                              HttpServletResponse response,
                                              HandlerMethod handlerMethod) throws Exception {
        
        // 检测返回类型并选择相应的ReturnValueHandler
        if (Async.class.isAssignableFrom(returnType.getParameterType())) {
            // 启动异步处理
            WebAsyncUtils.getAsyncManager(request).startCallableProcessing(callable, mavContainer);
            return null;
        }
    }
}
```
**阶段二：异步上下文管理**
Spring通过`WebAsyncManager`管理异步请求生命周期，关键方法`startCallableProcessing`：
```java
public void startCallableProcessing(Callable<?> callable, Object... processingContext) {
    // 1. 启动Servlet异步上下文
    AsyncWebRequest asyncWebRequest = getAsyncWebRequest();
    asyncWebRequest.startAsync();
    
    // 2. 提交任务到线程池
    Future<?> future = this.taskExecutor.submit(() -> {
        try {
            // 执行拦截器前置处理
            interceptorChain.applyPreProcess(asyncWebRequest, callable);
            
            // 执行实际业务逻辑
            Object result = callable.call();
            
            // 执行拦截器后置处理
            return interceptorChain.applyPostProcess(asyncWebRequest, callable, result);
        } catch (Throwable ex) {
            // 异常处理
            return interceptorChain.applyPostProcess(asyncWebRequest, callable, ex);
        }
    });
}
```
**阶段三：结果回调与请求恢复**
当异步任务完成时，通过`AsyncListener`机制通知Servlet容器：
```java
// 结果设置后的处理流程
private void setConcurrentResultAndDispatch(Object result) {
    synchronized (this) {
        this.concurrentResult = result;  // 保存结果
        this.concurrentResultContext = processingContext;
    }
    
    // 重新分派请求到Servlet容器
    this.asyncWebRequest.dispatch();
}
```
**DeferredResult的特殊处理机制：**
`DeferredResult`采用**事件驱动模式**，不依赖Spring线程池，而是通过应用程序主动设置结果：
```java
public class DeferredResult<T> {
    public boolean setResult(T result) {
        this.result = result;
        // 触发结果处理
        if (this.resultHandler != null) {
            this.resultHandler.handleResult(result);
            return true;
        }
        return false;
    }
}
```
**超时与异常处理机制：**
Spring MVC通过`AsyncTimeoutException`和相应的拦截器链处理异步超时：
```java
public class TimeoutDeferredResultProcessingInterceptor implements DeferredResultProcessingInterceptor {
    
    public <T> boolean handleTimeout(NativeWebRequest request, DeferredResult<T> result) {
        if (!result.isSetOrExpired()) {
            try {
                // 触发超时回调
                result.setErrorResult(new AsyncRequestTimeoutException());
            } catch (Exception ex) {
                return false;
            }
        }
        return false;
    }
}
```
**性能优化价值**：异步处理通过**减少线程阻塞**和**连接占用**，显著提升服务器吞吐量。在IO密集型场景下，异步处理可以将吞吐量提升数倍，同时保持较低的线程资源消耗。