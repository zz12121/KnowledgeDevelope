###### 1. mvc:annotation-driven 的作用是什么?
`mvc:annotation-driven`是Spring MVC中**启用注解驱动的核心配置标签**，它通过简化的XML配置方式自动注册Spring MVC运行所需的关键组件。当在Spring配置文件中添加此标签时，实际上是在激活Spring MVC的注解处理能力。
**核心组件自动注册机制：**
- **RequestMappingHandlerMapping**：处理`@RequestMapping`注解，建立请求URL到控制器方法的映射关系
- **RequestMappingHandlerAdapter**：实际调用控制器方法，处理参数绑定、数据转换和返回值处理
- **异常处理组件**：自动注册异常解析器，支持`@ExceptionHandler`注解
**高级功能支持：**
```xml
<!-- 实际配置示例 -->
<mvc:annotation-driven>
    <mvc:message-converters>
        <bean class="org.springframework.http.converter.StringHttpMessageConverter">
            <property name="supportedMediaTypes">
                <list>
                    <value>text/plain;charset=UTF-8</value>
                    <value>application/json;charset=UTF-8</value>
                </list>
            </property>
        </bean>
    </mvc:message-converters>
</mvc:annotation-driven>
```
**设计价值**：此标签极大简化了配置工作，开发者无需手动声明各个Bean，只需关注业务逻辑实现。
###### 2. @EnableWebMvc 注解的作用是什么?
`@EnableWebMvc`是**基于Java配置的注解驱动启用方式**，用于替代XML配置中的`mvc:annotation-driven`标签。该注解通过导入`DelegatingWebMvcConfiguration`类来启用Spring MVC的默认配置。
**源码级工作机制：**
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {}
```
**关键设计要点：**
- **自动配置控制**：当使用`@EnableWebMvc`时，会导入`WebMvcConfigurationSupport`，导致Spring Boot的自动配置失效（因为`@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)`条件不满足）
- **委托模式**：`DelegatingWebMvcConfiguration`通过依赖注入收集所有`WebMvcConfigurer`实现，实现配置的集中管理
**使用示例：**
```java
@Configuration
@EnableWebMvc
public class WebMvcConfig implements WebMvcConfigurer {
    // 自定义配置将通过实现WebMvcConfigurer接口的方法添加
}
```
###### 3. WebMvcConfigurer 接口的作用是什么?
`WebMvcConfigurer`是Spring MVC的**核心配置回调接口**，提供了多个默认方法供开发者重写，以自定义MVC行为的各个方面，同时保留Spring MVC的默认配置。
**接口设计理念：**
- **开闭原则**：通过接口扩展而非修改的方式增强功能
- **模块化配置**：每个方法负责一个特定的配置领域
- **默认方法**：Java 8的默认方法使接口演进更加平滑
**主要配置方法分类：**

|**配置类型**​|**关键方法**​|**应用场景**​|
|---|---|---|
|**拦截器配置**​|`addInterceptors()`|权限验证、日志记录|
|**资源处理**​|`addResourceHandlers()`|静态资源映射、缓存控制|
|**CORS配置**​|`addCorsMappings()`|跨域请求处理|
|**视图控制**​|`addViewControllers()`|简单页面跳转（无需控制器）|
|**消息转换**​|`configureMessageConverters()`|数据序列化/反序列化|
###### 4. 如何自定义 SpringMVC 配置?
自定义Spring MVC配置主要通过**实现WebMvcConfigurer接口**并重写相关方法来完成。以下是完整的配置实践：
**完整配置示例：**
```java
@Configuration
public class CustomWebMvcConfig implements WebMvcConfigurer {
    
    private final Logger logger = LoggerFactory.getLogger(getClass());
    
    // 1. 拦截器配置
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoggingInterceptor())
                .addPathPatterns("/api/**")
                .excludePathPatterns("/api/public/**");
        
        registry.addInterceptor(new AuthInterceptor())
                .addPathPatterns("/admin/**")
                .order(1); // 设置拦截器顺序
    }
    
    // 2. 静态资源配置
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/static/**")
                .addResourceLocations("classpath:/static/", "file:/opt/static/")
                .setCachePeriod(3600)
                .resourceChain(true)
                .addResolver(new VersionResourceResolver());
    }
    
    // 3. 跨域配置
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("https://domain.com")
                .allowedMethods("GET", "POST", "PUT")
                .allowCredentials(true)
                .maxAge(1800);
    }
    
    // 4. 格式化配置
    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addFormatter(new DateFormatter("yyyy-MM-dd"));
        registry.addConverter(new StringToEnumConverter());
    }
}
```
**配置优先级说明**：当存在多个`WebMvcConfigurer`实现时，Spring会按`@Order`注解或Bean定义顺序执行配置，后续配置不会覆盖前面的配置，而是累积生效。
###### 5. 如何配置消息转换器?
消息转换器配置是Spring MVC处理**数据序列化的核心环节**，主要通过`WebMvcConfigurer`的`configureMessageConverters`或`extendMessageConverters`方法实现。
**两种配置策略：**
**完全自定义配置**（替换所有默认转换器）：
```java
@Configuration
@EnableWebMvc
public class MessageConverterConfig implements WebMvcConfigurer {
    
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        // 清空默认转换器，完全自定义
        converters.clear();
        
        // 配置JSON转换器（Jackson）
        MappingJackson2HttpMessageConverter jsonConverter = new MappingJackson2HttpMessageConverter();
        jsonConverter.setObjectMapper(customObjectMapper());
        jsonConverter.setSupportedMediaTypes(Arrays.asList(
            MediaType.APPLICATION_JSON,
            new MediaType("application", "*+json")
        ));
        converters.add(jsonConverter);
        
        // 配置字符串转换器
        StringHttpMessageConverter stringConverter = new StringHttpMessageConverter(StandardCharsets.UTF_8);
        converters.add(stringConverter);
    }
    
    @Bean
    public ObjectMapper customObjectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.registerModule(new JavaTimeModule());
        return mapper;
    }
}
```
**扩展配置**（保留默认转换器，添加自定义转换器）：
```java
@Configuration
public class ExtendedMessageConverterConfig implements WebMvcConfigurer {
    
    @Override
    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        // 查找并移除默认的Jackson转换器
        converters.removeIf(converter -> converter instanceof MappingJackson2HttpMessageConverter);
        
        // 添加自定义的JSON转换器到首位
        MappingJackson2HttpMessageConverter customConverter = new MappingJackson2HttpMessageConverter();
        customConverter.setObjectMapper(customObjectMapper());
        converters.add(0, customConverter);
    }
}
```
###### 6. HttpMessageConverter 的作用是什么?
`HttpMessageConverter`是Spring MVC中**处理HTTP请求/响应体数据转换的核心接口**，负责Java对象与HTTP消息体之间的相互转换。
**接口设计源码：**
```java
public interface HttpMessageConverter<T> {
    boolean canRead(Class<?> clazz, MediaType mediaType);
    boolean canWrite(Class<?> clazz, MediaType mediaType);
    List<MediaType> getSupportedMediaTypes();
    T read(Class<? extends T> clazz, HttpInputMessage inputMessage) 
        throws IOException, HttpMessageNotReadableException;
    void write(T t, MediaType contentType, HttpOutputMessage outputMessage)
        throws IOException, HttpMessageNotWritableException;
}
```
**主要实现类及应用：**

| **转换器类型**​                            | **处理内容类型**​ | **典型应用**​    |
| ------------------------------------- | ----------- | ------------ |
| `MappingJackson2HttpMessageConverter` | JSON数据      | REST API数据交换 |
| `StringHttpMessageConverter`          | 文本数据        | 普通文本响应       |
| `FormHttpMessageConverter`            | 表单数据        | 表单提交处理       |
| `ByteArrayHttpMessageConverter`       | 字节数据        | 文件下载         |
**工作流程**：当控制器方法使用`@RequestBody`或`@ResponseBody`时，`RequestMappingHandlerAdapter`会遍历已注册的`HttpMessageConverter`，选择第一个支持当前类型的转换器进行数据转换。
###### 7. 如何配置内容协商?
内容协商配置允许客户端和服务器**协商响应的数据格式**。Spring MVC通过`ContentNegotiationManager`管理此过程。
**完整配置示例：**
```java
@Configuration
public class ContentNegotiationConfig implements WebMvcConfigurer {
    
    @Override
    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
        configurer
            .favorParameter(true)          // 支持URL参数指定格式
            .parameterName("format")       // 参数名
            .ignoreAcceptHeader(false)     // 不忽略Accept头
            .useRegisteredExtensionsOnly(false)
            .defaultContentType(MediaType.APPLICATION_JSON)  // 默认JSON
            .mediaType("json", MediaType.APPLICATION_JSON)   // 扩展名映射
            .mediaType("xml", MediaType.APPLICATION_XML)
            .mediaType("html", MediaType.TEXT_HTML);
    }
    
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        // 配置支持多种格式的转换器
        converters.add(new MappingJackson2HttpMessageConverter());  // JSON
        converters.add(new Jaxb2RootElementHttpMessageConverter());  // XML
    }
}
```
**内容协商策略：**
- **URL参数策略**：如`/api/users?format=json`
- **Accept头策略**：客户端通过HTTP Accept头指定偏好格式
- **URL扩展名策略**：如`/api/users.json`
- **默认回退策略**：当无法协商时使用默认格式