###### 1. SpringMVC 如何进行数据校验?
SpringMVC数据校验基于**校验框架整合**和**AOP拦截机制**实现，主要包括两种方式：基于JSR-303/349的Bean Validation和基于Validator接口的自定义校验。
**校验架构的核心组成：**
1. **Bean Validation标准校验**（主流方式）
    通过`LocalValidatorFactoryBean`集成JSR标准，使用注解声明校验规则：
    ```java
    @Configuration
    public class ValidationConfig {
        @Bean
        public LocalValidatorFactoryBean validator() {
            return new LocalValidatorFactoryBean();
        }
    }
    
    // 使用示例
    @RestController
    public class UserController {
        @PostMapping("/users")
        public ResponseEntity<?> createUser(@Valid @RequestBody User user, 
                                          BindingResult result) {
            if (result.hasErrors()) {
                // 处理校验错误
                return ResponseEntity.badRequest().body(result.getAllErrors());
            }
            return ResponseEntity.ok(userService.save(user));
        }
    }
    ```
1. **自定义Validator接口实现**
    实现Spring的Validator接口，编程式实现复杂校验逻辑：
    ```java
    public class UserValidator implements Validator {
        @Override
        public boolean supports(Class<?> clazz) {
            return User.class.equals(clazz);
        }
    
        @Override
        public void validate(Object target, Errors errors) {
            User user = (User) target;
            if (user.getAge() != null && user.getAge() < 18) {
                errors.rejectValue("age", "age.min", "年龄必须大于18岁");
            }
        }
    }
    
    // 在控制器中使用
    @Controller
    public class UserController {
        @Autowired
        private UserValidator userValidator;
    
        @PostMapping("/users")
        public String createUser(@ModelAttribute User user, BindingResult result) {
            userValidator.validate(user, result);
            if (result.hasErrors()) {
                return "user/form";
            }
            // 处理成功逻辑
        }
    }
    ```
**源码级校验流程：**
SpringMVC通过`MethodValidationInterceptor`实现AOP拦截。当方法参数带有`@Valid`或`@Validated`时，拦截器会调用`Validator`实施校验：
```java
public class MethodValidationInterceptor implements MethodInterceptor {
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // 校验方法参数
        for (Object arg : invocation.getArguments()) {
            if (arg != null && hasValidationAnnotations(arg)) {
                Set<ConstraintViolation<Object>> violations = 
                    validator.validate(arg);
                if (!violations.isEmpty()) {
                    throw new ConstraintViolationException(violations);
                }
            }
        }
        return invocation.proceed();
    }
}
```
###### 2. @Valid 和 @Validated 的区别是什么?
两者都是触发校验的注解，但在设计目标和应用场景上有重要差异。

|**特性**​|**@Valid**​|**@Validated**​|
|---|---|---|
|**来源标准**​|JSR-303/349 Bean Validation标准|Spring框架自定义注解|
|**作用层级**​|参数、方法、字段级别|类、方法级别|
|**分组校验**​|不支持|支持，通过groups属性|
|**嵌套校验**​|支持，需显式标注@Valid|支持|
|**适用场景**​|控制器层参数校验|Service层方法校验、分组校验|
**源码层面的关键差异：**
`@Valid`由Bean Validation标准定义，被Spring兼容支持：
```java
@Target({ METHOD, FIELD, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface Valid {
}
```
`@Validated`是Spring的增强实现，支持分组校验：
```java
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface Validated {
    Class<?>[] value() default {};  // 分组支持
}
```
**实战应用场景：**
```java
// @Valid主要用于控制器层
@RestController
public class UserController {
    @PostMapping("/users")
    public User createUser(@Valid @RequestBody User user) {
        return userService.save(user);
    }
}

// @Validated用于Service层和分组校验
@Service
@Validated
public class UserService {
    // Service层方法参数校验
    public User updateUser(@Valid User user) {
        return userRepository.save(user);
    }
    
    // 分组校验示例
    public User partialUpdate(@Validated(UpdateGroup.class) User user) {
        return userRepository.save(user);
    }
}
```
###### 3. BindingResult 的作用是什么?
BindingResult是SpringMVC中**处理校验结果的核心组件**，它封装了校验过程中的所有错误信息，使开发者能够细粒度控制错误处理。
**核心功能：**
- **错误信息收集**：存储字段错误和全局错误
- **校验状态判断**：提供`hasErrors()`方法判断校验是否通过
- **错误详情访问**：支持按字段、按错误代码获取具体错误信息
- **模型数据绑定**：将错误信息绑定到模型，供视图层显示
**源码结构分析：**
BindingResult继承自Errors接口，其默认实现`BeanPropertyBindingResult`内部维护了两个重要的错误集合：
```java
public class BeanPropertyBindingResult extends AbstractBindingResult {
    private final List<ObjectError> globalErrors = new ArrayList<>();
    private final Map<String, List<ObjectError>> fieldErrors = new LinkedHashMap<>();
    
    // 添加字段错误
    public void addFieldError(String field, String code, Object[] arguments) {
        // 错误信息处理逻辑
    }
}
```
**实战应用示例：**
```java
@Controller
public class UserController {
    
    @PostMapping("/register")
    public String registerUser(@Valid @ModelAttribute User user, 
                             BindingResult result, Model model) {
        
        // 自定义业务逻辑校验
        if (userService.existsByUsername(user.getUsername())) {
            result.rejectValue("username", "duplicate", "用户名已存在");
        }
        
        if (result.hasErrors()) {
            // 获取所有字段错误
            List<FieldError> fieldErrors = result.getFieldErrors();
            for (FieldError error : fieldErrors) {
                log.error("字段: {}, 错误: {}", error.getField(), error.getDefaultMessage());
            }
            
            // 获取特定字段的错误
            List<ObjectError> usernameErrors = result.getFieldErrors("username");
            
            // 将错误信息添加到模型
            model.addAttribute("errors", result.getAllErrors());
            return "user/register-form";
        }
        
        userService.save(user);
        return "redirect:/success";
    }
}
```
**高级错误处理技巧：**
```java
// 全局异常处理中统一处理校验错误
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationException(
            MethodArgumentNotValidException ex) {
        
        BindingResult result = ex.getBindingResult();
        Map<String, String> errors = new HashMap<>();
        
        result.getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage()));
        
        return ResponseEntity.badRequest().body(errors);
    }
}
```
###### 4. 如何自定义校验规则?
当标准校验注解无法满足复杂业务需求时，需要通过**自定义校验注解**和**校验器**来扩展校验规则。
**自定义校验实现步骤：**
1. **定义校验注解**
```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PhoneNumberValidator.class)
public @interface PhoneNumber {
    String message() default "手机号码格式不正确";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
    
    // 可选：定义地区码默认值
    String regionCode() default "86";
}
```
2. **实现校验逻辑**
```java
public class PhoneNumberValidator implements ConstraintValidator<PhoneNumber, String> {
    private String regionCode;
    private Pattern pattern;
    
    @Override
    public void initialize(PhoneNumber constraintAnnotation) {
        this.regionCode = constraintAnnotation.regionCode();
        // 根据不同地区配置不同的手机号规则
        if ("86".equals(regionCode)) {
            this.pattern = Pattern.compile("^1[3-9]\\d{9}$");
        } else {
            this.pattern = Pattern.compile("^\\d{10,15}$");
        }
    }
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true; // 使用@NotNull处理空值
        }
        
        if (!pattern.matcher(value).matches()) {
            // 自定义错误信息
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(
                "手机号格式错误，地区码:" + regionCode)
                   .addConstraintViolation();
            return false;
        }
        return true;
    }
}
```
3. **应用自定义注解**
```java
public class User {
    @PhoneNumber(regionCode = "86", message = "请输入正确的中国手机号")
    private String phone;
    
    // 组合注解示例：密码强度校验
    @StrongPassword(minLength=8, requireSpecialChar=true)
    private String password;
}
```
**高级技巧：跨字段校验**
```java
@Target({TYPE})
@Retention(RUNTIME)
@Constraint(validatedBy = PasswordMatchesValidator.class)
public @interface PasswordMatches {
    String message() default "密码不匹配";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

public class PasswordMatchesValidator implements ConstraintValidator<PasswordMatches, User> {
    public boolean isValid(User user, ConstraintValidatorContext context) {
        if (!user.getPassword().equals(user.getConfirmPassword())) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate("密码确认不匹配")
                   .addPropertyNode("confirmPassword")
                   .addConstraintViolation();
            return false;
        }
        return true;
    }
}

// 应用在类级别
@PasswordMatches
public class User {
    private String password;
    private String confirmPassword;
}
```
###### 5. JSR-303 规范是什么?
JSR-303是**Java规范请求**，定义了Bean Validation 1.0标准，后续的JSR-349定义了Bean Validation 1.1版本。这些规范为Java应用提供了一套**标准的声明式校验框架**。
**核心设计目标：**
- **声明式校验**：通过注解而非编程方式定义校验规则
- **与框架解耦**：校验逻辑独立于业务代码和特定框架
- **可扩展性**：支持自定义校验规则和注解
- **国际化支持**：内置错误消息的国际化机制
**规范实现体系：**
```
JSR-303/JSR-349 (标准规范)
    ↓
Hibernate Validator (参考实现)
    ↓
Spring Validation (框架整合)
```
**源码中的规范体现：**
规范定义的核心接口`ConstraintValidator`是所有校验器的基础：
```java
public interface ConstraintValidator<A extends Annotation, T> {
    default void initialize(A constraintAnnotation) {}
    boolean isValid(T value, ConstraintValidatorContext context);
}
```
Spring通过`LocalValidatorFactoryBean`实现规范的集成：
```java
public class LocalValidatorFactoryBean implements Validator, ValidatorFactory {
    // 委托给真正的Bean Validation实现（如Hibernate Validator）
    private ValidatorFactory validatorFactory;
    
    public void afterPropertiesSet() {
        this.validatorFactory = buildValidatorFactory();
    }
}
```
###### 6. 常用的校验注解有哪些?
JSR-303和Hibernate Validator提供了丰富的校验注解，覆盖大多数常见场景。
**标准JSR-303注解：**

| **注解**​       | **应用目标**​ | **功能描述**​ | **示例**​                               |
| ------------- | --------- | --------- | ------------------------------------- |
| `@NotNull`    | 任意类型      | 验证值不为null | `@NotNull String name`                |
| `@Null`       | 任意类型      | 验证必须为null | `@Null String unusedField`            |
| `@Size`       | 字符串、集合    | 验证长度或大小范围 | `@Size(min=2, max=10) String name`    |
| `@Min`        | 数值类型      | 验证最小值     | `@Min(18) Integer age`                |
| `@Max`        | 数值类型      | 验证最大值     | `@Max(100) Integer score`             |
| `@DecimalMin` | 数值类型      | 验证小数值最小值  | `@DecimalMin("0.0") BigDecimal price` |
| `@Pattern`    | 字符串       | 正则表达式匹配   | `@Pattern(regexp="[a-zA-Z0-9]+")`     |
| `@Past`       | 日期类型      | 必须是过去时间   | `@Past Date birthDate`                |
| `@Future`     | 日期类型      | 必须是将来时间   | `@Future Date expireDate`             |
**Hibernate扩展注解：**

|**注解**​|**功能描述**​|**示例用法**​|
|---|---|---|
|`@Email`|邮箱格式校验|`@Email String email`|
|`@NotBlank`|字符串非空且非纯空格|`@NotBlank String title`|
|`@Length`|字符串长度范围|`@Length(min=6, max=20) String password`|
|`@Range`|数值范围校验|`@Range(min=0, max=100) Integer score`|
|`@URL`|URL格式校验|`@URL String website`|
|`@SafeHtml`|HTML安全校验|`@SafeHtml String content`|
**完整实战示例：**
```java
public class Product {
    @NotBlank(message = "产品名称不能为空")
    @Length(min = 2, max = 50, message = "产品名称长度2-50字符")
    private String name;
    
    @NotNull(message = "价格不能为空")
    @DecimalMin(value = "0.0", inclusive = false, message = "价格必须大于0")
    @Digits(integer = 10, fraction = 2, message = "价格格式不正确")
    private BigDecimal price;
    
    @NotNull(message = "库存不能为空")
    @Min(value = 0, message = "库存不能为负数")
    private Integer stock;
    
    @Email(message = "供应商邮箱格式不正确")
    private String supplierEmail;
    
    @Pattern(regexp = "^(ACTIVE|INACTIVE)$", message = "状态值不合法")
    private String status;
    
    @Future(message = "过期时间必须是将来时间")
    private Date expiryDate;
}
```
###### 7. 如何实现分组校验?
分组校验允许**根据不同场景应用不同的校验规则**，是复杂业务系统中重要的校验策略。
**分组校验实现机制：**
1. **定义分组接口**
```java
// 创建不同的分组接口
public interface CreateGroup {}    // 创建时校验规则
public interface UpdateGroup {}    // 更新时校验规则
public interface AdvancedGroup {}  // 高级业务校验
```
1. **在实体类中指定分组**
```java
public class User {
    @NotNull(groups = {CreateGroup.class, UpdateGroup.class}, 
             message = "用户ID不能为空")
    private Long id;
    
    @NotBlank(groups = CreateGroup.class, message = "用户名创建时必填")
    @Size(min = 3, max = 20, groups = CreateGroup.class)
    private String username;
    
    @NotBlank(groups = CreateGroup.class, message = "密码创建时必填")
    @Size(min = 6, groups = {CreateGroup.class, AdvancedGroup.class})
    private String password;
    
    @Email(groups = {CreateGroup.class, UpdateGroup.class})
    private String email;
    
    // 高级业务分组校验
    @NotNull(groups = AdvancedGroup.class)
    @Min(value = 1000, groups = AdvancedGroup.class)
    private Integer securityLevel;
}
```
1. **在控制器中使用分组校验**
```java
@RestController
@Validated
public class UserController {
    
    // 创建用户：只校验CreateGroup分组
    @PostMapping("/users")
    public ResponseEntity<User> createUser(
            @Validated(CreateGroup.class) @RequestBody User user) {
        return ResponseEntity.ok(userService.create(user));
    }
    
    // 更新用户：校验UpdateGroup分组
    @PutMapping("/users/{id}")
    public ResponseEntity<User> updateUser(
            @PathVariable Long id,
            @Validated(UpdateGroup.class) @RequestBody User user) {
        user.setId(id);
        return ResponseEntity.ok(userService.update(user));
    }
    
    // 高级操作：校验多个分组（按顺序）
    @PostMapping("/users/{id}/secure")
    public ResponseEntity<User> secureOperation(
            @PathVariable Long id,
            @Validated({UpdateGroup.class, AdvancedGroup.class}) 
            @RequestBody User user) {
        return ResponseEntity.ok(userService.secureUpdate(user));
    }
}
```
**分组继承高级用法：**
```java
// 分组继承：DetailedGroup继承UpdateGroup的校验规则
public interface DetailedGroup extends UpdateGroup {}

public class Product {
    // DetailedGroup将同时包含UpdateGroup的校验
    @NotNull(groups = DetailedGroup.class)
    private String details;
}
```
**条件性分组校验：**
```java
// 根据业务状态动态选择分组
@RestController
public class DynamicValidationController {
    
    @PostMapping("/users/{action}")
    public ResponseEntity<User> handleUser(
            @PathVariable String action,
            @RequestBody User user) {
        
        // 根据action动态选择校验分组
        if ("create".equals(action)) {
            validateForCreate(user);
        } else if ("update".equals(action)) {
            validateForUpdate(user);
        }
        
        return ResponseEntity.ok(userService.save(user));
    }
    
    private void validateForCreate(User user) {
        Set<ConstraintViolation<User>> violations = 
            validator.validate(user, CreateGroup.class);
        if (!violations.isEmpty()) {
            throw new ConstraintViolationException(violations);
        }
    }
}
```