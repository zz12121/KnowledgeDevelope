###### 1. 什么是跨域问题?
跨域问题本质是**浏览器安全机制**与**现代Web开发需求**之间的冲突。从技术角度看，这是由**同源策略（Same-Origin Policy）引发的一系列访问限制。
同源策略的核心定义**：当两个URL的**协议（protocol）、域名（host）和端口（port）完全相同时，浏览器才认为它们是"同源"的。任何一项不匹配即构成跨域。
跨域的具体场景分析**：

|**当前页面URL**​|**请求目标URL**​|**是否跨域**​|**原因**​|
|---|---|---|---|
|`http://a.com/index`|`http://a.com/api`|否|协议、域名、端口完全相同|
|`http://a.com`|`https://a.com`|是|协议不同（HTTP vs HTTPS）|
|`http://a.com`|`http://b.com`|是|域名不同|
|`http://a.com:80`|`http://a.com:8080`|是|端口不同|
|`http://a.com`|`http://api.a.com`|是|子域名不同|
**浏览器层面的限制表现**：
- **AJAX请求拦截**：`XMLHttpRequest`和`Fetch API`发起的跨域请求被浏览器阻止
- **DOM访问限制**：无法通过JavaScript访问跨域iframe内的DOM结构
- **存储隔离**：无法读取跨域页面的Cookie、LocalStorage等存储数据
**设计价值**：同源策略是Web安全的基石，有效防止了CSRF（跨站请求伪造）、XSS（跨站脚本攻击）等安全威胁。但前后端分离架构的普及使得合法跨域需求日益增多，因而需要安全的跨域解决方案。
###### 2. SpringMVC 如何解决跨域问题?
SpringMVC提供了**多层次、可配置的跨域解决方案体系**，其核心设计基于**CORS（跨域资源共享）规范**，通过过滤器、拦截器等多重机制实现。
**解决方案架构图**：
```
跨域请求 → 前端应用 ←─┐
    ↓              │
浏览器拦截 ←─ 跨域限制   │ SpringMVC解决方案
    ↓              │
CORS机制 → 后端API ───┘
```
**三种核心解决策略**：
1. **注解驱动方案**：使用`@CrossOrigin`注解，细粒度控制单个控制器或方法
2. **全局配置方案**：通过`WebMvcConfigurer`统一配置，适用于整个应用
3. **过滤器方案**：通过`CorsFilter`在Servlet层面处理，优先级最高
**源码级的请求处理流程**：
```java
// Spring MVC的跨域处理核心流程
public class DispatcherServlet extends FrameworkServlet {
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) {
        // 1. 查找处理器映射
        HandlerExecutionChain mappedHandler = getHandler(processedRequest);
        
        // 2. 执行跨域检查（CorsProcessor处理）
        if (mappedHandler != null && mappedHandler.getCorsConfiguration() != null) {
            CorsProcessor processor = new DefaultCorsProcessor();
            if (!processor.processRequest(mappedHandler.getCorsConfiguration(), request, response)) {
                return; // 跨域检查未通过，直接返回
            }
        }
        
        // 3. 继续正常请求处理流程
        // ...
    }
}
```
**CORS核心响应头机制**：
- `Access-Control-Allow-Origin`：控制允许访问的源
- `Access-Control-Allow-Methods`：允许的HTTP方法
- `Access-Control-Allow-Headers`：允许的自定义请求头
- `Access-Control-Allow-Credentials`：是否允许携带凭证信息
- `Access-Control-Max-Age`：预检请求缓存时间
**预检请求（Preflight）机制**：对于非简单请求（如PUT、DELETE或包含自定义头的请求），浏览器会先发送OPTIONS预检请求，服务器必须正确处理这些请求才能完成实际跨域访问。
###### 3. @CrossOrigin 注解的作用是什么?
`@CrossOrigin`是Spring框架提供的**声明式跨域配置注解**，允许在控制器级别或方法级别精细控制跨域策略。该注解基于**AOP切面编程**思想，通过元注解机制实现配置注入。
**注解源码分析**：
```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface CrossOrigin {
    String[] origins() default {};                    // 允许的源
    String[] allowedHeaders() default {};             // 允许的请求头
    String[] exposedHeaders() default {};             // 暴露的响应头
    RequestMethod[] methods() default {};             // 允许的HTTP方法
    boolean allowCredentials() default false;         // 是否允许凭证
    long maxAge() default -1;                         // 预检请求缓存时间
}
```
**实战应用示例**：
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    // 方法级别配置：允许特定源访问
    @CrossOrigin(origins = "https://frontend.com")
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    // 类级别配置：应用于所有方法
    @CrossOrigin(
        origins = {"https://app.com", "https://admin.com"},
        methods = {RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT},
        allowedHeaders = {"Content-Type", "Authorization"},
        allowCredentials = "true",
        maxAge = 3600
    )
    @PostMapping
    public User createUser(@RequestBody User user) {
        return userService.save(user);
    }
}
```
**底层处理机制**：当控制器方法被`@CrossOrigin`注解时，Spring MVC会通过`RequestMappingHandlerMapping`在映射阶段收集CORS配置信息。在请求处理时，`CorsInterceptor`会拦截请求并应用相应的跨域策略。
**设计优势**：
- **细粒度控制**：不同API可以设置不同的跨域策略
- **代码直观**：配置与业务逻辑紧密关联，易于维护
- **类型安全**：编译期检查配置项的正确性
###### 4. 如何全局配置跨域?
全局跨域配置通过实现`WebMvcConfigurer`接口完成，提供**统一管理、集中配置**的解决方案，特别适合大型项目中需要一致跨域策略的场景。
**完整配置示例**：
```java
@Configuration
@EnableWebMvc
public class WebMvcConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // 1. 全局API配置
        registry.addMapping("/api/**")
                .allowedOrigins("https://frontend.com", "https://admin.com")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("Content-Type", "Authorization", "X-Requested-With")
                .allowCredentials(true)
                .maxAge(3600);
        
        // 2. 公开API配置（允许所有源访问）
        registry.addMapping("/public/**")
                .allowedOrigins("*")
                .allowedMethods("GET", "OPTIONS")
                .maxAge(1800);
        
        // 3. 管理端API配置（严格限制）
        registry.addMapping("/admin/**")
                .allowedOrigins("https://admin.internal.com")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(7200);
    }
}
```
**基于过滤器的全局配置**（优先级更高）：
```java
@Configuration
public class CorsFilterConfig {
    
    @Bean
    public FilterRegistrationBean<CorsFilter> corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        
        // 配置详细信息
        config.setAllowCredentials(true);
        config.addAllowedOrigin("https://trusted-domain.com");
        config.addAllowedMethod("GET");
        config.addAllowedMethod("POST");
        config.addAllowedHeader("Content-Type");
        config.setMaxAge(3600L);
        
        source.registerCorsConfiguration("/**", config);
        
        FilterRegistrationBean<CorsFilter> bean = 
            new FilterRegistrationBean<>(new CorsFilter(source));
        bean.setOrder(Ordered.HIGHEST_PRECEDENCE); // 最高优先级
        
        return bean;
    }
}
```
**配置优先级与覆盖规则**：
1. **过滤器配置**​ > **全局配置**​ > **注解配置**
2. 相同级别下，更具体的路径模式优先于通用模式
3. 方法级别注解会覆盖类级别注解配置
###### 5. CorsRegistry 的作用是什么?
`CorsRegistry`是Spring MVC提供的**全局跨域配置注册中心**，作为`WebMvcConfigurer`的核心组件，它通过**建造者模式**提供流畅的API用于统一管理跨域策略。
**核心架构设计**：
```java
public class CorsRegistry {
    private final List<CorsRegistration> registrations = new ArrayList<>();
    
    public CorsRegistration addMapping(String pathPattern) {
        CorsRegistration registration = new CorsRegistration(pathPattern);
        this.registrations.add(registration);
        return registration;
    }
    
    protected Map<String, CorsConfiguration> getCorsConfigurations() {
        // 返回路径模式到CorsConfiguration的映射
    }
}
```
**高级配置技巧**：
```java
@Configuration
public class AdvancedCorsConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // 动态配置：根据环境变量设置允许的源
        String[] allowedOrigins = getAllowedOriginsByEnv();
        
        registry.addMapping("/api/**")
                .allowedOrigins(allowedOrigins)
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600)
                .exposedHeaders("X-Total-Count", "X-RateLimit-Limit"); // 暴露自定义头
    }
    
    private String[] getAllowedOriginsByEnv() {
        String env = System.getProperty("app.env", "dev");
        switch (env) {
            case "prod":
                return new String[]{"https://prod.example.com"};
            case "staging":
                return new String[]{"https://staging.example.com"};
            default: // dev
                return new String[]{"http://localhost:3000", "http://localhost:8080"};
        }
    }
}
```
**与CorsConfiguration的集成关系**：
`CorsRegistry`内部维护一组`CorsRegistration`对象，每个注册项对应一个路径模式及其`CorsConfiguration`。当请求到达时，`HandlerMapping`会查找最匹配的CORS配置并应用到响应中。
**设计价值**：通过`CorsRegistry`的统一管理，Spring应用可以实现**集中化、可维护的跨域策略**，避免配置分散导致的维护困难，同时支持基于环境的动态策略调整。