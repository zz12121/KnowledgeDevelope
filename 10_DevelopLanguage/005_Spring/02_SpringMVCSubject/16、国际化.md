###### 1. SpringMVC 如何实现国际化?
SpringMVC国际化（i18n）基于**资源包（ResourceBundle）机制**和**Locale解析策略**实现，核心设计围绕`MessageSource`接口构建，通过**分层解析**和**fallback机制**提供多语言支持。
**国际化架构的核心组成：**
1. **资源文件管理**：基于Properties文件的键值对存储多语言内容
2. **Locale解析器**：通过`LocaleResolver`确定当前请求的语言环境
3. **消息解析**：`MessageSource`接口实现资源文本的查找和格式化
4. **视图集成**：与JSTL、Thymeleaf等视图技术无缝集成
**完整工作流程源码分析：**
```java
// Spring MVC国际化的核心处理流程
public class DispatcherServlet extends FrameworkServlet {
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) {
        // 1. 解析Locale
        Locale locale = this.localeResolver.resolveLocale(request);
        RequestContextHolder.setLocale(locale);  // 设置到线程上下文
        
        // 2. 处理请求并渲染视图
        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
        
        // 3. 视图解析时使用Locale信息
        View view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);
    }
}
```
**实战配置示例：**
```java
@Configuration
@EnableWebMvc
public class I18nConfig implements WebMvcConfigurer {
    
    // 配置Locale解析器
    @Bean
    public LocaleResolver localeResolver() {
        SessionLocaleResolver resolver = new SessionLocaleResolver();
        resolver.setDefaultLocale(Locale.CHINA);  // 默认语言环境
        return resolver;
    }
    
    // 配置拦截器支持语言参数切换
    @Bean
    public LocaleChangeInterceptor localeChangeInterceptor() {
        LocaleChangeInterceptor interceptor = new LocaleChangeInterceptor();
        interceptor.setParamName("lang");  // 通过URL参数切换语言
        return interceptor;
    }
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(localeChangeInterceptor());
    }
}
```
**资源文件组织规范：**
```
src/main/resources/i18n/
├── messages.properties          # 默认资源（如英文）
├── messages_zh_CN.properties   # 简体中文
├── messages_zh_TW.properties   # 繁体中文
└── messages_ja_JP.properties   # 日文
```
###### 2. LocaleResolver 的作用是什么?
`LocaleResolver`是Spring MVC国际化架构中的**语言环境决策器**，负责从HTTP请求中提取Locale信息，其设计采用**策略模式**，支持多种解析方式。
**源码接口定义：**
```java
public interface LocaleResolver {
    // 从请求解析Locale
    Locale resolveLocale(HttpServletRequest request);
    
    // 设置请求的Locale
    void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale);
}
```
**主要实现类及应用场景：**

|**实现类**​|**解析策略**​|**适用场景**​|**特点**​|
|---|---|---|---|
|`AcceptHeaderLocaleResolver`|HTTP Accept-Language头|国际化的Web应用|尊重浏览器设置，不支持动态切换|
|`SessionLocaleResolver`|HttpSession中存储|用户自定义语言偏好|支持持久化，用户体验好|
|`CookieLocaleResolver`|Browser Cookie存储|长期语言记忆|跨会话保持，减少重复设置|
|`FixedLocaleResolver`|固定Locale|单语言应用或测试|性能最佳，无解析开销|
**高级配置示例：**
```java
@Configuration
public class AdvancedLocaleConfig {
    
    // 基于Session的Locale解析器（推荐用于Web应用）
    @Bean
    public SessionLocaleResolver localeResolver() {
        SessionLocaleResolver resolver = new SessionLocaleResolver();
        resolver.setDefaultLocale(Locale.US);  // 默认英语
        resolver.setLocaleAttributeName("currentLocale");  // Session属性名
        resolver.setTimeToLive(3600);  // 缓存时间（秒）
        return resolver;
    }
    
    // 基于Cookie的Locale解析器（长期记忆）
    @Bean 
    public CookieLocaleResolver cookieLocaleResolver() {
        CookieLocaleResolver resolver = new CookieLocaleResolver();
        resolver.setCookieName("client-locale");
        resolver.setCookieMaxAge(365 * 24 * 60 * 60);  // 一年有效期
        resolver.setCookiePath("/");
        return resolver;
    }
}
```
**自定义LocaleResolver实现：**
```java
@Component
public class HybridLocaleResolver implements LocaleResolver {
    private final List<LocaleResolver> resolvers = Arrays.asList(
        new SessionLocaleResolver(),    // 优先Session
        new CookieLocaleResolver(),     // 其次Cookie  
        new AcceptHeaderLocaleResolver() // 最后浏览器头
    );
    
    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        // 链式解析：按优先级尝试各个解析器
        for (LocaleResolver resolver : resolvers) {
            try {
                Locale locale = resolver.resolveLocale(request);
                if (locale != null && !locale.toString().isEmpty()) {
                    return locale;
                }
            } catch (Exception e) {
                // 记录日志，继续下一个解析器
            }
        }
        return Locale.getDefault();  // 回退到系统默认
    }
}
```
###### 3. 如何配置国际化资源文件?
国际化资源文件配置核心是**正确的文件命名、编码规范和层次化组织**，Spring通过`ResourceBundleMessageSource`或`ReloadableResourceBundleMessageSource`进行管理。
**标准资源配置方式：**
```java
@Configuration
public class MessageSourceConfig {
    
    @Bean
    public MessageSource messageSource() {
        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
        messageSource.setBasenames("i18n/messages", "i18n/errors", "i18n/validation");
        messageSource.setDefaultEncoding("UTF-8");
        messageSource.setUseCodeAsDefaultMessage(true);  // 找不到资源时返回编码
        messageSource.setFallbackToSystemLocale(false);   // 禁用系统Locale回退
        return messageSource;
    }
}
```
**支持热加载的配置：**
```java
@Bean
public MessageSource messageSource() {
    ReloadableResourceBundleMessageSource messageSource = 
        new ReloadableResourceBundleMessageSource();
    messageSource.setBasenames(
        "classpath:i18n/messages",
        "file:/etc/app/i18n/errors"  // 外部文件支持
    );
    messageSource.setCacheSeconds(300);  // 缓存5分钟，支持开发期热重载
    messageSource.setDefaultEncoding("UTF-8");
    return messageSource;
}
```
**资源文件内容规范：**
```properties
# messages_zh_CN.properties
welcome.message=欢迎使用我们的系统
user.login.title=用户登录
button.submit=提交
button.cancel=取消

# 参数化消息
greeting.message=你好，{0}！今天是{1,date,long}

# 复数形式处理（通过ChoiceFormat）
items.count={0,choice,0#没有项目|1#一个项目|1<{0}个项目}
```
**高级功能：资源文件继承与fallback机制**
```properties
# 基础资源文件：messages.properties（默认）
button.delete=Delete
button.edit=Edit

# 中文扩展：messages_zh.properties  
button.delete=删除
button.edit=编辑

# 中国大陆特定：messages_zh_CN.properties
button.edit=修改  # 覆盖zh中的"编辑"
```
**XML配置方式（传统项目）：**
```xml
<bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
    <property name="basenames">
        <list>
            <value>i18n/messages</value>
            <value>i18n/errors</value>
        </list>
    </property>
    <property name="defaultEncoding" value="UTF-8"/>
</bean>
```
###### 4. MessageSource 的作用是什么?
`MessageSource`是Spring国际化架构的**核心接口**，定义了消息查找、解析和格式化的标准契约，采用**层次化委托设计**实现灵活的消息解析策略。
**源码架构分析：**
```java
public interface MessageSource {
    // 基础消息查找
    String getMessage(String code, Object[] args, String defaultMessage, Locale locale);
    
    // 必须存在的消息查找（找不到时抛出异常）
    String getMessage(String code, Object[] args, Locale locale) throws NoSuchMessageException;
    
    // 使用MessageSourceResolvable包装查询参数
    String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException;
}
```
**主要实现类对比：**

|**实现类**​|**特点**​|**适用场景**​|
|---|---|---|
|`ResourceBundleMessageSource`|基于JDK ResourceBundle，性能好|生产环境，资源稳定|
|`ReloadableResourceBundleMessageSource`|支持热加载，灵活性高|开发环境，需要频繁修改|
|`StaticMessageSource`|编程式添加消息，无需资源文件|测试环境，简单应用|
**实战应用示例：**
```java
@Service
public class BusinessService {
    private final MessageSource messageSource;
    
    public BusinessService(MessageSource messageSource) {
        this.messageSource = messageSource;
    }
    
    public String getLocalizedMessage(String userPreference) {
        // 动态解析Locale
        Locale locale = determineLocaleFromUser(userPreference);
        
        // 简单消息查找
        String welcomeMsg = messageSource.getMessage("welcome.message", null, locale);
        
        // 参数化消息
        String greeting = messageSource.getMessage(
            "greeting.message", 
            new Object[]{"张三", new Date()}, 
            locale
        );
        
        // 带默认值的消息查找
        String optionalMsg = messageSource.getMessage(
            "custom.message", 
            null, 
            "默认消息",  // 找不到资源时的回退值
            locale
        );
        
        return greeting;
    }
}
```
**在Web层控制器中的使用：**
```java
@Controller
public class UserController {
    
    @Autowired
    private MessageSource messageSource;
    
    @GetMapping("/profile")
    public String userProfile(Model model, Locale locale) {
        // 直接使用注入的MessageSource
        model.addAttribute("title", 
            messageSource.getMessage("user.profile.title", null, locale));
        
        return "profile";
    }
    
    // 使用Spring的RequestContext自动注入消息
    @ResponseBody
    @GetMapping("/message")
    public ResponseEntity<Map<String, String>> getMessage() {
        // 通过RequestContextHolder获取Locale
        Locale locale = RequestContextHolder.getRequestContext().getLocale();
        
        Map<String, String> messages = new HashMap<>();
        messages.put("greeting", messageSource.getMessage("welcome", null, locale));
        return ResponseEntity.ok(messages);
    }
}
```
**高级特性：MessageSourceResolvable应用**
```java
// 定义可解析的消息对象
public class ValidationMessage implements MessageSourceResolvable {
    private String code;
    private Object[] arguments;
    private String defaultMessage;
    
    // 实现接口方法
    @Override
    public String[] getCodes() { return new String[]{code}; }
    
    @Override
    public Object[] getArguments() { return arguments; }
    
    @Override
    public String getDefaultMessage() { return defaultMessage; }
}

// 在服务中使用
public void validateUser(User user, Locale locale) {
    if (user.getName() == null) {
        ValidationMessage message = new ValidationMessage();
        message.setCode("validation.user.name.required");
        message.setDefaultMessage("用户名不能为空");
        
        String errorMsg = messageSource.getMessage(message, locale);
        throw new ValidationException(errorMsg);
    }
}
```