###### 1. SpringMVC 如何处理异常?
SpringMVC的异常处理机制基于**责任链模式**，通过`HandlerExceptionResolver`接口及其实现类提供统一的异常处理框架。其核心流程是：当控制器方法执行过程中抛出异常时，`DispatcherServlet`会捕获异常并遍历所有注册的`HandlerExceptionResolver`实现，直到某个解析器成功处理异常并返回`ModelAndView`对象。
**源码级处理流程如下：**
- **异常捕获阶段**：`DispatcherServlet`的`doDispatch()`方法将控制器方法调用包裹在try-catch块中。当异常抛出时，会调用`processDispatchResult()`方法，进而触发`processHandlerException()`方法。
```java
// DispatcherServlet 中的关键代码
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) {
    try {
        // 执行控制器方法
        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
    } catch (Exception ex) {
        dispatchException = ex;
    }
    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
}

protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
    for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {
        ModelAndView exMv = resolver.resolveException(request, response, handler, ex);
        if (exMv != null) return exMv; // 链式处理，第一个返回非null结果的处理器的解析器生效
    }
    throw ex; // 无解析器处理时重新抛出
}
```
- **解析器执行顺序**：SpringMVC默认注册多个`HandlerExceptionResolver`，按顺序执行：
    1. `ExceptionHandlerExceptionResolver`：处理`@ExceptionHandler`注解的方法。
    2. `ResponseStatusExceptionResolver`：处理带有`@ResponseStatus`注解的异常。
    3. `DefaultHandlerExceptionResolver`：处理Spring内置异常（如404、405等）。
    4. 自定义解析器（如`SimpleMappingExceptionResolver`）。
- **设计价值**：该机制实现了**业务逻辑与异常处理的解耦**，通过可插拔的解析器支持灵活扩展。
###### 2. @ExceptionHandler 注解的作用是什么?
`@ExceptionHandler`是一个方法级注解，用于**在控制器内部定义特定异常的处理逻辑**。其核心作用是将异常处理代码本地化，避免在业务方法中编写重复的try-catch块。
**源码机制与实战应用：**
- **注解定义**：该注解接收一个异常类数组参数，标识其修饰的方法能处理的异常类型。
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ExceptionHandler {
    Class<? extends Throwable>[] value(); // 指定可处理的异常类型
}
```
- **处理流程**：当控制器抛出异常时，`ExceptionHandlerExceptionResolver`会通过反射扫描当前控制器类中所有带有`@ExceptionHandler`的方法，并选择最匹配的方法执行（优先匹配异常类型最接近的）。匹配逻辑通过`ExceptionHandlerMethodResolver`实现，其内部维护了一个异常类型与方法映射的缓存。
- **方法签名灵活性**：被注解的方法支持多种参数类型（如`HttpServletRequest`、`Model`）和返回类型（如`ModelAndView`、`ResponseEntity`、`String`视图名）。
```java
@Controller
public class UserController {
    @ExceptionHandler({UserNotFoundException.class, DataAccessException.class})
    public ResponseEntity<ErrorResponse> handleUserRelatedExceptions(Exception ex, WebRequest request) {
        ErrorResponse error = new ErrorResponse("USER_ERROR", ex.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
```
- **局限**：默认情况下，`@ExceptionHandler`仅对**当前控制器有效**。需结合`@ControllerAdvice`实现全局处理。
###### 3. @ControllerAdvice 注解的作用是什么?
`@ControllerAdvice`是一个**组件级注解**，用于定义全局异常处理器，统一处理应用中所有控制器的异常。其本质是`@Component`的特殊化，能被Spring组件扫描并注册为Bean。
**源码与核心机制：**
- **作用范围控制**：通过注解属性实现细粒度控制：
    - `annotations`：仅处理指定注解（如`@RestController`）的控制器。
    - `basePackages`：仅处理特定包下的控制器。
    - `assignableTypes`：仅处理指定类或其子类的控制器。
```java
@ControllerAdvice(annotations = RestController.class, basePackages = "com.example.api")
public class GlobalApiExceptionHandler {
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAll(Exception ex) {
        // 全局异常处理逻辑
    }
}
```
- **底层实现**：Spring在启动时会扫描所有带`@ControllerAdvice`的类，并由`ExceptionHandlerExceptionResolver`统一管理其内的`@ExceptionHandler`方法。当异常发生时，解析器会优先查找当前控制器的本地处理器，未找到时再遍历全局处理器。
- **设计优势**：此注解实现了**横切关注点的集中管理**，避免异常处理代码分散在各个控制器中。
###### 4. @RestControllerAdvice 和 @ControllerAdvice 的区别是什么?
`@RestControllerAdvice`是`@ControllerAdvice`的**特殊化版本**，专为RESTful API场景设计。其核心区别在于响应体的处理方式。
**源码级差异：**
- **元注解定义**：`@RestControllerAdvice`本身被`@ResponseBody`注解标记，因此其内部所有方法的返回值会自动序列化为JSON/XML等格式。
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ControllerAdvice
@ResponseBody  // 关键差异：自动启用消息转换
public @interface RestControllerAdvice {
    // 属性继承自@ControllerAdvice
}
```
- **使用场景对比**：
    - `@ControllerAdvice`：适用于传统MVC应用，可返回`ModelAndView`或视图名称，用于页面渲染。
    - `@RestControllerAdvice`：适用于前后端分离架构，直接返回序列化数据（如JSON）。
```java
// 传统Web应用：返回视图
@ControllerAdvice
public class WebExceptionHandler {
    @ExceptionHandler(Exception.class)
    public ModelAndView handleException(Exception ex) {
        ModelAndView mav = new ModelAndView("error");
        mav.addObject("message", ex.getMessage());
        return mav;
    }
}

// RESTful API应用：返回JSON
@RestControllerAdvice
public class ApiExceptionHandler {
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleException(Exception ex) {
        ApiError error = new ApiError("INTERNAL_ERROR", ex.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
```
###### 5. SimpleMappingExceptionResolver 的作用是什么?
`SimpleMappingExceptionResolver`是一个**基于配置的异常解析器**，提供将异常类映射到特定视图名的能力。它通过预定义异常-视图映射关系，实现无需编码的简单异常处理。
**核心特性与源码机制：**
- **映射配置**：通过`exceptionMappings`属性（Properties类型）配置异常类与视图名的键值对。当异常发生时，解析器会遍历映射表，使用第一个匹配的异常类或其父类对应的视图。
- **额外功能**：
    - `exceptionAttribute`：将异常对象暴露给视图（默认键为"exception"）。
    - `defaultErrorView`：为未明确映射的异常指定默认视图。
    - `warnLogCategory`：设置日志分类，用于异常记录。
- **配置示例**：
```java
@Configuration
public class ExceptionConfig {
    @Bean
    public SimpleMappingExceptionResolver simpleMappingExceptionResolver() {
        SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver();
        Properties mappings = new Properties();
        mappings.put("com.example.NotFoundException", "error/404");
        mappings.put("java.lang.Exception", "error/generic");
        resolver.setExceptionMappings(mappings);
        resolver.setDefaultErrorView("error/default");
        resolver.setExceptionAttribute("ex");
        return resolver;
    }
}
```
- **源码解析**：其核心方法`doResolveException()`会调用`determineViewName()`根据异常类型查找视图，并通过`getModelAndView()`将异常对象添加到模型：
```java
protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
    String viewName = determineViewName(ex, request);
    if (viewName != null) {
        return getModelAndView(viewName, ex, request);
    }
    return null;
}
```
- **适用场景**：适合简单的异常-页面映射需求，但灵活性不如基于注解的方式。
###### 6. 如何实现全局异常处理?
实现全局异常处理主要依赖`@ControllerAdvice`（或`@RestControllerAdvice`）结合`@ExceptionHandler`**，以下是完整实践方案。
**步骤与最佳实践：**
1. **创建全局异常处理类**：使用`@ControllerAdvice`注解标记类，Spring会自动将其注册为组件。
2. **定义异常处理方法**：在类中使用`@ExceptionHandler`注解修饰方法，方法参数可灵活获取请求上下文。
3. **处理多种异常类型**：通过多个方法覆盖不同异常，利用异常继承关系实现精细化处理。
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    private final Logger logger = LoggerFactory.getLogger(getClass());

    // 处理业务异常
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiResponse<Void>> handleBusinessException(BusinessException ex) {
        ApiResponse<Void> response = ApiResponse.error(ex.getCode(), ex.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }

    // 处理数据校验异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Map<String, String>>> handleValidationException(MethodArgumentNotValidException ex) {
        Map<String, String> errors = ex.getBindingResult().getFieldErrors().stream()
            .collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage));
        ApiResponse<Map<String, String>> response = ApiResponse.error("VALIDATION_FAILED", "数据校验失败", errors);
        return ResponseEntity.badRequest().body(response);
    }

    // 处理所有未显式处理的异常
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleUnknowException(Exception ex) {
        logger.error("系统异常: ", ex); // 记录未知异常日志
        ApiResponse<Void> response = ApiResponse.error("INTERNAL_ERROR", "系统繁忙，请稍后重试");
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
    }
}
```
**关键要点**：
- **异常匹配顺序**：Spring会按**精确度优先**匹配（子类异常优先于父类）。
- **响应统一性**：全局异常处理确保所有接口返回统一的错误格式。
- **敏感信息控制**：生产环境中，通用异常处理方法应避免向客户端返回详细堆栈。
###### 7. 如何自定义异常类?
自定义异常类通常用于**封装特定业务错误**，并通过注解与HTTP状态码绑定。以下是结合`@ResponseStatus`注解的标准化实践。
**创建与使用步骤：**
1. **定义异常类**：继承`RuntimeException`，使用`@ResponseStatus`注解指定HTTP状态码和原因。
```java
@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "用户不存在")
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(Long userId) {
        super("用户ID: " + userId + " 不存在");
    }
}

// 支持动态原因的高级用法
public class BusinessException extends RuntimeException {
    private final String errorCode;
    
    public BusinessException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
    // getter...
}
```
1. **在服务层抛出**：业务逻辑中直接抛出自定义异常。
```java
@Service
public class UserService {
    public User findById(Long id) {
        return userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException(id));
    }
}
```
1. **全局异常处理中捕获**：在`@ControllerAdvice`中处理自定义异常。
```java
@ExceptionHandler(BusinessException.class)
public ResponseEntity<ApiResponse<Void>> handleBusinessException(BusinessException ex) {
    ApiResponse<Void> response = ApiResponse.error(ex.getErrorCode(), ex.getMessage());
    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
}
```
**设计价值**：自定义异常增强了代码可读性，并将**HTTP状态码与业务错误解耦**（如"用户不存在"可映射为404，而非全部500错误）。
###### 8. HandlerExceptionResolver 的作用是什么?
`HandlerExceptionResolver`是SpringMVC异常处理机制的**核心接口**，定义了解析异常的标准化契约。其作用是**将异常转换为统一的错误响应**（如ModelAndView），避免异常直接传播到Servlet容器。
**源码深度解析：**
- **接口定义**：接口唯一的`resolveException`方法返回`ModelAndView`，若返回`null`表示未处理，异常会传递到下一个解析器。
```java
public interface HandlerExceptionResolver {
    @Nullable
    ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, 
                                  @Nullable Object handler, Exception ex);
}
```
- **关键实现类**：
    - `ExceptionHandlerExceptionResolver`：处理`@ExceptionHandler`方法，内部通过`ExceptionHandlerMethodResolver`缓存异常与方法映射。
    - `ResponseStatusExceptionResolver`：检查异常类或其父类的`@ResponseStatus`注解，并调用`response.sendError()`设置状态码。
    - `DefaultHandlerExceptionResolver`：将Spring内置异常（如`HttpRequestMethodNotSupportedException`）转换为对应HTTP状态码（如405）。
- **执行顺序控制**：解析器通过`Ordered`接口排序，默认顺序为：`ExceptionHandlerExceptionResolver`→ `ResponseStatusExceptionResolver`→ `DefaultHandlerExceptionResolver`。开发者可通过实现`Ordered`接口或设置`order`属性调整优先级。
- **扩展机制**：自定义解析器可通过实现该接口集成到处理链中：
```java
@Component
public class CustomHandlerExceptionResolver implements HandlerExceptionResolver, Ordered {
    @Override
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        if (ex instanceof CustomException) {
            response.setStatus(HttpStatus.BAD_REQUEST.value());
            return new ModelAndView("error/custom"); 
        }
        return null; // 无法处理，传递到下一个解析器
    }
    
    @Override
    public int getOrder() {
        return 0; // 最高优先级
    }
}
```