###### 1. SpringMVC 如何实现文件上传?
SpringMVC通过**MultipartResolver策略接口**实现文件上传功能，其核心设计基于**装饰器模式**，对Servlet API的Part对象进行封装处理。文件上传流程涉及**请求解析、数据封装、业务处理**三个关键阶段。
**源码级上传流程分析：**
1. **请求拦截与解析**：当Content-Type为`multipart/form-data`的请求到达时，`DispatcherServlet`会检查已注册的`MultipartResolver`。通过`isMultipart()`方法判断后，调用`resolveMultipart()`方法将原生`HttpServletRequest`包装为`MultipartHttpServletRequest`。
```java
// DispatcherServlet中的关键处理逻辑
public class DispatcherServlet extends FrameworkServlet {
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) {
        HttpServletRequest processedRequest = request;
        // 检查是否为文件上传请求并包装
        if (isMultipart(request) && getMultipartResolver() != null) {
            processedRequest = getMultipartResolver().resolveMultipart(request);
        }
    }
    
    private boolean isMultipart(HttpServletRequest request) {
        return "multipart/form-data".equalsIgnoreCase(request.getContentType());
    }
}
```
2. **数据提取与封装**：`MultipartResolver`的实现类（如`CommonsMultipartResolver`）会解析请求体，将每个文件部分封装为`MultipartFile`对象，表单字段则存入参数映射中。
3. **参数绑定**：`RequestMappingHandlerAdapter`在调用控制器方法时，通过`HandlerMethodArgumentResolver`解析方法参数。对于`MultipartFile`类型参数，会从`MultipartHttpServletRequest`中提取对应的文件数据。
**完整实现示例：**
```java
@Controller
public class FileUploadController {
    
    @PostMapping("/upload")
    public String handleFileUpload(@RequestParam("file") MultipartFile file) {
        if (!file.isEmpty()) {
            try {
                // 安全处理文件名
                String fileName = StringUtils.cleanPath(file.getOriginalFilename());
                
                // 创建目标目录
                Path uploadPath = Paths.get("uploads");
                if (!Files.exists(uploadPath)) {
                    Files.createDirectories(uploadPath);
                }
                
                // 保存文件（方法内处理相对路径安全）
                Path targetLocation = uploadPath.resolve(fileName);
                file.transferTo(targetLocation);
                
                return "redirect:/success";
            } catch (IOException ex) {
                throw new FileStorageException("文件保存失败", ex);
            }
        }
        return "redirect:/error";
    }
}
```
###### 2. MultipartFile 的作用是什么?
`MultipartFile`是Spring文件上传的**核心数据载体接口**，它封装了上传文件的元数据和内容，提供统一的API访问文件信息。从设计角度看，它采用了**桥接模式**，屏蔽底层存储细节（内存或临时磁盘）。
**接口源码深度分析：**
```java
public interface MultipartFile {
    // 元数据获取
    String getName();                    // 表单字段名
    String getOriginalFilename();        // 原始文件名（含路径）
    String getContentType();            // MIME类型
    boolean isEmpty();                   // 是否空文件
    long getSize();                      // 文件大小（字节）
    
    // 内容访问
    byte[] getBytes() throws IOException;                    // 字节数组形式（适合小文件）
    InputStream getInputStream() throws IOException;         // 输入流形式（推荐大文件）
    void transferTo(File dest) throws IOException;          // 直接传输到目标文件
}
```
**核心方法应用场景：**
- **小文件处理**：使用`getBytes()`将文件内容加载到内存进行校验或处理
- **大文件流式处理**：通过`getInputStream()`分块读取，避免内存溢出
- **直接存储**：`transferTo()`方法内部优化了文件拷贝逻辑，性能最佳
**实战中的高级应用：**
```java
@Service
public class FileValidationService {
    
    public boolean isValidFile(MultipartFile file) {
        // 1. 基础校验
        if (file.isEmpty() || file.getSize() == 0) {
            return false;
        }
        
        // 2. 文件类型白名单验证
        Set<String> allowedTypes = Set.of("image/jpeg", "image/png", "application/pdf");
        if (!allowedTypes.contains(file.getContentType())) {
            return false;
        }
        
        // 3. 文件签名验证（防伪冒）
        try (InputStream is = file.getInputStream()) {
            byte[] header = new byte[8];
            is.read(header);
            return isValidFileSignature(header, file.getContentType());
        } catch (IOException e) {
            return false;
        }
    }
    
    private boolean isValidFileSignature(byte[] header, String contentType) {
        // 实际项目中这里实现具体的文件魔术数字验证
        if ("image/jpeg".equals(contentType)) {
            return (header[0] & 0xFF) == 0xFF && (header[1] & 0xFF) == 0xD8;
        }
        return true;
    }
}
```
###### 3. 如何配置文件上传解析器?
配置文件上传解析器需要**准确设置Bean标识和性能参数**，SpringBoot自动配置简化了此过程，但传统XML配置仍需注意细节。
**SpringBoot自动配置（推荐）：**
```yaml
# application.yml
spring:
  servlet:
    multipart:
      enabled: true                   # 启用文件上传支持
      max-file-size: 10MB             # 单个文件最大大小
      max-request-size: 100MB         # 整个请求最大大小
      file-size-threshold: 2MB        # 内存存储阈值，超过此值会写入临时目录
      location: /tmp/uploads          # 临时文件存储目录
```
**传统XML配置细节：**
```xml
<bean id="multipartResolver" 
      class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <!-- 关键：bean id必须为multipartResolver，否则Spring无法识别[1](@ref) -->
    <property name="defaultEncoding" value="UTF-8"/>
    <property name="maxUploadSize" value="10485760"/>          <!-- 总大小10MB -->
    <property name="maxInMemorySize" value="40960"/>           <!-- 内存阈值40KB -->
    <property name="uploadTempDir" value="/tmp/uploads"/>      <!-- 临时目录 -->
</bean>
```
**Java配置方式（现代应用）：**
```java
@Configuration
@EnableWebMvc
public class FileUploadConfig {
    
    @Bean
    public CommonsMultipartResolver multipartResolver() {
        CommonsMultipartResolver resolver = new CommonsMultipartResolver();
        resolver.setDefaultEncoding("UTF-8");
        resolver.setMaxUploadSize(10485760L);
        resolver.setMaxInMemorySize(40960);
        // 解决中文文件名乱码
        resolver.setResolveLazily(true);
        return resolver;
    }
}
```
**配置要点说明**：
- **Bean命名必须准确**：id必须为`multipartResolver`，这是Spring的约定
- **内存阈值优化**：`maxInMemorySize`影响性能，小文件可适当增大提高性能，大文件应减小避免OOM
- **临时目录清理**：生产环境需要定期清理`uploadTempDir`，避免磁盘写满
###### 4. 如何限制上传文件的大小?
文件大小限制需要在**多个层级进行配置**，从解析器到全局请求处理，形成完整的防护体系。
**多层防护配置：**
1. **MultipartResolver层级限制**（最常用）：
```properties
# application.properties - SpringBoot配置
spring.servlet.multipart.max-file-size=2MB
spring.servlet.multipart.max-request-size=10MB
```
2. **全局异常处理**：捕获`MaxUploadSizeExceededException`并提供友好提示
```java
@ControllerAdvice
public class FileUploadExceptionAdvice {
    
    @ExceptionHandler(MaxUploadSizeExceededException.class)
    public ResponseEntity<ErrorResponse> handleMaxSizeException() {
        return ResponseEntity.badRequest()
            .body(new ErrorResponse("文件大小超过限制"));
    }
}
```
3. **自定义校验注解**：在业务层面进行精细控制
```java
@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = FileSizeValidator.class)
public @interface ValidFileSize {
    String message() default "文件大小无效";
    long max() default 5 * 1024 * 1024; // 5MB默认值
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

public class FileSizeValidator implements ConstraintValidator<ValidFileSize, MultipartFile> {
    private long maxSize;
    
    @Override
    public void initialize(ValidFileSize constraint) {
        this.maxSize = constraint.max();
    }
    
    @Override
    public boolean isValid(MultipartFile file, ConstraintValidatorContext context) {
        return file == null || file.getSize() <= maxSize;
    }
}

// 在控制器中使用
@PostMapping("/upload")
public String uploadFile(@ValidFileSize(max = 2 * 1024 * 1024) @RequestParam MultipartFile file) {
    // 业务处理
}
```
###### 5. 如何实现多文件上传?
多文件上传通过**数组或列表接收**实现，SpringMVC会自动将同名文件字段绑定到集合中。
**前端表单设计：**
```html
<form method="post" action="/upload" enctype="multipart/form-data">
    <input type="file" name="files" multiple>           <!-- 多选 -->
    <input type="file" name="files" multiple>           <!-- 同名字段 -->
    <input type="file" name="documents">                <!-- 单文件 -->
    <button type="submit">上传</button>
</form>
```
**控制器实现方案：**
```java
@PostMapping("/upload")
public String handleMultipleUpload(@RequestParam("files") MultipartFile[] files,
                                  @RequestParam("documents") MultipartFile document) {
    // 处理文件数组
    if (files != null) {
        Arrays.stream(files)
              .filter(file -> !file.isEmpty())
              .forEach(this::processFile);
    }
    
    // 处理单个文件
    if (!document.isEmpty()) {
        processSingleFile(document);
    }
    
    return "redirect:/success";
}

// 更现代的List接收方式
@PostMapping("/upload-list")
public String handleListUpload(@RequestParam("files") List<MultipartFile> files) {
    files.parallelStream()  // 并行处理提高大文件上传效率
          .filter(file -> !file.isEmpty())
          .forEach(file -> {
              try {
                  // 生成唯一文件名避免冲突
                  String fileName = UUID.randomUUID() + "_" + 
                      StringUtils.cleanPath(file.getOriginalFilename());
                  file.transferTo(new File("/uploads/" + fileName));
              } catch (IOException e) {
                  throw new FileProcessingException("文件处理失败", e);
              }
          });
    return "redirect:/success";
}
```
**性能优化建议**：
- **并行处理**：对大量小文件使用`parallelStream()`提高处理速度
- **异步处理**：对大文件使用`@Async`避免阻塞请求线程
- **批量操作**：使用数据库批量插入保存文件元信息
###### 6. SpringMVC 如何实现文件下载?
文件下载的核心是**正确设置HTTP响应头**，控制浏览器以附件形式处理响应体。Spring提供多种实现方式，从底层的HttpServletResponse到高级的ResponseEntity封装。
**基于HttpServletResponse的传统实现：**
```java
@GetMapping("/download")
public void downloadFile(@RequestParam String fileName, 
                        HttpServletResponse response) throws IOException {
    // 1. 安全验证和路径构建
    File file = new File("/secure/path/" + fileName);
    if (!file.exists() || !file.getCanonicalPath().startsWith("/secure/path")) {
        response.sendError(HttpStatus.NOT_FOUND.value(), "文件不存在");
        return;
    }
    
    // 2. 设置响应头
    response.setContentType("application/octet-stream");
    response.setHeader("Content-Disposition", 
        "attachment; filename=\"" + URLEncoder.encode(fileName, "UTF-8") + "\"");
    response.setContentLength((int) file.length());
    
    // 3. 流式拷贝（避免内存溢出）
    try (InputStream is = new FileInputStream(file);
         OutputStream os = response.getOutputStream()) {
        IOUtils.copy(is, os);
        os.flush();
    }
}
```
**基于ResponseEntity的现代实现（推荐）：**
```java
@GetMapping("/download-improved")
public ResponseEntity<Resource> downloadImproved(@RequestParam String fileName) {
    // 1. 安全加载文件
    Path filePath = Paths.get("/secure/path").resolve(fileName).normalize();
    if (!Files.exists(filePath)) {
        return ResponseEntity.notFound().build();
    }
    
    // 2. 构建Resource对象
    Resource resource = new InputStreamResource(Files.newInputStream(filePath));
    
    // 3. 构建响应实体
    return ResponseEntity.ok()
        .contentType(MediaType.APPLICATION_OCTET_STREAM)
        .header(HttpHeaders.CONTENT_DISPOSITION, 
            "attachment; filename=\"" + fileName + "\"")
        .body(resource);
}
```
**高级特性 - 断点续传支持：**
```java
@GetMapping("/download-resumable")
public ResponseEntity<Resource> downloadResumable(@RequestParam String fileName,
                                                  HttpServletRequest request) throws IOException {
    Path filePath = Paths.get("/uploads/" + fileName);
    Resource resource = new UrlResource(filePath.toUri());
    
    // 支持Range请求（断点续传）
    String rangeHeader = request.getHeader(HttpHeaders.RANGE);
    if (rangeHeader != null) {
        // 实现206 Partial Content响应
        return buildPartialContentResponse(resource, rangeHeader, filePath);
    }
    
    return ResponseEntity.ok()
        .header(HttpHeaders.CONTENT_TYPE, "application/octet-stream")
        .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + fileName + "\"")
        .body(resource);
}
```
###### 7. ResponseEntity 的作用是什么?
`ResponseEntity`是Spring提供的**完整HTTP响应控制器**，它封装了状态码、头部信息和响应体，提供类型安全的响应构建方式。从设计模式角度看，它采用了**建造者模式**，支持链式调用构建复杂响应。
**源码结构分析：**
```java
public class ResponseEntity<T> extends HttpEntity<T> {
    private final Object status;  // HTTP状态码
    
    // 核心构造器
    public ResponseEntity(HttpStatus status) {
        this(null, null, status);
    }
    
    public ResponseEntity(T body, HttpStatus status) {
        this(body, null, status);
    }
    
    // 静态工厂方法提供流畅API
    public static BodyBuilder status(HttpStatus status) {
        return new DefaultBuilder(status);
    }
    
    public static BodyBuilder ok() {
        return status(HttpStatus.OK);
    }
}
```
**实战应用场景：**
1. **RESTful API响应**：
```java
@RestController
public class FileApiController {
    
    @GetMapping("/api/files/{id}")
    public ResponseEntity<FileInfo> getFileInfo(@PathVariable Long id) {
        FileInfo fileInfo = fileService.findById(id);
        if (fileInfo == null) {
            return ResponseEntity.notFound().build();  // 404
        }
        return ResponseEntity.ok(fileInfo);  // 200 + 文件信息
    }
    
    @PostMapping("/api/files")
    public ResponseEntity<FileInfo> uploadFile(@RequestBody FileUploadRequest request) {
        FileInfo savedInfo = fileService.save(request);
        URI location = ServletUriComponentsBuilder.fromCurrentRequest()
            .path("/{id}").buildAndExpand(savedInfo.getId()).toUri();
            
        return ResponseEntity.created(location).body(savedInfo);  // 201 Created
    }
}
```
2. **高级下载控制**：
```java
@GetMapping("/download-advanced")
public ResponseEntity<StreamingResponseBody> downloadAdvanced() {
    // 流式响应体，适合超大文件
    StreamingResponseBody stream = output -> {
        try (InputStream is = new FileInputStream("largefile.zip")) {
            byte[] buffer = new byte[8192];
            int bytesRead;
            while ((bytesRead = is.read(buffer)) != -1) {
                output.write(buffer, 0, bytesRead);
                output.flush();  // 及时刷新缓冲区
            }
        }
    };
    
    return ResponseEntity.ok()
        .header("Content-Type", "application/zip")
        .header("Content-Disposition", "attachment; filename=\"largefile.zip\"")
        .body(stream);
}
```
**设计优势**：
- **类型安全**：泛型保证响应体类型一致性
- **不可变性**：一旦创建不可修改，线程安全
- **流畅API**：建造者模式提供直观的链式调用
- **完整控制**：可精确控制状态码、头部等所有响应要素