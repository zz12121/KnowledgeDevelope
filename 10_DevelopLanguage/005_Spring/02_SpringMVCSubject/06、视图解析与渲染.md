###### 1. SpringMVC 支持哪些视图技术?
SpringMVC通过**可插拔的视图架构**支持多种视图技术，其核心设计基于**View接口抽象**，使得各种视图实现可以与框架解耦。以下是SpringMVC支持的主要视图技术：
**核心视图类型及对应实现：**

|**视图技术**​|**View实现类**​|**模板文件扩展名**​|**适用场景**​|
|---|---|---|---|
|**JSP/JSTL**​|`InternalResourceView`、`JstlView`|`.jsp`|传统Java Web应用|
|**Thymeleaf**​|`ThymeleafView`|`.html`|现代HTML5应用，强模板引擎|
|**FreeMarker**​|`FreeMarkerView`|`.ftl`|高性能模板渲染|
|**Velocity**​|`VelocityView`|`.vm`|老版本模板技术|
|**PDF文档**​|`AbstractPdfView`|-|报表生成|
|**Excel文档**​|`AbstractExcelView`|`.xls`|数据导出|
|**JSON序列化**​|`MappingJackson2JsonView`|-|RESTful API|
|**XML序列化**​|`MarshallingView`|-|Web Service|
**源码层面的View接口设计：**
```java
public interface View {
    String getContentType();  // 返回内容类型
    void render(Map<String, ?> model, 
                HttpServletRequest request, 
                HttpServletResponse response) throws Exception;
}
```
每种视图技术都通过实现View接口来提供特定的渲染逻辑。SpringMVC的这种设计符合**开闭原则**，可以轻松扩展新的视图技术。
###### 2. InternalResourceViewResolver 的作用是什么?
`InternalResourceViewResolver`是SpringMVC中**用于解析JSP视图的核心组件**，它将逻辑视图名解析为具体的JSP页面路径。
**核心职责与源码机制：**
1. **视图名称解析**：将控制器返回的逻辑视图名（如"user"）转换为完整物理路径（如"/WEB-INF/views/user.jsp"）
2. **视图对象创建**：创建`InternalResourceView`或`JstlView`实例
3. **请求转发**：通过`RequestDispatcher.forward()`实现服务器端页面跳转
**源码中的解析过程：**
```java
public class InternalResourceViewResolver extends UrlBasedViewResolver {
    protected AbstractUrlBasedView buildView(String viewName) throws Exception {
        // 构建完整视图路径
        String path = getPrefix() + viewName + getSuffix();
        InternalResourceView view = (InternalResourceView) super.buildView(viewName);
        view.setUrl(path);
        return view;
    }
}
```
**设计价值**：`InternalResourceViewResolver`通过**前缀后缀配置**实现了逻辑视图与物理路径的解耦，使控制器无需关心具体的视图文件位置。
###### 3. 如何配置视图解析器?
SpringMVC支持**XML和Java配置两种方式**来配置视图解析器，以下是最常用的配置示例：
**Java配置方式（推荐）：**
```java
@Configuration
@EnableWebMvc
public class WebMvcConfig implements WebMvcConfigurer {
    
    @Bean
    public InternalResourceViewResolver jspViewResolver() {
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/views/");
        resolver.setSuffix(".jsp");
        resolver.setViewClass(JstlView.class);  // 支持JSTL
        resolver.setOrder(1);  // 设置解析器优先级
        return resolver;
    }
    
    @Bean
    public ThymeleafViewResolver thymeleafViewResolver() {
        ThymeleafViewResolver resolver = new ThymeleafViewResolver();
        resolver.setTemplateEngine(templateEngine());
        resolver.setCharacterEncoding("UTF-8");
        resolver.setOrder(2);  // 优先级低于JSP解析器
        return resolver;
    }
    
    @Bean
    public SpringTemplateEngine templateEngine() {
        SpringTemplateEngine engine = new SpringTemplateEngine();
        engine.setTemplateResolver(templateResolver());
        return engine;
    }
    
    private ITemplateResolver templateResolver() {
        SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver();
        resolver.setPrefix("/WEB-INF/templates/");
        resolver.setSuffix(".html");
        resolver.setTemplateMode(TemplateMode.HTML);
        return resolver;
    }
}
```
**XML配置方式：**
```xml
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/views/"/>
    <property name="suffix" value=".jsp"/>
    <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
</bean>
```
**多视图解析器配置要点**：通过`order`属性控制解析顺序，SpringMVC会按order值从小到大依次尝试解析，直到某个解析器成功返回View对象。
###### 4. 什么是视图名称解析?
视图名称解析是SpringMVC将**控制器返回的逻辑视图名转换为具体视图对象**的过程，这个过程由`ViewResolver`接口的实现类完成。
**解析流程源码分析：**
```java
// DispatcherServlet中的视图解析流程
public class DispatcherServlet extends FrameworkServlet {
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) {
        // 1. 调用控制器方法，获取ModelAndView
        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
        
        // 2. 解析视图名称
        applyDefaultViewName(processedRequest, mv);
        View view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);
        
        // 3. 渲染视图
        view.render(mv.getModelInternal(), request, response);
    }
    
    protected View resolveViewName(String viewName, Map<String, Object> model, 
                                  Locale locale, HttpServletRequest request) {
        // 遍历所有ViewResolver，按order顺序尝试解析
        for (ViewResolver viewResolver : this.viewResolvers) {
            View view = viewResolver.resolveViewName(viewName, locale);
            if (view != null) return view;
        }
        return null;
    }
}
```
**实际解析示例：**
- **控制器返回**：`return "userList"`
- **解析器处理**：`InternalResourceViewResolver`将其解析为`/WEB-INF/views/userList.jsp`
- **视图创建**：返回一个`InternalResourceView`对象，该对象知道如何渲染指定的JSP页面
这种设计实现了**控制器与视图技术的完全解耦**，控制器只需要返回逻辑名称，具体渲染由配置的视图解析器决定。
###### 5. 如何返回 JSON 数据?
在SpringMVC中返回JSON数据主要通过`@ResponseBody`注解**和**HttpMessageConverter**机制实现。
核心配置与使用：
```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        // 配置Jackson JSON转换器
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        converter.setObjectMapper(new ObjectMapper());
        converters.add(converter);
    }
}

@RestController  // @Controller + @ResponseBody
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        // 自动转换为JSON：{"id":1, "name":"John"}
        return userService.findById(id);
    }
    
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User savedUser = userService.save(user);
        return ResponseEntity.ok(savedUser);
    }
    
    @GetMapping
    public List<User> getUsers() {
        // 自动转换为JSON数组
        return userService.findAll();
    }
}
```
**源码机制**：当方法有`@ResponseBody`注解时，`RequestResponseBodyMethodProcessor`会选择合适的`HttpMessageConverter`将返回值写入响应体。对于JSON数据，通常使用`MappingJackson2HttpMessageConverter`。
###### 6. 如何返回 XML 数据?
返回XML数据与JSON类似，需要配置XML相关的`HttpMessageConverter`。
**XML数据返回实现：**
```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    @Bean
    public Jaxb2Marshaller marshaller() {
        Jaxb2Marshaller marshaller = new Jaxb2Marshaller();
        marshaller.setPackagesToScan("com.example.entity");
        return marshaller;
    }
    
    @Bean
    public MarshallingHttpMessageConverter marshallingMessageConverter() {
        return new MarshallingHttpMessageConverter(marshaller());
    }
}

// 实体类需要JAXB注解
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class User {
    private Long id;
    private String name;
    // getters/setters
}

@RestController
@RequestMapping("/api")
public class XmlController {
    
    @GetMapping(value = "/user/{id}", produces = MediaType.APPLICATION_XML_VALUE)
    public User getUserXml(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    @GetMapping(value = "/users", produces = MediaType.APPLICATION_XML_VALUE)
    public UserList getUsersXml() {
        List<User> users = userService.findAll();
        UserList userList = new UserList();
        userList.setUsers(users);
        return userList;
    }
}
```
**内容协商支持**：可以通过`ContentNegotiatingViewResolver`根据请求的Accept头自动选择返回JSON或XML格式。
###### 7. ModelAndView 的作用是什么?
`ModelAndView`是SpringMVC中**同时封装模型数据和视图信息的容器对象**，为控制器方法提供灵活的返回类型选择。
**核心结构分析：**
```java
public class ModelAndView {
    private Object view;  // 视图信息（String/View对象）
    private ModelMap model;  // 模型数据
    private HttpStatus status;  // HTTP状态码
    
    // 构造方法
    public ModelAndView(String viewName) {
        this.view = viewName;
        this.model = new ModelMap();
    }
    
    public ModelAndView(String viewName, Map<String, ?> model) {
        this.view = viewName;
        this.model = new ModelMap(model);
    }
}
```
**实战使用示例：**
```java
@Controller
public class UserController {
    
    @GetMapping("/user/{id}")
    public ModelAndView getUserDetail(@PathVariable Long id) {
        ModelAndView mav = new ModelAndView("user/detail");
        
        // 添加模型数据
        mav.addObject("user", userService.findById(id));
        mav.addObject("profile", profileService.findByUserId(id));
        mav.addObject("pageTitle", "用户详情");
        
        // 设置HTTP状态
        mav.setStatus(HttpStatus.OK);
        
        return mav;
    }
    
    @PostMapping("/user")
    public ModelAndView createUser(@Valid User user, BindingResult result) {
        ModelAndView mav = new ModelAndView();
        
        if (result.hasErrors()) {
            mav.setViewName("user/form");
            mav.addObject("errors", result.getAllErrors());
            mav.setStatus(HttpStatus.BAD_REQUEST);
        } else {
            User savedUser = userService.save(user);
            mav.setViewName("redirect:/user/" + savedUser.getId());
            mav.setStatus(HttpStatus.CREATED);
        }
        
        return mav;
    }
}
```
**设计价值**：`ModelAndView`提供了**更细粒度的控制能力**，允许在单个返回值中同时指定视图、模型数据和HTTP状态，适合复杂业务场景。
###### 8. Model、ModelMap 和 Map 的区别是什么?
这三个接口在SpringMVC中都用于**存储模型数据**，但在抽象层次和使用场景上有细微差别。
**关系对比与源码分析：**
```java
// 接口继承关系
public interface Model {}  // 核心模型接口

public class ModelMap extends LinkedHashMap<String, Object> {}  // 具体实现

public class ExtendedModelMap extends ModelMap implements Model {}  // 桥接实现

// 控制器方法参数可以互换使用
@Controller
public class ModelController {
    
    // 1. 使用Model接口（推荐）
    @GetMapping("/test1")
    public String test1(Model model) {
        model.addAttribute("message", "Hello Model");
        return "view";
    }
    
    // 2. 使用ModelMap
    @GetMapping("/test2")
    public String test2(ModelMap model) {
        model.addAttribute("message", "Hello ModelMap");
        return "view";
    }
    
    // 3. 使用Map
    @GetMapping("/test3")
    public String test3(Map<String, Object> model) {
        model.put("message", "Hello Map");
        return "view";
    }
}
```
**底层实现机制**：Spring通过`ModelMethodProcessor`处理模型参数，内部使用`BindingAwareModelMap`作为统一实现：
```java
public class BindingAwareModelMap extends ModelMap implements Model {
    // 统一实现，三种参数类型最终都使用相同的存储结构
}
```
**选择建议**：
- **Model接口**：最常用，提供类型安全的API`addAttribute()`
- **ModelMap**：需要Map操作功能时使用
- **Map**：需要最大灵活性时使用
三者在实际效果上完全等价，只是API设计角度不同。
###### 9. RedirectAttributes 的作用是什么?
`RedirectAttributes`是SpringMVC提供的**在重定向间传递参数的专用接口**，解决了HTTP重定向导致请求属性丢失的问题。
**核心特性与实现：**
```java
@Controller
public class RedirectController {
    
    @PostMapping("/user")
    public String createUser(@Valid User user, RedirectAttributes redirectAttributes) {
        try {
            User savedUser = userService.save(user);
            
            // 添加成功消息（Flash属性）
            redirectAttributes.addFlashAttribute("successMessage", "用户创建成功");
            
            // 添加路径变量
            redirectAttributes.addAttribute("userId", savedUser.getId());
            
            return "redirect:/user/{userId}";
            
        } catch (Exception e) {
            // 添加错误消息
            redirectAttributes.addFlashAttribute("errorMessage", "创建失败: " + e.getMessage());
            return "redirect:/user/form";
        }
    }
    
    @GetMapping("/user/{userId}")
    public String getUser(@PathVariable Long userId, Model model) {
        // Flash属性自动从FlashMap中获取并添加到Model
        User user = userService.findById(userId);
        model.addAttribute("user", user);
        return "user/detail";
    }
}
```
**Flash属性原理**：Spring通过`FlashMap`和`FlashMapManager`在会话中临时存储属性，重定向后自动提取并清除：
```java
public interface RedirectAttributes {
    // 添加Flash属性（存储在会话中，重定向后自动移除）
    RedirectAttributes addFlashAttribute(String attributeName, Object attributeValue);
    
    // 添加URL参数（作为查询字符串附加到重定向URL）
    RedirectAttributes addAttribute(String attributeName, Object attributeValue);
}
```
**使用场景**：
- **成功/错误消息传递**：操作结果提示
- **表单重填保护**：Post-Redirect-Get模式
- **跨重定向参数传递**：保持状态信息
###### 10. 如何实现页面重定向?
在SpringMVC中，重定向主要通过`redirect:`前缀**和`RedirectView`实现，以下是详细实现方式：
基于字符串的重定向：**
```java
@Controller
public class RedirectController {
    
    // 1. 重定向到应用内URL
    @PostMapping("/process")
    public String processForm(Form form) {
        // 处理表单数据...
        return "redirect:/result";  // 重定向到/result GET请求
    }
    
    // 2. 重定向带路径变量
    @PostMapping("/user")
    public String createUser(User user) {
        User savedUser = userService.save(user);
        return "redirect:/user/" + savedUser.getId();  // 重定向到/user/123
    }
    
    // 3. 重定向带查询参数
    @GetMapping("/search")
    public String search(@RequestParam String keyword) {
        return "redirect:/results?keyword=" + URLEncoder.encode(keyword, "UTF-8");
    }
}
```
**基于RedirectView的重定向：**
```java
@Controller
public class AdvancedRedirectController {
    
    @PostMapping("/advanced")
    public RedirectView advancedRedirect(RedirectAttributes attributes) {
        RedirectView redirectView = new RedirectView();
        redirectView.setUrl("/success");
        redirectView.setContextRelative(true);  // 相对路径
        redirectView.setHttp10Compatible(false);  // 使用HTTP 1.1状态码
        
        attributes.addFlashAttribute("message", "操作成功");
        return redirectView;
    }
}
```
**源码机制**：当返回值以`"redirect:"`开头时，`UrlBasedViewResolver`会创建`RedirectView`实例，在`render`方法中调用`HttpServletResponse.sendRedirect()`。
###### 11. 如何实现请求转发?
请求转发通过`forward:`前缀**实现，在服务器内部将请求转发到其他资源。
转发实现方式：**
```java
@Controller
public class ForwardController {
    
    // 1. 转发到JSP页面
    @GetMapping("/page")
    public String toPage() {
        return "forward:/WEB-INF/views/page.jsp";  // 直接转发到JSP
    }
    
    // 2. 转发到其他控制器
    @GetMapping("/preprocess")
    public String preprocess() {
        // 前置处理逻辑...
        return "forward:/main/handle";  // 转发给其他控制器方法
    }
    
    @GetMapping("/main/handle")
    public String mainHandle() {
        // 主要处理逻辑
        return "result";
    }
    
    // 3. 转发保护资源
    @GetMapping("/protected")
    public String protectedResource() {
        // 转发到WEB-INF下的受保护资源
        return "forward:/WEB-INF/protected/data.xml";
    }
}
```
**与重定向的关键区别**：
- **URL不变**：浏览器地址栏显示原始URL
- **同一请求**：转发前后共享同一HttpServletRequest对象
- **服务器内部操作**：客户端无感知
###### 12. redirect 和 forward 的区别是什么?
redirect和forward是两种根本不同的**页面跳转机制**，理解它们的区别对设计正确的导航流程至关重要。
**全面对比分析：**

|**特性**​|**forward（转发）**​|**redirect（重定向）**​|
|---|---|---|
|**请求次数**​|1次请求|2次请求|
|**URL显示**​|浏览器地址栏不变|浏览器地址栏改变|
|**数据共享**​|共享Request属性|无法共享Request属性|
|**性能**​|较高（服务器内部跳转）|较低（客户端往返）|
|**目标限制**​|只能访问应用内资源|可以跨应用跳转|
|**实现方式**​|`return "forward:/path"`|`return "redirect:/path"`|
|**底层机制**​|`RequestDispatcher.forward()`|`HttpServletResponse.sendRedirect()`|
**源码级差异：**
```java
// forward实现
public class InternalResourceView extends AbstractUrlBasedView {
    protected void renderMergedOutputModel(Map<String, Object> model, 
                                         HttpServletRequest request, 
                                         HttpServletResponse response) throws Exception {
        // 暴露模型数据到Request属性
        exposeModelAsRequestAttributes(model, request);
        
        // 获取RequestDispatcher并转发
        RequestDispatcher rd = request.getRequestDispatcher(getUrl());
        rd.forward(request, response);
    }
}

// redirect实现  
public class RedirectView extends AbstractUrlBasedView {
    protected void renderMergedOutputModel(Map<String, Object> model, 
                                          HttpServletRequest request, 
                                          HttpServletResponse response) throws Exception {
        // 构建重定向URL
        String targetUrl = createTargetUrl(model, request);
        
        // 发送重定向响应
        response.sendRedirect(targetUrl);
    }
}
```
**设计选择建议**：
- **使用forward**：保持请求上下文、保护内部资源、性能敏感场景
- **使用redirect**：防止表单重复提交、完成Post-Redirect-Get模式、跨应用导航