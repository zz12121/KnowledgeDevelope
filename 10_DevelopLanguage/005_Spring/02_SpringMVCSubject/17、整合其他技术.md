###### 1. SpringMVC 如何整合 MyBatis?
SpringMVC整合MyBatis的核心在于**分层架构设计**和**依赖注入机制**，通过Spring的IoC容器统一管理MyBatis的核心组件。整合的关键是**SqlSessionFactoryBean**和**MapperScannerConfigurer**这两个核心类。
**整合架构与源码实现：**
**数据源与SqlSessionFactory配置**（applicationContext-dao.xml）：
```xml
<!-- 数据源配置 -->
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="${jdbc.driver}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
    <property name="maxActive" value="30"/>
    <property name="maxIdle" value="5"/>
</bean>

<!-- SqlSessionFactoryBean配置 -->
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="configLocation" value="classpath:mybatis/sqlMapConfig.xml"/>
    <!-- 别名包扫描 -->
    <property name="typeAliasesPackage" value="com.example.entity"/>
    <!-- mapper.xml文件位置 -->
    <property name="mapperLocations" value="classpath*:mapper/**/*.xml"/>
</bean>
```
**Mapper接口扫描配置**：
```xml
<!-- Mapper扫描器 -->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="com.example.mapper"/>
    <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
</bean>
```
**源码级整合原理**：
- **SqlSessionFactoryBean**实现了Spring的FactoryBean和InitializingBean接口，在afterPropertiesSet()方法中构建SqlSessionFactory
- **MapperScannerConfigurer**使用BeanDefinitionRegistryPostProcessor在容器启动时扫描指定包下的接口并注册为BeanDefinition
- **MapperFactoryBean**为每个Mapper接口创建代理实例，通过SqlSessionTemplate执行SQL
**事务管理配置**：
```xml
<!-- 事务管理器 -->
<bean id="transactionManager" 
      class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>

<!-- 注解驱动事务 -->
<tx:annotation-driven transaction-manager="transactionManager"/>
```
**完整的三层架构代码示例**：
```java
// Mapper接口
public interface UserMapper {
    User selectById(Long id);
    void insert(User user);
}

// Service层
@Service
@Transactional
public class UserServiceImpl implements UserService {
    @Autowired
    private UserMapper userMapper;
    
    public User getUserById(Long id) {
        return userMapper.selectById(id);
    }
}

// Controller层
@Controller
@RequestMapping("/user")
public class UserController {
    @Autowired
    private UserService userService;
    
    @GetMapping("/{id}")
    public String getUser(@PathVariable Long id, Model model) {
        User user = userService.getUserById(id);
        model.addAttribute("user", user);
        return "user/detail";
    }
}
```
###### 2. SpringMVC 如何整合 Hibernate?
SpringMVC整合Hibernate的核心是**SessionFactory的管理**和**事务的统一控制**，通过LocalSessionFactoryBean集成Hibernate的配置。
**Hibernate整合配置详解**：
**SessionFactory配置**：
```xml
<!-- 数据源配置 -->
<bean id="dataSource" class="org.apache.commons.dbcp2.BasicDataSource">
    <property name="driverClassName" value="${jdbc.driver}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>

<!-- Hibernate SessionFactory -->
<bean id="sessionFactory" 
      class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="packagesToScan" value="com.example.entity"/>
    <property name="hibernateProperties">
        <props>
            <prop key="hibernate.dialect">org.hibernate.dialect.MySQLDialect</prop>
            <prop key="hibernate.show_sql">true</prop>
            <prop key="hibernate.format_sql">true</prop>
            <prop key="hibernate.hbm2ddl.auto">update</prop>
            <prop key="hibernate.current_session_context_class">thread</prop>
        </props>
    </property>
</bean>
```
**事务管理配置**：
```xml
<!-- Hibernate事务管理器 -->
<bean id="transactionManager"
      class="org.springframework.orm.hibernate5.HibernateTransactionManager">
    <property name="sessionFactory" ref="sessionFactory"/>
</bean>

<!-- 注解驱动事务 -->
<tx:annotation-driven transaction-manager="transactionManager"/>
```
**DAO层设计与实现**：
```java
@Repository
@Transactional
public class UserDaoImpl implements UserDao {
    
    @Autowired
    private SessionFactory sessionFactory;
    
    private Session getCurrentSession() {
        return sessionFactory.getCurrentSession();
    }
    
    @Override
    public User findById(Long id) {
        return getCurrentSession().get(User.class, id);
    }
    
    @Override
    public void save(User user) {
        getCurrentSession().saveOrUpdate(user);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<User> findAll() {
        return getCurrentSession()
                .createQuery("from User", User.class)
                .getResultList();
    }
}
```
**Spring Data JPA整合**（现代推荐方式）：
```java
// Entity定义
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String username;
    private String email;
    // getters/setters
}

// Repository接口
public interface UserRepository extends JpaRepository<User, Long> {
    User findByUsername(String username);
    List<User> findByEmailContaining(String email);
}

// Service层
@Service
@Transactional
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(User user) {
        return userRepository.save(user);
    }
}
```
###### 3. SpringMVC 如何整合 Spring Security?
Spring Security整合采用**过滤器链机制**，通过DelegatingFilterProxy将安全控制嵌入Web请求处理流程。
**安全配置核心实现**：
**Web.xml配置**：
```xml
<!-- Spring Security过滤器 -->
<filter>
    <filter-name>springSecurityFilterChain</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
    <filter-name>springSecurityFilterChain</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```
**Java配置方式**（推荐）：
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
            .antMatchers("/admin/**").hasRole("ADMIN")
            .antMatchers("/user/**").hasAnyRole("USER", "ADMIN")
            .antMatchers("/public/**").permitAll()
            .anyRequest().authenticated()
            .and()
            .formLogin()
            .loginPage("/login")
            .permitAll()
            .and()
            .logout()
            .permitAll();
    }
    
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService)
            .passwordEncoder(passwordEncoder());
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```
**方法级安全控制**：
```java
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
}

// 在Service层使用方法级安全注解
@Service
public class UserService {
    
    @PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")
    public User getUserProfile(Long userId) {
        // 只有管理员或用户本人可以访问
        return userRepository.findById(userId);
    }
    
    @Secured("ROLE_ADMIN")
    public void deleteUser(Long userId) {
        // 只有管理员可以删除用户
        userRepository.deleteById(userId);
    }
}
```
**自定义访问决策逻辑**：
```java
@Component
public class CustomAccessDecisionVoter implements AccessDecisionVoter<Object> {
    @Override
    public boolean supports(ConfigAttribute attribute) {
        return true;
    }
    
    @Override
    public int vote(Authentication authentication, Object object, 
                   Collection<ConfigAttribute> attributes) {
        // 自定义访问决策逻辑
        return ACCESS_GRANTED;
    }
}
```
###### 4. SpringMVC 如何整合 Thymeleaf?
Thymeleaf整合通过**TemplateEngine和ViewResolver**实现，提供现代化的模板渲染能力。
**完整整合配置**：
**Java配置方式**：
```java
@Configuration
@EnableWebMvc
public class ThymeleafConfig implements WebMvcConfigurer {
    
    @Bean
    public SpringTemplateEngine templateEngine() {
        SpringTemplateEngine templateEngine = new SpringTemplateEngine();
        templateEngine.setTemplateResolver(templateResolver());
        templateEngine.addDialect(new SpringSecurityDialect()); // 集成Spring Security
        return templateEngine;
    }
    
    @Bean
    public SpringResourceTemplateResolver templateResolver() {
        SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver();
        resolver.setPrefix("classpath:/templates/");
        resolver.setSuffix(".html");
        resolver.setTemplateMode(TemplateMode.HTML);
        resolver.setCharacterEncoding("UTF-8");
        resolver.setCacheable(false); // 开发阶段关闭缓存
        return resolver;
    }
    
    @Bean
    public ThymeleafViewResolver thymeleafViewResolver() {
        ThymeleafViewResolver resolver = new ThymeleafViewResolver();
        resolver.setTemplateEngine(templateEngine());
        resolver.setCharacterEncoding("UTF-8");
        resolver.setOrder(1); // 视图解析器顺序
        return resolver;
    }
    
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.viewResolver(thymeleafViewResolver());
    }
}
```
**XML配置方式**：
```xml
<bean id="templateResolver" 
      class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">
    <property name="prefix" value="/WEB-INF/templates/" />
    <property name="suffix" value=".html" />
    <property name="templateMode" value="HTML" />
    <property name="characterEncoding" value="UTF-8" />
    <property name="cacheable" value="false" />
</bean>

<bean id="templateEngine" 
      class="org.thymeleaf.spring5.SpringTemplateEngine">
    <property name="templateResolver" ref="templateResolver" />
    <property name="additionalDialects">
        <set>
            <bean class="org.thymeleaf.extras.springsecurity5.dialect.SpringSecurityDialect"/>
        </set>
    </property>
</bean>

<bean class="org.thymeleaf.spring5.view.ThymeleafViewResolver">
    <property name="templateEngine" ref="templateEngine" />
    <property name="characterEncoding" value="UTF-8" />
    <property name="order" value="1" />
</bean>
```
**控制器与模板交互**：
```java
@Controller
public class UserController {
    
    @GetMapping("/user/{id}")
    public String userProfile(@PathVariable Long id, Model model) {
        User user = userService.findById(id);
        model.addAttribute("user", user);
        model.addAttribute("currentTime", LocalDateTime.now());
        return "user/profile"; // 对应templates/user/profile.html
    }
}
```
**Thymeleaf模板示例**：
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
    <title>用户详情 - <span th:text="${user.username}">用户名</span></title>
</head>
<body>
    <div sec:authorize="isAuthenticated()">
        <h1 th:text="'欢迎, ' + ${user.username}">欢迎用户</h1>
    </div>
    
    <div th:if="${user.active}">
        <p>用户状态: <span th:text="#{user.active}">活跃</span></p>
    </div>
    
    <ul>
        <li th:each="item : ${user.items}">
            <span th:text="${item.name}">项目名</span>
        </li>
    </ul>
    
    <script th:inline="javascript">
        var userId = [[${user.id}]];
        console.log('用户ID:', userId);
    </script>
</body>
</html>
```
###### 5. SpringMVC 如何整合 FreeMarker?
FreeMarker整合与Thymeleaf类似，但针对**高性能模板渲染**场景优化，适合大型企业级应用。
**FreeMarker详细配置**：
**Java配置实现**：
```java
@Configuration
@EnableWebMvc
public class FreeMarkerConfig implements WebMvcConfigurer {
    
    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath("classpath:/templates/");
        configurer.setDefaultEncoding("UTF-8");
        
        Properties settings = new Properties();
        settings.setProperty("datetime_format", "yyyy-MM-dd HH:mm:ss");
        settings.setProperty("number_format", "0.##");
        settings.setProperty("classic_compatible", "true");
        configurer.setFreemarkerSettings(settings);
        
        return configurer;
    }
    
    @Bean
    public FreeMarkerViewResolver freeMarkerViewResolver() {
        FreeMarkerViewResolver resolver = new FreeMarkerViewResolver();
        resolver.setCache(true);
        resolver.setPrefix("");
        resolver.setSuffix(".ftl");
        resolver.setContentType("text/html;charset=UTF-8");
        resolver.setExposeSpringMacroHelpers(true);
        resolver.setExposeRequestAttributes(true);
        resolver.setExposeSessionAttributes(true);
        return resolver;
    }
}
```
**XML配置方式**：
```xml
<bean id="freemarkerConfig" 
      class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
    <property name="templateLoaderPath" value="/WEB-INF/ftl/"/>
    <property name="defaultEncoding" value="UTF-8"/>
    <property name="freemarkerSettings">
        <props>
            <prop key="datetime_format">yyyy-MM-dd HH:mm:ss</prop>
            <prop key="number_format">0.##</prop>
            <prop key="classic_compatible">true</prop>
        </props>
    </property>
</bean>

<bean id="viewResolver" 
      class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver">
    <property name="cache" value="true"/>
    <property name="prefix" value=""/>
    <property name="suffix" value=".ftl"/>
    <property name="contentType" value="text/html;charset=UTF-8"/>
</bean>
```
**FreeMarker模板示例**：
```ftl
<#-- FreeMarker模板 -->
<!DOCTYPE html>
<html>
<head>
    <title>${user.username} - 用户详情</title>
    <meta charset="UTF-8">
</head>
<body>
    <h1>欢迎, ${user.username!''}</h1>
    
    <#if user.active>
        <p>用户状态: <span class="active">活跃</span></p>
    </#if>
    
    <table>
        <tr>
            <th>ID</th>
            <th>用户名</th>
            <th>邮箱</th>
            <th>注册时间</th>
        </tr>
        <tr>
            <td>${user.id}</td>
            <td>${user.username}</td>
            <td>${user.email}</td>
            <td>${user.createTime?string('yyyy-MM-dd HH:mm:ss')}</td>
        </tr>
    </table>
    
    <#-- 宏定义 -->
    <#macro userInfo user>
        <div class="user-info">
            <h3>${user.username}</h3>
            <p>${user.email}</p>
        </div>
    </#macro>
    
    <#-- 使用宏 -->
    <@userInfo user=user/>
</body>
</html>
```
###### 6. SpringMVC 如何整合 WebSocket?
WebSocket整合提供**全双工通信能力**，适用于实时应用场景。Spring通过**STOMP协议**和**消息代理**简化WebSocket开发。
**WebSocket完整配置**：
**基础配置类**：
```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // 注册STOMP端点，客户端通过此端点连接
        registry.addEndpoint("/ws")
                .setAllowedOriginPatterns("*")
                .withSockJS(); // 支持SockJS回退选项
    }
    
    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        // 启用简单内存消息代理
        registry.enableSimpleBroker("/topic", "/queue");
        // 应用目标前缀
        registry.setApplicationDestinationPrefixes("/app");
        // 用户目标前缀（点对点）
        registry.setUserDestinationPrefix("/user");
    }
}
```
**高级消息代理配置**（RabbitMQ/ActiveMQ）：
```java
@Configuration
@EnableWebSocketMessageBroker
public class AdvancedWebSocketConfig implements WebSocketMessageBrokerConfigurer {
    
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/websocket")
                .setHandshakeHandler(new DefaultHandshakeHandler())
                .setAllowedOriginPatterns("*");
    }
    
    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        // 使用外部消息代理（RabbitMQ）
        registry.enableStompBrokerRelay("/topic", "/queue")
                .setRelayHost("localhost")
                .setRelayPort(61613)
                .setClientLogin("guest")
                .setClientPasscode("guest");
        
        registry.setApplicationDestinationPrefixes("/app");
    }
    
    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(new ChannelInterceptor() {
            @Override
            public Message<?> preSend(Message<?> message, MessageChannel channel) {
                // 消息拦截和处理
                return message;
            }
        });
    }
}
```
**WebSocket控制器实现**：
```java
@Controller
public class WebSocketController {
    
    private final SimpMessagingTemplate messagingTemplate;
    
    public WebSocketController(SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }
    
    // 处理客户端发送的消息
    @MessageMapping("/chat.send")
    @SendTo("/topic/public")
    public ChatMessage sendMessage(@Payload ChatMessage chatMessage) {
        return chatMessage;
    }
    
    // 点对点消息
    @MessageMapping("/chat.private.{userId}")
    public void sendPrivateMessage(@DestinationVariable String userId, 
                                  @Payload ChatMessage chatMessage) {
        messagingTemplate.convertAndSendToUser(
            userId, 
            "/queue/private", 
            chatMessage
        );
    }
    
    // 处理用户加入事件
    @EventListener
    public void handleWebSocketConnectListener(SessionConnectedEvent event) {
        // 用户连接处理
    }
    
    // 处理用户断开事件
    @EventListener 
    public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {
        // 用户断开处理
    }
}
```
**前端JavaScript客户端**：
```javascript
// WebSocket客户端连接
const socket = new SockJS('/ws');
const stompClient = Stomp.over(socket);

stompClient.connect({}, function(frame) {
    console.log('Connected: ' + frame);
    
    // 订阅公共频道
    stompClient.subscribe('/topic/public', function(message) {
        showMessage(JSON.parse(message.body));
    });
    
    // 订阅私有频道
    stompClient.subscribe('/user/queue/private', function(message) {
        showPrivateMessage(JSON.parse(message.body));
    });
});

// 发送消息
function sendMessage() {
    const message = {
        content: document.getElementById('message').value,
        sender: username,
        timestamp: new Date()
    };
    stompClient.send("/app/chat.send", {}, JSON.stringify(message));
}
```
**安全配置**：
```java
@Configuration
public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {
    
    @Override
    protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
            .simpDestMatchers("/app/**").authenticated()
            .simpSubscribeDestMatchers("/topic/**", "/queue/**").authenticated()
            .anyMessage().permitAll();
    }
    
    @Override
    protected boolean sameOriginDisabled() {
        return true; // 禁用同源策略（开发环境）
    }
}
```