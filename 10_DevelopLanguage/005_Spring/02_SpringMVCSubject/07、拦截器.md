###### 1. 什么是拦截器?
拦截器是Spring MVC框架中的一种**横切关注点实现机制**，基于**AOP（面向切面编程）思想**，用于在控制器方法执行前后插入自定义处理逻辑。其核心价值在于实现**公共业务逻辑的模块化封装**，避免代码重复。
**源码层面的设计架构：**
Spring MVC通过`HandlerExecutionChain`类管理拦截器链，该类维护了一个`HandlerInterceptor`列表：
```java
public class HandlerExecutionChain {
    private final List<HandlerInterceptor> interceptorList = new ArrayList<>();
    
    boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) {
        for (int i = 0; i < this.interceptorList.size(); i++) {
            HandlerInterceptor interceptor = this.interceptorList.get(i);
            if (!interceptor.preHandle(request, response, this.handler)) {
                triggerAfterCompletion(request, response, null);
                return false;
            }
        }
        return true;
    }
}
```
**核心特性：**
- **非侵入式设计**：通过配置而非代码侵入方式增强功能
- **精确作用域**：仅针对Spring MVC管理的控制器方法
- **生命周期集成**：与请求处理流程深度集成，提供preHandle、postHandle、afterComplete三个切入点
- **链式执行**：支持多个拦截器形成处理链，按顺序执行
###### 2. 拦截器和过滤器的区别是什么?
拦截器与过滤器是Web应用中两个重要的横切处理组件，它们在设计层面和应用层面有本质区别。
**架构对比表：**

|**特性**​|**拦截器(Interceptor)**​|**过滤器(Filter)**​|
|---|---|---|
|**规范依赖**​|Spring框架特定组件|Servlet规范标准组件|
|**作用范围**​|仅针对Spring MVC控制器|所有Web请求（静态资源、Servlet等）|
|**依赖注入**​|支持Spring依赖注入|不支持，需通过其他方式获取Bean|
|**实现机制**​|基于Java反射和动态代理|基于函数回调|
|**控制粒度**​|方法级别拦截|URL模式匹配|
|**访问上下文**​|可访问HandlerMethod、ModelAndView等Spring对象|仅能访问Servlet API|
**源码级执行位置差异：**
在Spring MVC的`DispatcherServlet.doDispatch()`方法中，拦截器执行位于核心处理流程中：
```java
public class DispatcherServlet extends FrameworkServlet {
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) {
        HandlerExecutionChain mappedHandler = getHandler(processedRequest);
        
        // 1. 执行拦截器preHandle
        if (!mappedHandler.applyPreHandle(processedRequest, response)) {
            return; // 被拦截器阻断
        }
        
        // 2. 实际处理器执行
        ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
        
        // 3. 执行拦截器postHandle
        mappedHandler.applyPostHandle(processedRequest, response, mv);
        
        // 4. 流程完成后的afterCompletion执行
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
}
```
而Filter执行在更外层，由Servlet容器直接管理。
###### 3. 如何自定义拦截器?
创建自定义拦截器需要实现`HandlerInterceptor`接口并重写相关方法，以下是完整实现流程。
**基础实现示例：**
```java
@Component
public class AuthenticationInterceptor implements HandlerInterceptor {
    private final Logger logger = LoggerFactory.getLogger(getClass());
    
    @Autowired
    private UserService userService;  // 支持依赖注入
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 
                           Object handler) throws Exception {
        // 1. 类型检查
        if (!(handler instanceof HandlerMethod)) {
            return true;
        }
        
        // 2. 权限验证逻辑
        String token = request.getHeader("Authorization");
        if (!StringUtils.hasText(token)) {
            sendErrorResponse(response, 401, "未提供认证令牌");
            return false;
        }
        
        // 3. Token验证
        User user = userService.validateToken(token);
        if (user == null) {
            sendErrorResponse(response, 401, "认证令牌无效");
            return false;
        }
        
        // 4. 用户信息存储到请求上下文
        UserContext.setCurrentUser(user);
        logger.info("用户{}访问{}", user.getUsername(), request.getRequestURI());
        return true;
    }
    
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, 
                         Object handler, ModelAndView modelAndView) throws Exception {
        // 可向模型添加通用数据
        if (modelAndView != null) {
            modelAndView.addObject("currentUser", UserContext.getCurrentUser());
        }
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
                              Object handler, Exception ex) throws Exception {
        // 清理线程局部变量，防止内存泄漏
        UserContext.clear();
        if (ex != null) {
            logger.error("请求处理完成，发生异常: {}", ex.getMessage());
        }
    }
    
    private void sendErrorResponse(HttpServletResponse response, int status, String message) 
            throws IOException {
        response.setStatus(status);
        response.setContentType("application/json;charset=UTF-8");
        ResultVO result = new ResultVO(status, message);
        response.getWriter().write(JSON.toJSONString(result));
    }
}
```
**高级特性：基于注解的条件拦截**
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermission {
    String[] value() default {};
}

@Component
public class PermissionInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 
                           Object handler) throws Exception {
        if (!(handler instanceof HandlerMethod)) {
            return true;
        }
        
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        RequirePermission annotation = handlerMethod.getMethodAnnotation(RequirePermission.class);
        
        if (annotation != null) {
            User user = UserContext.getCurrentUser();
            if (user == null || !hasPermission(user, annotation.value())) {
                sendErrorResponse(response, 403, "权限不足");
                return false;
            }
        }
        return true;
    }
}
```
###### 4. HandlerInterceptor 接口有哪些方法?
`HandlerInterceptor`接口定义了三个核心方法，覆盖了请求处理的不同生命周期阶段。
**方法详细说明：**
1. **preHandle - 前置处理**
```java
boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
```
- **执行时机**：处理器方法执行之前
- **返回值语义**：true表示继续流程，false表示中断请求
- **典型应用**：身份验证、权限检查、日志记录
- **异常处理**：抛出异常将终止执行链，触发已执行拦截器的afterCompletion
2. **postHandle - 后置处理**
```java
void postHandle(HttpServletRequest request, HttpServletResponse response, 
                Object handler, ModelAndView modelAndView)
```
- **执行时机**：处理器方法执行后，视图渲染前
- **模型访问**：可修改ModelAndView对象
- **注意事项**：仅当处理器正常返回（未抛出异常）时执行
- **典型应用**：向模型添加通用数据、修改视图名称
3. **afterCompletion - 完成处理**
```java
void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                    Object handler, Exception ex)
```
- **执行时机**：整个请求处理完成后（视图渲染完毕）
- **异常信息**：可获取处理过程中抛出的异常（如有）
- **资源清理**：线程局部变量清理、资源释放
- **保证执行**：无论处理成功与否都会执行（类似于finally块）
###### 5. preHandle、postHandle 和 afterCompletion 方法的执行顺序是什么?
三个方法的执行遵循严格的**生命周期顺序**，理解这个顺序对正确使用拦截器至关重要。
**正常流程执行序列：**
```
请求到达
    ↓
preHandle1 → preHandle2 → preHandle3  (正向执行)
    ↓
控制器方法执行
    ↓
postHandle3 ← postHandle2 ← postHandle1  (反向执行)  
    ↓
视图渲染
    ↓
afterCompletion3 ← afterCompletion2 ← afterCompletion1  (反向执行)
    ↓
响应返回
```
**源码中的执行逻辑：**
在`HandlerExecutionChain`中，三个方法的调用位置如下：
```java
public class HandlerExecutionChain {
    // preHandle执行：正向顺序
    boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) {
        for (int i = 0; i < this.interceptorList.size(); i++) {
            HandlerInterceptor interceptor = this.interceptorList.get(i);
            if (!interceptor.preHandle(request, response, this.handler)) {
                triggerAfterCompletion(request, response, null);
                return false;
            }
            this.interceptorIndex = i;  // 记录最后执行的拦截器索引
        }
        return true;
    }
    
    // postHandle执行：反向顺序  
    void applyPostHandle(HttpServletRequest request, HttpServletResponse response, 
                        ModelAndView mv) {
        for (int i = this.interceptorList.size() - 1; i >= 0; i--) {
            HandlerInterceptor interceptor = this.interceptorList.get(i);
            interceptor.postHandle(request, response, this.handler, mv);
        }
    }
    
    // afterCompletion执行：反向顺序（仅针对已成功执行preHandle的拦截器）
    void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, 
                               Exception ex) {
        for (int i = this.interceptorIndex; i >= 0; i--) {
            HandlerInterceptor interceptor = this.interceptorList.get(i);
            interceptor.afterCompletion(request, response, this.handler, ex);
        }
    }
}
```
**异常情况处理：**
- **preHandle返回false**：后续拦截器和控制器方法不执行，但已执行preHandle的拦截器会执行afterCompletion
- **控制器方法抛出异常**：postHandle不执行，但afterCompletion会执行
- **postHandle抛出异常**：afterCompletion仍会执行，异常传递给DispatcherServlet的异常解析器
###### 6. 多个拦截器的执行顺序是怎样的?
多个拦截器形成**拦截器链**，其执行顺序由注册顺序决定，遵循**先进后出**的栈式行为。
**执行顺序规则：**
1. **preHandle**：按注册顺序**正序**执行
2. **postHandle**：按注册顺序**逆序**执行
3. **afterCompletion**：按注册顺序**逆序**执行
**配置顺序示例：**
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoggingInterceptor()).order(1);       // 最先注册
        registry.addInterceptor(new AuthInterceptor()).order(2);          // 其次注册  
        registry.addInterceptor(new PermissionInterceptor()).order(3);     // 最后注册
    }
}
```
**执行序列可视化：**
```
请求到达
    ↓
LoggingInterceptor.preHandle()     → 第一个执行
    ↓  
AuthInterceptor.preHandle()         → 第二个执行
    ↓
PermissionInterceptor.preHandle()  → 第三个执行
    ↓
控制器方法执行
    ↓
PermissionInterceptor.postHandle()  → 第一个执行（逆序）
    ↓
AuthInterceptor.postHandle()        → 第二个执行
    ↓
LoggingInterceptor.postHandle()    → 第三个执行
    ↓
视图渲染
    ↓
PermissionInterceptor.afterCompletion() → 第一个执行（逆序）
    ↓
AuthInterceptor.afterCompletion()       → 第二个执行
    ↓
LoggingInterceptor.afterCompletion()     → 第三个执行
```
**设计价值**：这种执行顺序确保了**资源申请的逆序释放**（如：日志拦截器最先开始记录，最后结束记录），符合资源管理的最佳实践。
###### 7. 如何配置拦截器?
Spring MVC提供了**灵活的多方式配置机制**，支持精确的URL模式匹配和排除规则。
**Java配置（推荐方式）：**
```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    @Autowired
    private LoggingInterceptor loggingInterceptor;
    @Autowired
    private AuthInterceptor authInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 日志拦截器：记录所有请求
        registry.addInterceptor(loggingInterceptor)
                .addPathPatterns("/**")                    // 拦截所有路径
                .order(1);
        
        // 认证拦截器：排除公开接口
        registry.addInterceptor(authInterceptor)
                .addPathPatterns("/api/**")                 // 拦截API路径
                .excludePathPatterns("/api/public/**")      // 排除公开接口
                .excludePathPatterns("/api/auth/login")     // 排除登录接口
                .order(2);
        
        // 权限拦截器：管理端接口
        registry.addInterceptor(new PermissionInterceptor())
                .addPathPatterns("/admin/**")              // 只拦截管理端
                .order(3);
    }
}
```
**路径匹配模式说明：**
- `/**`：匹配所有路径（包含多级路径）
- `/api/*`：只匹配/api下的一级路径
- `/static/**`：匹配/static下的所有子路径
- 精确匹配：如`/api/users`只匹配该精确路径
**XML配置（传统项目）：**
```xml
<mvc:interceptors>
    <!-- 全局拦截器，拦截所有路径 -->
    <bean class="com.example.LoggingInterceptor"/>
    
    <!-- 指定路径拦截器 -->
    <mvc:interceptor>
        <mvc:mapping path="/api/**"/>
        <mvc:exclude-mapping path="/api/public/**"/>
        <bean class="com.example.AuthInterceptor"/>
    </mvc:interceptor>
</mvc:interceptors>
```
**高级配置：条件拦截器**
```java
@Configuration
public class ConditionalInterceptorConfig implements WebMvcConfigurer {
    @Value("${features.auth.enabled:true}")
    private boolean authEnabled;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 根据配置条件动态启用拦截器
        if (authEnabled) {
            registry.addInterceptor(new AuthInterceptor())
                    .addPathPatterns("/**")
                    .order(1);
        }
    }
}
```
###### 8. 拦截器的应用场景有哪些?
拦截器在企业级应用中有广泛的实用场景，以下是几个典型应用模式。
**1. 身份认证与授权**
```java
@Component
public class JwtAuthInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 
                           Object handler) throws Exception {
        String token = extractToken(request);
        if (token == null) {
            sendUnauthorizedResponse(response, "缺少认证令牌");
            return false;
        }
        
        try {
            Claims claims = Jwts.parserBuilder()
                    .setSigningKey(jwtSecret)
                    .build()
                    .parseClaimsJws(token)
                    .getBody();
                    
            String username = claims.getSubject();
            User user = userService.findByUsername(username);
            UserContext.setCurrentUser(user);
            return true;
            
        } catch (JwtException e) {
            sendUnauthorizedResponse(response, "令牌无效或已过期");
            return false;
        }
    }
}
```
**2. 接口性能监控**
```java
@Component
public class PerformanceInterceptor implements HandlerInterceptor {
    private final ThreadLocal<Long> startTime = new ThreadLocal<>();
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 
                           Object handler) throws Exception {
        startTime.set(System.currentTimeMillis());
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                              Object handler, Exception ex) throws Exception {
        long duration = System.currentTimeMillis() - startTime.get();
        startTime.remove();
        
        if (duration > 1000) {  // 记录慢请求
            logger.warn("慢接口: {} {} 耗时: {}ms", 
                request.getMethod(), request.getRequestURI(), duration);
        }
        
        // 记录指标到监控系统
        metricsService.recordRequestMetrics(request, duration, ex == null);
    }
}
```
**3. 日志追踪与链路跟踪**
```java
@Component
public class TraceInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                           Object handler) throws Exception {
        // 生成请求追踪ID
        String traceId = UUID.randomUUID().toString();
        MDC.put("traceId", traceId);
        response.setHeader("X-Trace-Id", traceId);
        
        logger.info("请求开始: {} {} from {}", 
            request.getMethod(), request.getRequestURI(), getClientIp(request));
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                              Object handler, Exception ex) throws Exception {
        logger.info("请求完成: {} {}", request.getMethod(), request.getRequestURI());
        MDC.clear();  // 清除线程上下文
    }
}
```
**4. 数据预处理与后处理**
```java
@Component
public class DataPreprocessInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                           Object handler) throws Exception {
        // 参数预处理：去除字符串参数的首尾空格
        Map<String, String[]> params = request.getParameterMap();
        for (String[] values : params.values()) {
            for (int i = 0; i < values.length; i++) {
                if (values[i] != null) {
                    values[i] = values[i].trim();
                }
            }
        }
        return true;
    }
    
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response,
                         Object handler, ModelAndView modelAndView) throws Exception {
        // 添加通用响应数据
        if (modelAndView != null) {
            modelAndView.addObject("serverTime", LocalDateTime.now());
            modelAndView.addObject("version", "1.0.0");
        }
    }
}
```
**5. 防重复提交控制**
```java
@Component
public class IdempotentInterceptor implements HandlerInterceptor {
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                           Object handler) throws Exception {
        if (!"POST".equalsIgnoreCase(request.getMethod())) {
            return true;  // 只处理POST请求
        }
        
        String token = request.getHeader("Idempotent-Token");
        if (!StringUtils.hasText(token)) {
            sendErrorResponse(response, "缺少幂等令牌");
            return false;
        }
        
        // 检查令牌是否已使用
        String key = "idempotent:" + token;
        Boolean absent = redisTemplate.opsForValue().setIfAbsent(key, "1", Duration.ofMinutes(30));
        if (Boolean.FALSE.equals(absent)) {
            sendErrorResponse(response, "请求已处理，请勿重复提交");
            return false;
        }
        
        return true;
    }
}
```