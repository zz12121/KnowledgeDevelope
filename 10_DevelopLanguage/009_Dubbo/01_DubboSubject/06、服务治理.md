###### 1. Dubbo的服务治理功能包括哪些？
Dubbo的服务治理是一套用于保障分布式服务架构稳定性、可观测性和可控性的综合能力，涵盖服务生命周期的各个方面：
1. **服务注册与发现**：提供者自动注册，消费者动态发现，支持多种注册中心。
2. **负载均衡**：内置随机、轮询、最少活跃、一致性哈希等算法，支持自定义扩展。
3. **集群容错**：提供失败自动切换、快速失败、失败安全等多种容错策略。
4. **服务路由**：支持条件路由、标签路由等，实现流量调度和灰度发布。
5. **动态配置**：支持运行时动态调整参数（超时、权重、负载均衡策略等），无需重启。
6. **服务降级与Mock**：在非核心服务故障时进行降级，返回兜底数据或本地Mock结果。
7. **服务限流与熔断**：通过与Sentinel等组件的集成，实现流量控制、熔断降级。
8. **优雅上下线**：提供者预热、延迟暴露、优雅停机，消费者无感知切换。
9. **访问控制**：基于IP的黑白名单机制，保障服务安全。
10. **服务监控**：提供调用次数、耗时、成功率等统计信息，便于监控和排查。
11. **服务分组与版本**：通过分组和版本号实现环境隔离和多版本共存。
这些功能大部分通过SPI机制实现，例如`Router`、`ConfigCenter`、`MetadataReport`等扩展点。
###### 2. Dubbo如何实现服务降级和容错？
**服务降级**主要通过在消费者端配置`mock`实现，有两种模式：
- **本地Mock**：当调用失败（如超时、异常）时，返回预设的兜底数据。配置`mock="true"`会查找接口名+`Mock`后缀的本地类；也可通过`mock="force:return null"`强制返回null，不发起远程调用。在源码中，`MockClusterWrapper`包装了原始`Invoker`，在`invoke`方法中根据配置和调用结果决定是否执行Mock逻辑。
- **容错降级**：结合集群容错策略，如`Failsafe`在异常时直接忽略，`Failback`记录失败请求并定时重发。
**集群容错**通过`Cluster`接口及其实现完成。以默认的`FailoverClusterInvoker`为例，其`doInvoke`方法在捕获到`RpcException`时，会根据重试次数`retries`选择其他提供者重试。其他策略如`Failfast`直接抛出异常，`Failsafe`捕获异常并记录日志。
###### 3. Dubbo的服务分组和版本号有什么作用？
- **分组（group）**：用于区分同一接口的不同实现，常见于多环境隔离（如test、prod）或相同接口的多个实现。消费者必须指定分组才能调用对应服务。在注册中心，不同分组的服务属于不同路径，如`/dubbo/com.example.DemoService/providers`和`/dubbo/com.example.DemoService:test/providers`。
- **版本号（version）**：用于接口不兼容升级时的多版本共存和灰度过渡。提供者可以同时暴露v1.0.0和v2.0.0版本的服务，消费者根据自身需求引用指定版本。版本号作为服务URL的一部分，在`RegistryDirectory`的`notify`方法中会根据消费者URL中的版本过滤提供者列表。
**源码角度**：在`RegistryProtocol.doRefer`中，构建的订阅URL会包含group和version参数。在`ZookeeperRegistry.doSubscribe`中，这些参数用于确定具体的订阅路径。消费者最终获得的`Invoker`列表是经过group和version过滤后的。
###### 4. 服务上线怎么兼容旧版本？
采用**多版本并行**和**渐进式迁移**策略：
1. **接口设计兼容**：新接口添加方法而非修改原方法签名；DTO使用兼容性序列化（如Protobuf）或添加字段时使用可选值。
2. **同时部署新老版本**：新版本服务以新版本号（如v2.0.0）部署，与老版本（v1.0.0）并存。
3. **消费者逐步迁移**：
    - 先让部分消费者（如内部调用）升级到新版本，验证稳定性。
    - 利用Dubbo的**路由规则**，将特定流量（如测试用户）路由到新版本。
    - 最终全量消费者升级后，下线老版本服务。
4. **版本回滚预案**：一旦新版本有问题，可快速将消费者版本配置回滚至旧版本。
###### 5. Dubbo的服务上下线如何优雅处理？
**上线优雅处理**：
- **延迟暴露**：通过`delay`参数（单位毫秒）让服务在Spring容器初始化完成后延迟暴露，避免消费者在提供者未完全就绪时调用。在`ServiceConfig.export()`中，如果`delay > 0`，会使用定时器延迟调用`doExport()`。
- **服务预热**：通过`warmup`参数设置预热时间（如10分钟）。在此期间，该提供者的权重会从1线性增长至设定的权重，让流量缓慢增加。权重计算在`RegistryProtocol.doExport`中进行，公式为：`weight = calculateWarmupWeight(启动时间戳, 预热时间, 设定权重)`。
**下线优雅处理**：
- **优雅停机**：
- **从注册中心注销**：在停机前，先调用`Protocol.destroy()`，该方法会向注册中心注销服务，并等待一段时间让消费者感知。消费者通过注册中心通知更新本地`Invoker`列表，移除下线的提供者。
###### 6. 怎么实现动态感知服务下线的呢？
通过**注册中心的Watcher/Listener机制**实现。以Zookeeper为例：
1. 提供者启动时在Zookeeper的`/dubbo/{service}/providers`下创建**临时节点**。
2. 消费者启动时订阅该路径，并注册一个`ChildListener`。
3. 当提供者正常下线或异常崩溃（会话断开）时，Zookeeper会自动删除其临时节点。
4. Zookeeper触发`ChildListener.childChanged()`回调，消费者端的`ZookeeperRegistry`收到事件。
5. `ZookeeperRegistry`调用`RegistryDirectory.notify(List<URL> urls)`，更新本地`methodInvokerMap`，移除下线的`Invoker`。
源码中，`ZookeeperRegistry.doSubscribe()`会为路径添加`ChildListener`，其`childChanged()`方法最终调用`notify()`。`RegistryDirectory.notify()`会重新构建`Invoker`列表，并刷新`RouterChain`。
###### 7. Dubbo 如何优雅停机？
优雅停机流程由`DubboShutdownHook`触发，主要步骤：
1. **拒绝新请求**：关闭所有`Protocol`的`Server`，不再接受新的远程调用请求。
2. **等待已有请求完成**：通过计数器（如`Server`的`executor`）等待正在处理的请求完成，超时时间默认10秒，可通过`dubbo.service.shutdown.wait`配置。
3. **注销服务**：向注册中心注销所有服务，让消费者及时更新列表。
4. **释放资源**：关闭连接池、线程池等资源。
在`DubboProtocol`中，`destroy()`方法会遍历`serverMap`，关闭每个`ExchangeServer`。`ExchangeServer`关闭时会先停止接收新请求，然后等待`executor`中的任务完成。
###### 8. Dubbo 的管理控制台能做什么？
Dubbo Admin（管理控制台）提供可视化服务治理功能：
1. **服务查询**：查看服务提供者、消费者列表及其详细信息（IP、端口、版本、分组等）。
2. **服务测试**：手动触发服务调用，支持参数输入和结果查看。
3. **动态配置**：
    - 调整服务提供者权重，实时影响负载均衡。
    - 动态修改超时时间、重试次数等参数。
    - 配置条件路由和标签路由规则。
    - 配置动态`Mock`规则。
4. **服务治理**：
    - 启用/禁用服务，强制下线提供者。
    - 配置黑白名单。
5. **监控与统计**：查看服务调用统计（QPS、平均响应时间、成功率等）。
6. **依赖关系**：可视化展示服务间的调用依赖图。
控制台通过读取注册中心的数据获取服务信息，并通过操作注册中心或配置中心下发动态配置。
###### 9. Dubbo 如何实现服务限流？
Dubbo本身未内置限流，但可通过以下方式实现：
1. **自定义Filter**：实现`Filter`接口，在`invoke()`方法中加入限流逻辑（如计数器、令牌桶）。通过SPI文件`META-INF/dubbo/org.apache.dubbo.rpc.Filter`注册，然后在服务或方法上通过`filter`参数启用。
2. **集成Sentinel**：引入`dubbo-adapter`依赖，配置Sentinel的`DubboFilter`。在Sentinel控制台配置QPS或线程数规则。其原理是Sentinel的`DubboFilter`作为SPI Filter插入调用链，在`before`方法中进行流控检查。
3. **TpsLimitFilter**：Dubbo自带了一个简单的TPS限流Filter，可通过`tps`参数或`TPSLimiter`SPI进行配置，但功能较简单。
推荐使用Sentinel，它提供了更丰富的流控规则和实时监控。
###### 10. Dubbo 如何实现服务熔断？
类似限流，Dubbo原生未提供熔断器，但可通过集成第三方组件实现：
1. **集成Sentinel**：在Sentinel中配置熔断降级规则，如慢调用比例、异常比例。当达到阈值时，Sentinel的`DubboFilter`会抛出`BlockException`，触发熔断。在`CircuitBreaker`模块中，Sentinel实现了状态机（关闭、打开、半开）。
2. **自定义Filter模拟**：在Filter中统计调用失败率，超过阈值时在一段时间内直接抛出异常或返回mock值。需注意线程安全和时间窗口。
3. **结合集群容错**：使用`Failfast`或`Failsafe`策略快速失败，但无法实现动态熔断和自动恢复。
熔断的核心是**失败率统计和状态切换**，Sentinel等成熟组件提供了更可靠和丰富的实现。
###### 11. Dubbo 的服务路由规则有哪些？
Dubbo支持两种主要的路由规则：
1. **条件路由**：通过编写条件表达式来匹配消费者和提供者。规则示例：
    - `host = 10.20.153.10 => host = 10.20.153.11`：消费者IP为10.20.153.10时，只调用IP为10.20.153.11的提供者。
    - `method = find* => host = 10.20.153.10,10.20.153.11`：以find开头的方法调用指定的两个提供者。
        条件路由规则存储在注册中心（如`/dubbo/{service}/routers`）或配置中心。
2. **标签路由**：为提供者打上标签（如`tag="gray"`），消费者可通过`RpcContext.getContext().setAttachment("dubbo.tag", "gray")`携带标签。路由时，优先匹配相同标签的提供者；若无匹配，则降级调用无标签提供者。用于灰度发布。
路由规则在`RegistryDirectory.notify()`中被加载，构建`RouterChain`。在调用时，`AbstractClusterInvoker`会调用`RouterChain.route()`对`Invoker`列表进行过滤。
###### 12. Dubbo 如何实现灰度发布？
利用**标签路由**实现：
1. **部署新版本**：部署新版本服务提供者，并打上标签（如`tag="gray"`）。旧版本提供者保持无标签或`tag="stable"`。
2. **配置路由规则**：通过Dubbo Admin下发标签路由规则，指定哪些消费者携带灰度标签。例如，按IP或用户ID百分比。
3. **消费者携带标签**：在灰度用户请求的入口（如网关或Filter），通过`RpcContext.getContext().setAttachment("dubbo.tag", "gray")`设置标签。
4. **路由匹配**：`TagRouter`会根据消费者携带的标签选择相同标签的提供者；若消费者无标签，则选择无标签的提供者。从而实现灰度流量隔离。
5. **逐步全量**：验证无误后，逐步扩大灰度范围，最终全量升级并移除标签。
此外，也可使用**条件路由**实现更复杂的灰度策略，但标签路由是官方推荐的灰度发布方案。
###### 13. Dubbo 服务自省
Dubbo服务自省是Dubbo 2.7引入的重要特性，旨在**改进服务发现模型，降低对注册中心的压力**。
**传统模式**：服务提供者将完整的服务元数据（接口、方法、参数等）发布到注册中心，消费者从注册中心拉取。这导致注册中心存储压力大，且元数据变化频繁。
**自省模式**：将服务发现分为两层：
1. **实例发现**：注册中心仅存储服务实例的基本信息（IP、端口等），数据轻量。
2. **元数据同步**：服务提供者将详细的元数据发布到独立的**元数据中心**（如Nacos、Zookeeper）。消费者从元数据中心拉取元数据。
**配置**：
```properties
dubbo.metadata-report.address=nacos://127.0.0.1:8848
```
**优势**：
- 减轻注册中心压力，提高可扩展性。
- 元数据中心可以独立部署，支持更大规模的服务注册。
- 为Dubbo 3.0的应用级服务发现奠定基础。
在源码中，`MetadataReport`定义了元数据上报接口，`MetadataReportFactory`负责创建实例。提供者在`ServiceConfig.export()`时会调用`MetadataUtils.publishServiceDefinition()`上报元数据。消费者在引用服务时，会从元数据中心拉取元数据用于服务代理的生成。