###### 1. Dubbo的负载均衡策略有哪些？
Dubbo 提供了多种负载均衡策略，均通过 `org.apache.dubbo.rpc.cluster.LoadBalance`SPI 接口实现。消费者在调用集群中的某个服务时，会根据配置的策略从多个提供者中选择一个。内置策略包括：
1. **Random LoadBalance（随机，默认）**：按权重设置随机概率。这是 Dubbo 的**默认策略**。调用量越大分布越均匀。权重越大，被选中的概率越高。其算法原理是：先计算所有提供者的总权重，然后产生一个 `[0, totalWeight)`之间的随机数，接着遍历提供者列表，用随机数依次减去每个提供者的权重，当随机数小于0时，就选择当前的提供者。源码参见 `RandomLoadBalance`的 `doSelect`方法。
2. **RoundRobin LoadBalance（轮询）**：按公约后的权重设置轮询比率。存在慢的提供者累积请求的问题。比如第二台机器很慢，但请求会卡在那台机器上。其内部维护了一个 `ConcurrentMap<String, AtomicPositiveInteger>`用于记录每个方法的调用序列，实现加权轮询。源码参见 `RoundRobinLoadBalance`。
3. **LeastActive LoadBalance（最少活跃调用数）**：优先调用活跃数最小的提供者，使慢的提供者收到更少请求。活跃数指调用前后计数差（表示该提供者正在处理的请求数）。相同活跃数的随机。能很好地反应提供者的实时处理能力。源码在 `LeastActiveLoadBalance`中，会先遍历找出最小活跃数，然后在这些相同最小活跃数的提供者中，根据权重进行选择（类似随机策略）。
4. **ConsistentHash LoadBalance（一致性哈希）**：相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。默认只对第一个参数进行哈希。适用于有状态服务（如缓存、会话）。源码参见 `ConsistentHashLoadBalance`，它内部维护了一个 `ConsistentHashSelector`，为每个提供者创建多个虚拟节点，形成一个哈希环。
###### 2. Dubbo 默认的负载均衡策略是什么？
Dubbo **默认使用 Random LoadBalance，即随机负载均衡策略**。
**选择随机策略作为默认值的主要原因是其良好的综合性能和在分布式场景下的合理性：**
1. **简单高效，性能开销小**：随机选择算法的逻辑非常简单，只需要计算总权重并生成一个随机数，时间复杂度为O(n)。相比于轮询需要维护调用序列状态，其性能开销更小，且无状态，不需要在消费者端保存任何历史信息。
2. **自然平滑**：在请求量足够大、调用周期较长的情况下，随机算法可以很平滑地将请求分布到各个提供者节点上，最终结果接近按权重的比例分配，不会出现轮询策略中可能因某个节点响应慢而导致的“堆积”现象。
3. **避免热点与倾斜**：由于随机性，它不容易因为某些特定请求参数（与一致性哈希相比）或调用顺序（与轮询相比）导致流量长期集中在某个节点上，有利于集群资源的整体均衡利用。
4. **与权重配置配合良好**：随机策略完美支持权重配置。权重高的节点被选中的概率成比例增加，使得流量分配可以精细化控制。
在 `LoadBalance`的 SPI 扩展文件（`META-INF/dubbo/internal/org.apache.dubbo.rpc.cluster.LoadBalance`）中，随机策略被定义为 `random=org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance`。当未显式配置 `loadbalance`属性时，会通过 `ExtensionLoader`获取默认扩展名 `random`对应的实现。
###### 3. 如何自定义负载均衡策略？
Dubbo 的自定义负载均衡策略完全基于其**SPI机制**，步骤清晰：
1. **实现 `LoadBalance`接口**：创建一个类，实现 `org.apache.dubbo.rpc.cluster.LoadBalance`接口。该接口只有一个核心方法：
    ```java
    <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;
    ```
    你需要在该方法中实现自己的选择逻辑。`invokers`是可用的服务提供者列表，`url`包含本次调用的配置信息，`invocation`是本次调用的信息。
2. **声明 SPI 扩展**：在项目的 `resources`目录下创建文件 `META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance`（注意路径）。文件内容为自定义扩展名和实现类的全限定名。例如：
    ```java
    myLoadbalance=com.example.MyCustomLoadBalance
    ```
3. **在配置中启用**：在服务消费者端（`<dubbo:reference>`或 `@Reference`）或方法级别，通过 `loadbalance`属性指定自定义的策略名。
    ```xml
    <dubbo:reference interface="com.example.DemoService" loadbalance="myLoadbalance" />
    ```
    或者：
    ```java
    @Reference(loadbalance = "myLoadbalance")
    private DemoService demoService;
    ```
**源码角度**：当发起调用时，在 `AbstractClusterInvoker`的 `invoke`方法中，会调用 `doSelect`方法，其中通过 `ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(“myLoadbalance”)`加载你的实现，然后调用其 `select`方法。自定义策略将无缝融入 Dubbo 的集群调用流程。
###### 4. 集群容错方式有哪些？
集群容错发生在服务消费者端，当调用某个服务提供者失败时，Dubbo 提供的应对策略。所有容错策略都通过 `org.apache.dubbo.rpc.cluster.Cluster`SPI 接口及其包装器 `ClusterInvoker`实现。主要策略包括：
1. **Failover Cluster（失败自动切换，默认）**：调用失败后，自动切换至其他服务器重试。通常用于**读操作**。可通过 `retries=”2″`属性设置重试次数（不含第一次）。源码对应 `FailoverClusterInvoker`。
2. **Failfast Cluster（快速失败）**：只发起一次调用，失败后立即报错。通常用于**非幂等性的写操作**，如新增记录，避免重复执行。源码对应 `FailfastClusterInvoker`。
3. **Failsafe Cluster（失败安全）**：调用出现异常时，直接忽略，仅记录日志。通常用于写入审计日志等不重要的操作。源码对应 `FailsafeClusterInvoker`。
4. **Failback Cluster（失败自动恢复）**：调用失败后，后台记录失败请求，定时重发。通常用于消息通知等场景。源码对应 `FailbackClusterInvoker`，其内部有一个重试定时器。
5. **Forking Cluster（并行调用多个服务器）**：同时调用多个提供者，只要一个成功即返回。通常用于对实时性要求非常高的**读操作**，但会浪费更多资源。可通过 `forks=”2″`设置最大并行数。源码对应 `ForkingClusterInvoker`。
6. **Broadcast Cluster（广播调用）**：广播所有提供者，逐个调用，任意一个报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源。源码对应 `BroadcastClusterInvoker`。
这些容错策略的入口在 `Cluster`接口的 `join`方法，它接收一个 `Directory`（目录服务，持有所有可用Invoker），返回一个包装了容错逻辑的 `ClusterInvoker`。
###### 5. 如何实现Dubbo的集群部署？
实现 Dubbo 服务集群部署，核心是**启动多个服务提供者实例**，并让它们向同一个注册中心注册。消费者端通过负载均衡策略调用这些实例。具体步骤如下：
1. **服务提供者无状态化**：这是集群化的前提。确保服务实例不存储会话（Session）等状态数据，状态应外置于分布式缓存或数据库。这样任何请求都可以被任意一个实例处理。
2. **多实例启动**：
    - **物理机/虚拟机**：在不同机器或同一机器的不同端口上，部署相同的服务应用。例如，在机器A的20880端口和机器B的20880端口启动Provider。
    - **容器化（如Docker/K8s）**：使用同一个服务镜像，部署多个Pod（副本），并配置相同的服务名和注册中心地址。Kubernetes Service 或 Dubbo 自身负责服务发现。
3. **统一注册中心**：所有Provider实例和Consumer都配置**同一个注册中心集群**（如Zookeeper集群或Nacos集群地址）。这是它们相互发现的基础。
4. **消费者配置**：消费者只需配置要调用的服务接口和注册中心地址。启动后，它会从注册中心拉取该服务的所有提供者地址列表。
5. **负载均衡与容错**：在消费者端，通过配置 `loadbalance`和 `cluster`属性，来决定如何从多个Provider中选择以及调用失败后的行为。这是集群能力发挥的关键。
**示例配置**：
- **Provider A**​ (IP1:20880) 和 **Provider B**​ (IP2:20880) 的配置：
    ```xml
    <dubbo:application name="demo-provider"/>
    <dubbo:registry address="zookeeper://127.0.0.1:2181"/>
    <dubbo:protocol name="dubbo" port="20880"/>
    <dubbo:service interface="com.example.DemoService" ref="demoService"/>
    ```
- **Consumer**​ 配置：
    ```xml
    <dubbo:application name="demo-consumer"/>
    <dubbo:registry address="zookeeper://127.0.0.1:2181"/>
    <dubbo:reference id="demoService" interface="com.example.DemoService" loadbalance="random"/>
    ```
    启动后，Consumer会获得两个Provider地址，并根据配置的`random`策略进行调用。
###### 6. Dubbo 的集群容错默认是哪种策略？
Dubbo **默认的集群容错策略是 Failover Cluster，即失败自动切换**。
**为什么选择Failover作为默认？**
1. **符合普遍需求**：在大多数业务场景中，尤其是**读操作**，一次偶然的调用失败（如网络抖动、目标节点瞬时GC）是可以容忍的，通过重试其他节点往往能成功，从而**有效提升整体调用成功率和用户体验**。这比直接报错更友好。
2. **提高系统可用性**：在分布式环境中，单一节点的短暂不可用是常态。Failover机制能够自动屏蔽故障节点，将请求导向健康节点，从消费者角度看，服务整体可用性得到了保障。
3. **配置可控**：通过 `retries`参数（默认2次）可以控制重试次数，避免因无限重试导致的雪崩。通常 `retries=0`表示不重试，`retries=1`表示重试一次（共调用2次）。
4. **平衡与稳妥**：相比其他策略，Failover在成功率、延迟和资源消耗之间取得了一个较好的平衡。Failfast太脆弱，Forking太耗资源，Failback逻辑复杂。Failover是一个简单有效的通用方案。
**源码体现**：在 `Cluster`的 SPI 扩展文件中，默认扩展名指向 `failover`。在 `RegistryProtocol.doRefer`方法中创建 `Invoker`时，会调用 `Cluster$Adaptive.join`方法，如果没有特别指定 `cluster`参数，就会使用默认的 `failover`策略，最终生成一个 `FailoverClusterInvoker`。
###### 7. 服务读写推荐的容错策略是怎样的？
针对服务的读写特性，推荐的容错策略应有所不同，核心原则是：**保证数据一致性，避免非幂等操作重复执行。**
- **读服务（查询、获取信息等幂等操作）**：
    - **推荐策略**：**Failover Cluster（失败自动切换）**。
    - **理由**：读操作通常是**幂等**的，多次执行不会产生副作用。当一次调用失败时，重试其他节点可以最大程度保证成功，提升用户体验和系统可用性。
    - **配置建议**：可以适当设置 `retries`（如1或2）。同时可搭配较短的 `timeout`，以便快速失败并重试。负载均衡策略可选择 `Random`或 `LeastActive`。
- **写服务（新增、修改、删除等非幂等操作）**：
    - **推荐策略**：**Failfast Cluster（快速失败）**​ 或 **Failsafe Cluster（失败安全）**。
    - **理由**：
        - **Failfast**：适用于**核心写操作**（如创建订单、扣减库存）。一旦失败立即抛出异常，由上层业务逻辑（或用户）决定是否重试。这**严格避免了因框架层面的重试导致的数据重复等问题**（如重复下单）。
        - **Failsafe**：适用于**非核心的辅助写操作**（如记录操作日志、更新统计数据）。即使失败也不影响主流程，仅记录日志。
    - **配置建议**：
        - 对核心写操作，显式配置 `cluster=”failfast”`且 `retries=”0″`。
        - 对非核心写操作，可配置 `cluster=”failsafe”`。
        - 写操作的 `timeout`可以设置得比读操作长一些，因为写操作可能涉及更复杂的业务和数据库事务。
**总结**：**读重试，写快速失败**。这是分布式系统设计中的一个重要实践。在Dubbo中，可以通过在 `@Reference`或 `@Service`的 `method`属性上为不同方法指定不同的 `cluster`和 `retries`参数来实现细粒度控制。例如：
```java
@Reference(methods = {
    @Method(name = "queryData", retries = 2), // 读操作重试
    @Method(name = "submitOrder", retries = 0, cluster = "failfast") // 写操作不重试，快速失败
})
private OrderService orderService;
```