###### 1. 说几个 Dubbo 核心的配置
Dubbo的核心配置围绕服务提供方、消费方、注册中心、协议和监控等维度展开，主要配置类如下：
1. **应用配置 (`ApplicationConfig`)**：用于配置应用信息，如`name`（应用名，用于依赖追踪和监控）、`owner`（负责人）、`qosEnable`（是否启用QoS服务治理）、`qosPort`（QoS服务端口，默认为22222）等。
2. **注册中心配置 (`RegistryConfig`)**：用于配置注册中心信息，如`address`（注册中心地址，如`zookeeper://127.0.0.1:2181`）、`protocol`（注册中心协议）、`timeout`（连接超时时间，默认为5000ms）、`check`（启动时检查注册中心是否可用）等。
3. **协议配置 (`ProtocolConfig`)**：用于配置服务暴露的协议信息，如`name`（协议名称，默认为dubbo）、`port`（服务暴露端口，默认为20880）、`host`（绑定IP地址）、`threads`（业务线程池大小，默认为200）、`serialization`（序列化方式，默认为hessian2）等。
4. **服务提供者配置 (`ProviderConfig`)**：用于配置服务提供方的默认值，可被服务级别配置覆盖。如`timeout`（远程服务调用超时时间，默认为1000ms）、`retries`（失败重试次数，默认为2，不包含第一次调用）、`loadbalance`（负载均衡策略，默认为random）、`cluster`（集群容错模式，默认为failover）等。
5. **服务消费者配置 (`ConsumerConfig`)**：用于配置服务消费方的默认值，可被引用级别配置覆盖。配置项同ProviderConfig，如`timeout`、`retries`、`loadbalance`、`check`（启动时检查依赖服务是否可用，默认为true）等。
6. **服务暴露配置 (`ServiceConfig`)**：用于暴露一个服务，如`interface`（服务接口全限定名）、`ref`（服务实现Bean引用）、`version`（服务版本，默认为0.0.0）、`group`（服务分组，用于服务隔离）、`delay`（延迟暴露时间，单位为毫秒，-1表示Spring初始化完成后暴露）等。
7. **服务引用配置 (`ReferenceConfig`)**：用于引用一个远程服务，如`interface`、`version`、`group`、`url`（点对点直连地址，绕过注册中心）、`check`、`timeout`、`retries`等。
8. **方法级别配置 (`MethodConfig`)**：用于细粒度控制方法级别行为，可配置在`<dubbo:service>`或`<dubbo:reference>`内部。如`name`（方法名）、`timeout`、`retries`、`loadbalance`、`actives`（每服务消费者最大并发调用限制）等。
9. **监控中心配置 (`MonitorConfig`)**：用于配置监控中心，如`protocol`（监控中心协议，如registry表示从注册中心获取）、`address`（监控中心地址）等。
这些配置在源码中均有对应的Java Bean类，在Spring解析时被实例化并组装，最终驱动Dubbo框架的行为。
###### 2. Dubbo有哪几种配置方式？
Dubbo支持多种配置方式，以适应不同的部署环境和开发习惯：
1. **XML配置**：传统的Spring XML方式，在`dubbo.xsd`的约束下，使用`<dubbo:application>`、`<dubbo:service>`等标签进行配置。配置集中，结构清晰，是Dubbo最早支持的方式。
2. **注解配置**：在Spring Boot中广泛使用。在服务提供方使用`@Service`（`org.apache.dubbo.config.annotation.Service`）注解暴露服务；在服务消费方使用`@Reference`注解引用服务。同时，可以通过`@EnableDubbo`激活Dubbo的自动配置。这种方式配置简单，与代码结合紧密。
3. **属性文件配置 (Spring Boot Properties/YAML)**：在`application.properties`或`application.yml`中，以`dubbo.`为前缀进行配置。例如：
    ```properties
    dubbo.application.name=demo-provider
    dubbo.registry.address=zookeeper://127.0.0.1:2181
    dubbo.protocol.name=dubbo
    dubbo.protocol.port=20880
    dubbo.scan.base-packages=com.example
    ```
    Dubbo的Spring Boot Starter会自动读取这些属性并构建相应的配置Bean。这是Spring Boot项目中最常用的方式。
4. **API编程配置**：直接通过Dubbo提供的API（如`ServiceConfig`、`ReferenceConfig`）编程式地创建和发布/引用服务。这种方式通常在无Spring容器或需要动态生成服务的场景下使用，灵活性最高但代码侵入性强。示例：
    ```java
    ServiceConfig<DemoService> service = new ServiceConfig<>();
    service.setApplication(new ApplicationConfig("demo-provider"));
    service.setRegistry(new RegistryConfig("zookeeper://127.0.0.1:2181"));
    service.setInterface(DemoService.class);
    service.setRef(new DemoServiceImpl());
    service.export();
    ```
5. **外部化配置 (Configuration Center)**：Dubbo 2.7+ 支持从配置中心（如Nacos, Apollo, Zookeeper）读取外部化配置，实现配置的集中管理和动态刷新。优先级通常高于本地配置。
在实际项目中，可以混合使用多种方式，例如用属性文件配置全局参数，用注解定义和引用服务。
###### 3. 说说 Dubbo 的优先级配置
Dubbo的配置遵循一套明确的优先级规则，高优先级配置会覆盖低优先级配置。优先级从高到低如下：
1. **JVM启动参数 (`-D`参数)**：以`-Ddubbo.xxx`形式指定的参数，优先级最高。例如`-Ddubbo.protocol.port=20881`。
2. **外部化配置 (配置中心)**：从配置中心（如Nacos）读取的配置。这些配置可以动态覆盖本地配置，实现运行时调整。配置中心的配置又细分为应用级别、服务级别等。
3. **代码/本地配置文件**：
    - **API编程配置**：通过`ServiceConfig`、`ReferenceConfig`等编程式设置的参数。
    - **属性文件 (`application.properties/yml`)**：Spring Boot环境下的配置文件。
    - **XML配置/注解属性**：Spring XML中的标签属性或注解（如`@Service(version="1.0.0")`）中的属性。
4. **Dubbo本地默认配置**：Dubbo各组件内置的默认值，如`dubbo`协议默认端口20880。
**同源内部的细粒度优先级**：在同一配置源内部，更细粒度的配置会覆盖更粗粒度的配置。具体顺序为：**方法级 > 接口级 > 全局配置**。
- 对于服务提供方：`<dubbo:method>`> `<dubbo:service>`> `<dubbo:provider>`。
- 对于服务消费方：`<dubbo:method>`> `<dubbo:reference>`> `<dubbo:consumer>`。
**示例**：在XML中同时配置了全局超时、服务超时和方法超时，则方法调用的实际超时时间以方法配置为准。
在源码中，配置的解析和覆盖逻辑主要在`AbstractConfig`的子类（如`ServiceConfig`、`ReferenceConfig`）的`refresh()`方法中实现，最终会合并所有来源的配置到一个`URL`对象中，`URL`是Dubbo中传递配置的统一模型。
###### 4. 如何禁用某个服务的启动检查？
禁用服务启动检查主要是针对**服务消费者**，防止因依赖的服务提供者未就绪而导致自身启动失败。有以下几种方式：
1. **全局禁用**：在消费者全局配置中设置`check="false"`。
    - XML方式：
        ```xml
        <dubbo:consumer check="false" />
        ```
    - 属性文件方式：
        ```properties
        dubbo.consumer.check=false
        ```
2. **针对特定服务引用禁用**：在引用某个服务时设置`check="false"`。
    - XML方式：
        ```xml
        <dubbo:reference id="demoService" interface="com.example.DemoService" check="false" />
        ```
    - 注解方式：
        ```java
        @Reference(check = false)
        private DemoService demoService;
        ```
3. **禁用注册中心启动检查**：设置`registry.check="false"`，表示启动时不检查注册中心是否可用。
    ```xml
    <dubbo:registry address="zookeeper://127.0.0.1:2181" check="false" />
    ```
**原理**：在`ReferenceConfig.init()`方法中，会调用`checkAndUpdateSubConfigs()`进行配置检查。当`check`为`true`（默认）时，在`createProxy()`中，如果配置了注册中心，会触发`RegistryProtocol.refer()`，后者会检查注册中心是否可用以及服务提供者列表是否为空。如果`check=false`，则跳过这些检查，即使没有服务提供者，消费者也会正常启动（但调用时会失败）。源码中，判断逻辑位于`RegistryProtocol.doRefer()`-> `RegistryDirectory.subscribe()`，如果`check`为true且没有可用的`Invoker`，会抛出异常。
###### 5. Dubbo中有哪些调优参数？
Dubbo的性能调优参数众多，主要涉及以下几个层面：
1. **协议与线程池**：
    - `dubbo.protocol.threads`：业务线程池大小，默认200。根据业务类型（I/O密集型或CPU密集型）和服务器核心数调整。通常建议在200-600之间。
    - `dubbo.protocol.threadpool`：线程池类型，可选`fixed`（固定大小，默认）、`cached`（缓存）、`limited`（可伸缩）。`cached`适用于短小任务，避免线程堆积。
    - `dubbo.protocol.accepts`：服务提供方最大可接受连接数，默认0（不限制）。在高并发场景可限制连接数，如1000，以自我保护。
2. **超时与重试**：
    - `timeout`：远程调用超时时间（毫秒），默认1000。根据服务耗时中位数和峰值设置，避免级联等待。
    - `retries`：失败重试次数，默认2（不含第一次）。对非幂等写操作设为0。读操作可适当重试（如1-2次）。
3. **连接与心跳**：
    - `dubbo.protocol.connections`：每个服务对每个提供者建立的长连接数，Dubbo协议默认为1。在需要更高吞吐时，可适当增加（如2-5），但会增加资源消耗。
    - `dubbo.protocol.heartbeat`：心跳间隔（毫秒），默认60 * 1000。在空闲连接较多的场景可调大（如3分钟），减少不必要的心跳包。
4. **序列化**：
    - `serialization`：使用高性能序列化，如`kryo`、`fst`。需引入对应依赖并注册自定义类。
5. **负载均衡**：
    - `loadbalance`：根据场景选择策略。`leastactive`能较好反映实时负载，推荐使用。
6. **并发控制**：
    - `actives`：每服务消费者最大并发调用数。用于客户端限流，防止压垮服务端。
    - `executes`：每服务提供者最大可并行执行请求数。用于服务端限流，保护自身。
7. **缓冲区**：
    - `dubbo.protocol.buffer`：网络读写缓冲区大小，默认8 * 1024字节。可根据传输数据大小调整。
8. **注册中心**：
    - `dubbo.registry.timeout`：注册中心会话超时时间，默认5000ms。在Zookeeper网络不稳定时可适当调大。
9. **JVM参数**：
    - 调整堆内存、GC算法等，减少Full GC对Dubbo线程的影响，避免调用超时。
调优没有固定公式，需结合压测、监控和实际业务场景进行。建议开启Dubbo的QoS（`dubbo.application.qos.enable=true`）并利用`telnet`或`dubbo-admin`查看实时状态。
###### 6. Dubbo 配置的加载顺序是怎样的？
在应用启动时，Dubbo配置的加载顺序决定了最终生效的配置值。整体顺序如下（从高优先级到低优先级）：
1. **JVM系统参数 (`-D`)**：在启动命令中指定，如`-Ddubbo.protocol.port=20881`。这些参数在应用启动最早被加载。
2. **外部化配置中心**：如果配置了`dubbo.config-center`，Dubbo会从配置中心（如Nacos）拉取配置。配置中心的配置可以覆盖本地配置，且支持动态推送更新。
3. **Spring环境变量/属性文件**：在Spring Boot中，`application.properties`或`application.yml`中的配置，以及操作系统环境变量、`@PropertySource`引入的属性。Spring Boot的`PropertySource`顺序决定了优先级（如`命令行参数 > 系统属性 > 环境变量 > 配置文件`）。
4. **Dubbo XML/注解/API配置**：
    - 在Spring容器初始化过程中，XML配置被解析为对应的`BeanDefinition`，注解配置通过后处理器扫描，API配置则是编程式创建。
    - 这些配置最终会创建`ApplicationConfig`、`RegistryConfig`、`ServiceConfig`、`ReferenceConfig`等Bean实例。
    - **在合并配置时，细粒度配置覆盖粗粒度配置**：例如，`ServiceConfig`中的配置会覆盖`ProviderConfig`的默认值，`MethodConfig`会覆盖`ServiceConfig`。
5. **Dubbo SPI扩展点的默认值**：如果以上均未配置，则使用各组件通过SPI定义的默认值。例如，`Protocol`的默认实现是`dubbo`，`LoadBalance`的默认实现是`random`。
**配置合并过程**：在`ServiceConfig.export()`或`ReferenceConfig.get()`时，会调用`checkAndUpdateSubConfigs()`方法，该方法会从各个配置源收集配置，并按优先级合并，最终生成一个完整的`URL`。`URL`中的参数就是最终生效的配置。
**重要提示**：从Dubbo 2.7开始，加强了配置中心的能力，推荐将大部分动态配置（如超时、权重）放在配置中心，而将服务发现相关的地址信息放在注册中心。
###### 7. Dubbo 如何实现配置中心？
Dubbo的配置中心是一个独立的扩展点，接口为`org.apache.dubbo.configcenter.ConfigCenter`。它用于管理动态配置，实现配置与代码、注册中心的解耦。
1. **支持的实现**：
    - **Nacos**：`NacosConfigCenter`，是目前最主流的选择，兼具服务发现和配置管理功能。
    - **Zookeeper**：`ZookeeperConfigCenter`，利用ZNode存储配置，通过Watcher监听变化。
    - **Apollo**：`ApolloConfigCenter`，集成携程开源的配置中心。
    - **本地文件**：用于测试。
2. **核心功能**：
    - **应用级配置**：在`dubbo.properties`中配置全局参数，如`dubbo.application.name`。
    - **服务级配置**：针对特定服务的配置，如`com.example.DemoService`的超时、重试规则。
    - **动态覆盖**：配置中心的配置可以动态推送到客户端，覆盖本地配置，无需重启应用。
3. **配置方式**：
    - 在`application.properties`中指定配置中心地址：
        ```properties
        dubbo.config-center.address=nacos://127.0.0.1:8848
        dubbo.config-center.namespace=dubbo-demo
        ```
    - 或者通过XML配置：
        ```xml
        <dubbo:config-center address="nacos://127.0.0.1:8848" />
        ```
4. **工作原理**：
    - 应用启动时，`ConfigCenter`接口的实现类会连接到配置中心服务器。
    - 订阅预先定义的配置节点（如`/dubbo/config/dubbo/dubbo.properties`）。
    - 当配置发生变化时，配置中心推送变更，Dubbo客户端接收到变更后，调用`ConfigurationListener`的`process()`方法，更新内部配置（如更新`ReferenceConfig`的`timeout`值）。
    - 配置更新是实时生效的，例如修改超时时间后，下一次调用立即生效。
5. **与注册中心的关系**：
    - 注册中心：负责服务实例的注册与发现，存储的是**易失的、动态的**服务地址信息。
    - 配置中心：负责存储和推送**持久化的、稳定的**配置信息，如超时、权重、路由规则。
**源码角度**：`ConfigCenter`接口定义了`getProperties()`、`addListener()`等方法。`AbstractConfigCenter`提供了模板方法。在`ConfigManager`中，会初始化`ConfigCenter`，并加载配置。动态配置的监听和更新在`AbstractConfig`的`refresh()`方法中触发，最终反映在`URL`的参数变化上。