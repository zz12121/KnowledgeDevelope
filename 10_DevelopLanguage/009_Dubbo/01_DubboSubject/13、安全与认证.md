###### 1. Dubbo 如何实现服务鉴权？
Dubbo 的服务鉴权机制主要围绕 **AK/SK（Access Key/Secret Key）签名认证**​ 和 **鉴权服务中心**​ 构建，从 2.7.5 版本开始引入，旨在为敏感业务提供身份验证和防篡改保障。
**核心原理**：
1. **签名生成（消费者端）**：在调用需要鉴权的服务前，消费者使用自己的 SK（Secret Key）对本次请求的**元数据**（如接口、方法、时间戳）以及可选的**请求参数**进行哈希计算，生成一个签名（SigningKey）。时间戳用于防重放攻击。
2. **签名传递**：生成的签名、AK（Access Key）、时间戳等信息通过 Dubbo 的 **Attachment 机制**（`RpcContext`或 `Invocation`的附件）随请求一起发送给提供者。
3. **验签（提供者端）**：提供者收到请求后，从附件中提取 AK，通过鉴权服务中心查询对应的 SK（或本地缓存）。然后用同样的算法和规则重新计算签名，并与传递来的签名进行比对。如果一致且时间戳有效，则鉴权通过；否则抛出 `RpcException`拒绝调用。
**配置与使用**：
- **提供者端**：通过 `service.auth`和 `param.sign`参数启用鉴权和参数签名校验。
    ```java
    @Service(parameters = {"service.auth", "true", "param.sign", "true"})
    public class AuthDemoServiceImpl implements AuthService {}
    ```
- **消费者端**：主要配置证书（AK/SK）信息。高级模式中，AK/SK 由鉴权服务中心动态下发和管理，无需硬编码在配置中，支持不重启应用刷新密钥。
**源码角度**：
鉴权的核心是一个实现了 `Filter`接口的拦截器（如 `AuthFilter`）。在 `invoke`方法中：
```java
public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
    // 1. 判断该服务是否需要鉴权 (从invoker.getUrl()获取参数)
    boolean authNeed = Boolean.parseBoolean(invoker.getUrl().getParameter("service.auth"));
    if (authNeed) {
        // 2. 从invocation附件中获取AK、签名、时间戳
        String ak = invocation.getAttachment("AK");
        String sign = invocation.getAttachment("SIGN");
        String timestamp = invocation.getAttachment("TIMESTAMP");
        // 3. 验签逻辑（可能调用远程鉴权服务）
        if (!validateSign(ak, sign, invocation, timestamp)) {
            throw new RpcException("Authentication failed.");
        }
    }
    // 4. 鉴权通过，继续调用链
    return invoker.invoke(invocation);
}
```
该 Filter 需要通过 SPI 机制注册，并被 `ProtocolFilterWrapper`组装到调用链中，在业务逻辑执行前进行拦截。
###### 2. Dubbo 如何实现 Token 验证？
Token 验证是 Dubbo 一种**简单而有效**的访问控制机制，主要用于**防止消费者绕过注册中心直接访问提供者**，并通过注册中心进行统一的权限管理。
**工作原理**：
1. **Token 配置与发布**：在服务提供者端配置 Token（一个字符串）。当服务暴露时，Token 会作为服务元数据的一部分发布到注册中心。
    - 配置方式：
        ```xml
        <dubbo:service interface="..." token="your-token-123" />
        ```
      或注解：`@Service(token = "your-token-123")`
    - 特殊值：如果配置为 `true`或 `default`，Dubbo 会自动生成一个随机的 UUID 作为 Token。
2. **Token 获取**：消费者从注册中心订阅服务时，会同时获取到该 Token。
3. **调用与验证**：消费者发起调用时，将 Token 设置在 `Invocation`的附件中。提供者端的 `TokenFilter`会拦截请求，比对本地配置的 Token 与请求携带的 Token 是否一致。
**源码核心：TokenFilter**
`org.apache.dubbo.rpc.filter.TokenFilter`是实现该功能的关键：
```java
@Activate(group = CommonConstants.PROVIDER, value = Constants.TOKEN_KEY)
public class TokenFilter implements Filter {
    @Override
    public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
        // 1. 从服务提供者URL配置中获取Token
        String token = invoker.getUrl().getParameter(Constants.TOKEN_KEY);
        if (ConfigUtils.isNotEmpty(token)) {
            // 2. 从调用附件中获取消费者传递的Token
            String remoteToken = (String) inv.getObjectAttachmentWithoutConvert(Constants.TOKEN_KEY);
            // 3. 进行字符串比对
            if (!token.equals(remoteToken)) {
                throw new RpcException("Invalid token! Forbid invoke remote service...");
            }
        }
        // 4. 验证通过，继续执行
        return invoker.invoke(inv);
    }
}
```
- **`@Activate`注解**：确保该 Filter 只在**提供者端**（`group = PROVIDER`）自动激活，并且仅在 URL 中包含 `token`参数时生效（`value = TOKEN_KEY`）。
- **验证失败**：会抛出 `RpcException`，其错误码为 `FORBIDDEN_EXCEPTION`(403)。
**高级用法**：Token 可以动态管理，消费者可以从配置中心获取最新的 Token，并通过 `RpcContext.getServiceContext().setAttachment(TOKEN_KEY, token)`动态设置。
###### 3. Dubbo 如何防止服务被非法调用？
防止非法调用是一个**多层次、纵深防御**的安全体系，Dubbo 提供了多种机制协同工作。
**1. 认证与鉴权（第一道防线）**：
- **Token 验证**：如上所述，防止未授权消费者调用。
- **AK/SK 签名认证**：提供更强的身份验证和防篡改能力。
- **自定义认证 Filter**：实现更复杂的业务鉴权逻辑，如与公司统一权限中心对接。
**2. 访问控制列表（ACL - 第二道防线）**：
- **IP 白名单/黑名单**：最基础的网络层控制。可以通过自定义 Filter 实现：
    ```java
    public class IpWhiteListFilter implements Filter {
        private Set<String> whiteList = Set.of("192.168.1.1", "10.0.0.1");
        @Override
        public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
            String clientIp = RpcContext.getContext().getRemoteHost();
            if (!whiteList.contains(clientIp)) {
                throw new RpcException("IP " + clientIp + " is not allowed.");
            }
            return invoker.invoke(invocation);
        }
    }
    ```
- **服务/应用黑白名单**：利用 Dubbo 的**条件路由**功能，在服务治理层面配置。可以指定哪些消费者应用可以调用哪些服务，实现应用粒度的访问控制。
**3. 传输安全（第三道防线）**：
- **SSL/TLS 加密**：对网络传输进行加密，防止通信内容被窃听或篡改。这是防止中间人攻击的关键。
**4. 请求校验与防护（第四道防线）**：
- **参数签名**：在 AK/SK 认证中启用 `param.sign`，确保请求参数在传输过程中未被篡改。
- **限流与熔断**：使用 `TpsLimitFilter`、`ActiveLimitFilter`或集成 Sentinel，防止恶意流量打垮服务。
- **时间戳防重放**：在签名机制中，服务器会校验请求时间戳，拒绝过期的请求。
**5. 注册中心安全（底层保障）**：
- 为 ZooKeeper 等注册中心配置 ACL，防止未授权的客户端注册或发现服务。
**最佳实践**：生产环境应组合使用以上机制。例如，内部可信网络可使用 IP 白名单+Token；对外暴露的接口则必须使用 SSL/TLS + AK/SK 签名认证。
###### 4. Dubbo 支持 SSL/TLS 加密吗？
**是的，Dubbo 从 2.7.5 版本开始，为内置的 Dubbo 协议（基于 Netty）和 gRPC 协议提供了完整的 TLS 传输加密支持**。
**配置方式**：
Dubbo 提供了统一的 `SslConfig`类进行 TLS 配置。
1. **服务提供者端配置**：
    ```java
    // 创建SSL配置
    SslConfig sslConfig = new SslConfig();
    sslConfig.setServerKeyCertChainPath("server-cert.pem"); // 服务端证书链
    sslConfig.setServerPrivateKeyPath("server-key.pem");     // 服务端私钥
    // 如果需要双向认证（mTLS）
    if (mutualTls) {
        sslConfig.setServerTrustCertCollectionPath("ca-cert.pem"); // 信任的CA证书
    }
    // 在协议配置中启用SSL
    ProtocolConfig protocolConfig = new ProtocolConfig("dubbo");
    protocolConfig.setSslEnabled(true);
    ```
2. **服务消费者端配置**：
    ```java
    SslConfig sslConfig = new SslConfig();
    if (!mutualTls) {
        // 单向认证，客户端只需信任CA证书
        sslConfig.setClientTrustCertCollectionPath("ca-cert.pem");
    } else {
        // 双向认证，客户端也需要提供自己的证书和私钥
        sslConfig.setClientTrustCertCollectionPath("ca-cert.pem");
        sslConfig.setClientKeyCertChainPath("client-cert.pem");
        sslConfig.setClientPrivateKeyPath("client-key.pem");
    }
    ```
**Spring Boot 属性配置**（更常用）：
```yaml
dubbo:
  protocol:
    name: dubbo
    port: 20880
    ssl-enabled: true
    ssl-client-key-cert-chain-path: classpath:client-cert.pem
    ssl-client-private-key-path: classpath:client-key.pem
    ssl-client-trust-cert-collection-path: classpath:ca-cert.pem
```
**源码实现**：
- Dubbo 在创建 Netty 客户端和服务器时（`NettyClient`和 `NettyServer`），会检查 `SslConfig`。
- 如果 SSL 启用，会通过 `SslHandler`构建器（如 `SslContextBuilder`）创建 `SslContext`，并将其添加到 Netty 的 ChannelPipeline 中。
- 对于 gRPC 协议，其本身支持 TLS，Dubbo 的 gRPC 实现会调用相应的 API 启用 TLS，并可能使用协议协商机制（如 ALPN）。
**重要提示**：启用 TLS 会带来一定的性能开销，但对于跨公网或对安全要求高的场景是必须的。证书应妥善管理，建议使用配置中心动态下发。
###### 5. Dubbo 如何实现接口级别的访问控制？
接口级别的访问控制要求对**特定的服务接口甚至方法**进行调用授权。Dubbo 主要通过**自定义 Filter**​ 和**服务治理规则**来实现这一细粒度控制。
**1. 自定义 Filter 方案（最灵活）**：
创建一个实现 `Filter`接口的类，在 `invoke`方法中根据调用上下文进行精细判断。
```java
@Activate(group = CommonConstants.PROVIDER, order = -10000)
public class InterfaceAuthFilter implements Filter {
    @Override
    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
        String serviceName = invoker.getInterface().getName();
        String methodName = invocation.getMethodName();
        String consumerApp = invocation.getAttachment("application");
        // 1. 从本地规则或远程权限中心查询：consumerApp是否有权调用serviceName.methodName
        if (!permissionService.checkPermission(consumerApp, serviceName, methodName)) {
            throw new RpcException(RpcException.FORBIDDEN_EXCEPTION,
                    String.format("App [%s] is not allowed to call [%s.%s]", consumerApp, serviceName, methodName));
        }
        // 2. 可选：参数级校验
        return invoker.invoke(invocation);
    }
}
```
**优势**：
- **动态生效**：规则可存储在配置中心（如 Nacos），修改后实时生效。
- **粒度极细**：可控制到方法级别，甚至基于参数值判断。
- **集成性强**：可轻松对接公司统一的权限管理系统。
**2. 利用服务治理的条件路由（黑白名单）**：
Dubbo 管理控制台（如 Dubbo Admin）或云服务商（如 EDAS）提供了基于**应用**和**服务**维度的黑白名单功能。
- 可以配置规则如：“允许应用A调用服务S，但拒绝应用B调用服务S”。
- 更进一步，可以通过 **`group`（服务分组）**​ 和 **`version`（服务版本）**​ 进行逻辑隔离。例如，内部管理接口部署在 `group="internal"`的分组中，普通消费者默认不会引用它们。
**3. 基于注解的声明式控制（需框架扩展）**：
这是一种更优雅的方式，但需要自行扩展 Dubbo。例如，定义注解：
```java
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface PreAuthorize {
    String value(); // 例如: "hasRole('ADMIN')"
}
```
然后在自定义 Filter 中解析该注解，并结合 Spring Security 或自定义的权限表达式解析器进行校验。
**配置与启用**：
- 自定义 Filter 需要在 `META-INF/dubbo/org.apache.dubbo.rpc.Filter`文件中声明：`interfaceAuth=com.example.InterfaceAuthFilter`。
- 在 `dubbo:provider`或 `dubbo:service`的 `filter`属性中启用它（如果未用 `@Activate`自动激活）。
**源码关联**：
无论哪种方案，最终都是通过 Dubbo 的 **Filter 责任链机制**​ 实现的。`ProtocolFilterWrapper.buildInvokerChain()`方法会加载并排序所有激活的 Filter，包括自定义的鉴权 Filter，确保其在业务逻辑执行前进行拦截。这种设计使得访问控制逻辑与业务代码完全解耦。