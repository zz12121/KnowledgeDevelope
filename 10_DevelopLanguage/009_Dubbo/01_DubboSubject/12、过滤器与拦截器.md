###### 1. Dubbo 的 Filter 是什么？有什么作用？
Dubbo Filter 是 Dubbo 框架中的**拦截器**，它基于**责任链模式**实现，允许开发者在服务调用的关键节点插入自定义逻辑。Filter 是 Dubbo SPI 机制的典型应用，通过装饰器模式对核心的 `Invoker`进行包装。
**核心作用**：
1. **调用拦截与增强**：在服务调用前后执行自定义逻辑，实现 AOP 功能。
2. **服务治理**：实现限流、熔断、降级、鉴权等治理能力。
3. **监控与统计**：收集调用 metrics（耗时、成功率等），用于监控和报警。
4. **日志与追踪**：记录调用日志、实现分布式链路追踪的上下文传递。
5. **参数校验与转换**：对 RPC 参数进行校验、清洗或转换。
**源码中的定位**：Filter 接口定义在 `org.apache.dubbo.rpc.Filter`，继承自 `org.apache.dubbo.common.extension.Adaptive`。其核心方法是：
```java
Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException;
```
`ProtocolFilterWrapper`是构建 Filter 链的关键类，它作为 `Protocol`的包装器，在 `export`（服务暴露）和 `refer`（服务引用）时，通过 `buildInvokerChain`方法将 Filter 组装成链，并包装原始的 `Invoker`。
###### 2. Dubbo 有哪些内置的 Filter？
Dubbo 内置了丰富的 Filter，它们通过 `@Activate`注解在特定条件下自动激活，主要分为以下几类：
1. **消费者端 Filter**：
    - `ConsumerContextFilter`：在调用前将本地上下文（如 `RpcContext`）设置到 `Invocation`的附件中，调用结束后清理。
    - `FutureFilter`：支持事件通知（`oninvoke`、`onreturn`、`onthrow`）。
    - `ActiveLimitFilter`：限制消费者端对特定服务的并发调用数（`actives`参数）。
2. **提供者端 Filter**：
    - `ContextFilter`：接收消费者端传递的上下文，并设置到当前线程的 `RpcContext`中，调用结束后清理。
    - `AccessLogFilter`：记录访问日志到文件。
    - `TimeoutFilter`：监控超时调用，打印警告日志。
    - `ExceptionFilter`：异常过滤，防止消费者端反序列化到不存在的异常类。它会将受检异常包装为 `RuntimeException`，非受检异常则直接抛出。
    - `ExecuteLimitFilter`：限制提供者端对特定服务的并发执行数（`executes`参数）。
    - `TpsLimitFilter`：限制 TPS（每秒事务数）。
    - `TokenFilter`：验证令牌，防止服务被未经授权的消费者调用。
    - `ClassLoaderFilter`：切换线程上下文类加载器，避免类加载问题。
3. **双向 Filter（消费者和提供者端均生效）**：
    - `MonitorFilter`：收集调用统计信息（次数、耗时）并上报到监控中心。
    - `GenericFilter`：处理泛化调用的参数和返回值转换。
    - `EchoFilter`：处理回声测试请求（`$echo`方法）。
    - `ValidationFilter`：基于 JSR-303 进行参数校验（需引入 `validation-api`依赖）。
这些 Filter 的加载顺序由 `@Activate`注解的 `order`属性决定，数值越小优先级越高。它们的定义可以在 `dubbo-rpc-api`模块的 `META-INF/dubbo/internal/`目录下的 SPI 配置文件中找到。
###### 3. 如何自定义 Dubbo 的 Filter？
自定义 Filter 需遵循 Dubbo SPI 规范，步骤如下：
1. **实现 Filter 接口**：创建类实现 `org.apache.dubbo.rpc.Filter`接口，并添加 `@Activate`注解（如需自动激活）或使用手动配置。
    ```java
    package com.example.filter;
    
    import org.apache.dubbo.common.extension.Activate;
    import org.apache.dubbo.rpc.*;
    import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER;
    
    @Activate(group = PROVIDER, order = 100) // 在提供者端自动激活，顺序100
    public class CustomTraceFilter implements Filter {
        @Override
        public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
            long start = System.currentTimeMillis();
            try {
                // 调用前逻辑
                System.out.println("Before invoking: " + invocation.getMethodName());
                Result result = invoker.invoke(invocation);
                // 调用后逻辑
                System.out.println("After invoking, elapsed: " + (System.currentTimeMillis() - start) + "ms");
                return result;
            } catch (RpcException e) {
                // 异常处理
                System.err.println("Invocation failed: " + e.getMessage());
                throw e;
            }
        }
    }
    ```
1. **创建 SPI 配置文件**：在项目的 `resources/META-INF/dubbo/`目录下创建文件 `org.apache.dubbo.rpc.Filter`，内容为：
    ```
    customTraceFilter=com.example.filter.CustomTraceFilter
    ```
2. **启用 Filter**：
    - **自动激活**：如果使用了 `@Activate`并指定了匹配的 `group`（如 `PROVIDER`），Filter 会在对应的角色端自动生效。
    - **手动配置**：在 XML 或注解中显式声明。
        ```xml
        <!-- 服务提供者全局配置 -->
        <dubbo:provider filter="customTraceFilter" />
        <!-- 或针对特定服务 -->
        <dubbo:service interface="com.example.DemoService" filter="customTraceFilter" />
        ```
        ```java
        @Service(filter = {"customTraceFilter"})
        public class DemoServiceImpl implements DemoService { ... }
        ```
**源码中的加载过程**：当 `ProtocolFilterWrapper.buildInvokerChain`被调用时，会通过 `ExtensionLoader.getActivateExtension()`获取所有激活的 Filter，包括内置的和自定义的，然后按顺序构建链。
###### 4. Dubbo Filter 的执行顺序是怎样的？
Filter 的执行顺序由 **激活顺序**​ 和 **排列顺序**​ 共同决定，遵循“先进后出”的责任链模式。
**决定因素**：
1. **`@Activate`注解的 `order`属性**：数值越小，优先级越高，在链中的位置越靠外（即越早执行 `invoke`方法的前置逻辑，但后执行后置逻辑）。内置 Filter 的 `order`值可在源码中查看。
2. **手动配置的 Filter 顺序**：在 `filter`属性中配置的 Filter 名称列表，从左到右依次生效。这些 Filter 会**插入**到自动激活的 Filter 链中，但具体插入位置取决于框架实现（通常位于自动激活 Filter 之后，但在实际调用前）。
3. **`group`过滤**：只激活与当前角色（`PROVIDER`或 `CONSUMER`）匹配的 Filter。
**构建链的逻辑**（`ProtocolFilterWrapper.buildInvokerChain`）：
4. 获取所有激活的 Filter（包括通过 `@Activate`和通过 `filter`参数指定的）。
5. 按照 `order`和配置顺序进行排序。
6. **逆序**构建调用链：从排序列表的最后一个 Filter 开始，每个 Filter 包装下一个 `Invoker`，最终返回第一个 Filter 作为链的入口。
7. 因此，排序后**越靠前**的 Filter，其 `invoke`方法中的**前置逻辑越先执行**，但**后置逻辑越后执行**（类似于栈）。
**示例**：假设有 FilterA (order=1), FilterB (order=2)，手动配置了 FilterC。
- 链的构建顺序：FilterC -> FilterB -> FilterA -> 原始 Invoker。
- 调用时的执行顺序：FilterC.before -> FilterB.before -> FilterA.before -> 原始 Invoker -> FilterA.after -> FilterB.after -> FilterC.after。
可以通过在自定义 Filter 中打印日志或调试来观察实际执行顺序。
###### 5. Dubbo 的拦截器链是如何工作的？
拦截器链（Filter Chain）的工作机制是 Dubbo 可扩展性的核心，其工作原理可以概括为 **动态组装 + 递归调用**。
**详细工作流程**：
1. **链的构建（服务暴露/引用时）**：
    - 在 `ProtocolFilterWrapper`的 `export`或 `refer`方法中，会调用 `buildInvokerChain`方法。
    - 该方法获取所有激活的 Filter，然后逆序包装。
    ```java
    // 简化的构建逻辑
    Invoker<T> last = invoker; // 原始 Invoker
    for (int i = filters.size() - 1; i >= 0; i--) {
        final Filter filter = filters.get(i);
        final Invoker<T> next = last;
        last = new Invoker<T>() {
            @Override
            public Result invoke(Invocation invocation) throws RpcException {
                // 关键：调用 filter.invoke，并将 next 作为参数传入
                return filter.invoke(next, invocation);
            }
            // ... 其他方法
        };
    }
    return last; // 返回的是包装了所有 Filter 的 Invoker
    ```
    - 最终构建出一个嵌套的 Invoker 链，每个 Filter 都持有下一个节点（`next`）的引用。
2. **链的执行（调用发生时）**：
    - 当消费者发起调用时，调用的是链入口 Invoker 的 `invoke`方法。
    - 该方法会触发第一个 Filter 的 `invoke`方法，Filter 在执行自己的逻辑（前后置处理）后，调用 `next.invoke(invocation)`，将请求传递给链中的下一个节点。
    - 递归调用直至原始 Invoker（远程调用或本地实现），然后结果原路返回。
3. **关键设计**：
    - **装饰器模式**：每个 Filter 都装饰了下一个 Invoker，可以在不修改原有逻辑的情况下增强功能。
    - **递归调用**：链的调用本质是递归，利用方法调用栈实现顺序执行和反向返回。
    - **Invoker 统一模型**：无论是原始服务、远程代理还是 Filter 包装，都统一为 `Invoker`接口，使得链式调用成为可能。
**源码中的核心**：
- `Filter.invoke(Invoker<?> invoker, Invocation invocation)`方法签名是关键。`invoker`参数代表链中的下一个节点，由框架在构建链时注入。
- `Invocation`封装了本次调用的所有信息（方法名、参数、附件等），在链中传递。
- 任何一个 Filter 都可以选择不调用 `next.invoke()`而直接返回，从而中断调用链（如权限校验失败时）。
**示例流程**：
```
调用开始
    -> Filter1.invoke() [前置逻辑]
        -> Filter2.invoke() [前置逻辑]
            -> ... 
                -> 原始Invoker.invoke() [执行实际业务]
            -> ... [后置逻辑]
        -> Filter2.invoke() [后置逻辑]
    -> Filter1.invoke() [后置逻辑]
调用结束
```