###### 1. MyBatis 支持哪些常用注解？
MyBatis注解体系完整，可按功能分为以下几类：

|**类别**​|**注解**​|**作用**​|**等效XML**​|
|---|---|---|---|
|**CRUD注解**​|`@Select`, `@Insert`, `@Update`, `@Delete`|声明SQL语句|`<select>`, `<insert>`, `<update>`, `<delete>`|
|**结果映射**​|`@Results`, `@Result`, `@ResultMap`|配置结果集映射|`<resultMap>`|
|**关联映射**​|`@One`, `@Many`|处理一对一、一对多关系|`<association>`, `<collection>`|
|**参数处理**​|`@Param`, `@Options`, `@SelectKey`|参数命名和选项配置|`<selectKey>`, `useGeneratedKeys`|
|**动态SQL**​|`@InsertProvider`, `@SelectProvider`等|动态生成SQL|`<if>`, `<foreach>`等动态标签|
|**缓存配置**​|`@CacheNamespace`, `@CacheNamespaceRef`|配置二级缓存|`<cache>`, `<cache-ref>`|
|**Mapper扫描**​|`@Mapper`, `@MapperScan`(Spring)|自动扫描和注册Mapper接口|`<mappers>`配置|
**关键注解示例：**
```java
// 结果映射与关联查询
@Select("SELECT * FROM users WHERE id = #{id}")
@Results(id = "userMap", value = {
    @Result(property = "id", column = "user_id", id = true),
    @Result(property = "name", column = "user_name"),
    @Result(property = "orders", column = "id", 
             many = @Many(select = "com.example.OrderMapper.findByUserId"))
})
User selectUserWithOrders(@Param("id") Long id);

// 使用@ResultMap复用映射
@Select("SELECT * FROM users")
@ResultMap("userMap")
List<User> selectAllUsers();
```
###### 2. MyBatis 中 @Param 注解的作用是什么？
`@Param`注解的核心作用是**为方法参数命名**，解决多参数场景下的映射问题。
**源码机制分析：**
当调用Mapper方法时，MyBatis通过`MapperProxy`动态代理拦截方法调用。在参数处理阶段，会调用`ParamNameResolver`解析参数名称：
1. **无`@Param`注解时**：MyBatis使用默认命名规则（`param1`, `param2`...或`arg0`, `arg1`...）
2. **有`@Param`注解时**：使用注解指定的名称覆盖默认命名
```java
// 源码逻辑简化（org.apache.ibatis.reflection.ParamNameResolver）
public Object getNamedParams(Object[] args) {
    if (names.isEmpty()) return args; // 无参数
    if (args == null) return null;
    
    final Map<String, Object> param = new HashMap<>();
    for (Map.Entry<Integer, String> entry : names.entrySet()) {
        String name = entry.getValue();
        int index = entry.getKey();
        param.put(name, args[index]);
        // 同时保留默认参数名（param1, param2...）保证兼容性
        param.put("param" + (index + 1), args[index]);
    }
    return param;
}
```
**使用场景对比：**
```java
// 错误：多参数时MyBatis无法正确映射
User selectUser(String name, Integer age);

// 正确：使用@Param明确参数名
User selectUser(@Param("username") String name, @Param("userage") Integer age);

// XML或注解中可明确引用
@Select("SELECT * FROM users WHERE name = #{username} AND age = #{userage}")
User selectUser(@Param("username") String name, @Param("userage") Integer age);
```
###### 3. MyBatis 的 Mapper 接口是如何工作的？
Mapper接口的工作原理基于**JDK动态代理**模式，实现了接口方法与SQL执行的绑定。
**核心工作流程：**
1. **动态代理创建**：
```java
    // 源码关键类：org.apache.ibatis.binding.MapperProxyFactory
    public class MapperProxyFactory<T> {
        public T newInstance(SqlSession sqlSession) {
            final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface);
            return (T) Proxy.newProxyInstance(
                mapperInterface.getClassLoader(),
                new Class[]{mapperInterface},
                mapperProxy);
        }
    }
```
2. **方法拦截与执行**：
    - 当调用`mapper.selectUser(1)`时，实际调用`MapperProxy.invoke()`方法
    - 通过`MapperMethod`将Java方法调用转换为SQL命令执行
**执行流程的源码分析：**
```java
// MapperMethod核心执行逻辑
public class MapperMethod {
    public Object execute(SqlSession sqlSession, Object[] args) {
        switch (command.getType()) {
            case SELECT: 
                if (method.returnsVoid()) {
                    // 处理无返回值查询
                    sqlSession.selectOne(command.getName(), param);
                } else {
                    // 关键：根据返回类型选择执行方法
                    result = sqlSession.selectOne(command.getName(), param);
                }
                break;
            case INSERT:
                // 插入操作处理
                break;
            // ... 其他操作类型
        }
    }
}
```
**为什么Mapper接口不需要实现类？**
- MyBatis在运行时通过动态代理生成接口的实现
- 将接口方法调用路由到对应的SQL语句执行
- 避免了手动编写重复的DAO实现代码
###### 4. MyBatis 如何实现 Mapper 接口与 XML 的绑定？
绑定机制通过**命名空间匹配**实现，确保接口方法与XML语句一一对应。
**绑定规则：**
1. **命名空间对应**：XML中的`namespace`属性必须对应Mapper接口的全限定名
2. **方法ID对应**：XML语句的`id`属性必须对应接口方法名
**配置示例：**
```xml
<!-- UserMapper.xml -->
<mapper namespace="com.example.mapper.UserMapper">
    <select id="selectById" resultType="User">
        SELECT * FROM users WHERE id = #{id}
    </select>
</mapper>
```
```java
// Mapper接口
package com.example.mapper;
public interface UserMapper {
    User selectById(@Param("id") Long id);
}
```
**启动时的加载过程：**
1. MyBatis解析`mybatis-config.xml`中的mapper配置
2. 使用`XMLMapperBuilder`解析XML文件，创建`MappedStatement`对象
3. 将`MappedStatement`注册到`Configuration`中，key为"接口全限定名.方法名"
###### 5. MyBatis 中使用注解和 XML 配置的优缺点是什么？

|**维度**​|**注解方式**​|**XML方式**​|
|---|---|---|
|**简洁性**​|⭐⭐⭐⭐⭐ 代码即配置，无需文件切换|⭐⭐ 需要维护独立XML文件|
|**可读性**​|⭐⭐ SQL与Java代码混合，长SQL难阅读|⭐⭐⭐⭐⭐ SQL集中管理，结构清晰|
|**动态SQL**​|⭐⭐ 需借助`<script>`或Provider类，不够直观|⭐⭐⭐⭐⭐ 原生支持`<if>`,`<foreach>`等标签|
|**复杂度**​|⭐⭐⭐ 适合简单CRUD和固定SQL|⭐⭐⭐⭐⭐ 擅长处理复杂SQL和结果映射|
|**维护性**​|⭐⭐ 修改SQL需要重新编译|⭐⭐⭐⭐⭐ 热加载，修改无需重新编译|
|**团队协作**​|⭐⭐ 前后端开发者都需要懂Java|⭐⭐⭐ DBA可独立优化SQL|
**选择建议：**
- **简单项目/快速原型**：优先使用注解，减少配置文件
- **企业级复杂应用**：推荐XML方式，便于SQL优化和团队协作
- **混合模式**：简单CRUD用注解，复杂查询用XML，发挥各自优势
###### 6. MyBatis 的 @SelectProvider、@InsertProvider 等注解的作用是什么？
`@*Provider`注解用于**动态生成复杂SQL**，将SQL构造逻辑提取到独立的Java类中。
**核心Provider注解：**
- `@SelectProvider`、`@InsertProvider`、`@UpdateProvider`、`@DeleteProvider`
- 通过指定`type`(提供者类)和`method`(方法名)动态生成SQL
**使用示例：**
```java
// 1. 定义Provider类
public class UserSqlProvider {
    public String selectUsersByConditions(final Map<String, Object> params) {
        return new SQL() {{
            SELECT("*");
            FROM("users");
            if (params.get("name") != null) {
                WHERE("name = #{name}");
            }
            if (params.get("minAge") != null) {
                WHERE("age >= #{minAge}");
            }
            ORDER_BY("create_time DESC");
        }}.toString();
    }
}

// 2. 在Mapper接口中使用
public interface UserMapper {
    @SelectProvider(type = UserSqlProvider.class, method = "selectUsersByConditions")
    List<User> selectByConditions(@Param("name") String name, @Param("minAge") Integer minAge);
}
```
**Provider方法的签名要求：**
- 必须是`public`方法
- 返回`String`类型（生成的SQL语句）
- 参数可选：无参数或与Mapper方法相同的参数
**动态SQL构建技巧：**
```java
// 使用MyBatis的SQLBuilder
public String buildComplexQuery(Map<String, Object> params) {
    SQL sql = new SQL()
        .SELECT("u.id", "u.name", "d.department_name")
        .FROM("users u")
        .LEFT_OUTER_JOIN("departments d ON u.dept_id = d.id");
    
    if (params.containsKey("department")) {
        sql.WHERE("d.name = #{department}");
    }
    
    return sql.toString();
}
```
**最佳实践：**
- 将复杂的动态SQL逻辑提取到Provider类中
- 使用MyBatis提供的`SQL`工具类构建SQL，避免拼接错误
- Provider类应该是无状态的，便于测试和复用