###### 1. MyBatis 自带的连接池有什么特点？
MyBatis自带的数据源实现主要有两种：**UNPOOLED**​ 和 **POOLED**。
**UNPOOLED（非池化数据源）**​ 的特点是每次请求时都会**新建一个数据库连接**，使用完毕后立即关闭。它不管理连接的复用，适用于简单的测试环境或对性能要求极低的场景。其实现类 `UnpooledDataSource`在调用 `getConnection()`方法时，会直接通过 `DriverManager.getConnection()`创建新连接。
**POOLED（池化数据源）是MyBatis内置的**轻量级连接池实现**，也是我们讨论的重点。它的核心设计围绕 `PooledDataSource`类展开，其特点如下：
- **基本连接池功能**：它维护了两个重要的连接列表：`idleConnections`（空闲连接池）和 `activeConnections`（活跃连接池）。当应用请求连接时，它优先从空闲池中获取；如果没有空闲连接且未达到活跃连接数上限，则创建新连接；否则，当前线程会进入等待。
- **连接状态管理**：它通过 `PooledConnection`类对原始的JDBC `Connection`进行包装。这个包装类额外记录了连接的状态信息，如创建时间、最后使用时间、检出时间等，为连接的生命周期管理提供了依据。
- **连接有效性检测**：支持通过 `poolPingQuery`（如 `SELECT 1`）来定期检查空闲连接是否仍然有效，防止应用程序使用已被数据库服务器关闭的“僵尸连接”。
- **轻量与无依赖**：作为MyBatis的一部分，它无需引入额外的第三方依赖，配置简单，开箱即用。
**源码角度：连接获取流程**
在 `PooledDataSource`中，最核心的方法是 `popConnection()`。该方法在一个同步块（`synchronized (state)`）内执行，保证了线程安全。其简化逻辑如下：
1. 检查 `idleConnections`是否为空，如果不空，则直接取出第一个连接返回。
2. 如果 `idleConnections`为空，则检查当前活跃连接数是否小于设置的最大值（`poolMaximumActiveConnections`）。如果是，则创建一个新的 `PooledConnection`。
3. 如果活跃连接数已满，则尝试取出最早创建的活跃连接，并检查其“检出时间”（checkout time）是否已超过 `poolMaximumCheckoutTime`。如果超时，则“征用”此连接（将其从活跃列表移除，并回滚可能未提交的事务），然后将其包装为新连接返回。
4. 如果无法获取或征用连接，则线程进入等待（`state.wait(poolTimeToWait)`），直到有连接被释放或超时。
**优缺点与适用场景**
- **优点**：简单、无外部依赖，适合中小型应用、开发测试环境。
- **缺点**：功能相对单一，**缺乏连接泄漏检测、详细的监控指标**等高级特性。在高并发场景下，其性能与稳定性不如HikariCP、Druid等专业连接池。
- **生产环境建议**：对于生产环境，尤其是高并发、高性能要求的系统，**强烈建议使用第三方连接池**，如HikariCP或Druid。
###### 2. MyBatis 如何配置第三方连接池（如 HikariCP、Druid）？
切换到第三方连接池非常简单，只需修改MyBatis的配置文件并添加相应依赖即可。其原理是MyBatis的 `DataSource`接口是开放的，可以接入任何实现了该接口的连接池。
**配置HikariCP（以Spring Boot为例）**
1. **添加依赖**：
```xml
    <dependency>
        <groupId>com.zaxxer</groupId>
        <artifactId>HikariCP</artifactId>
    </dependency>
```
2. **在 `application.yml`中配置**：

```yaml
    spring:
      datasource:
        url: jdbc:mysql://localhost:3306/my_db
        username: root
        password: yourpassword
        driver-class-name: com.mysql.cj.jdbc.Driver
        hikari:
          maximum-pool-size: 20
          connection-timeout: 30000
          idle-timeout: 600000
          max-lifetime: 1800000
```
在传统的 `mybatis-config.xml`中，你可以直接将 `type`属性设置为HikariCP数据源的全限定名：
```xml
    <dataSource type="com.zaxxer.hikari.HikariDataSource">
      <property name="jdbcUrl" value="..."/>
      <property name="username" value="..."/>
      <!-- 其他HikariCP特有属性 -->
    </dataSource>
```
**配置Druid（功能强大，带监控）**
1. **添加依赖**：
```xml
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid-spring-boot-starter</artifactId>
        <version>1.2.8</version>
    </dependency>
```
    
2. **在 `application.yml`中配置**：
```yaml
    spring:
      datasource:
        url: jdbc:mysql://localhost:3306/my_db
        username: root
        password: yourpassword
        driver-class-name: com.mysql.cj.jdbc.Driver
        type: com.alibaba.druid.pool.DruidDataSource
        druid:
          initial-size: 5
          min-idle: 5
          max-active: 20
          filters: stat,wall,log4j2
          stat-view-servlet:
            enabled: true
 ```
同样，也可以在 `mybatis-config.xml`中通过 `type`属性指定，或通过继承 `PooledDataSourceFactory`创建自定义工厂类。
**选择建议**：
- **追求极致性能**：选择 **HikariCP**。
- **需要强大监控和防SQL注入等功能**：选择 **Druid**。
###### 3. MyBatis 如何实现多数据源配置？
在Spring Boot项目中，实现多数据源的核心是配置多个 `DataSource`Bean，并为每个数据源创建独立的 `SqlSessionFactory`和 `TransactionManager`。
**配置步骤详解**：
假设我们有两个数据源：`primaryDb`和 `secondaryDb`。
1. **在 `application.yml`中定义两个数据源的配置**：
```yaml
    primary:
      datasource:
        url: jdbc:mysql://localhost:3306/primary_db
        username: primary_user
        password: ...
    secondary:
      datasource:
        url: jdbc:mysql://localhost:3310/secondary_db
        username: secondary_user
        password: ...
 ```
2. **Java配置类中创建数据源及相关组件**：
为每个数据源创建一套完整的MyBatis运行时环境。
```java
    @Configuration
    @MapperScan(basePackages = "com.example.mapper.primary",
                sqlSessionFactoryRef = "primarySqlSessionFactory")
    public class PrimaryDataSourceConfig {
    
        @Bean
        @Primary
        @ConfigurationProperties(prefix = "primary.datasource")
        public DataSource primaryDataSource() {
            // 这里返回HikariDataSource或DruidDataSource
            return DataSourceBuilder.create().type(HikariDataSource.class).build();
        }
    
        @Bean
        @Primary
        public SqlSessionFactory primarySqlSessionFactory(@Qualifier("primaryDataSource") DataSource dataSource) throws Exception {
            SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
            sessionFactory.setDataSource(dataSource);
            // 设置Mapper.xml位置，如果与次数据源不同
            sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/primary/*.xml"));
            return sessionFactory.getObject();
        }
    
        @Bean
        @Primary
        public DataSourceTransactionManager primaryTransactionManager(@Qualifier("primaryDataSource") DataSource dataSource) {
            return new DataSourceTransactionManager(dataSource);
        }
    }
    
    @Configuration
    @MapperScan(basePackages = "com.example.mapper.secondary",
                sqlSessionFactoryRef = "secondarySqlSessionFactory")
    public class SecondaryDataSourceConfig {
    
        @Bean
        @ConfigurationProperties(prefix = "secondary.datasource")
        public DataSource secondaryDataSource() {
            return DataSourceBuilder.create().type(HikariDataSource.class).build();
        }
    
        @Bean
        public SqlSessionFactory secondarySqlSessionFactory(@Qualifier("secondaryDataSource") DataSource dataSource) throws Exception {
            SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
            sessionFactory.setDataSource(dataSource);
            sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/secondary/*.xml"));
            return sessionFactory.getObject();
        }
    
        @Bean
        public DataSourceTransactionManager secondaryTransactionManager(@Qualifier("secondaryDataSource") DataSource dataSource) {
            return new DataSourceTransactionManager(dataSource);
        }
    }
```
**关键点**：
- **`@MapperScan`**：通过指定 `basePackages`和 `sqlSessionFactoryRef`，将不同包下的Mapper接口与对应的 `SqlSessionFactory`绑定。
- **`@Primary`**：在多个同类型Bean存在时，标记一个为首选（例如，主数据源的相关Bean）。
- **`@Qualifier`**：在注入时明确指定要注入的Bean名称，避免歧义。
###### 4. MyBatis 多数据源下如何切换数据源？
上述配置实现了**静态数据源隔离**，即每个Mapper在启动时就已经确定使用哪个数据源。但在某些业务场景下，我们需要在**运行时动态切换**数据源，例如根据租户ID或业务参数决定访问哪个数据库。
**实现动态数据源切换的核心技术是 `AbstractRoutingDataSource`**。
1. **定义动态数据源类，继承 `AbstractRoutingDataSource`**：
```java
    public class DynamicDataSource extends AbstractRoutingDataSource {
    
        @Override
        protected Object determineCurrentLookupKey() {
            // 这个方法返回一个“键”，用于从已配置的数据源Map中查找当前应使用的数据源。
            return DataSourceContextHolder.getDataSourceType();
        }
    }
```
2. **使用ThreadLocal保存当前线程的数据源标识**：
```java
    public class DataSourceContextHolder {
        private static final ThreadLocal<String> CONTEXT_HOLDER = new ThreadLocal<>();
    
        public static void setDataSourceType(String dataSourceType) {
            CONTEXT_HOLDER.set(dataSourceType);
        }
    
        public static String getDataSourceType() {
            return CONTEXT_HOLDER.get();
        }
    
        public static void clearDataSourceType() {
            CONTEXT_HOLDER.remove();
        }
    }
```
3. **配置动态数据源，注入多个目标数据源**：
```java
    @Bean
    public DataSource dynamicDataSource(@Qualifier("primaryDataSource") DataSource primary,
                                         @Qualifier("secondaryDataSource") DataSource secondary) {
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put("primary", primary);
        targetDataSources.put("secondary", secondary);
    
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        dynamicDataSource.setTargetDataSources(targetDataSources);
        dynamicDataSource.setDefaultTargetDataSource(primary); // 设置默认数据源
        return dynamicDataSource;
    }
```
然后，让 `SqlSessionFactory`和 `TransactionManager`使用这个 `dynamicDataSource`。
4. **在Service层切换数据源**：
通常通过自定义注解和AOP切面来实现优雅的切换。
```java
    @Target(ElementType.METHOD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface DataSource {
        String value() default "primary";
    }
    
    @Aspect
    @Component
    public class DataSourceAspect {
        @Before("@annotation(dataSourceAnnotation)")
        public void before(JoinPoint joinPoint, DataSource dataSourceAnnotation) {
            DataSourceContextHolder.setDataSourceType(dataSourceAnnotation.value());
        }
    
        @After("@annotation(dataSourceAnnotation)")
        public void after(JoinPoint joinPoint, DataSource dataSourceAnnotation) {
            DataSourceContextHolder.clearDataSourceType();
        }
    }
    
    @Service
    public class UserService {
        @DataSource("secondary") // 使用次数据源执行此方法
        public User getUserFromSecondaryDB(Long id) {
            return userMapper.selectById(id);
        }
    }
```
**注意事项**：动态数据源切换必须与事务管理器（`PlatformTransactionManager`）配合好，**最好在开启事务之前就确定数据源**，否则可能导致事务和数据源不一致的问题。
###### 5. MyBatis 如何实现读写分离？
读写分离可以看作是**多数据源的一个特例**，其核心是一个主库（Master）用于写操作，一个或多个从库（Slave）用于读操作。
**实现方案**：
方案基本与动态数据源切换一致，但路由逻辑更简单明确：
1. **配置主从数据源**：分别配置Master和Slave的 `DataSource`。
2. **创建路由数据源**：继承 `AbstractRoutingDataSource`。
3. **实现路由逻辑**：在 `determineCurrentLookupKey()`方法中，根据操作类型是读还是写返回不同的数据源键。
**路由策略示例**：
```java
public class ReadWriteDataSourceRouter extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        // 可以根据方法名、注解或事务只读属性来判断
        boolean isReadOperation = TransactionSynchronizationManager.isCurrentTransactionReadOnly();
        // 或者从自定义的上下文中获取，例如：
        // String operationType = ReadWriteContext.get();
        
        if (isReadOperation) {
            // 可以在这里加入负载均衡逻辑，随机选择多个从库中的一个
            return "slave";
        } else {
            return "master";
        }
    }
}
```
**与Spring事务的整合**：在Service方法上使用 `@Transactional(readOnly = true)`来标记一个只读事务，路由数据源会据此自动将查询操作路由到从库。