###### 1. MyBatis 与 JPA 的区别是什么？如何选择？
**核心设计哲学差异**
- **MyBatis**：采用**半自动化ORM**模式，核心是SQL映射框架。它不试图完全屏蔽SQL，而是让开发者直接编写和优化SQL，框架主要负责将结果集映射到Java对象。
- **JPA**：作为Java持久化API标准，是**全自动ORM**框架。它通过注解或XML配置实现对象与数据库表的映射，开发者通过操作对象来间接操作数据库，框架自动生成SQL。
**具体区别对比**

|**对比维度**​|**MyBatis**​|**JPA (以Hibernate为例)**​|
|---|---|---|
|**SQL控制**​|完全掌控，手动编写与优化|有限控制，自动生成SQL|
|**开发效率**​|中等，需编写SQL|高，简单CRUD零代码|
|**性能调优**​|直接精准，可针对每条SQL优化|间接，需理解生成SQL及缓存机制|
|**学习曲线**​|平缓，熟悉SQL即可上手|陡峭，需掌握实体状态、延迟加载等概念|
|**数据库兼容性**​|需手动处理方言差异|优秀，Hibernate方言自动适配|
**源码角度解析**
- **MyBatis执行机制**：通过`SqlSessionTemplate`创建`SqlSession`，`MappedStatement`描述SQL信息，`Executor`执行SQL并处理缓存。开发者编写的SQL直接被执行，控制路径清晰。
- **JPA执行机制**：`EntityManager`作为入口，底层`SessionImpl`管理实体状态。查询时JPQL被解析为AST，再转换为特定数据库SQL。这个过程涉及查询重写、优化，相对复杂。
**选择建议**
- **选择MyBatis**：复杂查询系统（如报表、数据分析）、遗留系统改造、对SQL性能有极致要求的场景。
- **选择JPA**：快速原型开发、DDD领域驱动设计项目、简单CRUD为主的系统。
- **混合使用**：核心复杂业务用MyBatis，简单模块用JPA，但需注意事务一致性管理。
###### 2. MyBatis 与 Spring Data JDBC 的区别是什么？
**架构层级差异**
- **MyBatis**：是完整的SQL映射框架，提供强大的结果集映射、缓存机制和动态SQL支持。
- **Spring Data JDBC**：是Spring Data家族成员，本质是**JdbcTemplate的封装**，提供更简单的Repository抽象，避免ORM复杂性。
**核心特性对比**

|**特性**​|**MyBatis**​|**Spring Data JDBC**​|
|---|---|---|
|**映射复杂度**​|支持复杂嵌套结果映射|简单一对一映射，不支持懒加载|
|**SQL支持**​|完整动态SQL、存储过程|基本CRUD，复杂查询需@Query注解|
|**缓存机制**​|一级、二级缓存支持|无内置缓存|
|**事务管理**​|与Spring事务集成|基于Spring事务|
**设计理念差异**
- **MyBatis**追求SQL灵活性，允许开发者精细控制每个查询操作。
- **Spring Data JDBC**遵循"简单至上"原则，没有脏检查、延迟加载等复杂特性，更接近SQL本质。
**适用场景**
- **MyBatis**：需要复杂映射、动态SQL、性能调优的企业级应用。
- **Spring Data JDBC**：微服务架构中的简单数据访问、对启动速度有要求的场景、不想引入完整ORM框架的项目。
###### 3. 什么场景下适合使用 MyBatis？
**复杂SQL查询场景**
当业务需要复杂的多表关联、自定义函数、窗口函数等高级SQL特性时，MyBatis的直接SQL控制能力具有明显优势。例如金融行业的报表系统、电商平台的商品筛选。
**性能敏感型应用**
在对响应时间有严格要求的系统中，如高并发交易系统，MyBatis允许开发者编写优化过的SQL，避免ORM自动生成的SQL可能存在的性能问题。
**遗留系统集成与改造**
在需要与现有存储过程、特定数据库功能（如Oracle的CONNECT BY）集成的场景，MyBatis的灵活性使其成为理想选择。
**大数据量处理**
需要流式查询、分页、批量操作的场景，MyBatis提供更好的控制能力。例如数据导出、批量处理任务。
**团队技术栈考量**
当开发团队SQL能力强，希望直接控制数据库交互时，MyBatis比全自动ORM更符合团队技能结构。
###### 4. MyBatis 的优缺点是什么？
**核心优势**
1. **SQL灵活性与控制力**
    - 直接编写和优化SQL，支持复杂查询和数据库特定功能。
    - 动态SQL功能（`<if>、<choose>、<foreach>`）强大，适应多变业务需求。
    - 源码层面，`DynamicSqlSource`负责解析动态标签，`BoundSql`生成最终SQL。
2. **性能优化空间大**
    - 接近JDBC的性能，无复杂ORM开销。
    - 缓存机制可配置：一级缓存（SqlSession级别）、二级缓存（Mapper级别）。
    - 支持批量操作（`ExecutorType.BATCH`），大幅提升写入性能。
3. **易于调试和监控**
    - SQL日志清晰，便于性能分析和问题定位。
    - 与Druid等连接池集成，提供详细监控指标。
4. **与Spring生态无缝集成**
    - 通过`SqlSessionFactoryBean`简化配置，与Spring事务管理紧密结合。
**主要局限性**
5. **开发效率相对较低**
    - 简单CRUD也需编写SQL和映射配置，代码量较大。
    - 与JPA的派生查询相比，开发效率有差距。
6. **数据库移植性挑战**
    - SQL中使用的数据库特定语法和函数会降低可移植性。
    - 分页等操作需为不同数据库编写不同实现。
7. **学习与维护成本**
    - 复杂XML配置和动态SQL需要学习成本。
    - 大型项目中XML文件可能变得冗长，维护困难。
8. **对象关联处理较弱**
    - 相比JPA的自动关联管理，MyBatis需要手动处理复杂对象关系。
**改进与演进**
MyBatis-Plus等增强工具通过提供代码生成、Lambda表达式查询等功能，正在弥补MyBatis在开发效率方面的不足。