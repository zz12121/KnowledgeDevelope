###### 1. MyBatis 的插件机制是什么？如何自定义插件？
**MyBatis插件机制**是一种基于**拦截器（Interceptor）**​ 的框架扩展点，它允许开发者在MyBatis核心流程的特定节点插入自定义逻辑，而无需修改框架源码。其本质是**JDK动态代理**和**责任链模式**的综合运用，实现对**Executor**、**StatementHandler**、**ParameterHandler**、**ResultSetHandler**这四大核心组件的方法进行拦截和增强。
**自定义插件的步骤如下：**
1. **实现Interceptor接口**：创建一个类实现`org.apache.ibatis.plugin.Interceptor`接口，并实现其三个核心方法。
    - `intercept(Invocation invocation)`：在此方法中编写拦截后的增强逻辑。通过`Invocation`对象可以获取目标方法、参数等，调用`invocation.proceed()`来继续执行责任链。
    - `plugin(Object target)`：此方法通常固定返回`Plugin.wrap(target, this)`，用于使用当前拦截器包装目标对象，生成代理对象。
    - `setProperties(Properties properties)`：用于接收在配置文件中为插件设置的属性。
2. **使用注解声明拦截点**：在插件类上使用`@Intercepts`和`@Signature`注解，精确指定要拦截的类、方法及参数类型。
```java
    @Intercepts({
        @Signature(type = StatementHandler.class, method = "prepare", 
                  args = {Connection.class, Integer.class})
    })
    public class MyPlugin implements Interceptor {
        // ... 实现方法
    }
```
    
3. **在配置文件中注册插件**：在`mybatis-config.xml`中配置自定义的插件。
```xml
    <configuration>
        <plugins>
            <plugin interceptor="com.example.MyPlugin">
                <property name="someProperty" value="someValue"/>
            </plugin>
        </plugins>
    </configuration>
```
**源码角度解析插件加载与生效机制：**
1. **解析配置**：MyBatis启动时，`XMLConfigBuilder.parseConfiguration()`方法会调用`pluginElement()`来解析`<plugins>`标签。它会通过反射实例化插件类，并调用`setProperties`方法传入配置参数，最后将插件实例添加到`Configuration`对象的`InterceptorChain`（拦截器链）中。
2. **创建代理**：当MyBatis创建四大组件（如`Executor`）的实例时，会调用`Configuration.newExecutor()`等方法。在创建完原生对象后，会调用`interceptorChain.pluginAll(target)`方法。该方法遍历所有已注册的拦截器，并依次调用其`plugin`方法，对目标对象进行层层包装，最终返回一个代理对象。
3. **执行拦截**：当调用代理对象的方法时，会触发`Plugin`类的`invoke`方法。该方法检查当前方法是否在拦截器声明的签名内，如果是，则转而调用拦截器的`intercept`方法，从而执行自定义逻辑。
###### 2. MyBatis 插件的拦截点有哪些？
MyBatis插件只能拦截定义好的四大核心组件中的特定方法，这些组件涵盖了SQL执行的生命周期：

|**拦截组件**​|**组件职责**​|**可拦截的关键方法**​|**典型应用场景**​|
|---|---|---|---|
|**Executor**​|SQL执行器，负责全局缓存、事务管理等|`update`, `query`, `commit`, `rollback`|分页插件、数据权限过滤、读写分离、二级缓存定制|
|**StatementHandler**​|SQL语法构建器，负责创建`Statement`|`prepare`, `parameterize`, `batch`, `update`, `query`|**SQL重写**（如分页）、性能监控、SQL记录|
|**ParameterHandler**​|参数处理器，将Java对象转换为JDBC类型|`getParameterObject`, `setParameters`|参数加密、参数验证、参数美化|
|**ResultSetHandler**​|结果集处理器，将结果集转换为Java对象|`handleResultSets`, `handleOutputParameters`|结果集解密、数据脱敏、自定义类型转换|
**注意**：拦截点的选择取决于业务需求。例如，要修改SQL语句，最有效的拦截点是`StatementHandler.prepare`方法，因为此时可以获取并修改`BoundSql`对象中的SQL字符串。
###### 3. MyBatis 的分页插件（PageHelper）是如何工作的？
PageHelper是MyBatis中最著名的分页插件，其核心工作原理同样是基于插件机制，它主要拦截`Executor`的查询方法。
**工作流程如下：**
1. **启动分页**：在查询方法执行前，调用`PageHelper.startPage(int pageNum, int pageSize)`。此方法会将分页参数（页码、页大小）存储在一个`ThreadLocal`变量中，从而保证线程安全。
2. **拦截查询**：当执行Mapper查询方法时，被PageHelper拦截器拦截。拦截器从`ThreadLocal`中获取分页参数。
3. **SQL重写与查询总数**：
    - **SQL重写**：拦截器会修改原始的SQL语句，根据数据库方言（如MySQL的`LIMIT`，Oracle的`ROWNUM`）添加分页条件。
    - **查询总数**：为了得到总记录数以计算总页数，拦截器会生成并执行一条`COUNT`查询语句（例如：`SELECT COUNT(*) FROM (原始SQL)`）。
4. **执行分页查询**：使用重写后的SQL执行查询，数据库只返回当前页的数据。
5. **封装分页信息**：拦截器将查询结果和总记录数等信息封装到`Page`或`PageInfo`对象中，并清理`ThreadLocal`中的分页参数，最后返回结果。
**源码角度**：PageHelper拦截器在`intercept`方法中，通过`MetaObject`等反射工具获取并修改`MappedStatement`对象中`BoundSql`的SQL内容，从而实现物理分页。
###### 4. MyBatis 如何实现物理分页和逻辑分页？

|**对比维度**​|**物理分页**​|**逻辑分页（内存分页）**​|
|---|---|---|
|**原理**​|在**数据库层面**执行分页，SQL语句中包含分页关键字（如`LIMIT`）。|在**应用层面**分页，先查询出所有数据到内存，再使用`RowBounds`或Java代码截取部分数据。|
|**实现方式**​|1. **手动SQL**：在Mapper XML中直接写带分页的SQL。  <br>2. **分页插件**：如PageHelper，自动重写SQL。|使用MyBatis内置的`RowBounds`参数，或直接在Java集合中进行`subList`。|
|**性能**​|**高**。只从数据库传输当前页的数据，网络和内存开销小。|**低**。当数据量大时，查询所有数据会消耗大量数据库和网络资源，易导致内存溢出（OOM）。|
|**适用场景**​|**生产环境推荐**，尤其适用于数据量大的情况。|仅适用于数据量极小（如几百条）或测试环境。|
**逻辑分页示例（RowBounds）**：
```java
// Mapper接口
List<User> selectUsersByRowBounds(RowBounds rowBounds);
// 服务层调用
int offset = (pageNum - 1) * pageSize;
RowBounds rowBounds = new RowBounds(offset, pageSize);
List<User> users = userMapper.selectUsersByRowBounds(rowBounds);
```
**源码角度**：`RowBounds`逻辑分页在`DefaultResultSetHandler`处理结果集时，通过游标跳过`offset`条数据，然后只取`limit`条。它并未减少数据库的查询压力。
###### 5. MyBatis 的拦截器（Interceptor）有什么作用？
`Interceptor`（拦截器）是MyBatis插件机制的核心接口，其作用可以概括为以下三点：
1. **方法拦截与增强**：通过`intercept`方法，在目标方法执行前后插入自定义逻辑，实现AOP（面向切面编程）式的功能增强。
2. **生成代理对象**：通过`plugin`方法，将拦截器逻辑织入到目标对象中，生成一个代理对象，这是动态代理模式的体现。
3. **接收配置参数**：通过`setProperties`方法，使拦截器行为可配置，增加灵活性。
**核心作用是实现对MyBatis核心流程的无侵入式扩展**，使得开发者能够在不修改MyBatis源码的情况下，实现诸如分页、性能监控、数据加密、审计日志、动态表名等复杂功能。
###### 6. MyBatis 如何实现 SQL 性能监控？
利用自定义拦截器，可以非常方便地实现SQL性能监控，核心思路是拦截SQL执行方法，记录执行时间。
**实现步骤示例：**
1. **创建性能监控拦截器**：通常选择拦截`Executor`的`query`和`update`方法。
```java
    @Intercepts({
        @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}),
        @Signature(type = Executor.class, method = "update", args = {MappedStatement.class, Object.class})
    })
    public class SqlPerformanceInterceptor implements Interceptor {
        private static final long SLOW_SQL_THRESHOLD = 1000; // 定义慢SQL阈值(ms)
    
        @Override
        public Object intercept(Invocation invocation) throws Throwable {
            long startTime = System.currentTimeMillis();
            try {
                // 继续执行原方法
                return invocation.proceed();
            } finally {
                long costTime = System.currentTimeMillis() - startTime;
                // 获取执行的SQL信息
                MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];
                String sqlId = mappedStatement.getId();
    
                // 记录日志或发送到监控系统
                if (costTime > SLOW_SQL_THRESHOLD) {
                    System.err.printf("慢SQL警告 => ID: %s, 耗时: %d ms%n", sqlId, costTime);
                } else {
                    System.out.printf("SQL执行 => ID: %s, 耗时: %d ms%n", sqlId, costTime);
                }
            }
        }
        // ... 实现plugin和setProperties方法
    }
```
1. **注册拦截器**：在`mybatis-config.xml`中配置该拦截器。
**进阶监控方案：**
- **与监控系统集成**：可以将监控数据（如SQL ID、执行时间、参数等）发送到Prometheus、SkyWalking等APM（应用性能管理）系统，进行聚合分析和可视化告警。
- **统计SQL执行频率**：在拦截器中维护一个Map，统计每个SQL语句的执行次数，用于发现热点数据或无效查询。
- **检查结果集大小**：拦截`ResultSetHandler`，检查返回的结果集是否过大，预防内存问题。
