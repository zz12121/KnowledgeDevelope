###### 1. MyBatis 如何开启 SQL 日志？
MyBatis 开启 SQL 日志主要有三种方式，根据使用场景选择合适方案。
**Spring Boot 项目配置（推荐）**
在 `application.yml`或 `application.properties`中配置：
```yaml
# 方法一：设置特定Mapper接口的日志级别
logging:
  level:
    com.example.mapper: debug  # 将包路径替换为你的Mapper接口所在包

# 方法二：使用MyBatis内置的STDOUT日志（开发环境）
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```
**传统MyBatis项目配置**
在 `mybatis-config.xml`中指定日志实现：
```xml
<configuration>
  <settings>
    <setting name="logImpl" value="SLF4J"/>  <!-- 可选值：SLF4J、LOG4J、LOG4J2等 -->
  </settings>
</configuration>
```
**Log4j2 详细配置**
创建 `log4j2.xml`配置文件：
```xml
<Configuration>
  <Appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>
  </Appenders>
  
  <Loggers>
    <!-- 针对MyBatis SQL日志的专门配置 -->
    <Logger name="com.example.mapper" level="DEBUG" additivity="false">
      <AppenderRef ref="Console"/>
    </Logger>
    <Logger name="org.apache.ibatis" level="DEBUG" additivity="false">
      <AppenderRef ref="Console"/>
    </Logger>
    
    <Root level="INFO">
      <AppenderRef ref="Console"/>
    </Root>
  </Loggers>
</Configuration>
```
**源码机制**：MyBatis 的日志系统通过 `LogFactory`在初始化时检测当前项目的日志框架，采用适配器模式统一接口。当设置 `log-impl`时，实际上指定了具体的日志适配器实现 。
###### 2. MyBatis 如何查看执行的 SQL 语句？
**日志输出方式**
配置成功后，控制台会输出完整SQL信息，格式通常为：
```
Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@5e8c3] was not registered for synchronization because synchronization is not active
JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1a6c101] will not be managed by Spring
==>  Preparing: SELECT * FROM users WHERE id = ? AND name = ?
==> Parameters: 1(Integer), test(String)
<==    Total: 1
```
**拦截器方式（获取完整SQL）**
实现 `Interceptor`接口获取带实际参数的SQL：
```java
@Intercepts({
    @Signature(type = Executor.class, method = "update", args = {MappedStatement.class, Object.class}),
    @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
})
public class SqlInterceptor implements Interceptor {
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];
        Object parameter = invocation.getArgs()[1];
        BoundSql boundSql = mappedStatement.getBoundSql(parameter);
        
        String sql = boundSql.getSql();
        Object[] params = invocation.getArgs();
        
        System.out.println("SQL: " + sql);
        System.out.println("Parameters: " + Arrays.toString(params));
        
        return invocation.proceed();
    }
}
```
在配置文件中注册拦截器：
```xml
<plugins>
    <plugin interceptor="com.example.SqlInterceptor"/>
</plugins>
```
**调试断点方式**
在 IDEA 中调试 MyBatis 源码：
1. 打开 `org.apache.ibatis.executor.SimpleExecutor`类
2. 在 `doQuery`方法中设置断点
3. 查看 `BoundSql boundSql = mappedStatement.getBoundSql(parameter)`变量
4. 其中的 `sql`字段包含完整SQL，`parameterMappings`包含参数映射
###### 3. MyBatis 常见的异常有哪些？如何解决？
**Invalid bound statement (not found)**
- **现象**：`org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)`
- **原因**：Mapper接口方法与XML配置无法正确绑定
- **解决方案**：
    1. 检查XML中的`namespace`是否与Mapper接口全限定名完全一致
    2. 确认方法名是否与XML中的`id`属性一致
    3. 验证Mapper XML文件是否被正确打包到classpath目录
    4. 在Spring Boot中检查是否添加了`@Mapper`或`@MapperScan`注解
**参数绑定异常**
- **现象**：`org.apache.ibatis.type.TypeException: Could not set parameter`
- **原因**：参数名称不匹配或类型转换错误
- **解决方案**：
 ```java
    // 错误：多参数未使用@Param注解
    User findUser(String name, Integer age);
    
    // 正确：使用@Param明确参数名
    User findUser(@Param("userName") String name, @Param("userAge") Integer age);
    ```
   在XML中参数名必须一致：`WHERE name = #{userName} AND age = #{userAge}`
**结果映射异常**
- **现象**：`ResultMap contains duplicates of value`或属性映射失败
- **原因**：结果集映射配置错误或实体类属性不匹配
- **解决方案**：
    1. 检查`resultMap`中是否存在重复的id配置
    2. 确认数据库字段名与实体类属性名的映射关系
    3. 使用`@Result`注解或`<result>`标签明确指定映射
**事务相关异常**
- **现象**：`TransactionException`或数据修改未生效
- **原因**：事务配置错误或未正确提交
- **解决方案**： 
    ```java
    // 确保在需要事务的方法上添加注解
    @Transactional
    public void updateUser(User user) {
        userMapper.update(user);
        // 默认在方法结束时自动提交
    }
    ```
###### 4. MyBatis 的 Mapper 找不到的问题如何排查？
**系统化排查流程**
1. **检查基础配置**
    - 验证Mapper接口是否有`@Mapper`注解或已在`@MapperScan`指定的包路径内
    - 确认MyBatis配置文件中`<mappers>`配置正确
2. **验证XML映射文件**
    - 检查XML中的`namespace`必须与Mapper接口全限定名完全一致（包括大小写）
    - 确认方法名与XML中的`id`属性完全一致
    - 验证XML文件是否位于正确路径并被正确加载
3. **构建工具配置检查**
对于Maven项目，确保`pom.xml`正确配置资源文件包含：
```xml
    <build>
      <resources>
        <resource>
          <directory>src/main/java</directory>
          <includes>
            <include>**/*.xml</include>
          </includes>
        </resource>
        <resource>
          <directory>src/main/resources</directory>
        </resource>
      </resources>
    </build>
```
4. **运行时验证**
```java
    // 在测试代码中验证Mapper是否被正确加载
    @SpringBootTest
    class MapperLoadTest {
      @Autowired
      private ApplicationContext context;
    
      @Test
      void testMapperLoaded() {
        // 检查Mapper是否作为Bean被加载
        String[] beanNames = context.getBeanNamesForType(UserMapper.class);
        assertTrue(beanNames.length > 0);
      }
    }
```
5. **常见特定场景**
    - **多模块项目**：确保子模块配置正确，主模块能扫描到子模块的Mapper
    - **热部署环境**：检查IDE的自动编译设置，必要时清理重建项目
    - **版本兼容性**：确认MyBatis与Spring、MyBatis-Spring版本兼容
###### 5. MyBatis 如何调试 SQL 参数绑定？
**日志级别调试**
设置更详细的日志级别来查看参数绑定详情：
```yaml
logging:
  level:
    com.example.mapper: trace  # TRACE级别显示最详细参数信息
    org.apache.ibatis: debug
    org.springframework.jdbc: debug
```
**自定义TypeHandler调试**
实现自定义TypeHandler来监控参数处理过程：
```java
public class DebugTypeHandler extends BaseTypeHandler<String> {
    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
        System.out.println("参数位置：" + i + ", 值：" + parameter);
        ps.setString(i, parameter);
    }
    
    // 其他方法实现...
}
```
在映射中使用：
```xml
<resultMap>
  <result column="name" property="name" typeHandler="com.example.DebugTypeHandler"/>
</resultMap>
```
**源码调试技巧**
1. 在`org.apache.ibatis.scripting.defaults.DefaultParameterHandler`的`setParameters`方法设断点
2. 观察`parameterMappings`和`parameterObject`的值
3. 跟踪`TypeHandler`的处理流程，验证参数类型转换
**边界情况处理**
```java
// 1. 处理null值参数
queryUser(@Param("name") String name, @Param("age") Integer age);

// XML中处理null值
<if test="name != null and name != ''">AND name = #{name}</if>
<if test="age != null">AND age = #{age}</if>

// 2. 复杂对象参数嵌套访问
public class QueryCondition {
    private User user;
    private Date createTime;
    // getter/setter
}
```
在XML中通过属性路径访问：`#{user.name}, #{createTime}`
**动态SQL调试**
在动态SQL中使用`<choose>`, `<when>`时，添加调试语句：
```xml
<select id="findUsers">
  SELECT * FROM users
  <where>
    <if test="name != null">
      AND name = #{name}
      <!-- 调试用注释 -->
    </if>
    <choose>
      <when test="type == 'ADMIN'">
        AND role = 'admin'
      </when>
      <otherwise>
        AND role = 'user'
      </otherwise>
    </choose>
  </where>
</select>
```