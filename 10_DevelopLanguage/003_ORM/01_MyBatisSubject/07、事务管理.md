###### 1. MyBatis 如何管理事务？
MyBatis的事务管理机制基于**Transaction接口**和**SqlSession生命周期**，分为独立使用和与Spring集成两种模式。
**核心组件与工作机制：**
- **Transaction接口**：定义了事务管理的核心契约，包括`getConnection()`、`commit()`、`rollback()`、`close()`方法。
- **事务管理器实现**：
    - **JdbcTransaction**：用于独立MyBatis环境，直接封装JDBC连接的事务操作。其`commit()`和`rollback()`方法直接调用底层`Connection`对象的对应方法。
    - **ManagedTransaction**：将事务管理权交给容器（如应用服务器或Spring框架），其`commit()`和`rollback()`方法为空实现，事务生命周期由容器控制。
- **事务工厂（TransactionFactory）**：负责创建Transaction实例，根据MyBatis配置文件中`<transactionManager>`的`type`属性（JDBC或MANAGED）决定创建哪种Transaction实现。
**独立使用MyBatis时的事务管理流程：**
事务的生命周期与SqlSession绑定。通过`sqlSessionFactory.openSession()`获取SqlSession时，MyBatis会创建Transaction实例并关闭连接的自动提交（`autoCommit=false`），开启事务。开发者需手动调用`sqlSession.commit()`或`sqlSession.rollback()`来结束事务。
```java
// 独立使用MyBatis时的事务管理示例[4](@ref)
SqlSession sqlSession = sqlSessionFactory.openSession(); // 默认autoCommit=false，开启事务
try {
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    userMapper.insertUser(new User("张三"));
    userMapper.updateUserStatus(1L, "ACTIVE");
    sqlSession.commit(); // 手动提交事务
} catch (Exception e) {
    sqlSession.rollback(); // 异常时回滚
} finally {
    sqlSession.close();
}
```
**源码角度**：在`JdbcTransaction`的`commit()`方法中，可以看到其直接调用了`connection.commit()`。而`ManagedTransaction`的对应方法则为空。
###### 2. MyBatis 中事务的隔离级别如何设置？
事务隔离级别定义了事务之间的可见性规则。MyBatis本身不直接实现隔离级别，而是**依赖于底层数据库或集成框架（如Spring）的支持**。
**在独立MyBatis环境中设置隔离级别：**
可以在创建SqlSession时，通过传递`TransactionIsolationLevel`枚举参数来设置。MyBatis会通过`JdbcTransaction`将该隔离级别设置到JDBC连接上。
```java
// 在独立MyBatis中设置事务隔离级别[3](@ref)
try (SqlSession session = sqlSessionFactory.openSession(TransactionIsolationLevel.READ_COMMITTED)) {
    // 执行数据库操作，使用READ_COMMITTED隔离级别
    // ...
    session.commit();
} catch (Exception e) {
    session.rollback();
}
```
`TransactionIsolationLevel`枚举包含了与JDBC对应的级别：`NONE`, `READ_COMMITTED`, `READ_UNCOMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE`。
**在与Spring集成时设置隔离级别：**
更常见的做法是在Spring的`@Transactional`注解中设置`isolation`属性。
```java
@Service
public class UserService {
    @Transactional(isolation = Isolation.SERIALIZABLE) // 设置隔离级别为SERIALIZABLE[7](@ref)
    public void criticalOperation() {
        // ... 业务操作
    }
}
```
也可以通过XML配置为特定方法设置隔离级别。
```xml
<tx:advice id="txAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <tx:method name="criticalOperation" isolation="SERIALIZABLE"/> <!-- 设置隔离级别 -->[6](@ref)
    </tx:attributes>
</tx:advice>
```
###### 3. MyBatis 与 Spring 集成后，事务是如何管理的？
当MyBatis与Spring集成时，事务管理的主导权从MyBatis转移到了**Spring框架**。Spring通过其声明式事务管理模型，为MyBatis操作提供了强大且便捷的事务控制能力。
**核心整合机制：**
1. **事务管理器接管**：Spring的`PlatformTransactionManager`（通常使用`DataSourceTransactionManager`）取代了MyBatis自身的`Transaction`接口，成为实际的事务管理器。
2. **SqlSessionTemplate**：这是整合的关键。它是`SqlSession`的线程安全代理实现，确保了在每个事务上下文中，所有数据库操作都使用同一个与当前线程绑定的`SqlSession`（从而使用同一个数据库连接）。
3. **AOP与动态代理**：Spring利用AOP（面向切面编程）技术。当方法被`@Transactional`注解标记时，Spring会为该Bean创建代理对象。当代理方法被调用时，事务拦截器（`TransactionInterceptor`）会先于目标方法执行，负责开启事务、绑定资源等。
4. **ThreadLocal资源绑定**：Spring通过`TransactionSynchronizationManager`将数据库连接（`ConnectionHolder`）绑定到当前线程的ThreadLocal变量中。`SqlSessionTemplate`在执行数据库操作时，会从该管理器中获取当前事务使用的连接，保证了事务内连接的一致性。
**工作流程示例：**
```java
@Service
public class UserService {
    @Autowired
    private UserMapper userMapper; // 由MyBatis-Spring生成的Mapper代理对象

    @Transactional // 声明式事务管理[3,10](@ref)
    public void createUser(User user) {
        userMapper.insert(user); // 操作1，使用事务性SqlSession
        // ... 其他业务操作
        // 方法结束时，若无异常，TransactionInterceptor会提交事务；若有异常，则回滚[11](@ref)
    }
}
```
**源码角度**：`SqlSessionTemplate`内部有一个`SqlSessionInterceptor`拦截器，它通过`TransactionSynchronizationManager.getResource()`来获取与当前事务同步的`SqlSession`。
###### 4. MyBatis 的事务传播行为有哪些？
事务传播行为（Propagation Behavior）定义了**在事务方法之间相互调用时，事务应该如何传播**。此概念源于Spring框架，MyBatis在独立使用时并不直接支持复杂的传播行为。传播行为主要在MyBatis与Spring集成时通过Spring的`@Transactional`注解的`propagation`属性来配置和使用。
**常见的传播行为包括：**

|传播行为|说明|
|---|---|
|**PROPAGATION_REQUIRED**​ (**默认**)|如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。|
|**PROPAGATION_REQUIRES_NEW**​|创建一个新的事务，如果当前存在事务，则**挂起**当前事务。两个事务互不干扰。|
|**PROPAGATION_SUPPORTS**​|如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。|
|**PROPAGATION_MANDATORY**​|如果当前存在事务，则加入该事务；如果当前没有事务，则**抛出异常**。|
|**PROPAGATION_NESTED**​|如果当前存在事务，则在一个嵌套事务中执行。嵌套事务是外部事务的一部分，可以独立回滚，但提交需要依赖外部事务。|
|**PROPAGATION_NOT_SUPPORTED**​|以非事务方式执行操作，如果当前存在事务，则挂起当前事务。|
|**PROPAGATION_NEVER**​|以非事务方式执行，如果当前存在事务，则抛出异常。|
**使用示例：**
```java
@Service
public class OrderService {

    @Transactional(propagation = Propagation.REQUIRED)
    public void placeOrder(Order order) {
        // ... 主订单逻辑
        logOrderActivity(order.getId(), "PLACED"); // 该方法将加入placeOrder的事务
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logOrderActivity(Long orderId, String action) {
        // 这个方法总是会开启一个新的事务，即使调用它的placeOrder方法已经在事务中[11,13](@ref)
        // 即使日志记录失败回滚，也不会影响主订单事务的提交
    }
}
```
###### 5. MyBatis 如何处理事务回滚？
事务回滚是确保数据一致性的关键机制。MyBatis处理回滚的方式取决于其使用模式。
**1. 独立使用MyBatis：编程式回滚**
在此模式下，回滚是**显式（编程式）**​ 的。开发者需要在代码中捕获异常并手动调用`SqlSession.rollback()`。
```java
SqlSession sqlSession = sqlSessionFactory.openSession();
try {
    // 执行数据库操作
    userMapper.insert(user);
    // ... 其他操作
    sqlSession.commit(); // 手动提交
} catch (Exception e) {
    sqlSession.rollback(); // 手动回滚[3,4](@ref)
    // 记录日志或抛出异常
    throw new RuntimeException("Transaction failed", e);
} finally {
    sqlSession.close();
}
```
**2. 与Spring集成：声明式自动回滚**
这是最常用的方式。回滚由Spring框架**自动**处理，称为声明式回滚。
- **默认回滚规则**：默认情况下，只有当方法抛出**运行时异常（RuntimeException）**​ 或**Error**时，Spring才会自动回滚事务。
- **自定义回滚异常**：可以使用`@Transactional`注解的`rollbackFor`/ `noRollbackFor`属性精确控制哪些异常触发回滚。
```java
@Transactional(rollbackFor = {Exception.class}) // 遇到任何Exception（包括受检异常）都回滚[7](@ref)
public void updateUser(User user) throws BusinessException {
    try {
        userMapper.update(user);
    } catch (DuplicateKeyException e) {
        throw new BusinessException("用户已存在", e); // 此自定义受检异常也会触发回滚
    }
}
```

- **手动回滚**：在业务逻辑中，如果需要在不抛出异常的情况下回滚事务，可以调用`TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()`将当前事务标记为仅回滚。
**源码角度**：在Spring的`TransactionInterceptor`中，`completeTransactionAfterThrowing()`方法是异常回滚的核心。它会根据异常类型和事务属性决定是回滚还是提交。在`JdbcTransaction`中，回滚操作最终委托给`connection.rollback()`执行。