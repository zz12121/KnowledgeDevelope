###### 1. MyBatis 如何实现批量插入？
MyBatis实现批量插入主要有三种方式，各有适用场景：
**使用`<foreach>`标签实现单条SQL批量插入**
这是最高效的方式，将多条INSERT语句合并为一条SQL。
```xml
<insert id="batchInsert" parameterType="java.util.List">
    INSERT INTO user(name, age, email) VALUES
    <foreach collection="list" item="item" separator=",">
        (#{item.name}, #{item.age}, #{item.email})
    </foreach>
</insert>
```
**源码角度**：MyBatis的`DynamicContext`类会解析`<foreach>`标签，通过`StringJoiner`将多个VALUES组拼接成完整SQL。这种方式显著减少网络往返次数，但需要注意SQL长度限制（建议每批500-1000条）。
**使用`ExecutorType.BATCH`实现JDBC级别批处理**
适用于需要逐条处理对象的场景。
```java
// 获取批处理SqlSession
SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
UserMapper mapper = sqlSession.getMapper(UserMapper.class);

for (User user : userList) {
    mapper.insert(user);  // 不会立即执行，而是添加到批处理
    if (i % 1000 == 0) {
        sqlSession.flushStatements();  // 分批提交
    }
}
sqlSession.commit();
```
**源码机制**：`BatchExecutor`内部维护`Statement`缓存列表，`doUpdate()`方法将SQL添加到批处理，`flushStatements()`才真正执行`executeBatch()`。
**返回主键的批量插入**
MySQL支持获取批量插入的自增ID：
```xml
<insert id="batchInsert" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO user(name, email) VALUES
    <foreach collection="list" item="item" separator=",">
        (#{item.name}, #{item.email})
    </foreach>
</insert>
```
**注意**：需数据库支持批量获取自增ID，且`keyProperty`需正确设置到集合元素属性上。
###### 2. MyBatis 的批处理（Batch）模式是什么？如何使用？
**批处理模式核心机制**
`ExecutorType.BATCH`基于JDBC的`addBatch()`机制，将多个SQL语句缓存后一次性提交。
**三种执行器对比**

|**执行器类型**​|**特点**​|**适用场景**​|
|---|---|---|
|**SIMPLE**（默认）|为每个语句创建新PreparedStatement|常规操作，小数据量|
|**REUSE**​|复用预编译的Statement|相同SQL频繁执行|
|**BATCH**​|缓存多个操作，批量提交|大数据量插入、更新|
**Spring Boot集成配置**
```java
@Configuration
public class MyBatisConfig {
    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {
        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
        factoryBean.setDataSource(dataSource);
        
        org.apache.ibatis.session.Configuration config = new Configuration();
        config.setDefaultExecutorType(ExecutorType.BATCH);  // 全局批处理
        factoryBean.setConfiguration(config);
        
        return factoryBean;
    }
}
```
**性能优化要点**
- **批处理大小**：每500-1000条调用`flushStatements()`，避免内存溢出
- **MySQL参数**：URL添加`rewriteBatchedStatements=true`提升批量性能
- **事务管理**：批处理必须在事务中，确保失败时回滚
###### 3. MyBatis 如何优化大数据量查询？
**流式查询（ResultHandler）**
避免一次性加载所有数据到内存：
```xml
<select id="streamingQuery" resultType="User" fetchSize="1000">
    SELECT * FROM large_table WHERE conditions
</select>
```
```java
sqlSession.select("streamingQuery", param, new ResultHandler<User>() {
    @Override
    public void handleResult(ResultContext<? extends User> context) {
        User user = context.getResultObject();
        // 单条处理并释放资源
        if (context.getResultCount() % 100 == 0) {
            context.stop(); // 可控制停止条件
        }
    }
});
```
**源码角度**：`DefaultResultSetHandler`通过`ResultSet.TYPE_FORWARD_ONLY`和`FETCH_SIZE`实现流式获取。
**分页查询优化**
避免深分页，使用基于索引的分页：
```xml
<select id="pagingQuery" resultType="User">
    SELECT * FROM user 
    WHERE id > #{lastId} AND create_time > #{cutoffTime}
    ORDER BY id LIMIT #{pageSize}
</select>
```
**游标查询（Cursor）**
MyBatis 3.4.6+支持游标方式逐条处理：
```java
try (Cursor<User> cursor = userMapper.scanAll()) {
    cursor.forEach(user -> {
        // 处理每条数据
    });
}
```
###### 4. MyBatis 的 N+1 查询问题是什么？如何解决？
查询主表N条记录时，对每条记录执行关联查询（1次主查询 + N次关联查询）。
**示例场景**
```xml
<!-- 错误方式：N+1查询 -->
<resultMap id="userResultMap" type="User">
    <collection property="orders" ofType="Order" 
                select="selectOrdersByUserId" column="id"/>
</resultMap>

<select id="selectUser" resultMap="userResultMap">
    SELECT * FROM user WHERE id = #{id}  <!-- 1次查询 -->
</select>

<select id="selectOrdersByUserId" resultType="Order">
    SELECT * FROM orders WHERE user_id = #{userId}  <!-- N次查询 -->
</select>
```
**解决方案**
**使用JOIN查询一次性获取**
```xml
<resultMap id="userWithOrdersMap" type="User">
    <id property="id" column="user_id"/>
    <result property="name" column="user_name"/>
    <collection property="orders" ofType="Order">
        <id property="id" column="order_id"/>
        <result property="amount" column="order_amount"/>
    </collection>
</resultMap>

<select id="selectUserWithOrders" resultMap="userWithOrdersMap">
    SELECT u.id as user_id, u.name as user_name,
           o.id as order_id, o.amount as order_amount
    FROM user u LEFT JOIN orders o ON u.id = o.user_id
    WHERE u.id = #{id}
</select>
```
**使用IN查询批量获取**
先查询主表ID，再用IN查询关联表：
```sql
SELECT * FROM orders WHERE user_id IN (1, 2, 3, ...)
```
**延迟加载策略**
对不常用的关联数据启用延迟加载：
```xml
<settings>
    <setting name="lazyLoadingEnabled" value="true"/>
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```
###### 5. MyBatis 如何避免全表扫描？
**SQL层面优化**
- **索引匹配**：确保WHERE条件使用索引列
- **避免函数操作**：不在索引列上使用函数或计算
- **Like查询优化**：前缀匹配使用`column LIKE 'value%'`
**MyBatis动态SQL优化**
```xml
<select id="searchUsers" parameterType="map" resultType="User">
    SELECT * FROM user 
    <where>
        <if test="name != null and name != ''">
            AND name = #{name}  <!-- 使用索引 -->
        </if>
        <if test="age != null">
            AND age = #{age}
        </if>
        <if test="email != null and email != ''">
            AND email LIKE CONCAT(#{email}, '%')  <!-- 前缀匹配 -->
        </if>
    </where>
    ORDER BY create_time DESC
    LIMIT 1000  <!-- 限制结果集 -->
</select>
```
**分页限制**
大数据量查询必须分页，避免一次性返回过多数据。
###### 6. MyBatis 的执行器（Executor）有哪几种类型？各有什么特点？
**执行器架构**
执行器是MyBatis核心组件，负责SQL语句生成和参数绑定。

|**执行器类型**​|**实现类**​|**特点**​|**适用场景**​|
|---|---|---|---|
|**SIMPLE**​|`SimpleExecutor`|每次执行创建新Statement|默认模式，通用场景|
|**REUSE**​|`ReuseExecutor`|复用预编译Statement|相同SQL频繁执行|
|**BATCH**​|`BatchExecutor`|批量操作，延迟执行|大数据量操作|
**源码分析**
```java
// BaseExecutor.query()方法核心逻辑
public <E> List<E> query(MappedStatement ms, Object parameter, 
                         RowBounds rowBounds, ResultHandler resultHandler) {
    // 1. 获取BoundSql（已解析的SQL）
    BoundSql boundSql = ms.getBoundSql(parameter);
    
    // 2. 创建CacheKey（缓存键）
    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
    
    // 3. 执行查询（模板方法模式）
    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
}
```
**执行器选择策略**
- **默认情况**：使用`SimpleExecutor`，线程安全但性能一般
- **性能要求高**：`ReuseExecutor`减少预编译开销
- **批量操作**：显式创建`ExecutorType.BATCH`的SqlSession
###### 7. MyBatis 如何进行 SQL 调优？
**SQL语句优化**
- **索引优化**：EXPLAIN分析执行计划，确保使用合适索引
- **避免SELECT***：只查询需要的字段
- **分页优化**：使用基于游标或索引的分页代替`LIMIT offset, size`
**MyBatis配置优化**
```xml
<settings>
    <!-- 开启二级缓存 -->
    <setting name="cacheEnabled" value="true"/>
    
    <!-- 延迟加载设置 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <setting name="aggressiveLazyLoading" value="false"/>
    
    <!-- 数据库字段下划线转Java属性驼峰 -->
    <setting name="mapUnderscoreToCamelCase" value="true"/>
</settings>
```
**连接池优化**
```yaml
# Spring Boot配置
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
```
**监控与诊断**
- **慢SQL日志**：配置`log4j.logger.java.sql=DEBUG`监控SQL执行时间
- **MyBatis统计**：使用`org.apache.ibatis.executor.BaseExecutor`日志查看缓存命中率
**批量操作性能要点**
1. 合理设置批处理大小（500-1000条/批）
2. 定期调用`flushStatements()`避免内存溢出
3. 使用事务确保批量操作的原子性
4. MySQL配置`rewriteBatchedStatements=true`优化批量性能