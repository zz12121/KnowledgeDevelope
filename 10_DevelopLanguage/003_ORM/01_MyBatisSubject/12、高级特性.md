###### 1. MyBatis 如何处理枚举类型？
MyBatis提供了两种内置的枚举处理器，并支持自定义处理逻辑。
**内置枚举处理器**
- **EnumTypeHandler**：默认处理器，将枚举实例的名称（name()）作为字符串存储。例如`ComputerState.OPEN`存储为"OPEN"。
- **EnumOrdinalTypeHandler**：将枚举的序号（ordinal()）作为整数存储。例如`ComputerState.OPEN`存储为0（假设它是第一个枚举值）。
**自定义枚举处理器**
当内置处理器不满足需求时（例如希望存储枚举的自定义code值），可以创建自定义处理器。核心步骤包括：
1. 定义标识接口，约定枚举行为：
```
public interface BaseCodeEnum {
    int getCode(); // 约定返回枚举的自定义编码
}
```
2. 让枚举实现该接口：
```java
public enum ComputerState implements BaseCodeEnum {
	OPEN(10), CLOSE(11), OFF_LINE(12), FAULT(200), UNKNOWN(255);
	private int code;
	ComputerState(int code) { this.code = code; }
	@Override public int getCode() { return this.code; }
}
```
3. 继承`BaseTypeHandler`编写处理器，关键是在`setNonNullParameter`方法中将枚举的`getCode()`值设置到SQL参数，在`getNullableResult`方法中根据数据库中的值还原为枚举实例。
4. 在MyBatis配置中注册自定义处理器，或在MyBatis-Spring环境中通过`@Configuration`配置类动态注册所有实现`BaseCodeEnum`的枚举。
**源码角度**：枚举处理的核心在于`TypeHandler`。当MyBatis设置参数或获取结果时，`DefaultParameterHandler`和`DefaultResultSetHandler`会通过`TypeHandlerRegistry`找到对应的`TypeHandler`进行转换。
###### 2. MyBatis 如何自定义 TypeHandler？
自定义TypeHandler是扩展MyBatis类型转换能力的关键。其核心是实现`TypeHandler`接口或继承`BaseTypeHandler`抽象类。
**实现步骤**
1. **创建处理器类**：继承`org.apache.ibatis.type.BaseTypeHandler`，并指定泛型类型。重点实现四个方法：
    - `setNonNullParameter`：将Java类型参数转换为JDBC类型并设置到`PreparedStatement`。
    - 三个`getNullableResult`重载方法：分别从`ResultSet`（按列名、按列索引）和`CallableStatement`中将JDBC类型结果转换为Java类型。
    以下是一个将Java对象与JSON字符串相互转换的处理器示例：
	```java
    @MappedTypes(MyComplexType.class) // 指定处理的Java类型
    @MappedJdbcTypes(JdbcType.VARCHAR) // 指定对应的JDBC类型
    public class JsonTypeHandler extends BaseTypeHandler<MyComplexType> {
        private static final ObjectMapper mapper = new ObjectMapper();
        @Override
        public void setNonNullParameter(PreparedStatement ps, int i, MyComplexType parameter, JdbcType jdbcType) throws SQLException {
            ps.setString(i, mapper.writeValueAsString(parameter)); // 对象序列化为JSON字符串
        }
        @Override
        public MyComplexType getNullableResult(ResultSet rs, String columnName) throws SQLException {
            String json = rs.getString(columnName);
            return json == null ? null : mapper.readValue(json, MyComplexType.class); // JSON字符串反序列化为对象
        }
        // ... 实现另外两个getNullableResult方法
    }
    ```
2. **注册处理器**：
    - **配置文件注册**：在`mybatis-config.xml`中通过`<typeHandlers>`标签注册。
    - **包扫描注册**（Spring Boot常用）：在`application.yml`中配置`mybatis.type-handlers-package`，MyBatis会自动扫描该包下的处理器。
    - **注解注册**：使用`@MappedTypes`和`@MappedJdbcTypes`注解，MyBatis在扫描时会自动识别并注册。
**源码机制**：MyBatis启动时，`XMLConfigBuilder`会解析配置并初始化`TypeHandlerRegistry`，它将Java类型、JDBC类型与具体的`TypeHandler`实例建立映射关系。执行SQL时，`StatementHandler`通过此注册表获取对应的处理器进行类型转换。
###### 3. MyBatis 的 TypeHandler 有什么作用？
TypeHandler是MyBatis的核心组件之一，承担着**Java类型与JDBC类型之间的双向转换桥梁**角色。其作用主要体现在两个关键环节：
1. **参数设置（Parameter Setting）**：当执行`PreparedStatement`时，`TypeHandler`负责将Java对象中的属性值转换为JDBC类型，并调用`PreparedStatement.setXXX()`方法设置到SQL语句的占位符上。
2. **结果获取（Result Getting）**：当从`ResultSet`中获取数据时，`TypeHandler`负责将JDBC类型的结果值转换为Java对象，并设置到结果对象的对应属性中。
**具体应用场景包括**：
- **处理基本类型和常见对象**：如String、Integer、Date等，MyBatis提供了大量内置的`TypeHandler`。
- **处理枚举类型**：如上文所述。
- **处理复杂对象与特殊格式**：例如，将对象转换为JSON字符串存入数据库，或从数据库读取JSON字符串并解析为对象；处理BLOB/CLOB类型。
- **实现数据加密脱敏**：在存入数据库前对敏感数据加密，从数据库读出后进行解密。
###### 4. MyBatis 如何实现存储过程调用？
MyBatis通过`CallableStatement`支持存储过程的调用。
**Mapper接口定义**
```java
public interface UserMapper {
    // 方式一：使用Map接收OUT参数
    void callProcedureWithMap(Map<String, Object> params);
    // 方式二：使用注解指定参数模式
    @Select("{ CALL get_user_by_id(#{id, mode=IN}, #{userName, mode=OUT, jdbcType=VARCHAR, resultMap=userMap}) }")
    @Options(statementType = StatementType.CALLABLE)
    User callProcedureWithAnnotation(@Param("id") Long id, @Param("userName") String userName);
}
```
**Mapper XML配置**
在XML中，需要使用`statementType="CALLABLE"`来声明调用存储过程。
```xml
<select id="callUserProcedure" statementType="CALLABLE" parameterType="map">
    {call getUserDetail(
        #{userId, mode=IN, jdbcType=INTEGER},
        #{userName, mode=OUT, jdbcType=VARCHAR},
        #{userAge, mode=OUT, jdbcType=INTEGER}
    )}
</select>
```
**OUT参数处理**：对于OUT参数，MyBatis会通过`CallableStatementHandler`调用存储过程，并通过`DefaultResultSetHandler`处理结果和输出参数。输出参数的值会设置到你传入的参数对象（如Map）或注解指定的参数中。
###### 5. MyBatis 如何处理 BLOB 和 CLOB 类型？
MyBatis内置了`BlobTypeHandler`和`ClobTypeHandler`来处理这些大对象类型。
**基本处理方式**
- 对于`BLOB`（二进制大对象），通常映射为Java的`byte[]`或`java.sql.Blob`类型。
- 对于`CLOB`（字符大对象），通常映射为Java的`String`或`java.sql.Clob`类型。
**流式处理（避免内存溢出）**
对于超大BLOB/CLOB，应使用流式处理，避免一次性加载到内存。
```java
public interface BlobMapper {
    @Select("SELECT file_content FROM large_files WHERE id = #{id}")
    void getBlobContent(Long id, ResultHandler<byte[]> handler); // 使用ResultHandler流式处理
}
```
在XML中，可以为`resultType`指定`byte[]`或`String`，MyBatis会使用对应的TypeHandler进行流式读取。
**源码角度**：`BlobTypeHandler`在`getResult`方法中，会调用`ResultSet.getBlob()`方法获取`Blob`对象，然后通过`Blob.getBinaryStream()`读取数据。MyBatis的`DefaultResultSetHandler`会管理这个过程，确保资源正确关闭。
###### 6. MyBatis 如何实现动态表名？
MyBatis本身不直接支持在XML中动态指定表名，但可以通过以下技巧实现：
**使用`<script>`和`${}`（不推荐，有SQL注入风险）**
```xml
<select id="selectByTableName" resultType="map">
    SELECT * FROM ${tableName} WHERE id = #{id}
</select>
```
**注意：`${}`是字符串替换，而非预编译参数，存在SQL注入风险，应谨慎使用。**
**使用Provider类（MyBatis 3.4.2+）**
通过`@SelectProvider`等注解，在Java代码中动态构建SQL。
```java
public class DynamicTableProvider {
    public String selectByTableName(Map<String, Object> params) {
        String tableName = (String) params.get("tableName");
        return "SELECT * FROM " + tableName + " WHERE id = #{id}";
    }
}
// Mapper接口
@SelectProvider(type = DynamicTableProvider.class, method = "selectByTableName")
List<Map<String, Object>> selectByTableName(@Param("tableName") String tableName, @Param("id") Long id);
```
**拦截器方案（最安全灵活）**
通过实现`Interceptor`接口，拦截Executor的查询方法，在运行时修改BoundSql中的SQL文本，将预定义的表名占位符替换为实际的表名。这是最安全且功能最强大的方式。
###### 7. MyBatis 的鉴别器（discriminator）有什么作用？
`<discriminator>`是`<resultMap>`中的一个强大元素，用于实现基于某列值的不同而采用不同结果映射的策略，类似于Java中的switch-case语句。
应用场景
主要用于处理单表继承或类似场景，即一张表存储多种类型的数据，每种类型有不同的字段子集。
配置示例
```xml
<resultMap id="vehicleResultMap" type="Vehicle">
    <id property="id" column="id"/>
    <result property="brand" column="brand"/>
    <result property="color" column="color"/>
    <!-- 鉴别器：根据vehicle_type列的值选择不同的映射 -->
    <discriminator javaType="String" column="vehicle_type">
        <case value="CAR" resultMap="carResultMap"/>     <!-- 值为CAR时，使用carResultMap -->
        <case value="TRUCK" resultMap="truckResultMap"/> <!-- 值为TRUCK时，使用truckResultMap -->
    </discriminator>
</resultMap>

<!-- 汽车的特定映射 -->
<resultMap id="carResultMap" type="Car" extends="vehicleResultMap">
    <result property="doorCount" column="door_count"/>
</resultMap>

<!-- 卡车的特定映射 -->
<resultMap id="truckResultMap" type="Truck" extends="vehicleResultMap">
    <result property="payload" column="payload"/>
</resultMap>
```
查询时，MyBatis会根据vehicle_type字段的值，决定将一行数据映射为Car对象还是Truck对象，并映射其特有的字段。
源码角度：ResultSetHandler在处理结果集时，会检查ResultMap是否包含Discriminator。如果包含，它会获取鉴别器列的值，然后匹配对应的Case，最终使用Case中指定的ResultMap来创建和填充对象。
###### 8. MyBatis 如何实现结果集的嵌套映射？
MyBatis支持通过`<association>`（一对一）和`<collection>`（一对多）实现复杂的嵌套对象映射。
**一对一关联（`<association>`）**
```xml
<resultMap id="orderDetailMap" type="Order">
    <id property="id" column="order_id"/>
    <result property="orderNo" column="order_no"/>
    <!-- 关联一个User对象 -->
    <association property="user" javaType="User">
        <id property="id" column="user_id"/>
        <result property="username" column="username"/>
    </association>
    <!-- 或通过select触发嵌套查询（N+1查询问题需注意） -->
    <association property="user" column="user_id" javaType="User" select="selectUserById"/>
</resultMap>
```
**一对多关联（`<collection>`）**
```xml
<resultMap id="blogDetailMap" type="Blog">
    <id property="id" column="blog_id"/>
    <result property="title" column="title"/>
    <!-- 关联一个Post对象的集合 -->
    <collection property="posts" ofType="Post">
        <id property="id" column="post_id"/>
        <result property="content" column="content"/>
    </collection>
    <!-- 或通过select触发嵌套查询 -->
    <collection property="posts" column="blog_id" ofType="Post" select="selectPostsByBlogId"/>
</resultMap>
```
**嵌套查询与连接查询选择**
- **连接查询（单SQL）**：使用JOIN一次性获取所有数据，在`<association>`或`<collection>`中直接映射。性能较好，适合关联数据量不大的情况。
- **嵌套查询（多SQL）**：通过`select`属性触发另一次查询。可能导致N+1查询问题，但MyBatis提供了`lazyLoadingEnabled`（延迟加载）和`aggressiveLazyLoading`等配置来缓解。
**源码角度**：`DefaultResultSetHandler`的`handleResultSets`方法是处理嵌套映射的核心。它通过`getRowValue`方法处理每一行数据，并根据`ResultMap`的配置，使用`applyPropertyMappings`方法处理普通属性，使用`applyNestedResultMappings`方法处理嵌套映射。对于嵌套查询，它会通过`Executor`再次执行指定的`select`语句。