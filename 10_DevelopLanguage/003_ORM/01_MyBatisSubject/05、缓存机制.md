###### 1. MyBatis 的缓存机制是怎样的？
MyBatis的缓存机制采用**分层设计**，分为一级缓存和二级缓存，通过减少数据库访问次数来提升查询性能。
**一级缓存（本地缓存）**：
- **作用范围**：SqlSession级别，默认开启且无法关闭
- **存储机制**：基于BaseExecutor中的PerpetualCache实现，底层使用HashMap存储
- **源码实现**：在`org.apache.ibatis.executor.BaseExecutor`中，localCache字段维护缓存数据，通过CacheKey作为键
**二级缓存（全局缓存）**：
- **作用范围**：Mapper级别，跨SqlSession共享，需手动开启
- **架构设计**：采用装饰器模式，通过CachingExecutor包装基础Executor
- **事务性保证**：通过TransactionalCacheManager管理暂存区，确保只有事务提交后缓存才生效
**执行顺序**：查询时先检查二级缓存 → 一级缓存 → 数据库。这种设计确保在高频查询场景下显著降低数据库压力。
###### 2. MyBatis 一级缓存和二级缓存的区别是什么？

|**对比维度**​|**一级缓存**​|**二级缓存**​|
|---|---|---|
|**作用范围**​|SqlSession内部（线程私有）|Mapper级别（跨SqlSession共享）|
|**开启方式**​|默认开启，无法关闭|需手动配置`<cache/>`标签|
|**存储位置**​|BaseExecutor的localCache（HashMap）|可配置为内存、磁盘或第三方存储|
|**生命周期**​|随SqlSession创建而创建，关闭而销毁|应用生命周期，除非手动清除或过期|
|**序列化要求**​|无要求|实体类需实现Serializable接口|
|**数据一致性**​|高（会话内隔离）|中（依赖失效机制，可能脏读）|
**设计哲学差异**：一级缓存解决**同一会话内**的重复查询，二级缓存旨在**跨会话共享**静态数据。
###### 3. MyBatis 一级缓存的生命周期是什么？
一级缓存的生命周期与SqlSession紧密绑定，具体如下：
**创建时机**：
- 当调用`sqlSessionFactory.openSession()`创建SqlSession时，在BaseExecutor构造函数中初始化PerpetualCache
**销毁时机**：
1. **SqlSession关闭**：调用`sqlSession.close()`时清空缓存
2. **执行DML操作**：insert/update/delete操作会清空当前SqlSession的一级缓存
3. **手动清空**：调用`sqlSession.clearCache()`主动清空
4. **事务提交/回滚**：默认SESSION级别下，事务提交不会清空缓存；STATEMENT级别下每次查询后清空
**源码验证**：在`BaseExecutor.update()`方法中，首先调用`clearLocalCache()`清空缓存，再执行具体数据库操作。这种设计确保数据一致性，避免脏读。
###### 4. MyBatis 二级缓存如何配置？
二级缓存的配置需要多个步骤协同工作：
**1. 全局开关配置（默认true，可省略）**：
```xml
<settings>
    <setting name="cacheEnabled" value="true"/>
</settings>
```
**2. Mapper级别开启**：
在Mapper.xml中添加`<cache>`标签：
```xml
<mapper namespace="com.example.UserMapper">
    <cache 
        eviction="LRU"
        flushInterval="60000"
        size="1024"
        readOnly="true"/>
</mapper>
```
**3. 关键参数详解**：
- **eviction**：缓存回收策略（LRU、FIFO、SOFT、WEAK）
- **flushInterval**：自动刷新间隔（毫秒）
- **size**：缓存最大对象数
- **readOnly**：是否返回对象副本（线程安全）
**4. 实体类序列化**：
```java
public class User implements Serializable {
    // 字段定义
}
```
**注意事项**：二级缓存必须在事务提交后才生效，确保数据一致性。
###### 5. MyBatis 缓存的失效场景有哪些？
**一级缓存失效场景**：
- **SqlSession生命周期结束**：调用`close()`方法
- **DML操作**：执行insert、update、delete操作
- **手动清空**：调用`clearCache()`方法
- **查询参数变化**：CacheKey由SQL+参数等组成，参数变化导致缓存未命中
**二级缓存失效场景**：
- **同命名空间DML操作**：执行当前Mapper下的增删改操作
- **其他Mapper修改数据**：跨Mapper操作不会自动刷新缓存（需使用`<cache-ref>`）
- **缓存过期**：达到flushInterval设置的时间间隔
- **缓存溢出**：超过size限制，按eviction策略淘汰
**多表关联的缓存陷阱**：如果Mapper A关联查询Mapper B的数据，当Mapper B更新时，Mapper A的缓存不会自动失效。解决方案是避免多表查询使用二级缓存或在业务层控制。
###### 6. MyBatis 如何集成第三方缓存（如 Redis、Ehcache）？
集成第三方缓存主要为了支持分布式环境和提供更好的缓存管理能力。
**Redis集成步骤**：
1. **添加依赖**：
```xml
<dependency>
    <groupId>org.mybatis.caches</groupId>
    <artifactId>mybatis-redis</artifactId>
    <version>1.0.0-beta2</version>
</dependency>
```
1. **配置Mapper**：
```xml
<cache type="org.mybatis.caches.redis.RedisCache"/>
```
1. **Redis配置**（redis.properties）：
```properties
host=localhost
port=6379
password=123456
```
**Ehcache集成**：
```xml
<dependency>
    <groupId>org.mybatis.caches</groupId>
    <artifactId>mybatis-ehcache</artifactId>
    <version>1.2.2</version>
</dependency>

<cache type="org.mybatis.caches.ehcache.EhcacheCache"/>
```
**自定义缓存实现**：实现Cache接口，重写关键方法：
```java
public class CustomRedisCache implements Cache {
    private final String id;
    private final JedisPool jedisPool;
    
    @Override
    public void putObject(Object key, Object value) {
        // 自定义存储逻辑
    }
    
    @Override
    public Object getObject(Object key) {
        // 自定义获取逻辑
    }
}
```
###### 7. MyBatis 缓存的命中率如何优化？
**监控与诊断**：
1. **开启日志**：观察`Cache Hit Ratio`输出
2. **性能监控**：集成Druid等工具查看缓存命中率
**优化策略**：
3. **合理选择缓存级别**：
    - 高频会话内查询：使用一级缓存 
    - 跨会话静态数据：使用二级缓存
4. **缓存粒度控制**：
    - 细粒度缓存：对热点数据单独缓存
    - 避免过度缓存：频繁更新的数据不适合缓存
5. **配置优化**：
```xml
<cache eviction="LRU" 
        flushInterval="1800000" 
        size="1000" 
        readOnly="false"
        blocking="true"/>
```
6. **防止缓存穿透**：
    - 设置`blocking="true"`防止并发查询
    - 缓存空值避免频繁查询数据库
7. **分布式环境策略**：
    - 使用Redis等分布式缓存替代默认实现
    - 设置合理的缓存过期时间，平衡一致性需求