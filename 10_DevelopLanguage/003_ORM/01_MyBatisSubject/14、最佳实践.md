###### 1. MyBatis 的最佳实践有哪些？
**架构设计层面**
- **SQL与Java代码分离**：将SQL语句与Java代码分离，Mapper接口定义方法，XML文件编写SQL，提高代码可读性和可维护性
- **合理使用注解与XML**：简单场景使用注解减少配置，复杂SQL使用XML获得更好可读性
- **分层架构设计**：采用经典的分层架构，将代码分为实体层、Mapper层、Service层等，各层职责明确
**性能优化层面**
- **动态SQL优先**：复杂条件查询首选`<if>`、`<choose>`、`<foreach>`等动态SQL标签，避免拼接字符串导致SQL注入风险
- **批量操作优化**：使用`<foreach>`标签或`BatchExecutor`执行器高效处理批量插入/更新
- **二级缓存慎用**：读多写少场景可配置二级缓存，频繁更新数据需配置缓存刷新策略
**可维护性层面**
- **统一异常处理**：在Mapper接口方法中添加异常处理逻辑，捕获数据访问错误
- **编写单元测试**：为Mapper接口编写单元测试，确保代码正确性和稳定性
- **代码审查机制**：定期进行代码审查，发现潜在问题和不足
###### 2. MyBatis 项目中如何组织 Mapper 文件？
**标准目录结构**
```
src/
├── main/
│   ├── java/
│   │   └── com/example/
│   │       ├── entity/          # 实体类
│   │       ├── mapper/          # Mapper接口
│   │       │   ├── UserMapper.java
│   │       │   └── OrderMapper.java
│   │       └── service/         # 业务逻辑层
│   └── resources/
│       ├── mapper/              # XML映射文件
│       │   ├── UserMapper.xml
│       │   └── OrderMapper.xml
│       └── mybatis-config.xml   # MyBatis配置
```
**Maven资源配置**
```xml
<build>
    <resources>
        <resource>
            <directory>src/main/resources</directory>
            <includes>
                <include>**/*.xml</include>
            </includes>
        </resource>
    </resources>
</build>
```
确保XML文件被正确打包到target目录中
**模块化组织策略**
- **按功能模块划分**：用户模块的UserMapper、订单模块的OrderMapper等
- **统一的命名约定**：Mapper接口与XML文件同名，如`UserMapper.java`对应`UserMapper.xml`
- **包扫描配置**：在Spring Boot中使用`@MapperScan`注解自动扫描Mapper接口
###### 3. MyBatis 的命名规范有哪些建议？
**包命名规范**
- 采用全小写字母，多级包之间用点分隔
- 例如：`org.dromara.mybatis.jpa.mapper`
**类与接口命名**
- 类名采用帕斯卡命名法（PascalCase），如`UserMapper`
- 接口名以"I"开头，如`IJpaMapper`
- Mapper接口名一般为`xxxxMapper`，如`UserMapper`、`BookMapper`
**方法命名规范**
- 采用驼峰命名法（camelCase），使用动词或动词短语
- 常见操作：`saveUser`、`updateUser`、`deleteById`、`findUserById`、`selectAll`
**数据库映射规范**
```xml
<settings>
    <setting name="mapUnderscoreToCamelCase" value="true"/>
</settings>
```
开启驼峰命名自动映射，将数据库列名（如`car_number`）自动映射到Java属性名（如`carNumber`）
**变量与常量命名**
- 变量名驼峰式：`userName`、`orderList`
- 常量全大写：`MAX_BATCH_SIZE`
###### 4. MyBatis 在微服务架构中如何使用？
**依赖配置**
```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.1.4</version>
</dependency>
```
在Spring Cloud项目中添加MyBatis依赖
**数据源配置**
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/your_database
    username: your_username
    password: your_password
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
```
配置连接池参数，支持高可用数据源
**MyBatis配置类**
```java
@Configuration
@MapperScan("com.example.demo.mapper")
public class MyBatisConfig {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);
        sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver()
                .getResources("classpath*:mapper/**/*.xml"));
        return sessionFactory.getObject();
    }
}
```
通过Java配置类替代XML配置
**微服务数据隔离**
- 每个微服务独立数据库，通过MyBatis将数据库操作封装为服务
- 结合Spring Cloud组件实现负载均衡和熔断处理
###### 5. MyBatis 如何与分库分表中间件（如 Sharding-JDBC）集成？
**依赖引入**
```xml
<dependency>
    <groupId>org.apache.shardingsphere</groupId>
    <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
    <version>${sharding-sphere.version}</version>
</dependency>
```
**分片规则配置**
```yaml
spring:
  shardingsphere:
    datasource:
      names: ds0,ds1
      ds0: # 数据源0配置
      ds1: # 数据源1配置
    sharding:
      tables:
        user:
          actualDataNodes: ds${0..1}.user_${0..15}
          tableStrategy:
            inline:
              shardingColumn: user_id
              algorithmExpression: user_${user_id % 16}
```
**MyBatis集成要点**
- **SQL兼容性**：避免使用数据库特异性语法，保证SQL在分片后能正确执行
- **分布式主键**：使用ShardingSphere的分布式主键生成器替代数据库自增ID
- **事务管理**：配置柔性事务或分布式事务保证数据一致性
**源码层面的适配**
- Sharding-JDBC通过实现DataSource接口，对MyBatis透明地提供分片能力
- 在`SqlSessionFactory`创建时注入ShardingSphere数据源，MyBatis无感知使用分片功能
###### 6. MyBatis 的安全性注意事项有哪些？
**SQL注入防护**
```xml
<!-- 安全：使用#{}预编译 -->
<select id="findUser" parameterType="String" resultType="User">
    SELECT * FROM users WHERE name = #{name}
</select>

<!-- 危险：使用${}字符串拼接 -->
<select id="findUser" parameterType="String" resultType="User">
    SELECT * FROM users WHERE name = '${name}'
</select>
```
始终使用`#{}`预编译参数，避免使用`${}`字符串拼接
**敏感数据保护**
- **数据加密**：自定义TypeHandler对敏感字段进行加解密处理
- **脱敏处理**：在ResultHandler中对查询结果进行脱敏
- **日志过滤**：配置日志插件过滤SQL中的敏感参数
**权限控制**
- **最小权限原则**：数据库用户只授予必要权限，避免过度授权
- **操作审计**：通过MyBatis插件记录重要操作日志
- **动态数据权限**：结合拦截器实现行级数据权限控制
**事务安全**
```java
@Service
public class UserService {
    @Transactional(rollbackFor = Exception.class)
    public void updateUser(User user) {
        // 业务操作
    }
}
```
使用Spring的`@Transactional`注解确保操作原子性
**配置安全**
- 禁止将数据库连接信息硬编码在代码中
- 使用配置中心管理敏感配置，如Spring Cloud Config
- 定期更换数据库密码，使用SSL加密连接