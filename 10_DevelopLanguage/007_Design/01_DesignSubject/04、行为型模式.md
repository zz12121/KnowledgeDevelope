###### 1. 什么是模板方法模式？
模板方法模式是一种**行为型设计模式**，它定义了一个操作中的算法骨架，而将一些步骤的具体实现延迟到子类中。通过这种方式，模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法的某些特定步骤。
**核心思想**：封装不变部分，扩展可变部分。将算法中不变的主体行为（如流程、顺序）封装在父类中，将可能变化的具体步骤行为留给子类去实现。
**模式结构**：
- **抽象类（Abstract Class）**：定义算法骨架，包含一个**模板方法**（通常用`final`修饰，防止子类重写算法结构）和若干**基本方法**。基本方法又分为：
    - **抽象方法**：必须由子类实现。
    - **具体方法**：父类已提供默认实现，子类可选择是否重写。
    - **钩子方法（Hook Method）**：父类提供空实现或默认逻辑的方法，子类可选择性重写，以影响模板方法的行为。
- **具体子类（Concrete Class）**：实现抽象类中定义的抽象方法和钩子方法，完成算法中与自身相关的具体步骤。
**源码角度示例**：在Spring框架中，`AbstractApplicationContext`的`refresh()`方法就是一个经典的模板方法。它定义了Spring容器启动的完整流程（如`prepareRefresh()`, `obtainFreshBeanFactory()`, `postProcessBeanFactory()`, `onRefresh()`, `finishRefresh()`等），其中`postProcessBeanFactory()`和`onRefresh()`就是钩子方法，留给像`AnnotationConfigApplicationContext`这样的具体子类去实现特定容器的行为。
```java
// 抽象类定义算法骨架
public abstract class Benchmark {
    // 模板方法 (final)
    public final void runBenchmark() {
        start();
        for (int i = 0; i < 10; i++) {
            run();
        }
        stop();
    }
    // 基本方法 (抽象)
    public abstract void start();
    public abstract void run();
    public abstract void stop();
}[1](@ref)
```
###### 2. 模板方法模式的使用场景？
模板方法模式适用于以下典型场景：

|场景|说明|示例|
|---|---|---|
|**算法流程固定，细节可变**​|当多个类具有相同或相似的算法逻辑（一系列步骤），但其中某些步骤的实现细节不同时。|不同类型的文件解析（JSON、XML），流程都是打开文件、读取内容、解析数据、关闭文件，但解析数据这一步的实现不同。|
|**框架设计**​|框架需要定义核心流程的骨架，但将具体实现留给用户或扩展模块。|Spring的`JdbcTemplate`定义了数据访问的流程（获取连接、创建语句、执行、处理结果、释放资源），用户只需实现`RowMapper`等回调接口。|
|**重构以消除重复代码**​|当多个子类中存在重复的代码时，可以将公共代码提取到父类的模板方法中。|多个审核流程（如贷款审批、采购审批）都有提交、审核、完成的步骤，可以将流程抽象到父类。|
|**控制子类扩展**​|当需要确保某个算法的整体结构不被改变，只允许子类扩展特定部分时。|游戏开发中，角色行为模板（发现目标、移动、攻击）是固定的，但不同职业（战士、法师）的具体行为不同。|
###### 3. 模板方法模式和策略模式的区别？
两者都用于处理算法或行为的变化，但思想和适用场景有本质区别。

|维度|**模板方法模式**​|**策略模式**​|
|---|---|---|
|**核心机制**​|**继承**（Inheritance）|**组合**（Composition）|
|**关注点**​|**定义算法骨架，延迟步骤实现**。强调算法步骤的固定和部分步骤的可变。|**定义算法家族，使它们可以互相替换**。强调整个算法的灵活选择和替换。|
|**灵活性**​|在**编译时**通过继承关系确定行为，结构相对静态。|在**运行时**可以动态切换策略，灵活性更高。|
|**代码复用**​|通过父类复用算法骨架代码。|主要通过上下文（Context）类复用策略接口的调用逻辑。|
|**类关系**​|抽象类与子类是**is-a**关系（子类是父类的一种特定实现）。|上下文与策略是**has-a**关系（上下文拥有一个策略）。|
**简单比喻**：
- **模板方法模式**：像一份**烹饪食谱**，规定了做菜的固定步骤（洗、切、炒、装盘），但具体如何切、如何炒可以由厨师发挥。
- **策略模式**：像选择**出行工具**去往目的地，你可以根据情况随时选择开车、坐地铁或骑车，整个出行方式（算法）是可替换的。
###### 4. 说说策略模式在开发中的场景？
策略模式在以下场景中非常实用：
1. **支付系统**：这是最经典的例子。一个订单支付功能，需要支持支付宝、微信支付、银联等多种支付方式。每种支付方式可以封装成一个策略类，在支付时根据用户选择动态切换。
2. **促销与折扣**：电商平台的优惠计算（如满减、折扣、优惠券、会员价）。每种优惠规则是一个策略，下单时根据活动选择相应的策略进行计算。
3. **数据验证规则**：对不同来源的数据（如用户注册、API接口、文件导入）有不同的验证规则集。可以将每套规则集定义为策略，根据数据来源动态应用。
4. **排序算法**：需要对一组数据排序，但排序算法（快速排序、归并排序、堆排序）可能根据数据量和特点动态选择。每种算法可以是一个策略。
5. **压缩与归档工具**：工具需要支持多种压缩格式（ZIP, RAR, TAR.GZ）。每种格式的压缩和解压逻辑可以封装为独立策略。
###### 5. 策略模式如何消除if-else？
策略模式是消除复杂`if-else`或`switch`语句的利器。其核心在于**将分支判断转化为对象映射**。
**传统if-else写法的问题**：
```java
public class PaymentService {
    public void pay(String type, BigDecimal amount) {
        if ("alipay".equals(type)) {
            // 复杂的支付宝支付逻辑
        } else if ("wechat".equals(type)) {
            // 复杂的微信支付逻辑
        } else if ("union".equals(type)) {
            // 复杂的银联支付逻辑
        } else {
            throw new IllegalArgumentException("Unsupported payment type");
        }
    }
}
```
**问题**：违背开闭原则，新增支付方式需要修改原有代码，分支逻辑臃肿难维护。
**策略模式重构方案**：
1. **定义策略接口**：统一所有策略的行为。
    ```java
    public interface PaymentStrategy {
        void pay(BigDecimal amount);
    }
    ```
2. **实现具体策略**：将每个分支逻辑封装成独立的类。
    ```java
    @Component("alipayStrategy") // 使用Spring管理
    public class AlipayStrategy implements PaymentStrategy {
        @Override
        public void pay(BigDecimal amount) {
            // 支付宝支付逻辑
        }
    }
    ```
3. **创建策略工厂（关键步骤）**：利用Spring的依赖注入，将所有策略实现自动装配到一个Map中，键为策略类型。
    ```java
    @Service
    public class PaymentStrategyFactory {
        // Spring会将所有PaymentStrategy实现类注入此Map，bean name作为key
        private final Map<String, PaymentStrategy> strategyMap;
    
        @Autowired
        public PaymentStrategyFactory(Map<String, PaymentStrategy> strategyMap) {
            this.strategyMap = strategyMap;
        }
    
        public PaymentStrategy getStrategy(String type) {
            PaymentStrategy strategy = strategyMap.get(type + "Strategy"); // 如传入"alipay"，获取bean "alipayStrategy"
            if (strategy == null) {
                throw new IllegalArgumentException("Unsupported payment type: " + type);
            }
            return strategy;
        }
    }
    ```
1. **在业务层使用**：通过工厂获取策略，消除if-else。
    ```java
    @Service
    public class OrderService {
        @Autowired
        private PaymentStrategyFactory strategyFactory;
    
        public void processOrder(Order order) {
            // ... 订单处理逻辑
            PaymentStrategy strategy = strategyFactory.getStrategy(order.getPaymentType());
            strategy.pay(order.getAmount()); // 简洁明了
        }
    }
    ```
**优势**：新增支付方式时，只需实现`PaymentStrategy`接口并注册为Spring Bean，**无需修改**`PaymentService`或`PaymentStrategyFactory`的代码，完全符合开闭原则。
###### 6. 策略模式和工厂模式可以结合使用吗？
**可以，而且这是非常经典和强大的组合**。两者结合可以发挥各自优势，实现更优雅的设计。
- **工厂模式**：负责**创建对象**，隐藏对象创建的复杂逻辑。
- **策略模式**：负责**封装行为**，使算法可以独立于客户端而变化。
**结合方式**：通常使用**工厂模式来创建和管理策略对象**。
**结合后的工作流程**：
1. 客户端向**策略工厂**请求一个策略。
2. **策略工厂**根据客户端传入的类型参数或配置，**创建并返回**对应的具体策略对象。
3. 客户端拿到策略对象后，调用其方法执行具体算法。
**源码示例（结合Spring）**：上面的第5点中的`PaymentStrategyFactory`就是一个工厂模式（具体是简单工厂）与策略模式结合的完美例子。工厂负责从Map（可视为一个对象池）中获取对应的策略对象，客户端无需关心策略的创建和查找逻辑。
这种结合使得系统**既具备了策略模式的算法灵活性，又具备了工厂模式的对象管理能力**，架构清晰，易于扩展和维护。
###### 7. 知道观察者模式吗？
观察者模式是一种**行为型设计模式**，它定义了对象间的一种**一对多的依赖关系**。当一个对象（称为**主题**或**被观察者**）的状态发生改变时，所有依赖于它的对象（称为**观察者**）都会自动得到通知并被更新。
**核心角色**：
- **Subject（主题）**：维护一个观察者列表，提供添加、删除和通知观察者的方法。
- **ConcreteSubject（具体主题）**：实现Subject接口。当自身状态改变时，向所有注册的观察者发出通知。
- **Observer（观察者）**：为所有具体观察者定义一个更新接口，以便在收到主题通知时进行自我更新。
- **ConcreteObserver（具体观察者）**：实现Observer接口，保存一个对具体主题的引用，并实现自己的更新逻辑。
**Java内置支持**：Java标准库提供了`java.util.Observable`类（主题）和`java.util.Observer`接口，但由于其实现较为简单，且`Observable`是一个类，限制了使用（Java类单继承），在实际开发中更多是自定义实现。
###### 8. 说说观察者模式的优缺点是什么？
**优点**：
1. **解耦**：主题和观察者之间是松耦合的。主题不需要知道观察者的具体类，只需要知道它们实现了Observer接口。
2. **开闭原则支持**：可以轻松地增加新的观察者，而无需修改主题的代码。
3. **建立触发机制**：主题的状态变化可以自动触发一系列连锁反应，非常适合实现事件处理系统。
**缺点**：
4. **通知顺序的不确定性**：如果观察者之间有依赖关系，通知的顺序可能会带来问题。Java的`Observable`并没有保证通知的顺序。
5. **内存泄漏风险**：如果观察者被注册后没有正确注销，而观察者对象又具有长生命周期，可能会导致主题无法被垃圾回收。
6. **性能开销**：如果观察者数量非常多，或者观察者的更新操作非常耗时，一次通知可能会引起性能问题。特别是如果通知是顺序同步执行的，会阻塞主题线程。
###### 9. 观察者模式和发布订阅模式的区别？
很多人将两者混为一谈，但它们有细微,重要的区别。**观察者模式是同步的、直接的，而发布订阅模式是异步的、通过中介的**。

|特征|**观察者模式**​|**发布订阅模式**​|
|---|---|---|
|**通信方式**​|**直接调用**：主题直接持有观察者的引用并调用其方法。|**通过消息代理（Broker）**：发布者和订阅者彼此不知道对方的存在。|
|**耦合度**​|松耦合，但主题和观察者仍有意识上的关联。|**完全解耦**，发布者和订阅者通过频道（Channel/Topic）关联。|
|**同步性**​|通常是**同步**的。通知操作会在主题的状态改变方法中依次完成。|通常是**异步**的。发布者将消息放入消息队列即可返回，由中间件负责传递。|
|**复杂度**​|相对简单，适合一对多关系不复杂的情况。|更灵活、强大，适合复杂的、跨系统的消息传递场景。|
**简单比喻**：
- **观察者模式**：像**报社送报**。你（观察者）向报社（主题）订阅了报纸。报社有新的报纸，会派送员直接送到你家。
- **发布订阅模式**：像**邮件订阅/消息队列**。你（订阅者）在邮件平台（消息代理）订阅了某个频道（Topic）。发布者发布消息到平台，平台负责将消息推送给所有订阅了该频道的邮箱。发布者和订阅者互不认识。
###### 10. Spring中哪里用到了观察者模式？
Spring框架中观察者模式的应用是**事件驱动模型**，这是一个非常清晰和强大的实现。
**核心组件**：
1. **`ApplicationEvent`**：所有应用事件的抽象基类，继承自`java.util.EventObject`。自定义事件需要继承此类。
2. **`ApplicationListener`**：应用监听器接口，继承自`java.util.EventListener`。泛型接口，指定它监听的事件类型。自定义监听器需实现此接口。
3. **`ApplicationEventPublisher`**：事件发布接口。`ApplicationContext`本身就实现了此接口，因此可以直接用来发布事件。
4. **`ApplicationEventMulticaster`**：事件广播器，负责管理监听器并广播事件。Spring有默认实现。
**工作流程**：
5. **定义事件**：创建一个类继承`ApplicationEvent`。
    ```java
    public class OrderCreatedEvent extends ApplicationEvent {
        private Order order;
        public OrderCreatedEvent(Object source, Order order) {
            super(source);
            this.order = order;
        }
        // getter...
    }
    ```
6. **定义监听器**：实现`ApplicationListener`接口或使用`@EventListener`注解。
    ```java
    @Component
    public class EmailListener implements ApplicationListener<OrderCreatedEvent> {
        @Override
        public void onApplicationEvent(OrderCreatedEvent event) {
            // 发送邮件通知
        }
    }
    
    // 或使用注解方式（更简洁）
    @Component
    public class SmsListener {
        @EventListener // 通过方法参数类型推断监听的事件类型
        public void handleOrderCreated(OrderCreatedEvent event) {
            // 发送短信通知
        }
    }
    ```
    
1. **发布事件**：在业务代码中，通过`ApplicationEventPublisher`发布事件。
    ```java
    @Service
    public class OrderService {
        @Autowired
        private ApplicationEventPublisher publisher;
    
        public void createOrder(Order order) {
            // ... 创建订单的持久化操作
            // 发布事件
            publisher.publishEvent(new OrderCreatedEvent(this, order));
        }
    }
    ```
**源码关联**：在Spring容器启动的模板方法`refresh()`中，有一个步骤是`initApplicationEventMulticaster()`，用于初始化事件广播器。还有一个步骤是`registerListeners()`，用于将容器中的监听器Bean注册到广播器中。这体现了模板方法模式和观察者模式在Spring中的协同工作。
###### 11. 知道责任链模式吗？
责任链模式是一种行为设计模式，**允许你将请求沿着处理者链进行发送**。收到请求后，每个处理者都可以对请求进行处理，或者将其传递给链上的下一个处理者。这种模式将请求的发送者与接收者解耦，让多个对象都有机会处理请求。
**核心思想**：通过构建一条处理链，让请求在链上传递，直到有处理者能够处理它为止。每个处理者都包含对下一个处理者的引用，形成链式结构。
**模式结构**：
- **Handler（抽象处理者）**：定义处理请求的接口，通常包含设置下一个处理者的方法和处理请求的方法。
- **ConcreteHandler（具体处理者）**：实现抽象处理者接口，包含实际处理逻辑。如果能处理请求就处理，否则将请求转发给下一个处理者。
- **Client（客户端）**：创建处理链，并向链的头部提交请求。
**源码级实现原理**：在Java中，责任链通常通过链表结构实现。每个处理者持有下一个处理者的引用，形成链式调用。处理请求时，会递归或迭代地在链上传递，直到某个处理者处理请求或到达链尾。
###### 12. 责任链模式的使用场景有哪些？
责任链模式适用于以下典型场景：
1. **多级审批流程**：如请假审批、采购审批等需要经过多个审批环节的系统。每个审批人作为链上的一个处理者，根据权限逐级审批。
2. **异常处理机制**：Java异常处理就是责任链模式的典型应用。当方法抛出异常时，JVM会沿着调用栈向上查找合适的catch块，每个catch块相当于一个异常处理者。
3. **日志记录系统**：不同的日志级别（DEBUG、INFO、ERROR）可以由不同的日志处理器处理，消息会沿着处理器链传递，每个处理器决定是否记录以及如何记录。
4. **Web请求过滤**：Java Servlet中的FilterChain和Spring MVC中的拦截器机制都使用责任链模式，对HTTP请求进行一系列预处理（如认证、日志、编码转换等）。
5. **中间件管道**：如Netty中的ChannelPipeline，各种Handler组成处理链，对网络事件进行处理和转发。
###### 13. 责任链模式在Spring中的应用？
在Spring框架中，责任链模式有多个经典应用：
**1. Spring MVC拦截器（HandlerInterceptor）**
Spring MVC使用`HandlerExecutionChain`来管理拦截器序列。当一个请求到达DispatcherServlet后，会按顺序执行拦截器的preHandle方法，处理完Controller后再逆序执行postHandle方法。
**源码分析**：
```java
public class HandlerExecutionChain {
    private final Object handler;
    private HandlerInterceptor[] interceptors;
    
    public boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {
        HandlerInterceptor[] interceptors = getInterceptors();
        if (!ObjectUtils.isEmpty(interceptors)) {
            for (int i = 0; i < interceptors.length; i++) {
                HandlerInterceptor interceptor = interceptors[i];
                if (!interceptor.preHandle(request, response, this.handler)) {
                    triggerAfterCompletion(request, response, null);
                    return false;
                }
            }
        }
        return true;
    }
}
```
每个拦截器都可以决定是否中断链条（返回false）或继续传递（返回true）。
**2. Spring Security过滤器链**
Spring Security使用复杂的过滤器链来处理安全请求，如UsernamePasswordAuthenticationFilter、BasicAuthenticationFilter等，每个过滤器负责特定的安全处理。
**3. Spring AOP通知链**
在面向切面编程中，多个通知（Advice）会组成一个拦截器链，按照@Before、@Around、@After等顺序执行，形成典型的责任链模式。
###### 14. 什么是命令模式？
命令模式是一种行为设计模式，**将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，支持请求的排队、记录、撤销/重做等操作**。
**核心思想**：将请求的发起者与执行者解耦，通过引入命令对象来封装请求的详细信息。这样，请求的发起者不需要知道具体的接收者，也不需要知道请求如何被执行。
**模式结构**：
- **Command（命令接口）**：声明执行操作的接口，通常包含execute()、undo()等方法。
- **ConcreteCommand（具体命令）**：实现命令接口，将接收者对象和动作绑定，定义执行逻辑。
- **Invoker（调用者）**：要求命令对象执行请求，持有命令对象。
- **Receiver（接收者）**：知道如何实施与执行一个请求相关的操作，是实际执行业务逻辑的对象。
- **Client（客户端）**：创建具体命令对象并设置其接收者。
###### 15. 命令模式的使用场景？
命令模式适用于以下场景：
1. **需要将操作排队、记录或支持撤销/重做功能**：如文本编辑器的撤销操作、事务回滚等。命令对象可以存储状态，便于实现撤销功能。
2. **需要支持宏命令（命令组合）**：可以将多个命令组合成一个复合命令，一次性执行多个操作。
3. **需要支持回调机制**：在需要将操作请求与执行解耦的场景中，如线程池的任务调度、GUI的事件处理等。
4. **需要实现操作的延迟执行或远程执行**：如RPC调用、消息队列中的任务处理，命令对象可以在不同时间、不同地点被执行。
**Java源码中的应用**：`Runnable`接口和线程池的实现可以看作是命令模式的变体。`Runnable`封装了要执行的任务（命令），而线程池（Invoker）负责执行这些命令。
###### 16. 什么是迭代器模式？
迭代器模式是一种行为设计模式，**提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示**。
**核心思想**：将集合对象的遍历行为抽象为独立的迭代器对象，使得可以在不暴露集合内部结构的情况下，顺序访问集合中的元素。
**模式结构**：
- **Iterator（迭代器接口）**：定义访问和遍历元素的接口，通常有hasNext()、next()等方法。
- **ConcreteIterator（具体迭代器）**：实现迭代器接口，跟踪当前访问位置。
- **Aggregate（聚合接口）**：定义创建相应迭代器对象的接口。
- **ConcreteAggregate（具体聚合）**：实现聚合接口，返回具体迭代器的实例。
###### 17. Java中哪里用到了迭代器模式？
迭代器模式在Java集合框架中有广泛应用：
**1. java.util.Iterator接口**
这是Java迭代器模式的核心接口，定义了基本的迭代方法：
```java
public interface Iterator<E> {
    boolean hasNext();
    E next();
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
}
```
**2. java.util.Collection接口及其实现**
所有Collection的实现类（如ArrayList、HashSet、LinkedList）都提供了iterator()方法返回相应的迭代器：
```java
List<String> list = new ArrayList<>();
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
}
```
**3. 增强for循环的底层实现**
Java的增强for循环（for-each）语法糖底层就是使用迭代器模式：
```java
// 源码写法
for (String item : list) {
    System.out.println(item);
}

// 等效于以下迭代器写法
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String item = iterator.next();
    System.out.println(item);
}
```
**4. 不同集合的特有迭代器**
如ArrayList的Itr内部类、HashMap的KeyIterator、ValueIterator等，都是针对特定集合结构优化的具体迭代器实现。
###### 18. 什么是中介者模式？
中介者模式是一种行为设计模式，**用一个中介对象来封装一系列的对象交互**。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
**核心思想**：将网状的对象引用关系转变为星形结构，通过引入中介者对象来协调多个对象之间的复杂交互，避免对象间的直接依赖。
**模式结构**：
- **Mediator（中介者接口）**：定义各个同事对象交互的接口。
- **ConcreteMediator（具体中介者）**：实现中介者接口，协调各个同事对象的行为。
- **Colleague（同事类）**：每个同事类都知道它的中介者对象，与其他同事对象的通信都通过中介者进行。
###### 19. 中介者模式的优缺点？
**优点**：
1. **降低耦合度**：将对象间的一对多关联转变为一对一关联，各个同事类之间解耦。
2. **集中控制交互**：将对象间的交互逻辑集中在中介者中，使得交互逻辑更容易理解和维护。
3. **简化对象协议**：用一对多的交互代替多对多的交互，将原本混乱的对象引用关系变得清晰。
4. **符合迪米特法则**：各个同事对象只需要与中介者通信，不需要了解其他同事对象。
**缺点**：
5. **中介者可能变得复杂**：如果对象间的交互逻辑复杂，中介者类会变得庞大且难以维护。
6. **中介者可能成为上帝对象**：中介者集中了过多的控制逻辑，可能违反单一职责原则。
**适用场景**：当对象之间存在复杂的网状引用关系，导致系统结构混乱时；当需要创建一个运行于多个类之间的可扩展行为，但又不想生成太多子类时。
###### 20. 什么是备忘录模式？
备忘录模式是一种行为设计模式，**在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后可以将该对象恢复到原先保存的状态**。
**核心思想**：引入备忘录对象来存储原始对象的内部状态，当需要回滚时，再从备忘录对象中恢复原始状态。
**模式结构**：
- **Originator（原发器）**：需要保存状态的对象，可以创建备忘录并恢复状态。
- **Memento（备忘录）**：存储原发器内部状态的对象。
- **Caretaker（负责人）**：负责保存备忘录，但不能对备忘录的内容进行操作或检查。
###### 21. 备忘录模式的应用场景？
备忘录模式适用于以下场景：
1. **撤销/恢复操作**：文本编辑器、图形编辑软件等需要实现撤销功能的场景。备忘录可以保存操作前的状态，支持多级撤销。
2. **游戏存档**：视频游戏中的存档功能，保存游戏角色的状态、位置、装备等信息，以便后续读取。
3. **数据库事务回滚**：数据库管理系统使用类似的机制实现事务回滚，保存事务开始前的数据状态。
4. **快照功能**：虚拟机、容器的快照功能，保存系统在某个时间点的完整状态。
**实现注意事项**：
- **封装性保护**：备忘录对象应该只允许原发器访问其内部状态，防止其他对象修改保存的状态。
- **状态存储效率**：当对象状态很大时，需要考虑存储效率和性能问题。
- **生命周期管理**：需要合理管理备忘录对象的创建和销毁，避免内存泄漏。
###### 22. 什么是状态模式？
状态模式是一种行为型设计模式，**允许对象在内部状态改变时改变它的行为，使得对象看起来似乎修改了它的类**。
**核心思想**：将对象的状态封装成独立的类，并将对象的行为委托给当前状态对象。当对象的状态发生变化时，其行为也随之自动改变，对外表现为类的行为发生了改变。
**模式结构**：
- **Context（环境类）**：定义客户感兴趣的接口，维护一个ConcreteState子类的实例，这个实例定义当前状态。
- **State（抽象状态类）**：定义一个接口以封装与Context的特定状态相关的行为。
- **ConcreteState（具体状态类）**：每一个子类实现一个与Context的一个状态相关的行为，包含该状态下的处理逻辑和状态转移控制。
**源码级实现原理**：在状态模式中，Context类持有当前状态对象的引用，将与状态相关的行为委托给当前状态对象。每个具体状态类都知道在什么条件下应该切换到什么状态，通常通过在状态处理方法中调用Context的setState()方法来实现状态转移。
**Java实现示例**：
```java
// 抽象状态接口
public interface OrderState {
    void pay(Order order);
    void ship(Order order);
    void complete(Order order);
}

// 具体状态类 - 已支付状态
public class PaidState implements OrderState {
    @Override
    public void pay(Order order) {
        System.out.println("订单已支付，无需重复支付");
    }
    
    @Override
    public void ship(Order order) {
        System.out.println("开始发货...");
        order.setState(new ShippedState()); // 状态转移
    }
    
    @Override
    public void complete(Order order) {
        System.out.println("订单尚未发货，不能完成");
    }
}

// 环境类
public class Order {
    private OrderState currentState;
    
    public Order() {
        this.currentState = new PendingPaymentState(); // 初始状态
    }
    
    public void setState(OrderState state) {
        this.currentState = state;
    }
    
    // 将行为委托给当前状态对象
    public void pay() {
        currentState.pay(this);
    }
    
    public void ship() {
        currentState.ship(this);
    }
}
```
**设计优势**：状态模式将大量复杂的条件判断语句（if-else/switch-case）转换为多态调用，符合开闭原则，新增状态只需添加新的状态类而无需修改现有代码。
###### 23. 状态模式和策略模式的区别？
虽然状态模式和策略模式在结构上相似，但它们的**设计意图和应用场景**有本质区别：

|维度|**状态模式**​|**策略模式**​|
|---|---|---|
|**意图和目的**​|管理状态转换，行为随状态改变而**被动**改变|封装可互换的算法，由客户端**主动**选择策略|
|**状态/策略之间的关系**​|状态之间彼此了解，形成状态转移链路|策略之间相互独立，不知道彼此的存在|
|**状态转移控制**​|由状态类自身控制状态转移|由客户端控制策略的切换|
|**模式目标**​|通过状态改变来改变对象行为|通过策略选择来改变算法实现|
|**适用场景**​|对象行为高度依赖于状态，且有复杂的状态转换逻辑|需要在多种算法中选择一种，且算法可互相替换|
**本质区别**：状态模式是**面向状态**的设计，关注状态改变带来的行为变化；策略模式是**面向算法**的设计，关注算法的灵活选择和替换。
**代码层面体现**：
- 在状态模式中，状态类通常需要持有Context的引用以便进行状态转移
- 在策略模式中，策略类通常不持有Context引用，只是单纯执行算法
###### 24. 什么是访问者模式？
访问者模式是一种行为型设计模式，**将数据结构与数据操作分离，允许在不修改数据结构的前提下定义作用于这些元素的新操作**。
**核心思想**：将操作从数据结构中分离出来，把相关的操作封装在一个访问者对象中，使得增加新操作变得容易，而不必修改每个元素类。
**模式结构**：
- **Visitor（抽象访问者）**：为每个具体元素类声明一个visit操作。
- **ConcreteVisitor（具体访问者）**：实现Visitor声明的每个操作。
- **Element（抽象元素）**：定义一个accept方法，接受一个访问者对象。
- **ConcreteElement（具体元素）**：实现accept方法，在方法中调用访问者的visit方法。
- **ObjectStructure（对象结构）**：能枚举它的元素，可以提供一个高层的接口允许访问者访问它的元素。
**工作流程**：
1. 客户端创建具体访问者对象
2. 客户端创建对象结构，并添加需要被访问的元素
3. 客户端调用对象结构的接受访问方法，传入访问者
4. 对象结构遍历所有元素，对每个元素调用其accept方法
5. 每个元素在accept方法中回调访问者的visit方法
**Java实现示例**：
```java
// 抽象元素
public interface DocumentElement {
    void accept(DocumentVisitor visitor);
}

// 具体元素 - 文本段落
public class ParagraphElement implements DocumentElement {
    private String content;
    
    @Override
    public void accept(DocumentVisitor visitor) {
        visitor.visit(this);
    }
    
    public String getContent() { return content; }
}

// 抽象访问者
public interface DocumentVisitor {
    void visit(ParagraphElement paragraph);
    void visit(ImageElement image);
    void visit(TableElement table);
}

// 具体访问者 - HTML导出
public class HtmlExportVisitor implements DocumentVisitor {
    @Override
    public void visit(ParagraphElement paragraph) {
        System.out.println("<p>" + paragraph.getContent() + "</p>");
    }
    
    @Override
    public void visit(ImageElement image) {
        System.out.println("<img src='" + image.getSource() + "'>");
    }
    
    // ... 其他元素的visit实现
}
```
###### 25. 访问者模式的优缺点？
**优点**：
1. **良好的扩展性**：增加新操作很容易，只需要增加新的访问者类，符合开闭原则。
2. **分离关注点**：将相关的行为集中在一个访问者对象中，而不是分散在多个元素类中。
3. **复用性高**：可以通过访问者实现多个对象协同工作完成的复杂功能。
4. **符合单一职责原则**：元素类只需关注自身结构，操作逻辑由访问者处理。
**缺点**：
5. **增加新元素类困难**：每增加一个新的元素类，都需要在抽象访问者角色中增加一个新的访问操作，违背开闭原则。
6. **破坏封装性**：访问者需要调用元素类的内部操作和属性，可能破坏元素的封装性。
7. **对象结构变化不灵活**：要求对象结构（元素集合）相对稳定，如果经常有新的元素类加入，则不适合使用访问者模式。
**适用场景**：
- 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作。
- 对象结构相对稳定，但经常需要在此结构上定义新的操作。
###### 26. 什么是解释器模式？
解释器模式是一种行为型设计模式，**给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子**。
**核心思想**：将语言中的每个语法规则表示为一个类，通过组合这些类来构建解释器，从而可以解释执行语言中的句子。
**模式结构**：
- **AbstractExpression（抽象表达式）**：声明抽象解释操作，是所有终结符和非终结符表达式的共同接口。
- **TerminalExpression（终结符表达式）**：实现与文法中的终结符相关的解释操作。
- **NonterminalExpression（非终结符表达式）**：实现文法中非终结符的解释操作，通常包含其他表达式的引用。
- **Context（上下文）**：包含解释器之外的一些全局信息。
- **Client（客户端）**：构建表示特定语言中句子的抽象语法树，并调用解释操作。
**适用场景**：
- 当语言语法比较简单，且效率不是关键问题时。
- 需要解析简单的语法或表达式，如数学表达式、SQL查询、正则表达式等。
- 可以用于实现简单的查询语言或领域特定语言（DSL）。
###### 27. 解释器模式的使用场景？
解释器模式在以下场景中特别有用：
1. **数学表达式计算**
    ```java
    // 构建表达式：1 + 2 * 3
    Expression expression = new Add(
        new Number(1),
        new Multiply(new Number(2), new Number(3))
    );
    int result = expression.interpret(); // 结果为7
    ```
2. **正则表达式引擎**：将正则表达式解析为抽象语法树，然后执行匹配操作。
3. **SQL解析**：解析简单的SQL查询条件，构建查询过滤器。
4. **业务规则引擎**：处理业务规则的条件判断，如风控规则、促销规则等。
5. **配置文件解析**：解析特定格式的配置文件，将其转换为内部数据结构。
6. **编译器设计**：在编译器的语法分析阶段，用于构建抽象语法树（AST）。
**实际应用中的注意事项**：
- 解释器模式适合处理简单的文法，复杂文法则会导致类层次结构过于庞大。
- 考虑性能问题，对于频繁使用的表达式，可以考虑先编译成中间代码。
- 通常与其他模式结合使用，如组合模式构建抽象语法树，访问者模式进行语法树遍历。