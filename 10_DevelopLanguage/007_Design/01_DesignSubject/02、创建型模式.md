###### 1. 说说什么是单例模式
单例模式是一种创建型设计模式，**确保一个类只有一个实例，并提供一个全局访问点来获取这个实例**。
**核心要点有三个**：
- **实例控制**：类负责创建并维护自己的唯一实例，禁止外部通过new关键字创建
- **自行创建**：在类的内部自行完成实例化过程
- **全局访问**：提供静态的公有方法让整个系统可以访问这个唯一实例
**设计动机**：对于系统中的某些类来说，只有一个实例非常重要。比如一个系统只能有一个窗口管理器、文件系统，或者一个ID生成器。如果出现多个实例，会导致资源浪费、状态不一致或行为异常。
**模式结构**：
- 私有静态成员变量：存储唯一实例
- 私有构造方法：防止外部实例化
- 公有静态工厂方法：提供全局访问点
**应用场景**：数据库连接池、线程池、配置管理类、日志对象等需要全局唯一实例的场景。
###### 2. 单例模式有哪些实现方式？
单例模式有多种实现方式，各有优缺点和适用场景：
**1. 饿汉式（静态常量/静态代码块）**
```java
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```
- **特点**：类加载时即完成实例化，天生线程安全
- **优点**：实现简单，无同步开销，线程安全
- **缺点**：如果实例一直未被使用，会造成内存浪费
**2. 懒汉式（线程不安全版）**
```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // 多线程下不安全
        }
        return instance;
    }
}
```
- **特点**：延迟加载，但多线程环境下可能创建多个实例
**3. 懒汉式（同步方法版）**
```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
- **特点**：线程安全但效率低
**4. 双重检查锁（DCL，推荐）**
```java
public class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
- **特点**：线程安全，延迟加载，且效率较高
- **volatile关键字的必要性**：防止指令重排序，避免返回未完全初始化的对象
###### 3. 懒汉式和饿汉式单例模式的区别？

|特性|饿汉式|懒汉式|
|---|---|---|
|**创建时机**​|类加载时立即创建|第一次调用getInstance()时创建|
|**资源利用**​|差，可能造成资源浪费|好，按需加载|
|**线程安全**​|天生线程安全|基础版非线程安全，需要额外同步措施|
|**性能特点**​|类加载时可能稍慢，但获取实例快|第一次调用时有初始化开销|
|**实现难度**​|简单|线程安全版本较复杂|
**选择建议**：
- 如果实例小且一定会用到，用**饿汉式**更简单可靠
- 如果实例大且可能用不到，或创建耗时，用**懒汉式**（推荐静态内部类或双重检查锁）
###### 4. 如何防止单例模式被反射破坏？
反射可以通过调用`setAccessible(true)`来访问私有构造方法，破坏单例性。以下是防御策略：
**1. 饿汉式/静态内部类的防御方案**
```java
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    
    private Singleton() {
        // 防止通过反射创建新实例
        if (INSTANCE != null) {
            throw new RuntimeException("单例模式禁止反射创建实例！");
        }
    }
    
    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```
原理：在构造方法中检查静态实例是否已初始化，如果是则抛出异常。
**2. 枚举方案（最有效）**
```java
public enum Singleton {
    INSTANCE;
}
```
原理：JVM保证枚举类型的每个值都是单例，反射机制在创建枚举实例时有特殊限制。
**3. 懒汉式的防御挑战**
懒汉式难以完全防止反射攻击，因为反射可能**在正式实例化前调用构造方法**：
```java
public class Singleton {
    private static Singleton instance;
    private static boolean flag = true; // 信号量防御
    
    private Singleton() {
        synchronized (Singleton.class) {
            if (!flag) {
                throw new RuntimeException("单例模式被侵犯！");
            }
            flag = false;
        }
    }
    // 但反射可以修改flag值，防御仍可能被突破[10](@ref)
}
```
**最佳实践**：如果需要绝对防止反射攻击，**优先选择枚举实现单例**。
###### 5. 说说工厂模式
工厂模式是一种创建型模式，**将对象的创建逻辑封装起来，让使用者和具体实现类解耦**。
**核心思想**：定义一个创建对象的接口，但让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。
**三种形式**：
1. **简单工厂模式**：一个工厂类根据参数创建不同产品
2. **工厂方法模式**：每个产品对应一个工厂类
3. **抽象工厂模式**：创建相关或依赖对象家族
**应用场景**：
- 对象创建过程复杂，涉及多个步骤
- 需要根据不同条件创建不同对象
- 希望将对象创建与使用分离
**JDK中的例子**：`DateFormat`、`Calendar`都是工厂类，通过静态方法创建实例。
###### 6. 什么是工厂方法模式
工厂方法模式定义一个用于创建对象的接口，但让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
**核心结构**：
- **Product**：产品接口，定义产品的规范
- **ConcreteProduct**：具体产品，实现产品接口
- **Creator**：创建器，声明工厂方法
- **ConcreteCreator**：具体创建器，实现工厂方法，返回具体产品实例
**代码示例**：
```java
// 产品接口
interface Shape {
    void draw();
}

// 具体产品
class Circle implements Shape {
    public void draw() {
        System.out.println("绘制圆形");
    }
}

class Rectangle implements Shape {
    public void draw() {
        System.out.println("绘制矩形");
    }
}

// 创建器
abstract class ShapeFactory {
    public abstract Shape createShape();
    
    // 可能包含其他业务方法
    public void render() {
        Shape shape = createShape();
        shape.draw();
    }
}

// 具体创建器
class CircleFactory extends ShapeFactory {
    public Shape createShape() {
        return new Circle();
    }
}

class RectangleFactory extends ShapeFactory {
    public Shape createShape() {
        return new Rectangle();
    }
}
```
**优点**：符合开闭原则，新增产品时只需添加新的工厂类。
###### 7. 说说抽象工厂模式
抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
**适用场景**：当需要创建**产品家族**（多个相关的产品）时，确保这些产品是兼容的。
**代码示例**（电子设备家族）：
```java
// 抽象产品
interface Phone {
    void makeCall();
}

interface Laptop {
    void program();
}

// 具体产品 - 苹果系列
class iPhone implements Phone {
    public void makeCall() {
        System.out.println("iPhone打电话");
    }
}

class MacBook implements Laptop {
    public void program() {
        System.out.println("MacBook编程");
    }
}

// 具体产品 - 小米系列  
class MiPhone implements Phone {
    public void makeCall() {
        System.out.println("小米手机打电话");
    }
}

class MiLaptop implements Laptop {
    public void program() {
        System.out.println("小米笔记本编程");
    }
}

// 抽象工厂
interface DeviceFactory {
    Phone createPhone();
    Laptop createLaptop();
}

// 具体工厂
class AppleFactory implements DeviceFactory {
    public Phone createPhone() {
        return new iPhone();
    }
    
    public Laptop createLaptop() {
        return new MacBook();
    }
}

class XiaomiFactory implements DeviceFactory {
    public Phone createPhone() {
        return new MiPhone();
    }
    
    public Laptop createLaptop() {
        return new MiLaptop();
    }
}
```
**优势**：保证创建的产品是兼容的，比如苹果工厂创建的都是苹果生态产品。
###### 8. 工厂方法模式和抽象工厂模式的区别？

|维度|工厂方法模式|抽象工厂模式|
|---|---|---|
|**产品维度**​|创建**一种**产品|创建**产品家族**（多种相关产品）|
|**抽象层次**​|类级别抽象|系统级别抽象|
|**扩展方向**​|垂直扩展（新增产品种类）|水平扩展（新增产品家族）|
|**实现方式**​|通过继承：子类决定创建什么对象|通过组合：工厂对象包含多个创建方法|
|**适用场景**​|产品结构相对简单，主要是单一产品的创建|复杂系统，需要确保相关产品兼容性|
**选择建议**：
- 如果主要是创建单一类型对象，用**工厂方法模式**
- 如果需要创建**相关联的一系列对象**，用**抽象工厂模式**
###### 9. 什么是建造者模式
建造者模式将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
**核心思想**：将对象的构建步骤抽象出来，让不同的实现可以按照特定顺序执行这些步骤，从而构造出不同的产品。
**适用场景**：
- 创建复杂对象，对象由多个部分组成
- 对象的各个部分经常变化，但构建顺序相对稳定
- 需要精确控制对象的创建过程
**模式角色**：
- **Builder**：抽象建造者，定义构建步骤的接口
- **ConcreteBuilder**：具体建造者，实现构建步骤
- **Director**：指挥者，控制构建过程
- **Product**：最终构建的复杂对象
###### 10. 说说建造者模式的使用场景
**1. 复杂对象创建**
比如创建一个`Computer`对象，需要CPU、内存、硬盘等多个组件：
```java
Computer computer = new Computer.Builder()
    .setCPU("Intel i7")
    .setMemory("16GB")
    .setStorage("1TB SSD")
    .build();
```
**2. 构建过程需要特定顺序**
比如建造房屋：打地基→建框架→安装水电→装修，顺序不能乱。
**3. 需要创建多个表示形式**
同一个构建过程可以产生不同的表示，比如快餐店的套餐构建器可以根据选择生成不同的套餐组合。
**4. 避免过多构造器参数**
当构造器参数过多（比如超过4个）时，建造者模式比重叠构造器模式更优雅。
###### 11. 建造者模式和工厂模式的区别？

|维度|建造者模式|工厂模式|
|---|---|---|
|**目的**​|创建**复杂对象**（多部分组成）|创建**单一产品**​|
|**构建过程**​|分步骤构建，可以控制构建顺序|一步到位创建完整对象|
|**产品复杂度**​|创建复杂对象，由多个部分组成|创建相对简单的对象|
|**关注点**​|**如何构建**（构建过程和组织方式）|**创建什么**（实例化哪个具体类）|
|**灵活性**​|通过不同的建造者实现不同的表示|通过不同的工厂创建不同的产品|
**简单比喻**：
- **工厂模式**：点一份标准套餐（直接得到完整产品）
- **建造者模式**：自定义套餐，选择主食、饮料、小吃（控制构建过程）
###### 12. 什么是原型模式？
原型模式用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
**核心思想**：通过复制现有对象来创建新对象，而不是通过new关键字。
**Java实现**：通过实现`Cloneable`接口并重写`clone()`方法：
```java
public class Prototype implements Cloneable {
    private String field;
    
    public Prototype(String field) {
        this.field = field;
    }
    
    @Override
    public Prototype clone() {
        try {
            return (Prototype) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError(); // 不会发生
        }
    }
}
```
**适用场景**：
- 对象创建成本较高（如需要大量计算或资源）
- 要创建的对象与现有对象差别不大
- 避免使用与产品类层次平行的工厂类层次
###### 13. 原型模式中深拷贝和浅拷贝的区别？

|特性|浅拷贝|深拷贝|
|---|---|---|
|**拷贝层次**​|只拷贝基本数据类型，引用类型**拷贝引用**​|基本类型和引用类型都**创建新对象**​|
|**内存表现**​|原对象和副本**共享引用对象**​|原对象和副本**完全独立**​|
|**实现复杂度**​|简单，Object.clone()默认实现|复杂，需要递归拷贝所有引用对象|
|**性能**​|快|慢（特别是对象图复杂时）|
**代码示例**：
```java
// 浅拷贝
public class ShallowCopy implements Cloneable {
    private int[] data;
    
    @Override
    public ShallowCopy clone() {
        return (ShallowCopy) super.clone(); // 数组引用被共享
    }
}

// 深拷贝  
public class DeepCopy implements Cloneable {
    private int[] data;
    
    @Override
    public DeepCopy clone() {
        DeepCopy copy = (DeepCopy) super.clone();
        copy.data = this.data.clone(); // 创建新的数组
        return copy;
    }
}
```
**选择建议**：
- 如果对象只有基本类型字段，或引用对象不可变，用**浅拷贝**
- 如果对象有可变引用字段，且希望副本完全独立，用**深拷贝**
**实现深拷贝的其他方式**：序列化/反序列化、手动递归拷贝等。