###### 1. 在实际项目中如何选择合适的设计模式？
在实际项目中选择设计模式需要基于**问题驱动**而非**模式驱动**的原则。以下是系统的选择策略：
**核心选择原则**：
- **识别变化点**：分析系统中哪些部分可能经常变化，针对变化点应用相应模式。例如，对象创建逻辑多变用工厂模式，算法多变用策略模式。
- **遵循SOLID原则**：单一职责原则指导我们识别职责分离点；开闭原则指导我们选择对扩展开放的模式。
- **评估实现成本**：考虑模式的复杂性和团队熟悉度，简单项目避免使用复杂模式。
**项目规模适配策略**：
- **小型项目**：优先使用单例模式管理全局资源，工厂模式封装对象创建。
- **中型项目**：引入观察者模式处理事件驱动逻辑，策略模式消除复杂条件判断。
- **大型复杂系统**：采用抽象工厂管理产品族，组合模式处理树形结构，桥接模式分离抽象与实现。
**实际选择流程**：
1. **分析需求本质**：明确是需要创建对象、组织结构还是定义交互行为
2. **判断稳定性**：稳定部分直接实现，多变部分用模式封装
3. **评估扩展性**：预计频繁扩展的场景选择策略模式、装饰器模式等灵活方案
**避免误区**：不要为了使用模式而使用，简单if-else能解决的问题不需要策略模式，直接new能创建的对象不需要工厂模式。
###### 2. 设计模式在Spring框架中的应用有哪些？
Spring框架是设计模式应用的典范，几乎包含了所有经典模式的实现：
**1. 单例模式（Singleton）**
- **应用场景**：Bean的默认作用域就是单例
- **源码实现**：`DefaultSingletonBeanRegistry`通过ConcurrentHashMap缓存单例Bean
```java
// Spring单例注册表核心实现
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);

protected void addSingleton(String beanName, Object singletonObject) {
    synchronized (this.singletonObjects) {
        this.singletonObjects.put(beanName, singletonObject);
    }
}
```
**2. 工厂模式（Factory）**
- **BeanFactory**：最基本的工厂模式，根据名称或类型获取Bean实例
- **FactoryBean**：特殊工厂，用于创建复杂对象，如SqlSessionFactory
**3. 模板方法模式（Template Method）**
- **应用场景**：JdbcTemplate、JmsTemplate等
- **设计思想**：固定流程骨架，变化部分通过回调接口实现
```java
// JdbcTemplate的模板方法模式应用
public class JdbcTemplate {
    public void execute(final String sql) {
        execute(new ExecuteStatementCallback(sql));
    }
    
    // 固定流程骨架
    protected <T> T execute(StatementCallback<T> action) {
        // 获取连接、创建语句、执行SQL、异常处理、资源清理
    }
}
```
**4. 代理模式（Proxy）**
- **AOP基础**：JDK动态代理和CGLIB字节码生成
- **源码体现**：`JdkDynamicAopProxy`实现InvocationHandler接口
**5. 适配器模式（Adapter）**
- **Spring MVC应用**：HandlerAdapter将不同类型的Handler适配成统一处理接口
```java
protected HandlerAdapter getHandlerAdapter(Object handler) {
    for (HandlerAdapter adapter : this.handlerAdapters) {
        if (adapter.supports(handler)) {
            return adapter;
        }
    }
}
```
**6. 观察者模式（Observer）**
- **应用事件机制**：ApplicationEvent和ApplicationListener
**其他重要模式**：责任链模式（Interceptor链）、策略模式（实例化Bean策略）、装饰器模式（Bean包装）等。
###### 3. MyBatis中用到了哪些设计模式？
MyBatis在架构设计中也大量使用了设计模式：
**1. 建造者模式（Builder）**
- **应用场景**：SqlSessionFactoryBuilder、XMLConfigBuilder等
- **设计目的**：通过多步构建复杂对象Configuration
**2. 工厂模式（Factory）**
- **SqlSessionFactory**：创建SqlSession实例
- **ObjectFactory**：创建结果对象
**3. 代理模式（Proxy）**
- **Mapper接口代理**：MapperProxy通过动态代理实现接口方法到SQL的映射
```java
public class MapperProxy<T> implements InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args) {
        // 将方法调用转换为SQL执行
        MapperMethod mapperMethod = cachedMapperMethod(method);
        return mapperMethod.execute(sqlSession, args);
    }
}
```
**4. 组合模式（Composite）**
- **动态SQL处理**：SqlNode接口形成组合结构
- **实现类**：IfSqlNode、TrimSqlNode、WhereSqlNode等共同构建SQL
**5. 模板方法模式（Template Method）**
- **Executor体系**：BaseExecutor定义执行骨架，子类实现具体数据库操作
**6. 装饰器模式（Decorator）**
- **缓存装饰器**：Cache包中的decorators子包
- **功能增强**：如日志缓存、同步缓存、序列化缓存等装饰器
###### 4. JDK源码中常见的设计模式有哪些？
JDK自身就是设计模式的优秀实践库：
**创建型模式**：
- **单例模式**：Runtime.getRuntime()返回全局唯一实例
- **工厂方法**：Calendar.getInstance()根据Locale创建具体日历对象
- **抽象工厂**：DocumentBuilderFactory创建整个XML解析器产品族
**结构型模式**：
- **装饰器模式**：Java I/O流体系是经典应用
```java
// 装饰器模式在IO中的应用
InputStream is = new BufferedInputStream(
                   new FileInputStream("file.txt"));
```
- **适配器模式**：Arrays.asList()将数组适配为List接口
**行为型模式**：
- **观察者模式**：Observer接口和Observable类（已过时，但思想仍在）
- **责任链模式**：Servlet Filter机制是典型实现
- **迭代器模式**：Collection框架的Iterator接口
- **策略模式**：Comparator接口定义比较算法策略
**并发相关模式**：
- **生产者-消费者**：BlockingQueue实现
- **线程局部存储**：ThreadLocal实现每个线程单例
###### 5. 过度使用设计模式会带来什么问题？
过度使用设计模式会产生严重的**过度设计**问题：
**主要负面影响**：
1. **代码复杂度增加**：简单业务被复杂分层包装，可读性下降
2. **维护成本上升**：后续开发人员需要理解多层抽象，学习曲线陡峭
3. **性能开销**：多层代理、频繁对象创建会增加内存和CPU消耗
4. **开发效率降低**：简单需求需要创建大量类文件，违反YAGNI原则
**过度设计的具体表现**：
- **抽象过度**：为可能永远不会变化的需求提前抽象
- **模式堆砌**：在不必要的地方强行使用模式
- **忽略简单方案**：能用if-else解决的问题硬要用策略模式
**平衡原则**：
- **循序渐进**：从简单实现开始，需求变化时再重构引入模式
- **实用主义**：评估模式引入的性价比，确保收益大于成本
- **团队共识**：选择团队熟悉且能维护的模式方案
###### 6. 如何平衡设计模式和代码简洁性？
平衡设计模式与代码简洁性需要遵循以下实践原则：
**1. 遵循"三次法则"**
- **第一次**：直接实现功能，保持简单
- **第二次**：遇到相似需求，复制修改但保持独立
- **第三次**：识别出模式，进行抽象重构
**2. 渐进式重构策略**
```java
// 初始简单实现
public class PaymentService {
    public void pay(String type, double amount) {
        if ("alipay".equals(type)) {
            // 支付宝支付逻辑
        } else if ("wechat".equals(type)) {
            // 微信支付逻辑
        }
        // 当新增支付方式时，考虑引入策略模式
    }
}
```
**3. 衡量标准**
- **可读性**：代码是否容易被新手理解
- **可维护性**：修改需求是否容易且影响范围可控
- **可测试性**：是否便于单元测试和模拟
**4. 实用主义指导**
- **简单设计优先**：能用继承解决的问题不要用组合，能用接口解决的问题不要用模式
- **适时重构**：在出现明确痛点（如添加新功能需要修改多处）时再引入模式
- **代码审查**：通过团队评审判断模式使用是否合理
###### 7. 设计模式和架构模式的区别？
设计模式与架构模式属于不同抽象层次的概念：
**范畴与粒度对比**：

|维度|设计模式|架构模式|
|---|---|---|
|**抽象层次**​|微观代码层面|宏观系统层面|
|**关注点**​|特定问题的代码解决方案|整体系统结构和组件关系|
|**粒度**​|类/对象级别|模块/子系统级别|
|**影响范围**​|局部代码结构|整个应用架构|
**具体区别**：
- **设计模式**：如工厂模式解决对象创建，观察者模式解决对象通知
- **架构模式**：如MVC分离表现层与业务层，微服务定义服务边界
**关系**：架构模式为设计模式提供上下文环境，如MVC架构中View可能使用观察者模式监听Model变化。
###### 8. 微服务架构中常用的设计模式有哪些？
微服务架构有其特定的模式集合：
**1. 服务治理模式**
- **服务注册与发现**：Eureka、Consul等实现的注册中心模式
- **API网关**：统一入口处理认证、路由、限流等横切关注点
**2. 容错模式**
- **断路器模式**：Hystrix、Resilience4j实现的故障隔离
- **重试模式**：弹性重试失败请求
- **降级模式**：服务不可用时提供默认响应
**3. 数据管理模式**
- **每个服务独立数据库**：数据所有权分离
- **事件溯源**：通过事件序列重建状态
- **Saga模式**：管理分布式事务
**4. 通信模式**
- **同步通信**：REST、gRPC直接调用
- **异步消息**：基于消息代理的发布-订阅
**5. 配置模式**
- **外部配置**：配置中心统一管理
- **特性切换**：动态启用/禁用功能
###### 9. 说说你在项目中实际应用过的设计模式
在实际项目中，设计模式的应用都是基于具体业务需求：
**电商平台订单系统的模式应用**：
1. **策略模式+工厂模式**：多种优惠计算策略
```java
// 优惠策略接口
public interface DiscountStrategy {
    BigDecimal calculate(BigDecimal amount, Order order);
}

// 策略工厂管理所有优惠策略
@Component
public class DiscountStrategyFactory {
    @Autowired
    private Map<String, DiscountStrategy> strategies;
    
    public DiscountStrategy getStrategy(String type) {
        return strategies.get(type + "DiscountStrategy");
    }
}
```
1. **观察者模式**：订单状态变更通知
    - 订单支付成功后通知库存系统扣减库存
    - 通知物流系统准备发货
    - 通知用户系统发送短信/邮件
2. **模板方法模式**：支付流程统一处理
```java
public abstract class AbstractPaymentProcessor {
    // 模板方法定义支付流程
    public final PaymentResult process(PaymentRequest request) {
        validate(request);
        preProcess(request);
        PaymentResult result = doPay(request);
        postProcess(result);
        return result;
    }
    
    protected abstract PaymentResult doPay(PaymentRequest request);
}
```
**配置管理中的单例模式**：
```java
public class ConfigManager {
    private static volatile ConfigManager instance;
    private final Properties config;
    
    private ConfigManager() {
        // 加载配置文件的复杂逻辑
    }
    
    public static ConfigManager getInstance() {
        if (instance == null) {
            synchronized (ConfigManager.class) {
                if (instance == null) {
                    instance = new ConfigManager();
                }
            }
        }
        return instance;
    }
}
```
###### 10. 如何重构代码以应用设计模式？
重构引入设计模式需要系统性的方法和谨慎的态度：
**重构识别指标**：
- **过长方法**：多个条件判断提示策略模式
- **大类职责过多**：提示需要拆分或使用状态模式
- **频繁修改的类**：违反开闭原则，需要装饰器或策略模式
**系统化重构流程**：
1. **建立测试保护网**：确保重构安全性
2. **小步渐进修改**：每次只完成一个明确目标
3. **持续集成验证**：每步重构后验证系统行为
**具体重构示例（if-else到策略模式）**：
```java
// 重构前
public class PaymentService {
    public void pay(String type, BigDecimal amount) {
        if ("alipay".equals(type)) {
            // 复杂支付宝逻辑
        } else if ("wechat".equals(type)) {
            // 复杂微信逻辑
        } else if ("union".equals(type)) {
            // 复杂银联逻辑
        }
        // 新增支付方式需要修改此处
    }
}

// 重构后：策略模式+工厂模式
public class PaymentService {
    @Autowired
    private PaymentStrategyFactory factory;
    
    public void pay(String type, BigDecimal amount) {
        PaymentStrategy strategy = factory.getStrategy(type);
        strategy.pay(amount);
    }
}
```
**重构注意事项**：
- **保持接口稳定**：重构不影响现有调用方
- **版本控制**：小步提交，便于回滚
- **文档更新**：更新设计文档和注释