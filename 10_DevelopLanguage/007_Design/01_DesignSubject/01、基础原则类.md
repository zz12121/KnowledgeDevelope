###### 1. 为什么要学习设计模式
- **提供经过验证的解决方案**：设计模式是针对软件设计中**重复出现的问题的通用、可复用的解决方案**。它们凝聚了前人的经验，学习它们相当于站在巨人的肩膀上，避免重新发明轮子，能直接应用优秀的设计方案来提高代码质量和开发效率。
- **提升代码质量和可维护性**：设计模式天然促进了**高内聚、低耦合**​ 的设计思想。例如，通过封装变化点（策略模式、工厂模式），代码变得更灵活，易于扩展和维护。当需求变更时，模式提供了对修改友好的结构，遵循**开闭原则**，降低维护成本。
- **增强团队沟通效率**：设计模式提供了一套**通用的词汇表**。在团队讨论或代码评审时，直接说“这里可以用一个观察者模式来解耦”，就能让其他开发者立刻理解你的设计意图，极大提升了沟通效率。
- **深入理解主流框架源码**：几乎所有主流Java框架（如Spring、MyBatis）都大量使用了设计模式。学习设计模式是读懂这些框架源码的钥匙。例如，Spring中的`ApplicationContext`使用了**工厂模式**来创建Bean，`BeanPostProcessor`机制体现了**模板方法模式**，而事件驱动模型则是**观察者模式**的典型应用。理解这些模式，能让你更深刻地理解框架的设计哲学，从而更好地使用和扩展它们。
- **培养抽象设计思维**：学习设计模式的过程，就是训练如何**识别问题、抽象共性、构建弹性架构**的过程。这种设计思维比记忆模式本身更为重要，它能帮助你在面对复杂业务场景时，做出更优雅、更长远的架构决策。
###### 2. 什么是开闭原则？
开闭原则是面向对象设计的核心原则之一，其定义是：**软件实体（类、模块、函数等）应该对扩展开放，而对修改关闭**。
- **核心思想**：一个软件实体应该允许在不修改其现有代码的前提下，通过扩展的方式（如添加新类或新方法）来改变其行为或增加新功能。
- **“开放”与“关闭”的辩证关系**：“关闭”指的是**基础抽象层（如接口、抽象类）的稳定性**，它们一旦定义好就不应轻易改动。“开放”指的是**具体实现层的可扩展性**，可以通过创建新的实现类来应对变化。
- **实现的关键**：**抽象化是多态的关键**。通常通过定义**接口或抽象类**来构建系统的抽象层，这是实现“关闭”的基础。然后，通过**继承、多态、组合**等技术，利用具体实现类来实现“开放”。
- **源码示例**：`java.util.AbstractList`。这个抽象类实现了`List`接口的大部分方法（“对修改关闭”），但它将核心的`get(int index)`和`size()`方法定义为抽象方法。当我们需要创建一个新的、不可变的List实现时，我们**无需修改`AbstractList`**，只需**扩展**它并实现这两个抽象方法即可。`Collections.unmodifiableList()`方法内部返回的包装类就是这种扩展的体现。
```java
// 违反开闭原则的例子：需要修改已有代码
public class AreaCalculator {
    public double calculateArea(Object shape) {
        if (shape instanceof Circle) {
            // ...计算圆形面积
        } else if (shape instanceof Rectangle) {
            // ...计算矩形面积
        }
        // 新增三角形？必须修改此方法，添加一个else if分支！
        throw new IllegalArgumentException("Unknown shape");
    }
}

// 遵循开闭原则的例子：通过扩展来增加新功能
public interface Shape {
    double area();
}

public class Circle implements Shape { /* 实现area方法 */ }
public class Rectangle implements Shape { /* 实现area方法 */ }

// 现在需要支持三角形，只需新增一个类，无需修改任何已有类
public class Triangle implements Shape {
    @Override
    public double area() {
        // 计算三角形面积
        return 0;
    }
}

// AreaCalculator类依赖于抽象Shape，对扩展开放
public class AreaCalculator {
    public double calculateTotalArea(List<Shape> shapes) {
        return shapes.stream().mapToDouble(Shape::area).sum();
    }
}
```
###### 3. 说说什么是依赖倒转原则？
依赖倒转原则规定：
1. **高层模块不应该依赖低层模块，二者都应该依赖于抽象。**
2. **抽象不应该依赖于细节，细节应该依赖于抽象**。
- **核心思想**：**要面向接口编程，而不是面向实现编程**。它通过引入抽象层，反转了传统的自上而下的依赖关系，从而降低了模块间的耦合度。
- **“倒转”的含义**：在传统的结构化设计中，高层模块会直接调用和依赖低层模块，依赖关系是自上而下的。而DIP则要求高层和低层模块都**依赖于一个抽象的接口**，这个接口通常由高层模块定义。这使得低层模块的实现细节依赖于高层模块定义的抽象契约，实现了依赖关系的“倒转”。
- **实现方式**：主要通过**依赖注入**来实现，常见方式有构造器注入、Setter方法注入和接口注入。框架（如Spring）的IoC容器是管理依赖的绝佳实践。
- **源码示例**：在Spring框架中，一个`UserService`（高层模块）不应该直接`new`一个`UserRepositoryImpl`（低层模块）。而是应该定义一个`UserRepository`接口，让`UserService`依赖于这个接口。`UserRepositoryImpl`作为细节去实现这个接口。依赖关系通过构造器或`@Autowired`注解由容器注入。
```java
// 违反依赖倒转原则：高层模块直接依赖低层模块
public class UserService {
    private UserRepositoryImpl userRepository = new UserRepositoryImpl(); // 直接依赖具体实现
    // ...
}

// 遵循依赖倒转原则：高层和低层都依赖抽象
public interface UserRepository { // 抽象
    User findById(Long id);
}

public class UserRepositoryImpl implements UserRepository { // 细节依赖于抽象
    @Override
    public User findById(Long id) { ... }
}

public class UserService { // 高层模块依赖于抽象
    private final UserRepository userRepository; // 依赖抽象接口

    // 依赖通过构造器注入
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    // ...
}
```
###### 4. 什么是单一职责原则
单一职责原则的定义是：**一个类应该只有一个引起它变化的原因**。换句话说，一个类只负责一项职责。
- **核心思想**：**职责是变化的原因**。如果一个类承担了过多的职责，就意味着这些职责**耦合**在一起。任何一个职责的变化都可能削弱或抑制该类完成其他职责的能力，导致设计变得脆弱。
- **如何识别职责**：问自己一个问题：“这个类有多少个不同的理由会导致它被修改？”如果答案多于一个，那么这个类就可能承担了多个职责。
- **好处**：遵循SRP可以**提高类的内聚性**，降低类的复杂度，使类更容易被理解和维护。同时，当某个职责需要修改时，可以**降低对其他职责的影响**。
- **源码示例**：考虑一个违反SRP的类：
```java
// 违反SRP：这个类承担了数据持久化、格式验证和报告生成三个职责。
public class UserManager {
    public void saveUser(User user) { ... } // 职责1：持久化
    public boolean validateUser(User user) { ... } // 职责2：验证
    public void generateUserReport(User user) { ... } // 职责3：报告生成
    // 任何一个需求的变更（如换数据库、改验证规则、改报告格式）都需要修改这个类。
}
```
重构后，将不同职责分离到不同的类中：
```java
// 遵循SRP：每个类只有一个明确的职责
public class UserRepository { // 职责：数据持久化
    public void save(User user) { ... }
}
public class UserValidator { // 职责：格式验证
    public boolean isValid(User user) { ... }
}
public class UserReportGenerator { // 职责：报告生成
    public void generate(User user) { ... }
}
```
在JDK中，`java.lang.String`是一个非常纯粹的例子，它的职责就是表示和操作字符序列，没有其他无关的职责。
###### 5. 什么是里氏替换原则？
里氏替换原则的核心思想是：**所有引用基类（父类）的地方必须能透明地使用其子类的对象而不产生错误**。
- **核心思想**：它是对继承关系的约束，确保继承是“Is-A”关系（子类是父类的一种）的合理扩展，而不是简单的代码复用。子类可以扩展父类的功能，但**不能改变父类原有的功能**。
- **具体规则**：
    1. **方法签名兼容**：子类的方法重写或实现，其**前置条件（对输入的要求）不能比父类更严格**，**后置条件（对输出的承诺）不能比父类更宽松**。
    2. **不破坏父类行为**：子类不应重写父类中已实现的非抽象方法，除非是为了修复bug。尤其要注意，子类**不应该在重写的方法中抛出父类方法没有声明的异常**。
    3. **保持完整性**：子类可以拥有自己的独特方法，但不能改变父类定义的行为契约。
- **源码示例**：在Java集合框架中，`java.util.List`接口和它的实现类`ArrayList`, `LinkedList`之间的关系就符合LSP。任何期望`List`接口的地方，都可以传入`ArrayList`或`LinkedList`，程序行为在契约（如`add`, `get`, `size`等方法的行为）上是一致的。
    违反LSP的典型例子是让`Square`类继承`Rectangle`类。因为`Rectangle`有`setWidth`和`setHeight`两个独立方法，而`Square`需要同时修改宽高，重写这两个方法会破坏`Rectangle`的行为契约。
    ```java
    // 违反LSP的经典例子
    class Rectangle {
        protected int width, height;
        public void setWidth(int w) { width = w; }
        public void setHeight(int h) { height = h; }
        public int getArea() { return width * height; }
    }
    
    class Square extends Rectangle {
        @Override
        public void setWidth(int w) {
            super.setWidth(w);
            super.setHeight(w); // 破坏了Rectangle的行为，设置宽会同时修改高
        }
        @Override
        public void setHeight(int h) {
            super.setHeight(h);
            super.setWidth(h); // 破坏了Rectangle的行为，设置高会同时修改宽
        }
    }
    // 测试代码
    void testArea(Rectangle r) {
        r.setWidth(5);
        r.setHeight(4);
        assert r.getArea() == 20; // 如果传入Square，断言会失败！
    }
    ```
###### 6. 说说接口隔离原则
接口隔离原则要求：**客户端不应该被迫依赖于它不使用的接口**。一个类对另一个类的依赖应该建立在**最小的接口**上。
- **核心思想**：**将庞大的、臃肿的接口拆分成更小、更具体的接口**，使得客户端只需要知道和依赖它所需的方法即可。目的是避免“接口污染”，减少耦合。
- **与单一职责原则的关系**：ISP和SRP角度不同但目标一致。SRP关注的是类的职责单一，而ISP关注的是**接口的职责单一**。违反SRP的类往往也会导致其实现的接口变得臃肿，从而违反ISP。
- **源码示例**：考虑一个臃肿的接口：
```java
// 违反ISP：这个接口承担了太多职责
public interface Worker {
    void code(); // 程序员工作
    void test(); // 测试员工作
    void design(); // 架构师工作
    void deploy(); // 运维工作
}
// 一个后端程序员类，被迫实现它不需要的方法
public class BackendProgrammer implements Worker {
    @Override public void code() { ... } // 这是它的工作
    @Override public void test() { ... } // 可能被迫空实现或抛出异常
    @Override public void design() { ... } // 可能被迫空实现或抛出异常
    @Override public void deploy() { ... } // 可能被迫空实现或抛出异常
}
```
遵循ISP进行重构：
```java
// 遵循ISP：将大接口拆分为多个特定于角色的接口
public interface Coder { void code(); }
public interface Tester { void test(); }
public interface Designer { void design(); }
public interface Deployer { void deploy(); }

// 后端程序员只需要实现与编码相关的接口
public class BackendProgrammer implements Coder, Tester { // 可能也参与测试
    @Override public void code() { ... }
    @Override public void test() { ... } // 这是合理的
}
```
在JDK中，`java.util`包下的`List`, `Set`, `Map`等集合接口都定义得非常精确，没有冗余方法，是遵循ISP的典范。
###### 7. 什么是迪米特法则（最少知识原则）？
迪米特法则，也叫最少知识原则，其核心思想是：**一个对象应该对其他对象有最少的了解**。通俗地说，只与你的**直接朋友**通信，不和“陌生人”说话。
- **核心思想**：**降低类之间的耦合度**，提高模块的相对独立性。一个类对自己需要耦合或调用的类知道得越少，系统的耦合度就越低，越有利于复用和扩展。
- **“朋友”的定义**：对于一个对象来说，其“朋友”包括：
    - 当前对象本身 (`this`)
    - 以方法参数形式传入的对象
    - 当前对象的成员变量引用的对象
    - 当前对象所创建的对象
    - 当前对象的方法内部所创建或实例化的任何对象
- **实践体现**：主要体现在**封装**上。一个方法应尽量不暴露其内部细节，不返回内部对象（如果需要，应返回副本或不可变视图），也不应深入调用链去操作间接对象（即避免`a.getB().getC().doSomething()`这样的“火车式”调用）。
- **源码示例**：
```java
// 违反迪米特法则
public class Company {
    private Employee employee;

    public void printCEOName() {
        // 当前对象（Company）深入到了employee的homeAddress的street层级，这是“陌生人”
        System.out.println(this.employee.getHomeAddress().getStreet().getCEOName()); // 荒谬的调用链，仅为示例
        // 正确的做法应该是：让Employee提供一个getCEOName()方法，或让Address提供相关方法。
        // Company只与Employee交互，不深入其内部细节。
    }
}

// 遵循迪米特法则
public class Company {
    private Employee employee;

    public void printCEOName() {
        // 只与直接朋友Employee交互，由Employee去处理内部的逻辑
        System.out.println(this.employee.getCEOName());
    }
}
public class Employee {
    private Address homeAddress;
    public String getCEOName() {
        // Employee与Address交互，获取所需信息
        return this.homeAddress.getCEOName();
    }
}
```
###### 8. 说说合成复用原则
合成复用原则指出：**应优先使用对象组合/聚合，而不是继承来达到软件复用的目的**。
- **核心思想**：**黑箱复用优于白箱复用**。继承是白箱复用，因为子类对父类的实现细节是可见的，这破坏了封装性，而且继承关系在编译时就被静态确定，缺乏灵活性。而组合/聚合是黑箱复用，对象之间通过接口或抽象类进行协作，被包含对象的内部细节对外是不可见的。
- **优势**：
    1. **维持封装性**：组合只通过接口交互，不会破坏被组合对象的封装。
    2. **耦合度低**：组合是松散的临时性关系，而继承是紧耦合的静态关系。
    3. **灵活性高**：可以在运行时动态地改变组合的对象，例如通过Set注入或构造器注入。
- **何时使用继承**：只有当两个类之间确实是“Is-A”关系，并且符合**里氏替换原则**时，才考虑使用继承。继承应主要用于表现多态性，而不是为了代码复用。
- **源码示例**：在Java的IO包中，`java.io.FilterInputStream`是使用组合的经典例子。它包含一个`InputStream`的实例，并将所有方法调用委托给它。这样，`BufferedInputStream`, `DataInputStream`等装饰器可以动态地给任何`InputStream`子类添加缓冲或数据读取功能，而不是通过继承来硬编码这种功能组合，极大地增强了灵活性。
    ```java
    // 使用组合（合成复用原则）
    public class FilterInputStream extends InputStream {
        protected volatile InputStream in; // 组合一个InputStream对象
        protected FilterInputStream(InputStream in) {
            this.in = in;
        }
        public int read() throws IOException {
            return in.read(); // 委托给被组合的对象
        }
        // ... 其他方法也委托给 'in'
    }
    
    // 使用继承（不符合合成复用原则，除非确实是"is-a"关系）
    public class MySpecialBufferedFileInputStream extends FileInputStream {
        // 这种设计很僵硬，它只能给FileInputStream添加缓冲功能。
        // 如果想给ByteArrayInputStream也加缓冲，就得再写一个类似的类。
    }
    ```