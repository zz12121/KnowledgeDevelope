###### 1. 说说你对代理模式的理解
代理模式是一种结构型设计模式，**为其他对象提供一种代理以控制对这个对象的访问**。代理对象在客户端和目标对象之间起到中介作用，在不改变目标对象的前提下，提供额外的功能扩展或访问控制。
**核心思想**：通过引入代理层，实现客户端与目标对象的解耦。代理类与目标类实现相同的接口，客户端通过代理对象间接访问目标对象，从而可以在访问前后添加自定义逻辑。
**从JVM层面看**：静态代理在编译时就将接口、实现类、代理类变成实际class文件；动态代理在运行时动态生成类字节码并加载到JVM中。
**源码级实现**：Java动态代理的核心是`java.lang.reflect.Proxy`和`InvocationHandler`接口。`Proxy.newProxyInstance()`方法会动态生成代理类，其核心原理包括：
- 根据接口信息动态生成代理类的字节码
- 通过`sun.misc.Unsafe`定义这个类
- 生成的方法实现会回调`InvocationHandler.invoke()`
**主要应用场景**：
- **远程代理**：为不同地址空间的对象提供本地代表（如RPC调用）
- **虚拟代理**：延迟创建开销大的对象（如图片懒加载）
- **保护代理**：控制访问权限，在代理层进行安全校验
- **智能引用代理**：添加额外操作，如引用计数、日志记录
###### 2. 静态代理和动态代理的区别？

|维度|静态代理|动态代理|
|---|---|---|
|**实现时机**​|编译期确定，手动编写代理类|运行期动态生成代理类|
|**灵活性**​|差，每个目标类需对应一个代理类|高，一个处理器可代理多个类|
|**代码冗余**​|大量重复模板代码|代码复用性高，避免重复|
|**维护性**​|接口变更需修改所有代理类|接口变更影响小|
|**适用场景**​|代理类较少、功能固定的场景|需要代理大量类或横切关注点|
**本质区别**：静态代理是**编码阶段**的硬编码关系，动态代理是**运行时**的灵活生成。在Spring框架中，AOP默认使用动态代理，极大减少了样板代码
###### 3. JDK动态代理和CGLIB代理的区别？

|特性|JDK动态代理|CGLIB代理|
|---|---|---|
|**实现原理**​|基于接口，通过反射实现|基于继承，通过字节码技术生成子类|
|**目标要求**​|必须实现至少一个接口|可代理普通类，无需接口|
|**性能特点**​|调用接口方法时较快|方法调用效率高，但生成类较慢|
|**限制条件**​|只能代理接口方法|无法代理final类和方法|
|**依赖关系**​|JDK原生支持|需要第三方CGLIB库|
**源码级分析**：JDK动态代理使用`ProxyGenerator.generateProxyClass()`生成字节码，其生成的代理类会继承Proxy并实现目标接口。CGLIB则使用ASM框架直接操作字节码，通过`Enhancer`创建目标类的子类，重写非final方法并关联`MethodInterceptor`。
**选择策略**：在Spring中，默认优先使用JDK动态代理，当目标类未实现接口时自动切换到CGLIB。可通过配置强制使用CGLIB以获得更好的性能
###### 4. 装饰器模式是什么
装饰器模式是一种结构型设计模式，**动态地给一个对象添加一些额外的职责**。就增加功能来说，装饰器模式比生成子类更为灵活。
**核心结构**：
- **Component**：抽象组件，定义对象的接口
- **ConcreteComponent**：具体组件，实现基本功能
- **Decorator**：装饰器抽象类，持有组件引用
- **ConcreteDecorator**：具体装饰器，添加具体功能
**设计思想**：装饰器与目标对象实现相同的接口，通过组合而非继承来扩展功能。这种设计符合**开闭原则**，允许在不修改原有代码的情况下扩展功能。
**Java源码应用**：`java.io`包是装饰器模式的经典实现。例如：
```java
// 层层装饰的IO流
InputStream in = new BufferedInputStream(
                   new FileInputStream("test.txt"));
```
其中`FileInputStream`是具体组件，`BufferedInputStream`是具体装饰器，它们都继承自`InputStream`抽象组件。
###### 5. 代理模式和装饰器模式有什么区别？
虽然两者在结构上相似，但**设计意图和关注点**完全不同：

|维度|代理模式|装饰器模式|
|---|---|---|
|**目的**​|控制访问，增强与目标对象无关的功能|增强功能，扩展对象的能力|
|**关系建立**​|编译期或运行期确定，关系较固定|运行时动态组合，关系灵活|
|**关注点**​|强调对对象的访问控制和间接访问|强调功能的动态添加和扩展|
|**初始化**​|代理类可能负责目标对象的生命周期|装饰器由客户端创建并组装|
**关键区别**：代理模式是**让别人帮助你做你并不关心的事情**（如权限检查、日志记录），而装饰器模式是**让自己的能力增强**，使得增强后的自己能够使用更多的方法。
###### 6. 了解过适配器模式么？
适配器模式是一种结构型设计模式，**将一个类的接口转换成客户端期望的另一个接口**，使原本接口不兼容的类可以一起工作。
**核心思想**：通过适配器解决接口不兼容问题，避免大规模修改现有代码。它就像现实生活中的电源适配器，让不同标准的插头能够正常工作。
**主要角色**：
- **Target**：目标接口，客户端期望的接口
- **Adaptee**：被适配者，已存在的需要被适配的类
- **Adapter**：适配器，将Adaptee适配成Target接口
###### 7. 适配器模式有哪些实现方式？
**1. 类适配器（通过继承）**
```java
public class ClassAdapter extends Adaptee implements Target {
    @Override
    public void request() {
        super.specificRequest(); // 适配逻辑
    }
}
```
通过继承被适配类并实现目标接口，由于Java的单继承限制，灵活性较差。
**2. 对象适配器（通过组合，推荐）**
```java
public class ObjectAdapter implements Target {
    private Adaptee adaptee;
    
    public ObjectAdapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }
    
    @Override
    public void request() {
        adaptee.specificRequest(); // 委托给被适配对象
    }
}
```
通过组合方式持有被适配者引用，更灵活且符合合成复用原则。
###### 8. 适配器模式和装饰器模式的区别？

|维度|适配器模式|装饰器模式|
|---|---|---|
|**意图**​|转换接口，解决兼容性问题|增强功能，动态添加职责|
|**关系**​|适配者与目标类通常无关联|装饰器与组件接口相同|
|**创建时机**​|通常在编译期确定关系|可以在运行时动态组合|
|**关注点**​|接口的转换和兼容|功能的扩展和增强|
**关键区别**：适配器模式主要解决**接口不兼容**问题，而装饰器模式关注**功能增强**。适配器像是"翻译官"，装饰器像是"功能增强器"。
###### 9. 说说你对门面模式的理解
门面模式（外观模式）是一种结构型设计模式，**为子系统中的一组接口提供一个一致的界面**，定义了一个高层接口，使子系统更易使用。
**核心价值**：简化复杂系统的访问难度，为客户端提供统一入口，降低系统耦合度。
**设计思想**：
- **简化接口**：将复杂的子系统调用封装成简单接口
- **解耦**：客户端与子系统松耦合，子系统内部变化不影响客户端
- **层次化**：为系统划分访问层次，明确边界
**应用场景**：
- 为复杂模块或子系统提供简单接口
- 构建分层架构，减少系统间依赖
- 客户端需要与多个子系统交互，且逻辑复杂
###### 10. 门面模式和代理模式的区别？

|维度|门面模式|代理模式|
|---|---|---|
|**服务对象**​|为整个子系统提供统一入口|为单个对象提供代理控制|
|**关系层次**​|横向整合，简化多个子系统调用|纵向深入，控制单个对象访问|
|**职责范围**​|简化接口，减少客户端依赖|增强控制，添加额外功能|
|**可见性**​|可能暴露子系统部分功能|完全代表目标对象|
**关键区别**：门面模式是**简化复杂系统的访问**，代理模式是**控制对单个对象的访问**。门面模式关注的是**接口的简化**，代理模式关注的是**访问的控制**。
###### 11. 什么是桥接模式？
桥接模式是一种结构型设计模式，**将抽象部分与它的实现部分分离，使它们都可以独立地变化**。
**核心思想**：通过**组合**替代**继承**，解决多层继承带来的类爆炸问题。它将抽象和实现放在两个不同的类层次中，使它们可以独立扩展。
**主要角色**：
- **Abstraction**：抽象类，维护对实现类的引用
- **RefinedAbstraction**：扩展抽象类
- **Implementor**：实现类接口
- **ConcreteImplementor**：具体实现类
**设计优势**：符合**开闭原则**和**合成复用原则**，抽象和实现可以独立扩展，不会相互影响。
###### 12. 桥接模式的使用场景有哪些？
1. **跨平台UI开发**：抽象部分定义控件行为，实现部分处理平台特定绘制
2. **数据库驱动**：抽象定义SQL操作，不同实现处理各数据库差异
3. **消息发送系统**：抽象定义消息格式，实现处理不同发送方式（邮件、短信等）
4. **图形绘制**：抽象定义形状，实现处理不同绘制API
**Java源码应用**：JDBC是桥接模式的经典实现。`DriverManager`作为抽象层，不同数据库厂商提供具体的`Driver`实现，应用程序通过统一的JDBC接口操作各种数据库。
###### 13. 什么是组合模式？
组合模式是一种结构型设计模式，**将对象组合成树形结构以表示"部分-整体"的层次结构**，使客户端对单个对象和组合对象的使用具有一致性。
**核心思想**：通过统一的方式处理叶子节点和容器节点，使客户端代码简化。它让客户端可以忽略组合对象与单个对象的差异。
**主要角色**：
- **Component**：抽象组件，定义统一接口
- **Leaf**：叶子节点，没有子组件
- **Composite**：容器节点，包含子组件集合
###### 14. 组合模式在开发中的应用场景？
1. **文件系统**：文件和文件夹的统一处理
2. **UI组件库**：容器组件和叶子组件的统一管理
3. **菜单系统**：菜单项和子菜单的统一操作
4. **组织架构**：部门和员工关系的树形管理
**源码示例**：在Java AWT/Swing中，`Container`和`Component`的关系就是组合模式。`Container`可以包含其他`Component`（包括其他`Container`），但客户端调用`add()`、`remove()`等方法时无需区分具体类型。
###### 15. 知道享元模式吗？
享元模式是一种结构型设计模式，**运用共享技术有效地支持大量细粒度对象的复用**。它通过共享相似对象来减少内存使用和提高性能。
**核心思想**：将对象的**内在状态**（不变的、可共享的部分）和**外在状态**（变化的、不可共享的部分）分离，通过共享内在状态来减少对象数量。
**关键角色**：
- **Flyweight**：享元接口，定义操作
- **ConcreteFlyweight**：具体享元，实现内在状态存储
- **FlyweightFactory**：享元工厂，管理享元对象池
- **Client**：客户端，维护外在状态
###### 16. 享元模式和单例模式的区别？

|维度|享元模式|单例模式|
|---|---|---|
|**目的**​|对象复用，减少内存消耗|控制实例数量，确保全局唯一|
|**对象数量**​|多个共享对象，按需创建|只有一个实例|
|**状态管理**​|区分内在状态（共享）和外在状态|通常是无状态或全局状态|
|**应用场景**​|大量相似对象需要复用的场景|需要全局唯一访问点的场景|
**关键区别**：享元模式关注的是**大量相似对象的共享复用**，单例模式关注的是**实例数量的严格控制**
###### 17. 享元模式在Java中的应用？
1. **String常量池**：JVM通过字符串常量池实现字符串共享，相同的字面值指向同一对象
2. **Integer缓存**：`Integer.valueOf()`方法缓存-128到127之间的值
3. **连接池**：数据库连接池、线程池重用连接对象，避免重复创建销毁
4. **Java包装类缓存**：`Boolean`、`Byte`、`Character`等都有缓存机制
**源码级分析**：`Integer.IntegerCache`是享元模式的典型实现：
```java
private static class IntegerCache {
    static final Integer cache[];
    static {
        cache = new Integer[(-(-128)) + 127 + 1];
        for(int i = 0; i < cache.length; i++)
            cache[i] = new Integer(i - 128);
    }
}
```
通过静态代码块预先创建常用范围的Integer对象，`valueOf()`方法直接从缓存返回对象，避免重复创建。