###### 1. 消息队列常用的序列化方式有哪些？各有什么优缺点？

|序列化方式|优点|缺点|适用场景|
|---|---|---|---|
|**JSON**​|可读性好、跨语言支持完善、使用简单|空间效率低（冗余字段名）、序列化/反序列化性能相对较差、类型系统弱（无日期/二进制等原生类型）|业务系统、前后端交互、对可读性要求高的场景|
|**Java原生序列化**​|Java生态内置支持、实现简单（实现`Serializable`接口即可）|仅限Java语言、序列化后体积大、性能低、存在安全风险（通过构造恶意序列化数据可能执行任意代码）|简单的Java进程间通信、不推荐用于分布式系统|
|**Protocol Buffers (Protobuf)**​|高性能（序列化速度比JSON快2-3倍，反序列化快3-4倍）、高压缩率（比JSON小30%-80%）、强类型Schema、优秀的向前向后兼容性|需要预定义`.proto`文件、二进制格式可读性差、调试相对复杂|微服务RPC（gRPC）、对性能和带宽敏感的场景、长期数据存储|
|**Apache Avro**​|序列化后体积非常小（写入数据时不包含字段名等信息）、Schema演进能力强、动态Schema支持|需要Schema Registry等外围组件、序列化/反序列化需始终携带Schema|大数据领域（Hadoop、Kafka）、数据湖存储、Schema频繁演进的场景|
|**MessagePack**​|比JSON更高效紧凑、无需Schema、支持多语言|性能与压缩率通常不如Protobuf和Avro（因需在序列化数据中携带类型信息）|需要比JSON更好性能但不想引入Schema复杂性的场景，如WebSocket通信|
**Java生态中的具体实现示例**：
- **JSON序列化**（Jackson库）：
    ```java
    ObjectMapper mapper = new ObjectMapper();
    byte[] jsonBytes = mapper.writeValueAsBytes(userObject); // 序列化
    User user = mapper.readValue(jsonBytes, User.class);     // 反序列化
    ```
- **Protobuf序列化**：
    ```java
    // 根据.proto文件生成的Java类
    UserProto.User user = UserProto.User.newBuilder()
        .setId(123).setName("John").build();
    byte[] protoBytes = user.toByteArray(); // 序列化
    UserProto.User parsedUser = UserProto.User.parseFrom(protoBytes); // 反序列化
    ```
###### 2. JSON、Protobuf、Avro的区别与选择
这三种序列化方案在设计哲学和实现上有显著差异。

**核心技术差异对比**：

|特性|JSON|Protocol Buffers|Apache Avro|
|---|---|---|---|
|**数据格式**​|文本（UTF-8）|二进制|二进制|
|**Schema依赖**​|无（但可选用JSON Schema验证）|强依赖（需预编译.proto文件）|强依赖（序列化/反序列化均需Schema）|
|**编码方式**​|字段名明文存储|用字段标签（Tag）代替字段名|序列化数据中无字段名，按Schema中字段定义顺序编码|
|**类型系统**​|弱类型（数字不区分整型/浮点，无原生日期类型）|强类型（int32, double, bool等）|强类型（支持复杂联合类型）|
|**模式演进**​|灵活性高，但需手动处理兼容性|兼容性规则明确（字段标签一旦使用不应修改，可选字段等）|出色的Schema演进能力（支持字段重排序等）|
**选择策略**：
- **追求开发效率与可调试性**：选择JSON，尤其适用于业务变动频繁、对性能要求不极致的业务系统。
- **追求极致性能与带宽效率**：选择Protobuf，适用于微服务间高性能RPC通信或带宽敏感的场景。
- **需要灵活Schema演进**：选择Avro，适用于大数据平台（如Kafka）、数据湖架构，或Schema可能频繁变更的场景。
**性能深度分析**（基于JMH基准测试典型结果）：
- **序列化大小**：Avro ≈ Protobuf < MessagePack < JSON（JSON通常是Avro/Protobuf的2-3倍）
- **序列化速度**：Protobuf > Avro > MessagePack > JSON（Protobuf比JSON快约2-3倍）
- **反序列化速度**：Protobuf > Avro > MessagePack > JSON（Protobuf比JSON快约3-4倍）
- **内存分配**：Protobuf（通常对象不可变且可池化） < Avro < JSON
###### 3. 如何设计向后兼容的消息格式？
实现向后兼容的核心是**保证旧版本代码能够成功解析新版本代码产生的数据**。以下是基于Protobuf的最佳实践，其原则可推广至其他序列化方案。
**核心规则**：
1. **永不修改现有字段的标签（编号）或类型**：在Protobuf中，字段的唯一标识是标签（如`int32 id = 1;`中的`1`）。一旦字段被使用，其标签和数据类型（如`int32`）就不应改变，否则旧版本代码在解析新数据时会失败。
2. **谨慎添加新字段**：新增字段应使用新的标签号，并尽量设为可选（optional）。在Protobuf 3中，所有字段默认都是可选的，这有利于兼容。应避免新增必填（required）字段，因为旧版本代码无法提供该字段值。
3. **废弃字段的正确处理**：对于不再使用的字段，不应直接删除其定义，而应标记为废弃（`deprecated = true`），并且**绝不重新使用已废弃字段的标签号**。这可以防止解析冲突。
4. **考虑默认值的影响**：当新版本代码生成的记录被旧版本代码读取时，旧版本无法识别的新字段会被忽略。因此，业务逻辑不应依赖那些在旧版本中不存在的字段的值。为新字段设置合理的默认值也是一种好实践。
**Protobuf版本控制示例**：
假设初始消息定义如下：
```protobuf
message User {
  int64 user_id = 1;
  string email = 2;
}
```
需要添加一个可选的`phone_number`字段，应这样扩展：
```protobuf
message User {
  int64 user_id = 1;
  string email = 2;
  optional string phone_number = 3; // 使用新的标签号3，并设为可选
}
```
这样，旧版本的消费者在接收到包含`phone_number`的消息时，会忽略无法识别的标签3，仍然能正确解析`user_id`和`email`，从而保证了向后兼容。
**Avro的Schema演进**：Avro通过Writer Schema（写入数据时使用的Schema）和Reader Schema（读取数据时使用的Schema）来解决兼容性问题。只要Schema变更符合Avro的兼容性规则（例如，添加字段时可提供默认值），新旧版本就可以协同工作。
###### 4. 消息序列化中如何处理敏感数据？
处理敏感数据是序列化过程中需要特别关注的安全问题。
**技术方案**：
1. **字段级加密**：在序列化之前，对消息中的敏感字段（如身份证号、手机号）进行加密，将密文序列化。消费者端反序列化后需解密才能使用。
    - **推荐算法**：使用AES（对称加密）或RSA（非对称加密）。
    - **密钥管理**：是关键挑战，可使用HashiCorp Vault等专业密钥管理服务。
    - **示例**：
        ```java
        // 序列化前加密敏感字段
        public class User {
            private String name;
            @Encrypted(type="AES") 
            private String idCardNumber; // 序列化前此字段会被加密
        }
        ```
2. **结构化脱敏**：在序列化流程中集成脱敏逻辑，使敏感数据在序列化后以脱敏形式存在（如手机号显示为`138****5678`）。这通常用于日志记录或发送给非核心系统。可在序列化器的`writeObject`方法或自定义的`MessageConverter`中实现脱敏逻辑。
3. **选择性序列化**：使用注解（如Jackson的`@JsonIgnore`）或自定义序列化器，避免将敏感字段本身序列化到消息中。
    ```java
    public class User {
        private String name;
        @JsonIgnore // 此字段不会被序列化到JSON中
        private String password;
    }
    ```
**架构建议**：
- **最小化原则**：从根本上考虑是否必须将敏感数据放入消息。如果可能，传递不敏感的唯一标识符，让消费者按需向安全的数据源查询详细信息。
- **端到端加密**：在非常敏感的场景下，可考虑在生产者端进行整个消息的加密，并在消费者端解密，消息中间件仅传输密文。
- **审计与监控**：记录敏感数据的访问日志，监控异常的数据流动。