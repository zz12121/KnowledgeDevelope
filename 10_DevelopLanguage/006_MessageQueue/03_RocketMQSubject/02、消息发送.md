###### 1. RocketMQ 支持哪几种消息发送方式？各有什么特点？
RocketMQ 主要提供三种消息发送方式，它们在**可靠性、性能和实现复杂度**上有显著差异。

|**发送方式**​|**同步发送**​|**异步发送**​|**单向发送**​|
|---|---|---|---|
|**机制**​|发送线程**阻塞等待**Broker响应结果|发送后**立即返回**，通过**回调函数**异步处理结果|发送后**立即返回**，**不关心**发送结果|
|**可靠性**​|**最高**（自动重试，明确知悉结果）|**高**（有回调通知，可感知失败）|**最低**（可能丢失消息）|
|**吞吐量**​|中等（~5k-10k TPS）|高（~20k+ TPS）|极高（~50k+ TPS）|
|**资源消耗**​|中等（线程阻塞等待）|较高（需维护回调线程池）|最低（无额外开销）|
|**适用场景**​|金融交易、订单创建等**强一致性**场景|日志收集、通知类等**高吞吐**场景|心跳检测、监控上报等**可容忍丢失**的场景|
**源码与设计视角**：
- **同步发送**：在 `DefaultMQProducerImpl#sendSync`方法中，通过 `this.invokeSync`进行**同步网络调用**，线程会阻塞在 `CountDownLatch.await()`上，直到收到Broker响应或超时。
- **异步发送**：核心在于 `DefaultMQProducerImpl#sendAsync`方法，它将发送请求封装为 `Runnable`任务提交到**异步线程池**执行。该线程池默认使用有界队列（容量50,000），需注意队列积压风险。
- **单向发送**：`DefaultMQProducerImpl#sendOneway`方法仅执行网络写入（`channel.writeAndFlush`），**不等待响应也不注册回调**，是简单的"发后即忘"模式。
###### 2. 什么是 RocketMQ 的批量消息？如何使用？有什么限制？
批量消息是RocketMQ提升性能的**关键优化手段**，通过将多条消息打包成一次网络请求发送，显著降低网络开销。
**核心实现方式**：
```java
// 创建消息列表（必须同一Topic，非事务/延迟消息）
List<Message> messages = Arrays.asList(
    new Message("BatchTopic", "TagA", "Msg1".getBytes()),
    new Message("BatchTopic", "TagA", "Msg2".getBytes())
);

// 方法1：直接发送列表（内部自动封装为MessageBatch）
SendResult result = producer.send(messages);

// 方法2：手动创建MessageBatch（更精细控制）
MessageBatch batch = MessageBatch.generateFromList(messages);
SendResult result = producer.send(batch);
```
**批量消息限制与规避方案**：

|**限制类型**​|**具体约束**​|**规避方案**​|
|---|---|---|
|**大小限制**​|单批次总大小**≤4MB**（默认）|实现`ListSplitter`进行消息拆分|
|**主题一致性**​|同一批次消息必须**相同Topic**​|发送前进行Topic校验|
|**功能兼容性**​|**不支持**延迟消息、事务消息|特殊消息需单独发送|
|**存储一致性**​|所有消息需有相同`waitStoreMsgOK`设置|统一消息属性配置|
**消息拆分器实现**（应对4MB限制）：
```java
public class ListSplitter implements Iterator<List<Message>> {
    private final int SIZE_LIMIT = 4 * 1024 * 1024; // 4MB
    private final List<Message> messages;
    private int currIndex;
    
    @Override
    public List<Message> next() {
        int nextIndex = currIndex;
        int totalSize = 0;
        
        while (nextIndex < messages.size()) {
            Message message = messages.get(nextIndex);
            // 计算消息大小（含主题、属性、日志开销等）
            int tmpSize = calculateMessageSize(message);
            if (tmpSize + totalSize > SIZE_LIMIT) break;
            totalSize += tmpSize;
            nextIndex++;
        }
        return messages.subList(currIndex, nextIndex);
    }
}
// 使用拆分器发送超大消息列表
ListSplitter splitter = new ListSplitter(messages);
while (splitter.hasNext()) {
    List<Message> subList = splitter.next();
    producer.send(subList);
}
```
###### 3. RocketMQ 如何保证消息发送的性能？
RocketMQ通过**多层级优化**确保高性能消息发送，核心手段包括批量处理、故障规避和资源复用。
**性能优化架构**：

|**优化层面**​|**具体策略**​|**性能收益**​|
|---|---|---|
|**网络优化**​|批量发送减少网络往返|吞吐量提升5-10倍|
|**线程模型**​|异步发送+回调线程池|降低主线程阻塞|
|**故障规避**​|基于响应延迟的Broker自动屏蔽|避免向慢节点发送|
|**内存管理**​|消息压缩（阈值默认4KB）|减少网络传输量|
关键配置参数**：
```java
DefaultMQProducer producer = new DefaultMQProducer("ProducerGroup");
// 发送超时时间（默认3秒）
producer.setSendMsgTimeout(5000);
// 异步发送重试次数（默认2次）
producer.setRetryTimesWhenSendAsyncFailed(3);
// 开启Broker故障延迟规避
producer.setSendLatencyFaultEnable(true);
// 压缩消息阈值（默认4KB）
producer.setCompressMsgBodyOverHowmuch(4096);
```
**底层网络优化**：
RocketMQ使用**Netty**作为网络通信框架，通过以下机制优化性能：
- **I/O多路复用**：主从Reactor线程模型，高效处理海量连接
- **内存零拷贝**：使用`FileRegion`实现网络传输时的零拷贝
- **信号量控流**：异步发送时通过`Semaphore`防止过度内存占用
###### 4. RocketMQ 的消息发送重试机制是怎样的？
RocketMQ的重试机制分为**同步重试**和**异步重试**两种模式，确保消息在异常场景下的可靠投递。
**重试机制对比**：

|**重试类型**​|**触发条件**​|**重试策略**​|**适用场景**​|
|---|---|---|---|
|**同步重试**​|网络异常、Broker繁忙等|**立即重试**，默认2次|同步发送模式|
|**异步重试**​|异步发送失败|**回调通知**，可自定义重试逻辑|异步发送模式|
**同步重试源码解析**：
在 `DefaultMQProducerImpl#sendDefaultImpl`方法中，重试逻辑核心如下：
```java
// 计算重试次数（默认2次 + 原始1次 = 总共3次）
int timesTotal = 1 + (this.defaultMQProducer.getRetryTimesWhenSendFailed() ?? 2);

for (int times = 0; times < timesTotal; times++) {
    try {
        // 尝试选择消息队列并发送
        MessageQueue mq = this.selectOneMessageQueue(topic, latencyFaultTolerance);
        sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, timeout);
        break; // 成功则跳出循环
    } catch (RemotingException e) {
        // 网络异常，进行重试
        continue;
    } catch (MQBrokerException e) {
        // Broker异常，根据错误码决定是否重试
        switch (e.getResponseCode()) {
            case ResponseCode.TOPIC_NOT_EXIST:
                // 主题不存在，需要创建后重试
                this.createTopic(mq.getBrokerName(), topic);
                continue;
            default:
                throw e;
        }
    }
}
```
**高级重试策略**：
- **故障规避机制**：当Broker响应缓慢时，会临时将其加入**延迟规避表**，避免后续消息继续发送到该慢节点
- **顺序消息重试**：顺序消息的重试需要保证**队列一致性**，需通过`MessageQueueSelector`确保重试时选择同一队列
###### 5. 如何在 RocketMQ 中实现消息的负载均衡？
RocketMQ的负载均衡通过**生产者端的队列选择**和**消费者端的队列分配**共同实现。
**生产者负载均衡**：
```java
// 自定义队列选择器（实现负载均衡策略）
MessageQueueSelector selector = new MessageQueueSelector() {
    @Override
    public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {
        // 策略1：哈希分配（保证相同Key的消息到同一队列）
        if (arg instanceof String) {
            int index = Math.abs(arg.hashCode()) % mqs.size();
            return mqs.get(index);
        }
        
        // 策略2：轮询分配（均匀分布）
        long index = System.currentTimeMillis() % mqs.size();
        return mqs.get((int) index);
        
        // 策略3：随机分配
        // return mqs.get(ThreadLocalRandom.current().nextInt(mqs.size()));
    }
};

// 发送时指定选择器
producer.send(msg, selector, "OrderKey"); // OrderKey用于哈希计算
```
**消费者负载均衡**：
RocketMQ消费者通过**RebalanceService**定时重新分配队列：
- **集群模式**：同一消费者组内的多个消费者**平均分配**消息队列
- **广播模式**：每个消费者消费**全部队列**
- **分配策略**：默认采用**平均分配算法**（AllocateMessageQueueAveragely）
**配置优化建议**：
```java
DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("ConsumerGroup");
// 设置拉取批量大小（默认32）
consumer.setPullBatchSize(32);
// 设置并发消费者数量（与队列数匹配）
consumer.setConsumeThreadMin(16);
consumer.setConsumeThreadMax(32);
```
**负载均衡高级特性**：
- **动态扩缩容**：当消费者实例数量变化时，RocketMQ会自动**重新分配队列**，实现弹性伸缩
- **故障自动转移**：当消费者宕机时，其负责的队列会自动转移到**同组其他消费者**
- **虚拟队列**：通过创建更多队列（如100个）来实现更细粒度的负载均衡，避免"热点队列"问题