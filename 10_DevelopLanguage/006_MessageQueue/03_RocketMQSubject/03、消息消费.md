###### 1. RocketMQ 的 Push 和 Pull 消费模式有什么区别？
RocketMQ 提供了两种消息消费模式，它们在**控制权、实时性和资源消耗**方面有本质区别。

|**特性维度**​|**Push 模式**​|**Pull 模式**​|
|---|---|---|
|**控制机制**​|Broker 主动推送，消费者被动接收|消费者主动向 Broker 拉取消息|
|**实时性**​|**高**（基于长轮询实现准实时推送）|**可控**（取决于拉取频率）|
|**资源消耗**​|Broker 需维护更多连接，消费者可能过载|消费者按自身处理能力控制，避免过载|
|**复杂度**​|使用简单，API 封装完善|需要手动管理拉取频率、位点等|
|**适用场景**​|大部分业务场景，追求实时性|流计算、批量处理等特殊场景|
**源码与设计视角**：
- **Push 模式实现**：`DefaultMQPushConsumer`内部通过 `PullMessageService`线程**循环拉取**消息，然后通过 `ConsumeMessageService`将消息**推送**给业务监听器。这种设计本质上是 Pull 的封装，但对外表现为 Push 语义。
- **Pull 模式实现**：`DefaultMQPullConsumer`（或 `LitePullConsumer`）要求应用程序主动调用 `pull()`方法，并自行管理 `MessageQueue`的遍历和位点提交。
**核心代码差异**：
```java
// Push 模式示例
DefaultMQPushConsumer pushConsumer = new DefaultMQPushConsumer("group_name");
pushConsumer.subscribe("TopicTest", "*");
pushConsumer.registerMessageListener(new MessageListenerConcurrently() {
    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {
        // 消息被自动推送到此
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
});

// Pull 模式示例  
DefaultLitePullConsumer pullConsumer = new DefaultLitePullConsumer("group_name");
pullConsumer.subscribe("TopicTest", "*");
pullConsumer.start();
List<MessageExt> msgs = pullConsumer.poll(Duration.ofSeconds(5)); // 主动拉取
```
###### 2. RocketMQ 消费者的负载均衡策略有哪些？
RocketMQ 通过 `RebalanceService`线程实现客户端负载均衡，核心接口为 `AllocateMessageQueueStrategy`，默认提供多种策略。
**策略详解**：

|**策略类型**​|**算法原理**​|**适用场景**​|
|---|---|---|
|**平均分配**​|将队列连续分段，按消费者数平均分配|默认策略，保证绝对均衡|
|**环形平均**​|将队列视为环形队列，按消费者顺序轮询分配|队列数与消费者数差距较大时|
|**一致性哈希**​|使用虚拟节点减少重平衡时的数据迁移|需要最小化队列重新分配的场景|
|**机房临近**​|优先分配同机房队列|跨机房部署，优化网络延迟|
|**手动配置**​|用户指定队列与消费者映射关系|特殊业务需求|
**源码视角**：
平均分配策略的核心逻辑在 `AllocateMessageQueueAveragely`中：
```java
public List<MessageQueue> allocate(String currentCID, List<MessageQueue> mqAll, List<String> cidAll) {
    // 计算每个消费者应分配的平均队列数
    int averageSize = mqAll.size() <= cidAll.size() ? 1 : mqAll.size() / cidAll.size();
    // 计算当前消费者在列表中的索引
    int index = cidAll.indexOf(currentCID);
    // 计算起始偏移量
    int startIndex = (index * averageSize);
    int range = Math.min(averageSize, mqAll.size() - startIndex);
    // 返回连续的子队列列表
    return mqAll.subList(startIndex, startIndex + range);
}
```
**最佳实践**：
- 多数场景使用默认的**平均分配策略**即可
- 需要最小化重平衡影响时（如频繁发布）考虑**一致性哈希**
- 确保**消费者组内所有实例的策略配置一致**，避免分配冲突
###### 3. 什么是消费者组（Consumer Group）？它的作用是什么？
**消费者组**是 RocketMQ 实现**负载均衡**和**高可用**的核心机制，是一组行为逻辑相同的消费者实例的集合。
**核心作用**：
1. **负载均衡**：Topic 下的多个 MessageQueue 会自动分配给组内不同消费者，实现并行消费。
2. **高可用**：组内某个消费者宕机时，其负责的队列会**自动重新分配**给其他存活消费者，避免消息堆积。
3. **进度管理**：消费进度（Offset）以**消费者组**为单位管理，重启后能从断点继续消费。
**设计约束**（重要原则）：
同一消费者组内的**所有消费者实例必须保持一致**：
- 订阅相同的 **Topic**​ 和 **Tag**（过滤规则）
- 采用相同的**投递顺序**（并发或顺序）
- 采用相同的**重试策略**
**配置示例**：
```java
// 同一消费者组的两个实例（可能部署在不同机器）
DefaultMQPushConsumer consumer1 = new DefaultMQPushConsumer("ORDER_GROUP");
consumer1.subscribe("OrderTopic", "*");

DefaultMQPushConsumer consumer2 = new DefaultMQPushConsumer("ORDER_GROUP"); // 相同的Group Name
consumer2.subscribe("OrderTopic", "*"); // 相同的订阅关系
```
若违反一致性约束（如混用顺序和并发消费），会导致**消息乱序**或**消费卡顿**。
###### 4. RocketMQ 如何实现消息的并发消费和顺序消费？
**并发消费**：
- **机制**：消费者内建线程池，同时处理多个消息。
- **实现**：使用 `MessageListenerConcurrently`，默认线程数为 CPU 核心数。
- **配置**：可通过 `setConsumeThreadMin()`和 `setConsumeThreadMax()`调整。
**顺序消费**：
- **前提**：确保**同一组消息发送到同一队列**（使用 `MessageQueueSelector`）。
- **机制**：在消费者端对**每个队列加锁**，确保同一时刻只有一个线程处理该队列的消息。
- **实现**：使用 `MessageListenerOrderly`。
**源码与设计视角**：
顺序消费通过 `ConsumeMessageOrderlyService`实现：
- 对每个 `MessageQueue`加锁（`lockMap`）
- 使用 `msgTreeMap`（TreeMap）按位点顺序存储消息
- 正在处理的消息会暂存于 `consumingMsgOrderlyTreeMap`
**关键配置**：
```java
// 顺序消费示例
consumer.setMessageListener(new MessageListenerOrderly() {
    @Override
    public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {
        // 对同一队列的消息会串行执行此方法
        return ConsumeOrderlyStatus.SUCCESS;
    }
});
```
**注意事项**：
- 顺序消费的**性能低于**并发消费
- 遇到消费失败时，顺序消费会**阻塞队列**直到当前消息处理成功（或超时）
###### 5. RocketMQ 消费失败后的重试机制是怎样的？最大重试次数是多少？
RocketMQ 为**集群模式**下的普通消息（非顺序消息）提供了完善的重试机制。
**重试规则**：
- **最大重试次数**：默认 **16 次**。
- **重试间隔**：随重试次数增加而延长（非固定），遵循 10秒、30秒、1分钟、2分钟...的渐进式间隔。
**触发条件**（满足任一即可）：
- 消费者返回 `Action.ReconsumeLater`
- 消费者返回 `null`
- 消费者抛出异常
**配置重试次数**：
```java
Properties properties = new Properties();
properties.put(PropertyKeyConst.MaxReconsumeTimes, "20"); // 最大重试20次
Consumer consumer = ONSFactory.createConsumer(properties);
```
**顺序消息的重试**：
顺序消息失败后会**立即重试**（间隔1秒），而非渐进式等待。这可能导致**消费阻塞**，需特别关注。
**获取重试次数**：
```java
public Action consume(Message message, ConsumeContext context) {
    System.out.println("已重试次数: " + message.getReconsumeTimes());
}
```
**最佳实践**：
- 在消费逻辑中做好**幂等性**处理
- 根据业务容忍度调整最大重试次数
- 监控**死信队列**（`%DLQ%`+ ConsumerGroupName）处理最终失败的消息
###### 6. 什么是 RocketMQ 的消费进度（Offset）？如何管理？
**消费进度**是消费者在某个队列上**已成功消费的最后一条消息的位置**（偏移量），是保证消息**不丢不重**的关键。
**管理方式**：

|**消费模式**​|**进度存储位置**​|**特性**​|
|---|---|---|
|**广播模式**​|消费者**本地磁盘**​|每个消费者实例独立存储，互不影响|
|**集群模式**​|**Broker 端**（远程）|消费者组内共享，统一管理|
**进度提交机制**：
- **自动提交**：Push 模式消费者在消费成功后**自动提交**进度。
- **手动提交**：Pull 模式或 LitePull 消费者需**手动调用**​ `updateConsumeOffset()`方法。
**源码视角**：
进度管理由 `OffsetStore`接口定义，具体实现有：
- `LocalFileOffsetStore`：用于广播模式
- `RemoteBrokerOffsetStore`：用于集群模式
**运维命令**：
```bash
# 查看消费进度
mqadmin consumerProgress -g GROUP_NAME
```
###### 7. RocketMQ 如何实现广播消费？
**广播消费**是指**消费者组内的每个实例都会收到全量消息**，适用于所有消费者都需要处理同一份数据的场景（如刷新本地缓存）。
**实现方式**：
```java
DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("broadcast_consumer_group");
consumer.setMessageModel(MessageModel.BROADCASTING); // 设置为广播模式
consumer.subscribe("TopicTest", "*");
```
**核心特性**：
- **进度管理**：消费进度存储在**每个消费者实例的本地**，而非 Broker。
- **与集群模式对比**：

|**特性**​|**广播消费**​|**集群消费**​|
|---|---|---|
|**消息分发**​|组内每个实例消费**全部消息**​|组内每个实例消费**部分消息**​|
|**进度存储**​|本地存储|Broker 端集中存储|
|**重试机制**​|**不支持**消息重试|支持|
|**适用场景**​|配置分发、缓存刷新|大部分业务解耦场景|
**注意事项**：
- 广播消费**没有重试机制**，消费失败即失败
- 消费者实例的**消费进度相互独立**
- 需确保每个实例的**处理逻辑完全一致**