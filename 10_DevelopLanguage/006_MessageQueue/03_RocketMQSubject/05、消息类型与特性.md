###### 1. RocketMQ 支持哪些消息类型？
RocketMQ 支持丰富的消息类型，每种类型针对特定业务场景设计，其核心分类和特性如下：

|**消息类型**​|**核心特性**​|**应用场景**​|**关键约束**​|
|---|---|---|---|
|**普通消息**​|基础消息类型，无特殊语义|微服务解耦、事件通知、日志收集|消息大小 ≤ 4MB|
|**顺序消息**​|保证同一消息组内严格FIFO|订单流程、交易撮合、数据同步|需确保生产消费均有序|
|**延迟消息**​|消息发送后延迟指定时间投递|订单超时关闭、定时任务触发|开源版支持固定级别，商业版支持自定义|
|**事务消息**​|保证本地事务与消息发送最终一致|分布式事务场景（如支付结算）|消息大小 ≤ 64KB|
|**批量消息**​|单次调用发送多条消息提升吞吐|日志批量上传、数据批量同步|单批次大小 ≤ 4MB，不支持延迟/事务消息|
|**过滤消息**​|消费者按条件选择性消费|业务消息分类路由、条件订阅|支持Tag简单过滤和SQL92复杂过滤|
**普通消息**​ 是 RocketMQ 最基础的消息类型，适用于大部分业务解耦场景。其生命周期包括初始化、待消费、消费中、消费提交和消息删除五个阶段 。在可靠性方面，RocketMQ 默认对消息进行持久化，保证消息的可回溯性和系统故障场景下的可恢复性 。
###### 2. 什么是延迟消息？RocketMQ 如何实现延迟消息？
**延迟消息**​ 是指消息被发送到 Broker 后，不会立即投递给消费者，而是延迟指定时间后才对消费者可见的消息类型 。典型应用场景包括订单超时关闭、促销活动提醒等需要定时触发的业务 。
**RocketMQ 延迟消息的实现原理**​ 基于**主题切换+定时调度**机制：
1. **消息暂存**：当 Broker 检测到消息的 `delayTimeLevel > 0`时，会将消息的原始 Topic 和 QueueId 备份到 Properties 中，然后将 Topic 修改为内部主题 `SCHEDULE_TOPIC_XXXX`，QueueId 设置为 `delayLevel - 1`。这样，延迟消息会按照级别被暂存到不同的内部队列中。
    ```java
    // Broker 接收延迟消息时的处理逻辑 [6](@ref)
    if (msg.getDelayTimeLevel() > 0) {
        topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC; // 修改为内部主题
        int queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());
        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());
        msg.setTopic(topic);
        msg.setQueueId(queueId);
    }
    ```
2. **定时投递**：Broker 启动时，`ScheduleMessageService`会为每个延迟级别创建一个对应的 `DeliverDelayedMessageTimerTask`定时任务 。这些任务周期性扫描内部队列中的消息，计算是否到期。
    ```java
    // ScheduleMessageService 启动定时任务 [8](@ref)
    public void start() {
        this.timer = new Timer("ScheduleMessageTimerThread", true);
        for (Map.Entry<Integer, Long> entry : this.delayLevelTable.entrySet()) {
            // 为每个延迟级别创建定时任务
            this.timer.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);
        }
    }
    ```
3. **到期投递**：当消息到达预设延迟时间后，定时任务会从消息 Properties 中恢复其原始 Topic 和 QueueId，然后将消息重新写入 CommitLog，此时消息才对消费者可见 。
###### 3. RocketMQ 的延迟消息支持自定义延迟时间吗？
**RocketMQ 不同版本对自定义延迟时间的支持有所差异：**

|**版本**​|**支持情况**​|**实现方式**​|**精度控制**​|
|---|---|---|---|
|**RocketMQ 4.x**​|仅支持**18个固定延迟级别**​|通过 `setDelayTimeLevel(int level)`设置|秒级精度，实际调度间隔100ms|
|**RocketMQ 5.x**​|支持**自定义延迟时间**​|通过 `syncSendDelayTimeMills`等方法设置毫秒级延迟|毫秒级参数，但实际精度受系统负载影响|
**4.x 版本的固定延迟级别**​ 配置如下（共18个级别）：
```java
private String messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h";
```
使用时通过 `message.setDelayTimeLevel(3)`设置延迟级别（例如3代表延迟10秒） 。
**5.x 版本的自定义延迟时间**​ 示例：
```java
// RocketMQ 5.x 支持毫秒级自定义延迟 [9](@ref)
rocketMQTemplate.syncSendDelayTimeMills("myTopic:myTag", msgBody, 5000); // 延迟5秒
```
**注意事项**：使用自定义延迟时间时，需确保应用服务器与 RocketMQ Broker 的**系统时间同步**，否则可能因时间差导致投递时间不准确
###### 4. 什么是定时消息？与延迟消息有什么区别？
在 RocketMQ 中，**定时消息**和**延迟消息**在语义和实现上**本质相同**，都是指消息在指定时间后才被投递给消费者 。两者通常可以互换使用，但细微区别在于：
- **定时消息**：更强调在某个**具体的时间点**（例如，明天上午10点）触发。
- **延迟消息**：更强调延迟一段**特定的时间间隔**（例如，30分钟后）触发。
RocketMQ 官方文档也指出，定时消息和延时消息本质相同，都是服务端根据消息设置的定时时间在某一固定时刻投递 。其实现机制完全一致，均通过前述的 `ScheduleMessageService`处理。
###### 5. RocketMQ 如何实现消息过滤？
RocketMQ 提供了**服务端过滤**机制，避免消费者接收到不需要的消息，减少网络带宽浪费。主要支持两种过滤方式：

|**过滤方式**​|**原理**​|**优点**​|**缺点**​|
|---|---|---|---|
|**Tag 过滤**​|消费者订阅时指定 Tag，Broker 根据消息的 Tag 哈希码进行匹配|简单高效，性能损耗极低|一条消息只能设置一个 Tag|
|**SQL92 过滤**​|消费者通过 SQL 表达式定义过滤规则，Broker 对消息属性进行求值|灵活性高，支持复杂条件|消耗更多 CPU 资源，需开启 `enablePropertyFilter = true`|
**Tag 过滤示例**：
```java
// 消费者只订阅 TagA 或 TagC 的消息 [2](@ref)
consumer.subscribe("TagFilterTest", "TagA || TagC");
```
**SQL92 过滤示例**：
```java
// 使用 SQL 表达式进行复杂过滤 [2](@ref)
consumer.subscribe("SqlFilterTest",
    MessageSelector.bySql("(TAGS is not null and TAGS in ('TagA', 'TagB')) and (a between 0 and 3)"));
```
SQL92 过滤支持数值比较、字符比较、`IS NULL`、`IN`和逻辑运算符等 。
###### 6. RocketMQ 的 SQL92 过滤和 Tag 过滤有什么区别？
**SQL92 过滤和 Tag 过滤的核心区别在于过滤能力和执行效率的权衡：**

|**对比维度**​|**Tag 过滤**​|**SQL92 过滤**​|
|---|---|---|
|**过滤粒度**​|基于单个字符串标签|支持多属性复杂条件表达式|
|**性能开销**​|极低（哈希匹配）|较高（需要解析 SQL 并计算）|
|**使用限制**​|一条消息只能设置一个 Tag|需要 Broker 端开启参数支持|
|**适用场景**​|简单的业务分类订阅|需要根据多个业务属性进行精细过滤的场景|
**设计建议**：
- 对于大多数场景，**推荐使用 Tag 过滤**，因为其性能最优。
- 只有在 Tag 无法满足复杂过滤条件时，才考虑使用 **SQL92 过滤**，并注意监控 Broker 的 CPU 资源使用情况。
- 消息过滤功能**仅对推模式（PushConsumer）有效**，拉模式（PullConsumer）需在客户端自行实现过滤逻辑 。