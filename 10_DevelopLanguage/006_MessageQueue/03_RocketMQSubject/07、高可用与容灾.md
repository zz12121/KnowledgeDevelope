###### 1. RocketMQ 的 DLedger 模式是什么？它解决了什么问题？
**DLedger 模式**是 RocketMQ 基于 Raft 一致性协议实现的多副本高可用方案，核心目标是解决传统主从架构下的**自动故障转移**问题。
**解决的问题**：
- **手动切换瓶颈**：在 4.5.0 版本之前，RocketMQ 主从架构中主节点宕机后，需要运维人员手动干预才能将从节点提升为主节点，无法实现自动故障转移。
- **数据一致性保障**：传统异步复制模式下，主节点宕机可能造成数据丢失。DLedger 通过 Raft 协议实现了强一致性数据复制。
- **脑裂防护**：通过 Term（任期）机制和“多数派”投票原则，确保同一时刻集群中只有一个主节点，避免脑裂问题。
**核心实现机制**：
在 Broker 启动时，通过判断 `enableDLegerCommitLog`配置项决定是否启用 DLedger 模式：
```
// Broker 启动时判断是否启用 DLedger
if (messageStoreConfig.isEnableDLegerCommitLog()) {
    this.commitLog = new DLedgerCommitLog(this);  // DLedger 模式
} else {
    this.commitLog = new CommitLog(this);          // 传统主从模式
}
```
DLedger 将 Raft 协议的核心能力封装为独立的 Java 库，作为分布式存储系统的持久层。其**日志复制流程**主要包括四个核心步骤：
1. **Leader 接收日志请求并存储**
2. **Leader 转发日志到 Follower**（由 `EntryDispatcher`处理）
3. **Follower 接收和保存 Leader 推送的日志**（由 `EntryHandler`处理）
4. **Leader 仲裁复制结果**（由 `QuorumAckChecker`处理）
###### 2. RocketMQ 主从模式和 DLedger 模式的区别是什么？

|**维度**​|**主从模式**​|**DLedger 模式**​|
|---|---|---|
|**故障转移**​|手动切换，停机时间长|**自动选主**，秒级恢复|
|**数据一致性**​|异步/同步复制，可能丢数据|**基于 Raft 的强一致性**，数据安全更高|
|**架构复杂度**​|简单，易于部署|相对复杂，需要至少**3节点**避免脑裂|
|**性能**​|高（无协调开销）|较低（需日志复制和仲裁）|
|**适用场景**​|业务允许短暂停服、数据少量丢失|**金融级场景**，要求高可用和强一致性|
**设计哲学差异**：
- **主从模式**遵循“最终一致性”原则，优先保证可用性（AP）。
- **DLedger 模式**遵循“强一致性”原则，优先保证一致性（CP），在选举期间牺牲部分可用性。
###### 3. RocketMQ 如何实现自动故障转移？
自动故障转移通过 **DLedger 的选举机制**和 **Broker 角色状态切换**协同实现。
**选举流程源码解析**：
1. **节点状态初始化**：所有节点启动时初始状态为 `Follower`。
2. **心跳超时触发选举**：`Follower`在预设的选举超时时间（如150-300ms随机值）内未收到 `Leader`的心跳，则状态变为 `Candidate`并开始新一轮任期（Term），向集群发起投票请求。
3. **多数派投票**：`Candidate`需要获得集群**半数以上节点**的投票才能当选为 `Leader`。
    ```java
    // DLedgerLeaderElector 中的投票统计逻辑
    if (alreadyHasLeader.get() || memberState.isQuorum(acceptedNum.get())) {
        changeRoleToLeader(term); // 满足条件，切换为 Leader
    }
    ```
4. **状态切换通知**：选举结果通过 `DLedgerRoleChangeHandler`通知到 `BrokerController`，触发 `changeToMaster()`或 `changeToSlave()`方法，完成 Broker 角色的实际切换。
**Broker 角色切换关键逻辑**：
- **升主（changeToMaster）**：启动事务消息回查服务、关闭元数据同步定时任务。
- **降从（changeToSlave）**：关闭事务消息回查服务、启动向新主节点同步元数据的定时任务。
###### 4. NameServer 的作用是什么？为什么设计成无状态的？
**NameServer 的核心作用**是作为 **轻量级路由信息管理中心**，扮演着 RocketMQ 的“目录服务”角色。其核心功能包括
- **路由管理**：维护所有 Broker 的地址信息、Topic 队列配置等路由元数据。
- **服务发现**：生产者和消费者通过查询 NameServer 获取对应 Topic 的 Broker 地址列表，从而建立连接。
**设计成无状态的原因**：
1. **降低复杂度**：无状态设计使 NameServer 节点之间无需进行数据同步，极大降低了系统复杂度和运维成本。
2. **水平扩展性**：客户端可以通过连接任意一个可用的 NameServer 节点来获取完整的路由信息，易于通过增加节点实现水平扩展。
3. **最终一致性保障**：路由信息的正确性不依赖 NameServer 间的强一致性。Broker 会**定期向所有 NameServer 发送心跳**以注册和更新路由信息，确保所有 NameServer 上的数据最终一致。
###### 5. NameServer 挂了会怎样？如何保证其高可用？
**单点故障影响**：
- **生产者/消费者**：在**客户端缓存有效期内**（默认15秒），消息发送和消费**不受影响**。客户端使用本地缓存的路由信息进行通信。
- **新客户端**：无法连接已挂的 NameServer，但若配置了多个地址，会尝试连接其他可用的 NameServer。
- **路由更新**：Broker 的心跳更新会失败，但不会影响现有连接。
**高可用保障策略**：
1. **多节点部署**：生产环境至少部署 **2-3 个**​ NameServer 节点。
2. **客户端多地址配置**：在生产者/消费者配置中指定所有 NameServer 地址。
    ```java
    producer.setNamesrvAddr("namesrv1:9876;namesrv2:9876;namesrv3:9876");
    ```
3. **冗余网络连接**：Broker 和客户端与每个 NameServer 都建立独立的心跳或查询连接。
###### 6. RocketMQ 如何进行集群扩容？
扩容操作需谨慎，不同类型集群的扩容方式存在差异。
**主从模式集群扩容**：
1. **新增 Broker 组**：部署新的 Master-Slave 组，设置新的 `brokerName`（如 `broker-c`）。
2. **动态创建 Topic 路由**：通过 `mqadmin`命令或控制台为现有 Topic 在新 Broker 组上创建队列。
    ```bash
    mqadmin updateTopic -c DefaultCluster -t YourTopic -n localhost:9876 -r 8 -w 8
    ```
3. **客户端自动发现**：客户端从 NameServer 拉取更新后的路由信息，自动将部分消息发送到新 Broker。
**DLedger 模式集群扩容**：
4. **修改配置**：更新集群所有节点（包括新节点）的 `dLegerPeers`配置，加入新节点信息。
5. **数据同步**：新节点启动后，会自动从 Leader 节点同步全部数据，**此过程可能影响集群性能**。
6. **重平衡**：DLedger 会基于 Raft 协议重新分配数据副本。
**重要注意事项**：
- **DLedger 集群扩容后需要重启所有节点**以加载新的节点列表，因此规划初期应预留节点容量。
- 扩容操作建议在**业务低峰期**进行。
- 操作前务必**备份数据**并制定详细的回滚方案。