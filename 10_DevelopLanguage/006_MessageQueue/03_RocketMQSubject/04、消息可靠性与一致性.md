###### 1. RocketMQ 如何保证消息不丢失？
保证消息不丢失需要构建**生产者 → Broker → 消费者**的全链路防护体系。
**（1）生产者端防护**
- **同步发送 + 重试机制**：使用 `DefaultMQProducer.send()`同步发送，通过 `SendResult`确认消息是否成功到达 Broker。若发送失败（如网络抖动），内置重试机制（默认重试 2 次）会自动切换 Broker 重试。
    ```java
    // 设置重试次数（默认2次）
    producer.setRetryTimesWhenSendFailed(3);
    SendResult result = producer.send(msg);
    if (result.getSendStatus() != SendStatus.SEND_OK) {
        // 触发重试或告警
    }
    ```
- **事务消息机制**：避免本地事务成功但消息未发送的场景。采用**半消息（Half Message）**​ 两阶段提交，确保本地事务与消息发送的原子性。
- **失败规避策略**：通过 `MQFaultStrategy`记录 Broker 响应延迟，自动屏蔽故障节点，将消息路由到健康 Broker。
**（2）Broker 端防护**
- **同步刷盘（SYNC_FLUSH）**：消息写入内存后，Broker 立即调用 `MappedByteBuffer.force()`将数据刷入磁盘（对比异步刷盘性能下降但可靠性高）。源码中由 `GroupCommitService`处理刷盘请求，通过 `GroupCommitRequest`阻塞等待刷盘结果。
    ```java
    // broker.conf 配置
    flushDiskType = SYNC_FLUSH
    ```
- **同步复制（SYNC_MASTER）**：主节点等待从节点（Slave）存储成功后才返回响应。通过 `HAConnection`实现主从数据同步，避免主节点宕机导致消息丢失。
    ```java
    // broker.conf 配置
    brokerRole = SYNC_MASTER
    ```
    
- **DLedger 模式**（RocketMQ 5.0+）：基于 Raft 协议实现多副本一致性，自动选主与故障转移，从架构层面解决单点故障。
**（3）消费者端防护**
- **手动确认机制**：消费者处理业务逻辑后，返回 `ConsumeConcurrentlyStatus.CONSUME_SUCCESS`提交消费进度（Offset）。若处理失败，返回 `RECONSUME_LATER`触发重试（默认最多 16 次）。
    ```java
    consumer.registerMessageListener((msgs, context) -> {
        try {
            processMessage(msgs);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    });
    ```
- **避免异步消费丢失**：禁止在监听器中启动新线程处理消息后立即返回 `SUCCESS`，否则未处理完的消息会因 Offset 提交而丢失。
**全链路方案总结**

|环节|防护策略|关键技术|
|---|---|---|
|**生产者**​|同步发送 + 重试 + 事务消息|`SendResult`、半消息机制、`MQFaultStrategy`|
|**Broker**​|同步刷盘 + 同步复制 + DLedger 多副本|`GroupCommitService`、`HAConnection`、Raft|
|**消费者**​|业务成功后再提交 Offset + 死信队列（DLQ）监控|手动 ACK、`RECONSUME_LATER`、`%DLQ%`队列|
###### 2. RocketMQ 的刷盘机制有哪些？同步刷盘和异步刷盘的区别是什么？
刷盘机制是 Broker 将内存中的消息持久化到磁盘的核心过程，直接关系消息的可靠性。其核心区别如下：

|**维度**​|**同步刷盘（SYNC_FLUSH）**​|**异步刷盘（ASYNC_FLUSH）**​|
|---|---|---|
|**机制**​|消息写入内存后，立即阻塞等待刷盘完成才返回响应|消息写入内存后立即返回，由后台线程定时批量刷盘|
|**可靠性**​|高（数据落盘才确认）|较低（宕机可能丢失内存中未刷盘的数据）|
|**吞吐量**​|低（每次写操作需等待磁盘 I/O）|高（批量刷盘减少 I/O 次数）|
|**适用场景**​|金融交易、计费系统等对可靠性要求极高的场景|日志收集、监控数据等允许少量丢失的高吞吐场景|
**源码解析**
- **同步刷盘实现**：在 `CommitLog.putMessage()`中，若配置为 `SYNC_FLUSH`，会调用 `GroupCommitService`处理刷盘请求。该服务通过 `swapRequests()`交换读写队列，并由 `doCommit()`执行刷盘操作，最后通过 `CountDownLatch`唤醒阻塞的发送线程。
    ```java
    // GroupCommitService 核心逻辑
    public void run() {
        while (!stopped) {
            waitForRunning(10); // 等待10ms收集一批请求
            swapRequests();     // 交换读写队列
            doCommit();         // 刷盘
        }
    }
    ```
- **异步刷盘实现**：由 `FlushRealTimeService`或 `CommitRealTimeService`（启用 TransientStorePool 时）定时触发刷盘。默认每 500ms 执行一次 `MappedByteBuffer.force()`，或当堆外内存积压达到 4 页（4 * 4KB）时触发。
**配置建议**
```properties
# broker.conf
flushDiskType = SYNC_FLUSH    # 同步刷盘
flushDiskType = ASYNC_FLUSH   # 异步刷盘（默认）
```
###### 3. 什么是 RocketMQ 的主从同步机制？同步复制和异步复制的区别？
主从同步机制通过数据冗余实现高可用，其核心区别如下：

|**维度**​|**同步复制（SYNC_MASTER）**​|**异步复制（ASYNC_MASTER）**​|
|---|---|---|
|**数据一致性**​|强一致（主从均写入成功才返回响应）|最终一致（主节点写入成功即返回，从节点异步同步）|
|**性能**​|较低（RT 增加）|高（无等待从节点同步的开销）|
|**故障恢复**​|主节点宕机后从节点数据完整，可自动切换（DLedger 模式）|主节点宕机可能丢失未同步到从节点的数据|
**源码解析**
- **同步复制流程**：主节点通过 `HAConnection`维护与从节点的长连接，收到生产者消息后，等待从节点返回 `ACK`才响应生产者。超时未收到 `ACK`则返回 `FLUSH_SLAVE_TIMEOUT`。
- **异步复制流程**：主节点写入后立即返回成功，由 `HAService`异步将数据推送至从节点。
**配置建议**
```properties
# broker.conf
brokerRole = SYNC_MASTER   # 同步复制（高可靠）
brokerRole = ASYNC_MASTER  # 异步复制（高性能，默认）
```
###### 4. RocketMQ 如何实现消息的幂等性？
由于网络重试或消费者重启可能导致消息重复，业务端需自行实现幂等性。常用方案如下：
**（1）数据库唯一约束**
- 为消息表设置唯一索引（如订单 ID），重复消费时触发主键冲突。
    ```sql
    CREATE TABLE `mq_consume_record` (
      `msg_id` VARCHAR(64) PRIMARY KEY,  -- 消息唯一标识
      `order_id` VARCHAR(64) UNIQUE,     -- 业务唯一键
      `status` INT
    );
    ```
- 消费前插入记录，若插入失败则说明已处理。
**（2）Redis 原子操作**
- 使用 `SETNX`命令将消息 Key 存入 Redis，设置过期时间避免内存泄漏。
    ```java
    boolean isDuplicate = redisTemplate.opsForValue().setIfAbsent(msgKey, "1", 24, HOURS);
    if (!isDuplicate) {
        return; // 已消费
    }
    ```
**（3）业务状态机**
- 设计订单等业务状态为单向流转（如 `待支付 → 已支付`），通过 `update ... where status = 期望状态`避免重复处理。
**方案对比**

|方案|优点|缺点|
|---|---|---|
|**数据库唯一约束**​|强一致性、实现简单|数据库压力大|
|**Redis 原子操作**​|高性能、低延迟|数据易失（需持久化策略）|
|**业务状态机**​|无需额外存储|仅适用于有状态流转的业务|
###### 5. RocketMQ 中的事务消息实现原理是什么？
事务消息通过**半消息（Half Message）**​ 和**事务状态回查**机制，解决分布式事务的最终一致性。其核心流程如下：
**两阶段提交流程**
1. **第一阶段：发送半消息**​
    - 生产者发送半消息（对消费者不可见）到 Broker。
    - Broker 将消息存入 `RMQ_SYS_TRANS_HALF_TOPIC`主题，并回复 `SEND_OK`。
2. **第二阶段：提交/回滚本地事务**​
    - 生产者执行本地事务（如更新数据库），根据结果向 Broker 发送 `Commit`或 `Rollback`指令。
    - 若 Broker 收到 `Commit`，将半消息转存至目标 Topic，供消费者消费；若收到 `Rollback`，则丢弃消息。
**源码关键点**
- 半消息存储时，`CommitLog`会标记消息属性为 `TRAN_MSG`，Broker 通过 `TransactionalMessageService`管理半消息状态。
- 若生产者未及时提交事务状态，Broker 会触发回查机制。
###### 6. RocketMQ 事务消息的回查机制是怎样的？
回查机制用于解决生产者提交事务状态后发生宕机或超时的场景，确保事务状态最终一致。
**触发条件**
- 生产者发送半消息后，未在指定时间内（默认 60s）提交 `Commit`/`Rollback`。
- 生产者宕机或网络分区。
**回查流程**
1. Broker 启动定时任务（`TransactionalMessageCheckService`），扫描 `RMQ_SYS_TRANS_HALF_TOPIC`中的半消息。
2. 对超时未确认的消息，向生产者发起回查请求。
3. 生产者实现 `checkLocalTransaction`方法，查询本地事务状态（如检查数据库事务表），并返回 `COMMIT`、`ROLLBACK`或 `UNKNOWN`（继续等待下次回查）。
**配置参数**
```properties
# broker.conf
transactionTimeout = 60s           # 事务超时时间
transactionCheckMax = 5            # 最大回查次数
transactionCheckInterval = 60s     # 回查间隔
```
###### 7. 如何使用 RocketMQ 实现分布式事务？
结合事务消息与业务校验，可实现跨系统的最终一致性。以下以订单支付场景为例：
**场景描述**​
订单服务创建订单后，调用支付服务扣款，需保证两者数据一致。
**实现方案**
1. **订单服务发送半消息**​
    ```java
    TransactionMQProducer producer = new TransactionMQProducer("order-group");
    producer.setTransactionListener(new TransactionListener() {
        @Override
        public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {
            try {
                // 执行本地事务：创建订单记录
                orderService.createOrder(arg);
                return LocalTransactionState.COMMIT_MESSAGE;
            } catch (Exception e) {
                return LocalTransactionState.ROLLBACK_MESSAGE;
            }
        }
    
        @Override
        public LocalTransactionState checkLocalTransaction(MessageExt msg) {
            // 回查逻辑：查询订单状态
            OrderStatus status = orderService.queryOrder(msg.getKeys());
            return status == PAID ? COMMIT_MESSAGE : ROLLBACK_MESSAGE;
        }
    });
    producer.sendMessageInTransaction(msg, null);
    ```
1. **支付服务消费消息**​
    - 订阅订单 Topic，支付成功后更新订单状态。
    - 通过幂等性机制防重复支付。
**方案优势**
- **解耦**：订单服务无需依赖支付服务的实时可用性。
- **最终一致性**：通过回查机制自动补偿异常状态。
**注意事项**
- 回查方法需幂等，避免多次查询结果不一致。
- 本地事务与回查逻辑需共享数据源（如同一数据库），避免脏读。