###### 1. 如何保证消息不被重复消费？
保证消息不被重复消费需要从**消息重复产生的根源**入手，建立多层次的防护体系。消息重复主要源于以下三种场景 ：
- **发送时消息重复**：生产者已成功发送消息但未收到Broker确认，触发重试机制。
- **投递时消息重复**：消费者处理成功但返回ACK确认时网络闪断，Broker重新投递。
- **负载均衡时消息重复**：Broker或消费者重启、扩容缩容触发Rebalance，导致消息重新分配。
**解决方案架构：**
1. **消息去重过滤**：在消息入口处建立去重机制，利用唯一标识拦截重复消息。
2. **业务幂等设计**：核心手段，保证业务逻辑即使被重复执行，结果也保持一致。
3. **中间件特性利用**：如Kafka的`enable.idempotence`配置，可在生产者端实现会话内的精确一次发送 。
实现层面，推荐结合**数据库唯一约束**与**Redis原子操作**构建防护网。数据库提供强一致性保障，Redis提供高性能校验，两者互补 。
###### 2. 什么是消息幂等性？如何实现？
**消息幂等性**是指消费者对同一消息进行**多次消费**的结果与**一次消费**的结果完全相同，且不会对业务系统产生任何负面影响 。例如，同一笔订单的扣款操作，无论执行多少次，最终只扣款一次。
**实现幂等性的核心思路是确保业务操作的可重复执行。**​ 下表对比了常见的实现方案：

|方案|原理|适用场景|优点|缺点|
|---|---|---|---|---|
|**数据库唯一约束**​|利用数据库唯一索引防止重复数据插入 。|写操作为主，如创建订单、支付流水。|强一致性、实现简单可靠。|数据库压力大，高并发下可能成为瓶颈。|
|**乐观锁**​|基于版本号或状态字段，更新时校验数据是否被修改 。|更新操作，如更新订单状态、扣减库存。|避免锁竞争，并发性能高。|在冲突频繁的场景下成功率低。|
|**悲观锁**​|使用`SELECT ... FOR UPDATE`在事务开始时锁定数据 。|资金交易等强一致性场景。|保证绝对的数据安全。|性能开销大，容易导致死锁。|
|**Redis原子操作**​|使用`SETNX`（Set if not exist）等原子指令标记已处理消息 。|高并发场景下的快速校验，如秒杀、抢购。|性能极高，减轻数据库压力。|数据可靠性需考虑（持久化策略），可能存在极端情况下的数据不一致。|
|**状态机**​|设计业务状态流转逻辑，确保状态只能向前变更，不能回退或重复 。|有明确状态流转的业务，如订单（待支付->已支付->已完成）。|业务逻辑清晰，从设计上杜绝重复。|设计复杂度较高。|
**最佳实践**：通常组合使用多种方案。例如，先用Redis做高速预检拦截大部分重复请求，再用数据库唯一约束做最终保障。
###### 3. 如何设计全局唯一的消息 ID？
全局唯一消息ID是实现幂等的基石，其设计需满足**全局唯一性**、**趋势递增**（可选，利于排序）和**高性能**。
**常用方案对比：**

|方案|实现方式|优点|缺点|
|---|---|---|---|
|**UUID/GUID**​|`UUID.randomUUID().toString()`|本地生成，无网络开销，简单。|无序存储，作为数据库主键时影响插入性能；长度较长（32字符）。|
|**Snowflake算法**​|时间戳 + 工作机器ID + 序列号。|有序递增，作为数字类型存储空间小，性能高。|需解决机器ID的分配问题，存在时钟回拨问题（需算法处理）。|
|**数据库序列号**​|如MySQL的`AUTO_INCREMENT`。|绝对唯一，简单。|性能有瓶颈，依赖数据库。|
|**Redis INCR**​|`INCR`或 `INCRBY`命令。|性能高，可生成有序ID。|需保证Redis高可用，否则可能成为单点。|
|**业务复合键**​|业务标识（如订单号） + 时间戳/随机数。|兼具唯一性和业务意义。|长度不固定，复杂度高。|
**Snowflake算法Java示例：**
```java
public class SnowflakeIdGenerator {
    private final long workerId; // 机器ID
    private final long datacenterId; // 数据中心ID
    private long sequence = 0L;
    private long lastTimestamp = -1L;

    public synchronized long nextId() {
        long timestamp = timeGen();
        if (timestamp < lastTimestamp) {
            // 处理时钟回拨
            throw new RuntimeException("Clock moved backwards.");
        }
        if (lastTimestamp == timestamp) {
            sequence = (sequence + 1) & sequenceMask;
            if (sequence == 0) {
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            sequence = 0L;
        }
        lastTimestamp = timestamp;
        return ((timestamp - twepoch) << timestampLeftShift)
                | (datacenterId << datacenterIdShift)
                | (workerId << workerIdShift)
                | sequence;
    }
}
```
**关键点**：在分布式环境中，**Snowflake算法及其变种（如美团Leaf、百度UidGenerator）是首选**，它们在唯一性、有序性和性能之间取得了最佳平衡。消息ID应由生产者生成并在消息发送时设置 。
###### 4. 使用数据库唯一约束保证幂等性的方案是什么？
此方案的核心是利用关系型数据库的**唯一索引**特性，确保具有唯一标识的记录只能被插入一次。
**实现步骤与源码解析：**
1. **创建去重表**：建立一张专门的表，用于记录已成功处理的消息的唯一标识。
    ```sql
    CREATE TABLE message_idempotent (
        id BIGINT PRIMARY KEY AUTO_INCREMENT,
        message_key VARCHAR(64) NOT NULL UNIQUE, -- 建立唯一索引，使用业务唯一键
        business_type VARCHAR(32) NOT NULL,
        created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    ) ENGINE=InnoDB;
    ```
2. **消费逻辑与事务绑定**：将业务操作和插入去重表记录放在同一数据库事务中。
    ```java
    @Transactional(rollbackFor = Exception.class)
    public void processMessage(Message message) {
        // 1. 提取业务唯一键（例如，订单号）
        String businessKey = message.getBusinessKey();
    
        // 2. 尝试插入去重表
        try {
            idempotentMapper.insertIdempotentRecord(businessKey, "ORDER_CREATE");
        } catch (DuplicateKeyException e) {
            // 3. 捕获唯一键冲突异常，说明消息已处理，直接返回
            log.warn("Duplicate message detected, key: {}", businessKey);
            return; // 幂等生效，直接跳过
        }
    
        // 4. 如果没有异常，执行核心业务逻辑（例如，创建订单）
        orderService.createOrder(message.getOrderData());
    
        // 5. 事务提交：业务操作和去重记录插入同时成功
    }
    ```
**方案深度分析：**
- **原子性保证**：数据库事务确保了`insert`和业务操作的原子性，要么都成功，要么都失败。
- **强一致性**：唯一索引是数据库级别的最强约束，从根源上杜绝重复。
- **性能考量**：高频写入场景下，数据库可能成为瓶颈。可以对去重表进行**分库分表**（按`business_type`或时间），或将其作为**第一道防线**，与Redis等缓存方案结合。
###### 5. 使用 Redis 实现幂等性的方案是什么？
Redis凭借其**高性能**和**丰富的原子指令**，是实现幂等性的优选方案，尤其适合高并发场景。
**核心指令与演进方案：**
1. **方案一：`SETNX`+ `EXPIRE`(非原子性，不推荐)**
    ```java
    // 存在风险：SETNX成功后，若设置EXPIRE前服务宕机，Key将永不过期，导致后续消息永远被拦截。
    public boolean isIdempotent(String key, int expireSeconds) {
        Boolean result = jedis.setnx(key, "1");
        if (result) {
            jedis.expire(key, expireSeconds); // 非原子操作，存在风险
        }
        return result;
    }
    ```
2. **方案二：原子命令 `SET`配合 NX/EX 参数 (推荐)**
    ```java
    // 一行命令原子化地完成设置值和过期时间，推荐使用。
    public boolean isIdempotentAtomic(String key, int expireSeconds) {
        String result = jedis.set(key, "1", "NX", "EX", expireSeconds);
        return "OK".equals(result);
    }
    ```
3. **方案三：Redis + Lua 脚本 (最严谨，支持复杂逻辑)**
    Lua脚本在Redis中原子执行，适合处理需要**先判断后操作**的复杂幂等逻辑 。
    ```java
    // Lua脚本内容：如果Key不存在则设置值并过期，返回1；否则返回0。
    private static final String IDEMPOTENT_SCRIPT =
        "if redis.call('setnx', KEYS[1], ARGV[1]) == 1 then\n" +
        "   redis.call('expire', KEYS[1], ARGV[2])\n" +
        "   return 1\n" +
        "else\n" +
        "   return 0\n" +
        "end";
    
    public boolean isIdempotentLua(String key, String value, int expireSeconds) {
        // 使用eval命令执行Lua脚本，保证原子性
        Object result = jedis.eval(IDEMPOTENT_SCRIPT, 1, key, value, String.valueOf(expireSeconds));
        return Long.valueOf(1L).equals(result);
    }
    ```
    对于生产环境，可使用 `SCRIPT LOAD`预加载脚本，然后用 `evalsha`执行，减少网络传输 。
**方案选型建议：**
- **绝大多数场景**：直接使用原子化的 `SET key value NX EX timeout`命令。
- **超高性能或复杂校验需求**：使用预加载的Lua脚本。
- **数据可靠性**：为Redis配置恰当的持久化策略（AOF），防止宕机导致状态丢失。可将Redis作为高性能过滤器，最终一致性由数据库保证。