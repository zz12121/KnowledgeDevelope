###### 1. 说说生产者消息运转过程
生产者消息发送遵循严格的AMQP协议流程，确保消息可靠传输到目标队列。
**完整流程如下：**
1. **建立TCP连接**：通过`ConnectionFactory`配置服务器参数（主机、端口、虚拟主机、认证信息），调用`newConnection()`建立到RabbitMQ Broker的物理TCP连接。
2. **创建信道**：通过`connection.createChannel()`在TCP连接上创建轻量级的AMQP信道（Channel）。信道是执行AMQP指令的逻辑通道，支持多路复用，避免频繁创建TCP连接的开销。
3. **声明交换器与队列**：
    - 使用`channel.exchangeDeclare()`声明交换器，指定名称、类型（direct、fanout、topic、headers）及持久化等属性。
    - 使用`channel.queueDeclare()`声明队列，配置持久化（durable）、排他性（exclusive）、自动删除（autoDelete）等参数。
    - 通过`channel.queueBind()`将队列与交换器绑定，定义路由规则（Binding Key）。
4. **发布消息**：调用`channel.basicPublish()`发送消息，核心参数包括：
    - `exchange`：目标交换器名称（空字符串表示默认交换器）。
    - `routingKey`：路由键，交换器根据此键和绑定规则路由消息。
    - `mandatory`：若为`true`，当消息无法路由到任何队列时，Broker通过`ReturnListener`返回消息；否则丢弃。
    - `properties`：设置消息属性（如持久化`deliveryMode=2`、优先级、过期时间TTL）。
    - `body`：消息体字节数组。
5. **协议交互**：底层通过AMQP命令帧完成交互，如`Connection.Start/Start-Ok`、`Channel.Open/Open-Ok`、`Basic.Publish`。消息发布后，若开启生产者确认模式（Publisher Confirm），Broker会异步返回`Basic.Ack`或`Basic.Nack`。
6. **资源清理**：消息发送完成后，按顺序关闭信道和连接。
**源码角度**：在RabbitMQ Java客户端中，`ChannelN`类是核心实现，其`basicPublish`方法最终通过`AMQCommand`将协议帧写入Socket输出流。确认机制通过`ConfirmListener`回调处理，异步通知生产者消息状态。
###### 2. 说说消费者接收消息过程
消费者通过订阅或拉取方式从队列获取消息，核心在于消息确认机制确保可靠消费。
**完整流程如下：**
1. **建立连接和信道**：与生产者类似，通过`ConnectionFactory`创建连接和信道。
2. **声明队列**：需确保队列存在（与生产者声明参数一致），可调用`channel.queueDeclare()`，但通常消费者仅验证而非创建。
3. **设置预取值**：通过`channel.basicQos(prefetchCount)`限制未确认消息的最大数量，实现流量控制。
4. **消费消息**：
    - **推模式（推荐）**：使用`channel.basicConsume()`注册`Consumer`回调。当消息到达时，Broker主动推送，触发`handleDelivery()`方法。消费者在此方法内处理消息并手动确认（ACK）。
    - **拉模式**：调用`channel.basicGet()`主动拉取单条消息。无消息时立即返回`null`，适用于间歇性消费场景。
5. **消息确认**：
    - 自动确认（`autoAck=true`）：消息推送给消费者后立即被Broker删除，风险高（消费者崩溃可能导致消息丢失）。
    - 手动确认（`autoAck=false`）：消费者处理完成后调用`channel.basicAck(deliveryTag, multiple)`确认单条或批量消息。若处理失败，可调用`basicReject`或`basicNack`拒绝消息。
6. **消息删除**：Broker在收到ACK后，将消息从队列中删除。
**源码角度**：推模式中，主循环（MainLoop）线程持续从Socket读取AMQP帧，解析为`Basic.Deliver`命令后，通过`ChannelN`派发到注册的`Consumer`实例的`handleDelivery`方法。确认命令（`Basic.Ack`）通过相同信道异步发送回Broker。
###### 3. RabbitMQ 的推模式和拉模式有什么区别？
推模式和拉模式是消息传递的两种根本方式，设计哲学和适用场景不同。

|**特性**​|**推模式（Push）**​|**拉模式（Pull）**​|
|---|---|---|
|**机制**​|Broker主动将消息推送给消费者（`basicConsume`+回调）。|消费者主动从Broker拉取消息（`basicGet`）。|
|**实时性**​|**高**，消息到达后立即推送。|**低**，依赖消费者轮询间隔，有延迟。|
|**流控**​|依赖`basicQos`设置预取值（prefetch）来控制未确认消息的上限。|**天然支持**，消费者根据自身处理能力决定拉取时机和数量。|
|**性能影响**​|可能压垮消费者（需设预取值）；Broker需维护推送状态。|短轮询可能空转浪费资源；长轮询（RabbitMQ不支持原生）可优化。|
|**资源占用**​|消费者需缓冲区缓存推送的消息，有内存溢出风险。|无推送缓冲区，资源占用更可控。|
|**适用场景**​|**默认选择**，高吞吐、实时性要求高的场景。|需精确控制消费速率或间歇性处理的特殊场景。|
**设计哲学**：RabbitMQ基于AMQP协议，其交换器（Exchange）绑定队列的复杂路由逻辑，更适合由Broker统一处理后的主动推送（Push）。而Kafka这类以分区日志为核心的中间件，则采用消费者自主管理偏移量（Offset）的拉模式（Pull），更利于批量和高吞吐。
###### 4. 什么是消费者预取值（Prefetch Count）？
预取值是RabbitMQ**控制消费者流量的核心机制**，定义为信道或消费者级别允许的**未确认消息（unacked messages）的最大数量**。
**核心作用**：
- **流量整形**：防止Broker向消费者无限推送消息，避免消费者内存溢出或过载。
- **公平分发**：在多个消费者竞争同一队列时，确保消息能分发给空闲消费者，避免某个慢消费者堆积消息。
**设置方法与模式**：
通过`channel.basicQos(int prefetchCount, boolean global)`设置。
- **`prefetchCount`**：最关键参数，直接限制未确认消息的数量。
- **`global`**：控制作用范围。
    - `false`（默认）：作用于**单个消费者**。信道上每个新消费者独立受限。
    - `true`：作用于**整个信道**。信道下所有消费者共享该预取值配额。
**Java代码示例**：
```java
Channel channel = connection.createChannel();
// 设置每个消费者最多同时处理5条未确认消息
channel.basicQos(5); // 等价于 channel.basicQos(5, false);

// 设置为信道级别，该信道下所有消费者共享5个消息的配额
// channel.basicQos(5, true);
```
**配置建议**：
- **CPU密集型/处理慢**：设为`1`，确保公平分发，避免单个消费者积压。
- **I/O密集型（如调数据库/API）**：可设更高（如`CPU核心数 * 2`到`10`），充分利用等待时间。
- **高吞吐批处理**：可设`50`或更高，但需监控消费者内存。
- **绝对公平**：设为`1`。
在Spring Boot中可通过配置简单设置：`spring.rabbitmq.listener.simple.prefetch=5`。
###### 5. 如何实现消息的顺序消费？
保证消息顺序消费是分布式系统中的挑战。RabbitMQ仅在**单一队列、单一消费者、无消息重投递**的特定条件下保证FIFO。
**保障顺序性的核心思路是限制并行性**：
1. **单队列单消费者**：最根本的保证。一个队列只分配一个消费者，从根本上消除多消费者乱序的可能。
2. **设置预取值为1**：`channel.basicQos(1)`。确保消费者在前一条消息确认前，不会收到下一条消息。即使有多个消费者，也能在队列层面保证投递顺序（但一个消息只会被一个消费者处理）。
3. **避免自动重入队**：处理失败时，谨慎使用`basicReject`或`basicNack`的`requeue=true`参数。因为重入队的消息会回到队列**头部**（新版本）或**尾部**（旧版本），可能打乱顺序。更佳实践是：
    - 将失败消息发送到**死信队列（DLQ）**​ 进行事后分析或手动重放。
    - 在消费者内部进行重试，而非依赖Broker重入队。
4. **业务层排序**：对于需要全局顺序的消息，生产者可为消息分配单调递增的序列号（如数据库自增ID、雪花算法ID）。消费者虽可能乱序接收，但处理时可根据序列号调整状态，实现业务逻辑的最终顺序性。
**注意事项**：严格顺序性会牺牲吞吐量和可用性。若业务允许短暂乱序（如同一订单的不同操作消息），可通过更细粒度的分区（如按订单ID哈希到不同队列）来平衡顺序性和性能。
###### 6. 如何拒绝消息？reject 和 nack 有什么区别？
拒绝消息是消费者在处理消息出错时，向Broker通知失败的重要机制。`basicReject`和`basicNack`都用于拒绝消息，但能力有关键差异。
**拒绝消息的API**：
- **`basicReject(long deliveryTag, boolean requeue)`**：
    - **功能**：拒绝**单条**消息。
    - **参数**：
        - `deliveryTag`：当前消息的唯一标识（交付标签）。
        - `requeue`：`true`表示消息重新放回队列（可能被其他消费者或自己再次消费）；`false`表示直接丢弃或送入死信队列（如果配置了DLX）。
- **`basicNack(long deliveryTag, boolean multiple, boolean requeue)`**：
    - **功能**：拒绝**单条或批量**消息。是`basicReject`的增强版。
    - **参数**：
        - `deliveryTag`：当前消息的交付标签。
        - `multiple`：**关键区别**。若为`true`，则拒绝所有`deliveryTag`小于等于当前值的**未确认消息**，实现批量操作。若为`false`，则仅拒绝当前消息，等同于`basicReject`。
        - `requeue`：同`basicReject`，控制是否重入队。
**Java代码示例**：
```java
// 示例1：拒绝单条消息，并重新入队
channel.basicReject(deliveryTag, true);

// 示例2：拒绝单条消息，不重新入队（进入死信队列或丢弃）
channel.basicReject(deliveryTag, false);

// 示例3：批量拒绝：拒绝当前及之前所有未确认的消息（deliveryTag <= currentTag），并重新入队
channel.basicNack(deliveryTag, true, true);

// 示例4：拒绝单条消息，功能等同于 basicReject(deliveryTag, false)
channel.basicNack(deliveryTag, false, false);
```
**核心区别总结**：

|特性|`basicReject`|`basicNack`|
|---|---|---|
|**拒绝范围**​|仅能拒绝**单条**消息。|可拒绝**单条或批量**消息（通过`multiple`参数控制）。|
|**灵活性**​|功能单一。|更灵活，可完全覆盖`basicReject`的场景。|
**最佳实践**：**推荐优先使用`basicNack`**，因其功能更全面。特别是在需要批量拒绝的场景下（如消费者检测到自身存在严重问题，需要拒绝所有正在处理的消息），`basicNack`是唯一选择。谨慎使用`requeue=true`，避免消息无限循环。通常更好的做法是设置有限重试次数，失败后转入死信队列。
###### 7. 什么是消息重入队（Requeue）？
消息重入队是指当消息被消费者拒绝（使用`basic.reject`或`basic.nack`）且设置为`requeue = true`时，RabbitMQ Broker将该消息**重新放回原始队列**的机制。
**重入队的行为**：
- 消息会回到队列中，并准备再次被投递给消费者。
- 如果没有其他消费者，很可能会被**同一个消费者**再次接收到。
- 如果消息一直被拒绝且重入队，可能导致**无限循环**，消耗系统资源。
**重入队的风险与替代方案**：
由于无限重试的风险，**应极其谨慎地使用`requeue=true`**。更健壮的处理流程是：
1. **死信队列（DLQ）**：为队列配置死信交换器（DLX）。当消息被拒绝且`requeue=false`时，会被路由到DLQ，便于后续排查问题。
2. **有限重试**：在消费者内部维护重试计数器（可放在消息头或应用状态中）。当重试次数超过阈值后，主动确认消息或将其发布到专门的失败队列，而不是依赖Broker重入队。