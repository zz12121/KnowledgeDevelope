###### 1. RabbitMQ 有哪些交换器类型？
RabbitMQ 遵循 AMQP 0-9-1 协议，提供了四种核心的交换器类型，用于实现不同的消息路由模式。这些类型在 Java 客户端中由 `BuiltinExchangeType`枚举类定义 。

|交换器类型|枚举值|核心路由规则|典型应用场景|
|---|---|---|---|
|**Direct Exchange**​|`BuiltinExchangeType.DIRECT`|**精确匹配**​ Routing Key|点对点消息、任务队列、按日志级别路由|
|**Fanout Exchange**​|`BuiltinExchangeType.FANOUT`|**忽略**​ Routing Key，进行广播|发布/订阅、广播通知、群发消息|
|**Topic Exchange**​|`BuiltinExchangeType.TOPIC`|**模糊匹配**​ Routing Key（支持通配符）|多层级主题订阅、根据多种属性路由消息|
|**Headers Exchange**​|`BuiltinExchangeType.HEADERS`|**忽略**​ Routing Key，基于消息头（Headers）匹配|基于消息体属性（如版本、语言）的复杂路由|
此外，RabbitMQ 还内置了一个 **默认交换器（Default Exchange）**，它是一个没有名称（`""`）的 Direct 类型交换器 。
###### 2. Direct Exchange 的工作原理是什么？
**工作原理**：Direct Exchange 通过精确匹配消息的 **路由键（Routing Key）**​ 和队列与交换器绑定时设定的 **绑定键（Binding Key）**​ 来决定消息的路由路径。如果两者完全一致，消息就会被投递到对应的队列中 。
Java 代码示例**：
以下代码展示了如何声明一个 Direct Exchange 并发送一条路由到特定队列的消息。
```java
// 1. 声明一个持久化的 Direct Exchange
channel.exchangeDeclare("my_direct_exchange", BuiltinExchangeType.DIRECT, true);

// 2. 声明一个队列
channel.queueDeclare("error_queue", true, false, false, null);

// 3. 将队列绑定到交换器，并指定 Binding Key 为 "error"
channel.queueBind("error_queue", "my_direct_exchange", "error");

// 4. 发送一条消息，并指定其 Routing Key 为 "error"
String message = "An error occurred!";
// 这条消息会被路由到 "error_queue"
channel.basicPublish("my_direct_exchange", "error", null, message.getBytes());
```
**源码与设计角度**：
在 RabbitMQ 的 Erlang 源码实现中，可以理解为它维护了一个路由表。当消息到达 Direct Exchange 时，它会像一个 **哈希表（Hash Table）**​ 查找过程，使用 Routing Key 作为键（Key）来快速检索所有与之匹配的绑定队列。这种实现方式使得路由决策的时间复杂度接近 O(1)，非常高效。
**应用场景**：最典型的场景是日志系统，不同的日志级别（`info`, `warning`, `error`）可以绑定到不同的队列，由不同的消费者处理 。
###### 3. Topic Exchange 的工作原理是什么？
**工作原理**：Topic Exchange 在 Direct Exchange 精确匹配的基础上，引入了强大的 **通配符**​ 机制，允许进行灵活的模糊匹配。Routing Key 和 Binding Key 都是由点号（`.`）分隔的多个单词组成的字符串 。
**通配符规则**：
- `*`（星号）：匹配**恰好一个**单词。例如，绑定键 `*.orange.*`可以匹配路由键 `quick.orange.rabbit`，但不能匹配 `quick.orange`或 `lazy.orange.rabbit.fast`。
- `#`（井号）：匹配**零个或多个**单词。例如，绑定键 `lazy.#`可以匹配路由键 `lazy`、`lazy.orange`、`lazy.orange.rabbit`等 。
**Java 代码示例**：
```java
// 声明 Topic Exchange
channel.exchangeDeclare("my_topic_exchange", BuiltinExchangeType.TOPIC, true);

// 队列1：关注所有与美国体育相关的消息
channel.queueDeclare("usa_sports", true, false, false, null);
channel.queueBind("usa_sports", "my_topic_exchange", "usa.sports.*");

// 队列2：关注所有新闻消息，无论来自哪个国家或类别
channel.queueDeclare("all_news", true, false, false, null);
channel.queueBind("all_news", "my_topic_exchange", "#.news");

// 发送消息
// 这条消息会同时进入 "usa_sports" 和 "all_news" 队列
channel.basicPublish("my_topic_exchange", "usa.sports.news", null, "USA wins the championship!".getBytes());
```
**源码与设计角度**：Topic Exchange 的内部实现可以类比为一棵 **Trie 树（前缀树）**。每个由点号分隔的单词是树的一个节点。这种数据结构非常适合进行模式匹配，能够高效地处理包含通配符的绑定键，找到所有可能匹配的路由路径。
**应用场景**：股票市场数据推送（如 `stock.nyse.ibm`）、新闻分类（如 `sports.us.basketball`）等需要根据多重条件进行动态订阅的场景 。
###### 4. Fanout Exchange 的工作原理是什么？
**工作原理**：Fanout Exchange 的行为非常简单粗暴：它**完全忽略**消息的 Routing Key，将收到的每一条消息**无条件地路由到所有与它绑定的队列**​ 。正因为无需进行任何匹配计算，它是所有交换器类型中**性能最高、速度最快**的 。
**Java 代码示例**：
```java
// 声明 Fanout Exchange
channel.exchangeDeclare("my_fanout_exchange", BuiltinExchangeType.FANOUT, true);

// 声明三个队列，并都绑定到同一个 Fanout Exchange
channel.queueDeclare("queue_a", true, false, false, null);
channel.queueDeclare("queue_b", true, false, false, null);
channel.queueDeclare("queue_c", true, false, false, null);

// 绑定时空的 Routing Key 通常用 ""，但会被忽略
channel.queueBind("queue_a", "my_fanout_exchange", "");
channel.queueBind("queue_b", "my_fanout_exchange", "");
channel.queueBind("queue_c", "my_fanout_exchange", "");

// 发送一条消息，Routing Key 可以是任意值，不影响结果
// 这条消息会同时出现在 queue_a, queue_b, queue_c 中
channel.basicPublish("my_fanout_exchange", "any.routing.key", null, "Broadcast message!".getBytes());
```
**应用场景**：系统全局广播、聊天室中的"用户上线"通知、需要同时更新多个分布式缓存的数据同步等 。
###### 5. Headers Exchange 的工作原理是什么？
**工作原理**：Headers Exchange 不依赖于 Routing Key，而是根据消息的 **Headers 属性**（一个键值对集合）进行匹配。在绑定队列时，需要指定一组用于匹配的键值对条件，并设置一个关键的 `x-match`参数 。
- `x-match = all`：消息的 Headers 必须**完全包含**绑定时指定的所有键值对（值相等）才算匹配。相当于逻辑 **与（AND）**​ 操作。
- `x-match = any`：消息的 Headers 只需**包含**绑定键值对中的**任意一个**就算匹配。相当于逻辑 **或（OR）**​ 操作 。
**Java 代码示例**：
```java
// 声明 Headers Exchange
channel.exchangeDeclare("my_headers_exchange", BuiltinExchangeType.HEADERS, true);

// 绑定队列时设置参数
Map<String, Object> bindingArgs = new HashMap<>();
bindingArgs.put("format", "pdf");
bindingArgs.put("type", "report");
bindingArgs.put("x-match", "all"); // 必须同时满足 format=pdf 和 type=report

channel.queueDeclare("pdf_reports", true, false, false, null);
channel.queueBind("pdf_reports", "my_headers_exchange", "", bindingArgs);

// 发送消息时设置 Headers
AMQP.BasicProperties.Builder propsBuilder = new AMQP.BasicProperties.Builder();
Map<String, Object> headers = new HashMap<>();
headers.put("format", "pdf");
headers.put("type", "report");
propsBuilder.headers(headers);

// 这条消息会被路由到 "pdf_reports" 队列
channel.basicPublish("my_headers_exchange", "", propsBuilder.build(), "Report content".getBytes());
```
**应用场景与对比**：Headers Exchange 适用于路由规则基于消息自身多种属性（如消息格式、版本号、来源系统）的复杂场景。但由于需要进行复杂的属性匹配，其**性能相对较差**，在实际业务中远不如前三种交换器常用 。
###### 6. 默认交换器（Default Exchange）是什么？
默认交换器是一个 RabbitMQ 预先声明好的、Direct 类型的交换器，其名称为**空字符串**​ `""`。
**工作方式**：每个队列在创建时，都会**自动**以队列名作为 Binding Key 绑定到这个默认交换器。因此，当生产者发送消息时，如果将交换器名称指定为空字符串，并设置 Routing Key 为某个已存在的队列名，消息就会直接被路由到该队列。
**Java 代码示例**：
```java
// 不声明交换器，直接发送消息到队列 "my_queue"
// RabbitMQ 会使用默认交换器
channel.basicPublish("", "my_queue", null, "Hello World".getBytes());
// 等效于使用一个名为 "" 的 Direct Exchange，并进行了如下绑定：
// channel.queueBind("my_queue", "", "my_queue");
```
###### 7. Topic 模式的通配符有哪些？如何使用？
如第3点所述，Topic 模式的通配符是 `*`和 `#`。
**使用总结与注意事项**：
- **分隔符**：单词必须用点号 `.`分隔。
- `*`的用法：用于替代一个**必须存在**的单词。`usa.*`可以匹配 `usa.news`但不能匹配 `usa`。
- `#`的用法：非常灵活，可以匹配零个、一个或多个单词。
    - `usa.#`可以匹配 `usa`, `usa.news`, `usa.news.sports`。
    - 单独的 `#`会匹配所有消息，功能类似 Fanout Exchange 。
- **组合使用**：可以灵活组合，例如 `*.news.*`匹配任何中间部分为 `news`的三段式路由键。