### 一、Java 语言基础

###### 1. Java 语言有哪些特点⁠⁠​？
   Java 语言是一种被广泛使用的面向对象编程语言，具有以下核心特点：
- ==**面向对象**：Java 支持封装、继承、多态等面向对象特性，鼓励以对象为中心设计程序，提高代码的可维护性和复用性。==
- ==**平台无关性与跨平台性**：Java 程序通过编译生成字节码（.class 文件），由 Java 虚拟机（JVM）在不同平台上解释执行，实现"一次编写，到处运行"。==
- ==**健壮性**：Java 提供强类型检查、异常处理机制和自动内存管理（垃圾回收），有效减少程序崩溃和内存泄漏问题。==
- ==**安全性**：Java 内置安全机制，如沙箱（Sandbox）模型、字节码验证器和访问控制，防止恶意代码攻击。==
- ==**多线程支持**：Java 在语言级别支持多线程编程，允许程序同时执行多个任务，提高并发性能和资源利用率。==
- **简单易学**：Java 语法类似于 C++，但摒弃了 C++ 中复杂的特性（如指针、运算符重载、多重继承），并提供了自动垃圾回收机制，降低了学习门槛和编程复杂度。
- **分布式支持**：Java 提供网络编程类库（如 java.net 包），便于开发分布式应用和 Web 服务。
- **高性能**：通过即时编译器（JIT）将热点代码编译为本地机器码，性能接近 C++，同时垃圾回收机制优化了内存使用。
- **动态性**：支持运行时加载类、反射机制等，使程序能适应变化的环境
###### 2. 说说你对 JDK、JRE、JVM 的理解⁠⁠​？
JDK、JRE 和 JVM 是 Java 技术的核心组件，关系紧密但职责不同：
- **JVM（Java Virtual Machine，Java 虚拟机）**：是虚拟的计算机，负责将 Java 字节码（.class 文件）解释或编译为特定平台的机器指令执行。JVM 是 Java 跨平台的基础，不同平台有对应的 JVM 实现。
- **JRE（Java Runtime Environment，Java 运行环境）**：是运行 Java 程序所需的环境，包含 JVM 和 Java 核心类库（如 java.lang、java.util）。用户只需安装 JRE 即可运行已编译的 Java 程序，但无法进行开发。
- **JDK（Java Development Kit，Java 开发工具包）**：是开发者使用的工具集，包含 JRE 以及开发工具（如编译器 javac、调试器 jdb、打包工具 jar）。JDK 用于编写、编译和调试 Java 代码。
- **三者的关系**：JDK ⊃ JRE ⊃ JVM。即 JDK 包含 JRE，JRE 包含 JVM。开发 Java 程序需要 JDK，而运行程序只需 JRE
###### 3. Java 是如何实现跨平台的?⁠​
Java 通过 **Java 虚拟机（JVM）** 和 **字节码机制** 实现跨平台，具体过程如下：
- **编译阶段**：Java 源代码（.java）被编译器（javac）编译成与平台无关的字节码（.class 文件），而不是直接生成机器码。字节码是一种中间格式，不依赖任何特定操作系统或硬件。
- **运行阶段**：不同平台（如 Windows、Linux、macOS）安装对应的 JVM。JVM 将字节码加载到内存，通过解释器或即时编译器（JIT）将其转换为当前平台的本地机器指令并执行。由于字节码是标准化的，而各平台 JVM 负责适配本地环境，因此同一份字节码可在不同平台上运行，实现"一次编写，到处运行"。
- **关键点**：JVM 屏蔽了底层平台的差异，使开发者无需关注操作系统细节。但 JVM 本身不跨平台，每个平台需安装专属 JVM 实现
###### 4. 简单说说你写的 java 程序是如何执行的?⁠​
一个Java程序从源代码到最终执行，主要经历编译和运行两大阶段。

```mermaid
flowchart TD
    A[Java源代码<br>.java文件] -->|编译| B[字节码文件<br>.class文件]
    B -->|加载| C[类加载器<br>ClassLoader]
    C -->|验证| D[字节码校验]
    D -->|准备| E[为静态变量<br>分配内存并设默认值]
    E -->|解析| F[将符号引用<br>转换为直接引用]
    F -->|初始化| G[执行静态代码块<br>初始化静态变量]
    G --> H{执行引擎}
    H -->|解释执行| I[解释器<br>逐行翻译字节码为机器码]
    H -->|即时编译| J[JIT编译器<br>编译热点代码为本地机器码]
    I --> K[操作系统执行机器指令]
    J --> K
```

①编译阶段：从 `.java`到 `.class`
用 `javac`命令编译 `.java`源文件时，会经历词法分析、语法分析（生成抽象语法树）、语义分析等步骤，最终生成平台无关的 `.class`字节码文件。字节码是JVM的机器语言。
②运行阶段：
1. **类加载（Loading & Linking）**
    JVM的类加载器（ClassLoader）会去寻找并加载所需的 `.class`文件。加载后，会进行**链接（Linking）**，包括：
    - **验证**：确保字节码是安全合法的。
    - **准备**：为类变量（静态变量）分配内存并设置默认初始值（如int为0）。
    - **解析**：将常量池中的符号引用转换为直接引用。
    - **初始化**：执行类中的静态变量赋值语句和静态代码块。
2. **执行引擎（Execution Engine）如何工作**
    加载和初始化完成后，JVM的**执行引擎**负责执行字节码。
    - **解释执行**：执行引擎中的解释器（Interpreter）会逐行读取字节码，并快速地将其翻译成本地机器码并执行。优点是启动快，立即执行；缺点是逐行解释效率相对较低。
    - **即时编译（JIT Compilation）**：为了提升性能，JVM会监控代码的执行频率。对于那些被频繁调用的“**热点代码**”（如循环、常用方法），**JIT（Just-In-Time）编译器**会将其整个方法或代码块编译成本地机器码。这样，下次再执行这段代码时，就可以直接运行高效的本地机器码，无需再次解释，大大提高了长期运行的性能。这是一种在程序运行时进行的编译。
3. **内存管理（自动垃圾回收）**
    程序运行中创建的对象都存放在堆（Heap）内存中。JVM内置了**垃圾回收器（GC， Garbage Collector）**，它会自动回收不再使用的对象所占用的内存，从而避免了像C/C++那样需要手动管理内存可能带来的内存泄漏问题。
###### 5. 标识符的命名规则⁠?⁠​
标识符是用来为 Java 中的变量、方法、类、包等元素命名的符号。
**硬性规则（必须遵守，否则编译错误）**：
1. **组成字符**：可以由字母（A-Z, a-z）、数字（0-9）、下划线（_ ）和美元符号（$）组成。
2. **首字符**：**不能以数字开头**。
3. **区分大小写**：`myVar`和 `myvar`是两个不同的标识符。
4. **不能是关键字或保留字**：如 `class`, `public`, `static`, `void`等不能作为标识符。
5. **长度无限制**。
**特别注意**：虽然 Java 使用 Unicode 字符集，理论上可以使用中文等字符作为标识符，但**强烈不建议这样做**，会降低代码的可维护性和专业性。
###### 6. Java中的main方法为什么要声明为public static void?⁠
Java 中的 `main`方法声明为 `public static void`是由 Java 虚拟机（JVM）的调用机制决定的。
- **`public`**：`main`方法是程序的入口，JVM 需要从类的外部调用这个方法。`public`访问修饰符确保了 JVM 在任何情况下都能无障碍地访问到这个方法。
- **`static`**：JVM 在启动时，还没有创建包含 `main`方法的类的任何对象实例。`static`关键字表示该方法是**属于类本身**的，而不是属于某个对象。因此，JVM 可以直接通过类名来调用 `main`方法，而无需先实例化对象，这简化了程序的启动过程。
- **`void`**：`main`方法作为程序的起点，它执行完毕后，不需要向 JVM 返回一个结果。`void`关键字表明该方法**没有返回值**。任何返回值对 JVM 来说都没有意义。
**总结**：这个特定的方法签名是一个约定俗成的规范，确保了 JVM 能够**简单、直接地找到并执行**程序的入口点。
###### 7. 什么是字节码？字节码的好处是什么？
字节码是Java实现“一次编写，到处运行”（Write Once, Run Anywhere）理念的核心。

```mermaid
flowchart TD
    A[Java源代码<br>.java文件] --> B[编译<br>javac]
    B --> C[字节码文件<br>.class文件]
    C --> D{Java虚拟机<br>JVM}
    
    D --> E[类加载器<br>Loading]
    E --> F[链接<br>Linking]
    F --> G[初始化<br>Initialization]
    G --> H[执行引擎<br>Execution Engine]
    H --> I[解释器<br>Interpreter]
    H --> J[即时编译器<br>JIT Compiler]
    I & J --> K[本地机器码<br>Native Code]
    
    C --> L[字节码结构]
    L --> M[魔数<br>0xCAFEBABE]
    L --> N[版本号]
    L --> O[常量池]
    L --> P[访问标志]
    L --> Q[类/父类/接口索引]
    L --> R[字段表]
    L --> S[方法表<br>含字节码指令]
    L --> T[属性表]
```

简单来说，字节码（Bytecode）**是一种由Java编译器（`javac`）生成的、与特定机器指令集无关的中间代码，保存在 `.class`文件中。它本质上是 JVM 的机器语言指令集**。
- **平台无关的中间表示**：字节码不是直接面向任何特定的物理CPU（如x86或ARM），而是面向JVM这个抽象层。这使得它独立于底层硬件和操作系统。
- **二进制格式与紧凑结构**：字节码采用二进制格式存储，比源代码更紧凑。一个 `.class`文件具有严格的结构，包含魔数（`0xCAFEBABE`）、版本号、常量池、访问标志、字段表、方法表（内含字节码指令）等组成部分。
- **基于栈的计算模型**：JVM采用栈架构来执行字节码，大多数指令通过操作数栈进行数据处理，而非直接依赖于寄存器。
采用字节码为Java生态系统带来了多方面的重要好处。

| 优势             | 核心说明                                                | 价值体现                             |
| -------------- | --------------------------------------------------- | -------------------------------- |
| **跨平台性**       | 一次编译，到处运行。字节码由JVM解释或编译执行，JVM屏蔽了不同平台的差异。             | 显著降低了程序部署和分发的复杂性，是Java成功的基石。     |
| **安全性**        | JVM在执行字节码前会进行严格的验证，防止有害操作，同时Java字节码无法直接操作内存。        | 为网络环境下的代码执行提供了安全沙箱。              |
| **高性能（JIT优化）** | JVM会监控代码执行频率，通过即时编译器将热点字节码编译成本地机器码并缓存，大幅提升性能。       | 使Java应用在长期运行的服务端场景中能获得接近本地代码的效率。 |
| **动态性与灵活性**    | 支持运行时动态加载和修改字节码，反射机制也依赖于字节码的运行时信息。                  | 是实现热部署、AOP、动态代理等重要特性的基础。         |
| **强大的生态与工具支持** | 字节码是许多开发工具（如反编译、调试、性能分析工具）和框架（如Spring AOP）直接操作的对象。  | 方便开发者分析、调试、优化和增强程序行为。            |
| **跨语言支持**      | JVM成为了一个通用的运行时平台，其他语言如Kotlin、Scala等也可编译成字节码在JVM上运行。 | 丰富了JVM生态。                        |

如何查看与分析字节码，可以使用JDK自带的 `javap`工具来查看字节码。
1. **编译Java源文件**：首先使用 `javac YourClass.java`生成 `.class`文件。
2. **反编译查看字节码**：使用 `javap -c YourClass`可以输出易于阅读的字节码指令序列。添加 `-verbose`参数（`javap -c -verbose YourClass`）能获得更详细的信息，包括常量池、方法描述符等。

了解字节码的实用场景
- **代码优化**：通过分析关键代码路径的字节码，可以发现潜在的性能瓶颈，例如不必要的自动装箱、创建多余临时对象等。
- **问题排查**：当遇到一些底层机制相关的问题（如序列化、反射、同步等问题）时，查看字节码可能有助于理解深层原因。
- **字节码增强技术**：许多高级框架（如Spring的AOP功能）在运行时通过ASM、Byte Buddy等库动态修改或生成字节码，实现强大功能。
### 二、面向对象

###### 1. 面向对象和面向过程的区别?
| 特性         | 面向对象编程 (OOP)                                      | 面向过程编程 (POP)                                 |
| ---------- | ------------------------------------------------- | -------------------------------------------- |
| **编程思想**​  | 以**对象**为中心，对象是数据和行为的封装体。分析问题由哪些实体参与，这些实体有哪些属性和方法。 | 以**过程/步骤**为中心。将问题分解成一系列步骤，然后用函数实现这些步骤，按顺序调用。 |
| **数据与功能**​ | **封装**在一起，数据和对数据的操作绑定在对象中。                        | **相分离**，数据通常作为全局变量或参数传递给函数。                  |
| **程序结构**​  | 使用**类**和**对象**组织代码，更易于模拟现实世界，适合复杂、需协作的系统。         | 使用**函数**作为组织代码的基本单元。                         |
| **抽象级别**​  | 抽象级别更高，通过类和对象隐藏实现细节。                              | 抽象级别较低，更直接地操作数据和逻辑。                          |
| **核心特性**​  | 封装、继承、多态。                                         | 不支持继承和多态。                                    |
| **优势**​    | 代码**易维护、易复用、易扩展**，更适合应对复杂和变化的系统需求。                | **性能**通常更优，流程控制直接，适合性能敏感的场景（如嵌入式系统）或简单任务。    |
| **典型语言**​  | Java, C++, Pytho。                                 | C, Fortran。                                  |
###### 2. 说说面向对象编程三大特性⁠?
面向对象编程的三大基本特性是封装、继承和多态。
1. **封装（Encapsulation）**
    封装是将对象的**数据（属性）和行为（方法）捆绑在一起成为一个独立的单位（即类），并隐藏对象的内部实现细节**。通常，对象的属性会被设置为私有（private），只通过公共（public）的方法提供给外部访问和操作。这样做的好处是控制了外部代码对对象内部状态的随意修改，提高了代码的安全性和可维护性。
2. **继承（Inheritance）**
    继承是一种机制，它允许创建一个新类（子类或派生类）来**继承**另一个现有类（父类或基类）的**属性和方法**。这样可以实现代码的复用，并且子类可以在继承的基础上进行扩展，添加新的属性和方法，或修改父类的方法（重写）。继承清晰地描述了类与类之间“是（is-a）”的关系。
3. **多态（Polymorphism）**
    多态是指**同一个行为具有多个不同表现形式**的能力。在OOP中，它通常表现为：父类的引用变量可以指向子类的对象，且通过这个父类引用调用方法时，实际执行的是子类重写的方法。多态增强了程序的灵活性和可扩展性。
###### 3. 什么是多态机制？
多态机制是面向对象编程的核心特性之一，它允许**同一操作作用于不同的对象，可以产生不同的执行结果**。简单来说，就是“用一个接口，实现多种功能”。
多态的存在主要依赖于以下两点：
- **继承关系**：存在继承关系的类层次结构。
- **方法重写**：子类对父类的方法进行重新定义。
在程序运行时，JVM会根据实际对象的类型来动态决定调用哪个方法，这种行为称为**动态绑定**或**晚期绑定**。多态的最大意义在于，它允许程序在编写时面向父类（或接口）等通用类型编程，而在运行时却可以执行子类的具体实现，从而提高了代码的通用性和可扩展性。例如，一个“动物”父类有“叫”的方法，其子类“狗”和“猫”都重写了“叫”的方法。当使用“动物”引用指向一个“狗”对象并调用“叫”的方法时，实际执行的是狗的叫声，这便是多态的体现。
###### 4. 说说重载和重写的区别⁠?
重载（Overload）和重写（Override）都是实现多态的方式，但二者有本质区别。

| 特性        | 方法重载 (Overload)                    | 方法重写 (Override)                           |
| --------- | ---------------------------------- | ----------------------------------------- |
| **发生范围**​ | 发生在**同一个类内部**。                     | 发生在**具有继承关系的父类和子类之间**。                    |
| **方法名**​  | **必须相同**。                          | **必须相同**。                                 |
| **参数列表**​ | **必须不同**（参数类型、个数或顺序不同）。            | **必须完全相同**。                               |
| **返回类型**​ | **可以修改**，不能仅以返回类型不同作为重载的标准。        | 返回类型需要**相同或是父类方法返回类型的子类**。                |
| **访问权限**​ | **可以修改**，可以改变方法的访问修饰符。             | 子类方法的访问权限**不能比父类方法更严格**（即要大于等于父类权限）。      |
| **异常抛出**​ | **可以修改**，可以声明新的或更广的检查异常。           | 子类方法抛出的异常类型**不能比父类方法声明的更宽泛**（即要小于等于父类异常）。 |
| **本质**​   | 一个类中**同名不同参**的方法，是**编译时多态**（静态多态）。 | 子类对父类方法的**重新实现**，是**运行时多态**（动态多态）。        |
###### 5. 重载的方法能否根据返回类型进行区分?⁠
**不能。重载的方法**不能仅根据返回类型的不同来区分。
因为编译器在决定调用哪个重载方法时，是**根据方法调用的实参列表来匹配的**，与方法的返回类型无关。如果在同一个类中定义了两个方法名相同、参数列表也完全相同，仅返回类型不同的方法，编译器将无法区分，会导致编译错误。
例如，以下代码是错误的：
```java
public class Example {
    public int calculate(int a, int b) { ... }
    public double calculate(int a, int b) { ... } // 编译错误：已存在 calculate(int, int) 的方法
}
```
###### 6. 简单说说 Java 中接口和抽象类的区别?
| 特性         | 接口 (Interface)                                                                                | 抽象类 (Abstract Class)                                 |
| ---------- | --------------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| **定义关键字**​ | `interface`                                                                                   | `abstract class`                                     |
| **方法实现**​  | 在 Java 8 之前，所有方法都是**抽象方法**（隐式 `public abstract`），不能有具体实现。Java 8 后允许有 `default`和 `static`方法实现。 | 可以包含**抽象方法**（无方法体）和**具体实现的方法**。                      |
| **成员变量**​  | 变量默认为 `public static final`（常量）。                                                              | 变量可以是各种访问权限的普通成员变量。                                  |
| **构造方法**​  | **没有**构造方法。                                                                                   | **有**构造方法（虽然不能实例化，但可用于子类初始化）。                        |
| **继承方式**​  | 一个类可以**实现多个接口**（`implements Interface1, Interface2`）。                                         | 一个类只能**继承一个抽象类**（`extends AbstractClass`），Java 是单继承。 |
| **设计目的**​  | 定义一套**行为规范**，强调“能做什么”的契约。核心是 **"has-a"**​ （具有某种能力）的关系。                                        | 表示一种 **"is-a"**​ （是一种）的层次关系，用于代码复用和模板设计。             |
###### 7. 抽象类能使用 final 修饰吗？⁠
**不能。不能**被 `final`修饰。
因为 `abstract`和 `final`关键字的设计目的本质上是**冲突**的：
- `abstract`修饰的类**必须被继承**才能使用，它的价值需要子类来实现其抽象方法并创建实例来体现。
- `final`修饰的类表示**不可被继承**，是最终形态。
如果一个类被同时声明为 `abstract final`，则意味着它既需要被子类继承，又不允许被子类继承，这会产生矛盾，所以 Java 语法不允许这样做。
###### 8. 抽象的（abstract）方法是否可同时是静态的?⁠
**不能。 `abstract`方法和 `static`方法不能同时修饰一个方法。
原因如下：
- `abstract`方法是一个**没有方法体的抽象方法**，它**必须被子类重写**才能使用。它的调用是与具体的对象实例动态绑定在一起的（多态）。
- `static`方法（静态方法）是**属于类本身**的，它可以通过类名直接调用，**不需要创建对象实例**。静态方法也不能被重写（Override），只可以被隐藏。
由于 `abstract`方法要求被子类实现，而 `static`方法与具体实例无关，二者在语义上是矛盾的。因此，Java 不允许定义一个抽象静态方法。
###### 9. 什么是封装？如何实现封装？
封装是面向对象编程的核心理念之一，它有两个基本含义：
- **将数据（属性）和操作数据的行为（方法）捆绑在一起**，形成一个独立的单元（即类）。
- **隐藏对象的内部实现细节**，仅对外提供有限的、可控的访问方式。
实现封装通常通过以下步骤：
- **使用访问修饰符**：将类的成员变量（属性）声明为 **`private`**。这样，这些属性就不能被该类以外的代码直接访问，实现了信息的隐藏。
- **提供公共的访问方法**：为需要被外部访问或修改的私有属性，提供公共的（`public`）getter（获取值）和 setter（设置值）方法。在这些方法中，可以加入逻辑控制，对数据的有效性进行验证，确保对象的状态始终是安全有效的。
例如，一个 `BankAccount`类的封装实现：
```java
public class BankAccount {
    // 1. 将关键数据私有化
    private double balance;

    // 2. 通过构造方法初始化，也可控制逻辑
    public BankAccount(double initialBalance) {
        if (initialBalance >= 0) {
            this.balance = initialBalance;
        } else {
            this.balance = 0;
        }
    }

    // 3. 提供公共的方法来访问和修改数据，并加入控制逻辑
    public void deposit(double amount) { // 存款
        if (amount > 0) {
            balance += amount;
        }
    }

    public boolean withdraw(double amount) { // 取款，加入业务逻辑
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            return true;
        }
        return false;
    }

    public double getBalance() { // 获取余额，只提供读权限
        return balance;
    }
    // 不提供 setBalance 方法，防止余额被随意修改
}
```
封装的好处在于提高了代码的**安全性**和**可维护性**。内部实现的改变只要不影响到公共方法的签名，就不会影响外部调用者。
###### 10. 接口和抽象类各自的使用场景是什么？
选择使用接口还是抽象类，取决于具体的设计需求：
**优先考虑使用接口的场景：**
- **定义行为契约**：当需要定义一组不相关的类**都应该遵循的某种行为规范**时。例如，`Flyable`（可飞行的）、`Serializable`（可序列化的），这些能力与类的本身层次关系不大。
- **需要多重继承**：由于 Java 的单继承限制，当一个类需要具备多种不同能力时，通过实现多个接口来扩展功能是最佳选择。
- **作为架构的骨架**：在框架设计中，接口常用于定义模块之间的通信契约，降低耦合，提高系统的灵活性和可扩展性。
**优先考虑使用抽象类的场景：**
- **代码复用和模板设计**：当多个相关的类**共享一些通用的状态或行为**时，可以将这些共性的内容放在抽象类中实现，让子类继承，避免代码重复。抽象类可以提供一些部分实现的方法，作为模板。
- **定义紧密的类层次结构**：当要描述的是一种严格的 **"is-a"**​ （是一种）关系，并且这些类有很强的内在联系时。例如，`Animal`作为抽象类，其子类 `Dog`, `Cat`都是动物。
简单来说，**接口关注于功能，抽象类关注于共性**。在现代设计中，有一种“面向接口编程”的趋势，即优先使用接口来定义类型，以获得最大的灵活性，然后用抽象类或具体类去实现它，结合二者的优点。
### 三、数据类型与变量

###### 1. 说说八种基本数据类型的大小，以及他们的封装类⁠？⁠​
Java 的八种基本数据类型及其封装类如下：

|**基本数据类型**|**大小（字节）**|**封装类**|**取值范围/说明**|
|---|---|---|---|
|`byte`|1|`Byte`|-128 ~ 127|
|`short`|2|`Short`|-32768 ~ 32767|
|`int`|4|`Integer`|-2^31 ~ 2^31-1|
|`long`|8|`Long`|-2^63 ~ 2^63-1|
|`float`|4|`Float`|单精度浮点数|
|`double`|8|`Double`|双精度浮点数|
|`char`|2|`Character`|Unicode字符，0~65535|
|`boolean`|未严格定义（通常1位）|`Boolean`|true/false|

###### 2. char 型变量中能不能存贮一个中文汉字? 为什么?⁠⁠​
**可以**。原因在于：
- Java 的 `char`类型采用 **Unicode 编码**，占 **2 字节（16 位）**，可表示的范围是 0~65535（即 Unicode 字符集）。
- 中文汉字属于 Unicode 字符集的一部分（如常用汉字在 CJK 统一编码区间），每个汉字对应一个 Unicode 码点，因此可以被 `char`变量存储。
例如：

```java
char ch = '中';// 合法，存储汉字'中'
```

但需注意：某些生僻字或表情符号可能超出 Basic Multilingual Plane（BMP），需使用两个 `char`（即 `String`）表示。
###### 3. Java 中包装类型和基本类型的区别是什么⁠​？
Java 中的基本类型（Primitive Types）和包装类型（Wrapper Classes）在设计目的和特性上有显著区别，主要体现在以下几个方面：

| **特性**     | **基本类型**                            | **包装类型**                                                    |
| ---------- | ----------------------------------- | ----------------------------------------------------------- |
| **本质**     | 是 Java 预定义的简单数据类型，不是对象              | 是对基本类型的封装，是真正的类                                             |
| **声明与初始化** | 直接使用（如 `int num = 10;`），无需 `new`    | 通常需要使用 `new`关键字（如 `Integer num = new Integer(10);`），但支持自动装箱 |
| **存储方式**   | 变量直接存储**数据值**，通常在栈内存中               | 变量存储的是对象的**引用（地址）**，对象本身存储在堆内存中                             |
| **默认值**    | 有默认值（如 `int`为 0，`boolean`为 `false`） | 默认值为 `null`                                                 |
| **可空性**    | **不能**为 `null`                      | **可以**为 `null`                                              |
| **功能方法**   | 没有方法，只是一个数据值                        | 提供了丰富的实用方法（如 `Integer.parseInt()`、`Integer.valueOf()`）      |
| **泛型支持**   | **不能**用于泛型（如 `List<int>`是错误的）       | **可以**用于泛型（如 `List<Integer>`是正确的）                           |
| **性能**     | 更高效，因为直接在栈上分配，开销小                   | 相对较低，因为需要在堆上创建和回收对象，有额外开销                                   |
| **适用场景**   | 适用于大量计算、性能要求高的场景                    | 适用于集合框架、需要对象特性的场景（如可空性、作为方法参数传递对象）                          |

###### 4. 说说 Java 自动装箱与拆箱⁠⁠​？
自动装箱（Auto-boxing）和自动拆箱（Auto-unboxing）是 Java 5 引入的语法糖，用于简化基本类型和对应包装类型之间的转换
- **自动装箱**：指基本数据类型**自动转换**为对应的包装类对象。
``` java
// 手动装箱 (Java 5 之前)
Integer num1 = Integer.valueOf(100);
// 自动装箱 (Java 5 之后)
Integer num2 = 100;// 编译器自动转换为 Integer.valueOf(100)
```
- **自动拆箱**：指包装类对象**自动转换**为对应的基本数据类型。
```java
// 手动拆箱
int value1 = num1.intValue();
// 自动拆箱
int value2 = num2;// 编译器自动转换为 num2.intValue()
```
**实现原理**：这本质上是编译器在编译期帮我们完成的代码转换。自装箱时调用的是包装类的 `valueOf()`方法，自动拆箱时调用的是对应的 `xxxValue()`方法（如 `intValue()`。
**主要应用场景**：
- **集合框架（Collection）**：集合（如 `ArrayList`）只能存储对象，当我们添加基本类型时会发生自动装箱。
``` java
List<Integer> list = new ArrayList<>();
list.add(10);// 自动装箱：int -> Integerint 
first = list.get(0);// 自动拆箱：Integer -> int
```
- **泛型（Generics）**：泛型类型参数必须是引用类型。
- **方法参数和返回值传递**。
**注意事项**：
- **空指针异常（NullPointerException）**：如果一个包装类对象为 `null`，对其进行自动拆箱操作会抛出异常。
``` java
Integer nullInteger = null;
int num = nullInteger;// 运行时抛出 NullPointerException
```
- **性能开销**：在循环或大量数据操作中，频繁的装箱和拆箱会创建大量临时对象，增加垃圾回收（GC）压力，影响性能。在性能敏感的场景应谨慎使用 。
- **比较陷阱**：使用 `==`比较包装对象时，需要注意缓存范围。
###### 5. Integer a= 127 与 Integer b = 127 相等吗？⁠​
**相等（使用 `==`比较结果为 `true`）。**
**原因是 Integer 类的缓存机制（Integer Cache）**。默认情况下，Integer 类会缓存 **-128 到 127**之间的所有整数对象。
当通过自动装箱（即直接赋值）或调用 Integer.valueOf(int i) 方法创建 Integer 对象时，如果数值在这个范围内，就会直接返回缓存池中已存在的同一个对象的引用。
```java
Integer a = 127;// 相当于 Integer.valueOf(127)
Integer b = 127;// 相当于 Integer.valueOf(127)
System.out.println(a == b);// true，因为 a 和 b 指向缓存中的同一个对象
```
**但是，如果数值超出缓存范围，结果就不同了**：
```java
Integer c = 128;
Integer d = 128;
System.out.println(c == d);// false，因为 128 超出了默认缓存范围，会创建新的 Integer 对象
```
**要点**：
- 这种缓存机制是一种性能优化，避免频繁创建和销毁小整数对象。
- ==使用 `new Integer(int)`构造器会强制创建新对象，不会使用缓存==。
- 其他包装类也有类似的缓存机制，如 `Byte`缓存所有值（范围是-128 到 127），`Short`、`Long`缓存 -128 到 127，`Character`缓存 0 到 127，`Boolean`缓存 `TRUE`和 `FALSE`。
- 可以使用 `XX:AutoBoxCacheMax=<size>`JVM 参数来调整 Integer 缓存的上限 。
###### 6. 成员变量与局部变量有什么区别？⁠​
| **特性**    | **成员变量**                                                 | **局部变量**                         |
| --------- | -------------------------------------------------------- | -------------------------------- |
| **声明位置**  | 类内部，方法体外。                                                | 方法体、构造方法或代码块内部。                  |
| **生命周期**  | 伴随对象的存在而存在。实例变量随对象创建而诞生，随对象被回收而消亡；静态变量随类的加载而诞生，随类的卸载而消亡。 | 伴随方法的调用而存在，方法调用结束，栈帧弹出，局部变量随之销毁。 |
| **存储位置**  | 实例变量存储在堆内存的对象实体中；静态变量存储在方法区。                             | 存储在栈内存的方法栈帧中。                    |
| **默认值**   | **有默认值**。如数值类型为0，布尔型为false，引用类型为null。                    | **没有默认值**，必须先显式初始化后才能使用，否则编译报错。  |
| **访问修饰符** | 可以使用 `public`, `protected`, `private`, `static`等修饰。      | 不能使用访问修饰符，但可以被 `final`修饰。        |
| **作用域**   | 在整个类内部基本都可以直接访问（静态变量可通过类名访问）。                            | 仅限于定义它的方法、构造方法或代码块内部，出了这个范围即失效。  |
###### 7. 静态变量和实例变量区别?⁠⁠​
静态变量和实例变量是成员变量的两种类型。

|**特性**|**静态变量（类变量）**|**实例变量**|
|---|---|---|
|**归属**|属于**类**，所有对象共享同一份数据。|属于**对象实例**，每个对象都有自己独立的一份副本。|
|**内存分配**|在类加载的初始化阶段分配内存于方法区，仅分配一次。|在每次创建对象实例时，在堆内存中随对象一起分配内存。|
|**调用方式**|既可以通过**类名**直接访问，也可以通过对象引用访问（但不推荐）。|只能通过**对象引用**来访问。|
|**生命周期**|最长，随类的加载而存在，随类的卸载而消亡。|随对象的创建而存在，随对象的垃圾回收而消亡。|
###### 8. 静态变量与普通变量（局部变量）区别?⁠⁠​
|**方面**|**静态变量**|**局部变量**|
|---|---|---|
|**声明位置与作用域**|类内方法外，类级别作用域。|方法或代码块内，块级别作用域。|
|**内存与生命周期**|方法区，生命周期与类相同。|栈内存，生命周期与方法调用相同。|
|**初始化与访问**|有默认值，可通过类名或对象访问。|必须显式初始化，只能在作用域内访问。|
|**修饰符**|可用 `public`, `static`等。|仅可用 `final`。|
###### 9. 3 * 0.1 == 0.3 将会返回什么? true 还是 false?⁠⁠​
这个表达式将返回 **`false`**。
**原因**：这是由**浮点数在计算机中的表示方式**决定的。Java 中的 `float`和 `double`类型遵循 IEEE 754 标准，该标准使用二进制小数来近似表示十进制小数。有些十进制小数（如 `0.1`）无法用二进制小数精确表示。
- 在计算 `3 * 0.1`时，实际结果是一个非常接近但不完全等于 `0.3`的值（例如 `0.30000000000000004`）。
- 当使用 `==`运算符直接比较时，是在比较两个值的精确二进制表示，由于微小的误差，比较结果自然为 `false`。
**正确处理方式**：比较浮点数时，不应使用 `==`，而应检查两数之差的绝对值是否在一个极小的误差范围（epsilon）内。
```java
double result = 3 * 0.1;
double epsilon = 1e-10;// 定义一个极小的误差阈值
boolean isEqual = Math.abs(result - 0.3) < epsilon;// 返回 true
```
对于需要精确计算的场景（如金融），应使用 `BigDecimal`类。
###### 10. 什么是类型转换？自动类型转换和强制类型转换的区别？
类型转换是Java中将一个数据类型的值转换为另一种数据类型的过程。这对于处理不同数据类型之间的赋值、运算和方法调用至关重要。

|特性|自动类型转换 (隐式转换)|强制类型转换 (显式转换)|
|---|---|---|
|**转换方向**|小范围类型 → 大范围类型 (`byte`-> `int`等)|大范围类型 → 小范围类型 (`double`-> `int`等)|
|**语法要求**|自动完成，无需特殊语法|必须显式使用 `(目标类型)`进行转换|
|**数据风险**|安全，通常不会丢失信息|**可能丢失精度**（如小数部分）或**溢出**（超出目标类型范围）|
|**典型场景**|将`int`常量赋值给`long`变量|将`double`转换为`int`（取整）|
|**转换原则**|由编译器自动完成，保证安全性|开发者显式干预，**“后果自负”**|
**自动类型转换（隐式转换）**
自动类型转换就像是将一小杯水倒入一个大桶中，因为目标容器的容量足够大，所以这个过程是安全且自动完成的。
- **发生时机**：当将**数据范围较小**的类型（如 `byte`、`short`）赋值给**数据范围较大**的类型（如 `int`、`long`、`double`）时，编译器会自动进行转换。基本数据类型的转换方向通常遵循：`byte`-> `short`-> `int`-> `long`-> `float`-> `double`，以及 `char`-> `int`。
- **安全性**：这种转换是**安全**的，因为更大范围的类型足以容纳小范围类型的所有信息，通常不会导致数据丢失。
**强制类型转换（显式转换）**
强制类型转换则像是试图将一大桶水强行倒入一个小杯子，你必须明确下指令，并且必须承担可能溢出或洒掉（数据丢失）的风险。
- **发生时机与语法**：当需要将**数据范围较大**的类型赋值给**数据范围较小**的类型时，必须使用强制类型转换。语法是在需要转换的值或变量前加上`(目标类型)`，例如 `int i = (int) 10.5;`。
- **风险与后果**：这是**不安全**的转换，可能导致：
    - **精度丢失**：最常见的是浮点数转换为整数，小数部分会**直接舍弃**，而不是四舍五入。例如，`(int) 10.9`的结果是 `10`。
    - **数据溢出**：如果值超出了目标类型的表示范围，结果将不可预测。例如，将 `128`强制转换为 `byte`（范围-128~127）会得到错误的值 `-128`。
*关键场景与最佳实践*
- **表达式中的自动提升**
	在表达式中，如果存在不同数据类型一起运算，Java会自动将所有操作数提升到表达式中范围最大的那个类型。特别需要注意的是，`byte`、`short`、`char`在参与运算时，会**先自动提升为 `int`类型**。这就是为什么 `byte a = 1; byte b = a + 1;`会编译报错，因为 `a + 1`的结果已经是 `int`类型，不能自动赋值给 `byte`。
- **谨慎使用强制转换**
	由于强制转换存在风险，使用时务必确保你清楚可能的数据丢失后果，并确保转换后的值在目标类型的合理范围内。
- **注意扩展赋值运算符**
    类似 `+=`、`*=`这样的运算符内部**隐含了强制类型转换**。例如 `short s = 1; s += 1;`能正确编译，因为它等价于 `s = (short) (s + 1);`。
- **不相容类型的转换**
    `boolean`类型与其他7种基本数据类型**互不兼容**，不能进行任何形式的类型转换。
###### 11. 为什么浮点数运算会有精度问题？
浮点数运算的精度问题确实常让人困惑。其根源在于，**有些十进制小数无法用二进制精确表示**，以及计算机使用**IEEE 754标准**这类格式，以有限内存来近似表示实数。
下面这个表格汇总了常见精度问题的场景和原因，帮你快速了解：

| 问题场景                 | 示例 (Java代码)                                | 实际输出/结果                | 核心原因                                               |
| -------------------- | ------------------------------------------ | ---------------------- | -------------------------------------------------- |
| **简单加法**             | `System.out.println(0.05 + 0.01);`         | `0.060000000000000005` | 0.05和0.1的二进制表示是无限循环小数，存在舍入误差<br><br>。              |
| **简单减法**             | `System.out.println(1.0 - 0.42);`          | `0.5800000000000001`   | 参与计算的数值在二进制下已存在误差<br><br>。                         |
| **乘法运算**             | `System.out.println(4.015 * 100);`         | `401.49999999999994`   | 二进制表示不精确与运算过程中的舍入误差共同导致<br><br>。                   |
| **循环累加**             | `for (int i=0; i<10; i++) { sum += 0.1; }` | `0.9999999999999999`   | 误差在多次运算中不断累积<br><br>。                              |
| **数值比较**             | `if (0.1 + 0.2 == 0.3)`                    | `false`                | 运算结果的实际二进制表示与0.3的二进制表示不同。                          |
| **构造BigDecimal(错误)** | `new BigDecimal(0.1)`                      | 内部值并非精确的0.1            | `BigDecimal(double)`构造器直接继承了double本身的精度误差<br><br>。 |
*深入理解精度根源*
浮点数精度问题的根源可以归结为以下几个方面：
1. **二进制表示的“先天不足”**
    计算机使用二进制存储数据。对于小数，我们通常采用"乘2取整"的方法将十进制小数转换为二进制，但**很多在十进制下有限的小数，在二进制中会是无限循环的**。
    例如，十进制的0.1在二进制中是一个无限循环小数：`0.0001100110011...`。由于计算机的存储空间有限（float有23位尾数，double有52位尾数），必须对无限小数进行**截断和舍入**，这就引入了最初的误差。这类似于在十进制中无法精确表示1/3（0.333...）一样。
2. **IEEE 754标准与内存表示**
    浮点数在计算机中遵循IEEE 754标准，其表示格式可概括为 `(-1)^s * M * 2^E`，包括符号位（s）、阶码（E）和尾数（M）三部分。以32位的float类型为例，其内存布局如下：
    - **符号位 (s)**: 占1位（第31位），0代表正数，1代表负数。
    - **指数位 (E)**: 占8位（第23-30位），采用**偏移码**（float的偏移量是127）表示，目的是为了表示负指数。
    - **尾数位 (M)**: 占23位（第0-22位），存储的是规格化后二进制小数**小数点后的部分**。因为规格化后总可以表示为1.xxx...的形式，所以最高位的1被隐含，不直接存储，这样实际上获得了24位有效数字的精度。这种基于有限精度和指数表示的模型，本质上是实数的一种**离散化近似**，决定了浮点数无法精确表示所有实数。
3. **误差的累积与放大**
    单个浮点数的表示误差可能很小，但在运算（尤其是连续运算如累加`sum += 0.1`）过程中，这些微小的误差会**不断累积和放大**，最终导致计算结果与理论值出现明显偏差。在科学计算、金融等领域，这种累积误差可能带来严重后果。
*应对精度问题的策略*
核心原则是：**在需要精确计算的场景（特别是商业计算、金融领域），避免直接使用float和double进行计算**。
4. **使用 `BigDecimal`进行精确计算**
    Java提供了`BigDecimal`类来表示和计算精确的小数。它通过一个**未缩放整数值（BigInteger）**和一个**缩放因子（scale）**来表示小数（例如，`BigDecimal`可表示为 `unscaledValue × 10^(-scale)`），从而避免二进制表示问题。
    - **关键点：使用String构造器**
        务必使用`BigDecimal(String val)`构造器，而不是`BigDecimal(double val)`。因为使用double构造器时，不精确的二进制表示已经被带入，无法得到精确值。正确做法是：			
        `// 错误做法：精度已污染`
        `BigDecimal bad = new BigDecimal(0.1);`
        `// 正确做法：精确表示`
        `BigDecimal good = new BigDecimal("0.1");`
    - **比较值：使用 `compareTo()`**
        比较两个`BigDecimal`数值是否相等时，应使用`compareTo()`方法而非`equals()`方法。因为`equals()`还会比较缩放比例（scale），而`compareTo()`仅比较数值本身。
    - **除法运算：指定精度和舍入模式**
        进行除法运算时，如果结果是无限小数，必须指定精度（scale）和舍入模式（RoundingMode），否则会抛出`ArithmeticException`。
        BigDecimal a = new BigDecimal("10");
        BigDecimal b = new BigDecimal("3");
        // 正确：指定保留3位小数，采用四舍五入
        BigDecimal result = a.divide(b, 3, RoundingMode.HALF_UP);
5. **使用整数类型表示最小单位**
    在处理货币时，一个常见且高效的实践是使用**整数类型（如long）来表示金额的最小单位**（例如，用“分”而不是“元”）。这样可以完全避免小数运算。`long priceInCents = 199; // 表示1.99元`
6. **利用工具类简化 `BigDecimal`操作**
    为了方便使用，可以封装一个类似`ArithUtil`的工具类，将基本的四则运算封装起来，内部使用`BigDecimal`并处理字符串转换和精度控制。
### 四、关键字与运算符

###### 1. final 有哪些用法?⁠⁠​
`final`关键字在 Java 中用途广泛，用于表示“不可改变”，可以修饰变量、方法和类。
1. **final 变量（常量）**：
    - 修饰基本类型变量：值一旦初始化就不能再改变。
    - 修饰引用类型变量：引用地址不能改变，但其所指向对象内部的状态（属性值）是可以改变的。
    - 常与 `static`联用定义类常量，如 `public static final double PI = 3.14;`。
2. **final 方法**：
    - 被 `final`修饰的方法不能被子类**重写**。
    - 用于防止继承类改变方法的核心逻辑，或用于效率优化（早期版本，现在已不明显）。
3. **final 类**：
    - 被 `final`修饰的类不能被**继承**。
    - 用于表示这个类已经是“最终”形态，不需要或不允许被扩展，例如 Java 中的 `String`类。
###### 2. 说说 this 关键字的用法?⁠⁠​
`this`关键字在 Java 中是一个指向**当前对象实例**的引用。它的核心用途是帮助在类的内部明确地访问当前对象的成员（变量和方法），尤其在处理命名冲突或需要在多个构造方法之间进行调用时非常有用。
其主要用法可以归纳为以下四个方面：
1. **区分成员变量与局部变量**：当方法的参数名或局部变量名与类的成员变量名相同时，使用 `this.变量名`来明确指定要访问的是当前对象的成员变量，而不是局部变量。这避免了赋值无效或逻辑错误，是 `this`最常用的场景。
  ```java
   public class Person {
     private String name;
      public void setName(String name) {
      this.name = name;// 等号左边的this.name是成员变量，右边的name是方法参数
       }
    }
    ```
2. **在构造方法中调用其他构造方法**：在一个构造方法中，可以使用 `this()`或 `this(参数列表)`来调用同一个类中的其他构造方法。这种调用**必须位于构造方法的第一条语句**，目的是实现代码复用，避免在多个构造方法中编写重复的初始化逻辑。
```java
    public class Person {
       private String name;
       private int age;
    
    public Person() {
        this("未知", 0);// 调用带两个参数的构造器
      }
    
    public Person(String name, int age) {
       this.name = name;
        this.age = age;
	    }
    }
    ```
3. **将当前对象作为参数传递**：在需要将自身实例传递给其他方法或对象的场景下（例如事件监听、回调机制），可以使用 `this`来代表当前对象。
```java
    public class Button {
        public void click() {
            EventManager.register(this);// 将当前按钮对象注册到事件管理器
        }
    }
    ```
    
4. **实现链式调用（Method Chaining）**：通过在方法中返回当前对象（即 `return this;`），可以使多个方法调用连续进行，让代码更加简洁流畅。
```java
    public class Calculator {
        private int result;
        public Calculator add(int value) {
            this.result += value;
            return this;// 返回当前对象，支持链式调用
        }
        public Calculator multiply(int value) {
            this.result *= value;
            return this;
        }
    }
    // 使用方式：
    new Calculator().add(5).multiply(2).getResult();
```

**重要注意事项**：`this`关键字指向的是当前对象的实例，因此它**不能在静态方法（`static`方法）中使用**，因为静态方法属于类本身，不依赖于任何对象实例。
###### 3. 说说 super 关键字的用法?⁠​
`super`关键字在 Java 中是一个指向**当前对象的直接父类**的引用。
它主要用于在子类中访问和调用那些被子类覆盖或隐藏了的父类成员（变量、方法和构造方法）。
其主要用法有以下三种：
1. **调用父类的构造方法**：在子类的构造方法中，必须首先调用父类的构造方法以确保父类部分被正确初始化。这是通过 `super()`或 `super(参数列表)`实现的，并且**这条语句必须位于子类构造方法的第一行**。如果子类构造方法中没有显式写出，编译器会自动加上一个 `super()`调用父类的无参构造方法。
```java
    class Animal {
        public Animal(String type) {
            System.out.println("Animal constructor: " + type);
        }
    }
    class Dog extends Animal {
        public Dog(String name) {
            super("Dog");// 调用父类的有参构造方法，必须放在第一行
            System.out.println("Dog name: " + name);
        }
    }
```
2. **调用父类中被重写的方法**：当子类重写了父类的方法后，如果需要在子类方法中再次使用父类该方法的原始实现，可以使用 `super.方法名()`进行调用。
```java
    class Parent {
        public void display() {
            System.out.println("Parent's display method");
        }
    }
    class Child extends Parent {
        @Override
        public void display() {
            super.display();// 先调用父类的display方法
            System.out.println("Child's display method");
        }
    }
```
3. **访问父类中被隐藏的成员变量**：如果子类中声明的成员变量与父类中的成员变量同名，则父类的变量会被"隐藏"。此时，可以使用 `super.变量名`来访问父类中的那个变量。
``` java
	class Parent {
	    String name = "Parent";
	}
	class Child extends Parent {
	    String name = "Child";
	    void printNames() {
	        System.out.println(super.name);// 输出 "Parent"
	        System.out.println(this.name);// 输出 "Child"
	    }
	}
```
###### 4. this() & super()在构造方法中的区别？⁠​
`this()`和 `super()`都用于构造方法中，且都必须作为构造方法的第一条语句，但它们的目的是完全不同的。

| **特性**   | **`this()`**                   | **`super()`**                 |
| -------- | ------------------------------ | ----------------------------- |
| **调用对象** | 调用**当前类**的其他构造方法               | 调用**父类**的构造方法                 |
| **目的**   | 实现当前类内**构造方法的重用**，减少代码重复       | **初始化从父类继承来的部分**，确保父类被正确构造    |
| **语法要求** | 必须是构造方法中的**第一条语句**             | 必须是构造方法中的**第一条语句**            |
| **共存性**  | **不能**与 `super()`在同一个构造方法中同时出现 | **不能**与 `this()`在同一个构造方法中同时出现 |

**核心区别与选择**：
- 使用 `this()`是为了在本类的多个构造方法之间实现链式调用，目的是让代码更简洁。
- 使用 `super()`是为了显式地调用父类的特定构造方法，这是继承机制中保证对象初始化正确性的基石。
- 在一个构造方法中，你只能选择使用 `this()`或 `super()`其中之一，因为它们都必须占据第一行的位置。如果两者都不写，编译器会默认插入 `super()`。
###### 5. static 都有哪些用法?⁠⁠​
`static`关键字用于修饰类的成员（变量、方法、代码块以及内部类），表示这些成员属于**类本身**，而不是属于类的某个具体实例。因此，静态成员也被称为**类成员**。
1. **静态变量（类变量）**
    - 特点：在内存中只有一份拷贝，在类加载时被初始化。所有该类的实例共享同一份静态变量。
    - 访问方式：推荐通过**类名.变量名**直接访问（如 `Math.PI`），也可以通过对象实例访问（但不推荐）。
    - 与实例变量区别：实例变量是每个对象独有的，互不影响。
2. **静态方法（类方法）**
    - 特点：不依赖于任何对象实例，可以直接通过**类名.方法名()** 调用（如 `Arrays.sort()`）。
    - 限制：静态方法内部**不能直接访问**类的非静态成员（实例变量和实例方法），因为非静态成员需要先创建对象才能存在。静态方法内也不能使用 `this`和 `super`关键字。
    - 常见例子：`main`方法必须是静态的，因为程序启动时还没有创建任何对象。
3. **静态代码块**
    - 特点：用 `static { ... }`定义。在**类被加载到内存时执行一次**，且仅执行一次。执行顺序优先于实例代码块和构造方法。
    - 用途：用于对静态变量进行复杂的初始化，或执行只需进行一次的初始化操作（如加载驱动、建立连接）。
4. **静态内部类**
    - 特点：使用 `static`修饰的内部类。它不依赖于外部类的实例，可以独立创建。静态内部类不能直接访问外部类的非静态成员。
**核心理解**：`static`将成员提升到类级别，使其与实例解耦。静态成员的生命周期与类相同，从类加载开始，到类被卸载结束。
###### 6. &和&&的区别？⁠⁠​
`&`和 `&&`在 Java 中都表示逻辑"与"操作，但它们在行为上有根本性的不同，主要体现在**是否具有"短路"特性**上。

| **运算符**  | **名称**             | **短路特性**                                                          | **用途**                                    |
| -------- | ------------------ | ----------------------------------------------------------------- | ----------------------------------------- |
| **`&&`** | **短路与**            | **有**。如果**第一个操作数为 `false`**，则整个表达式结果必定为 `false`，**不会再去计算第二个操作数**。 | 仅用于**布尔值**的逻辑判断。                          |
| **`&`**  | **逻辑与**（当操作数为布尔值时） | **无**。无论第一个操作数是 `true`还是 `false`，**都会计算两个操作数**。                   | 1. 用于**布尔值**的逻辑判断。 2. 用于**整数**的**按位与**运算。 |

**核心区别与示例**：
- **短路特性是关键**：`&&`的效率通常更高，并且可以避免一些潜在的错误。例如，在检查一个对象不为 `null`后再调用其方法时，使用 `&&`是安全且高效的。
```java
    if (obj != null && obj.isValid()) {// 如果obj为null，&& 不会执行后面的方法，避免NullPointerException
	    // ...
    }
```
	如果使用 `&`，即使 `obj`为 `null`，它也会执行 `obj.isValid()`，从而抛出 `NullPointerException`。
- **`&`的额外功能**：`&`还可以作为按位运算符，对两个整数的二进制每一位进行"与"操作。
```java
    int a = 5;// 二进制 0101
    int b = 3;// 二进制 0011
    int c = a & b;// 结果 0001，即十进制 1
```
**总结**：在绝大多数需要进行逻辑"与"判断的场景下，都应优先使用 `&&`，以利用其短路特性保证效率和安全性。只有在需要确保两边操作数都被执行，或进行按位运算时，才使用 `&`。
###### 7. switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？⁠⁠​
`switch`语句的表达式的类型是有限制的。以下是具体规则：
- **能作用在 `byte`上**：**可以**。`switch`支持 `byte`类型，以及 `short`、`char`、`int`这些整数类型。
- **不能作用在 `long`上**：**不可以**。所有比 `int`大的整数类型，如 `long`，都不能作为 `switch`的表达式的类型。
- **能作用在 `String`上**：**可以（从 Java 7 开始）**。从 Java 7 开始，`switch`支持 `String`类型。
- **其他支持的类型**：还支持枚举（`enum`）类型和它们的包装类（如 `Integer`, `Character`）。
**底层原理**：对于 `String`类型的 `switch`，编译器在底层是通过调用 `hashCode()`和 `equals()`方法将其转换为 `int`值来实现的，从而保持高效性。
###### 8. a=a+b 与 a+=b 有什么区别吗?⁠​
`a = a + b`和 `a += b`的核心区别在于**类型转换**和**底层操作**。

|特性|`a = a + b`|`a += b`|
|---|---|---|
|**操作本质**​|先执行加法运算，再进行赋值操作|复合赋值运算符，是一个单一操作|
|**类型转换**​|需要显式类型转换（针对特定类型）|**自动隐式类型转换**​|
|**底层实现 (Python示例)**​|调用对象的 `__add__`方法|优先调用对象的 `__iadd__`方法|
|**对象影响 (Python示例)**​|对于可变对象，通常创建新对象|对于可变对象，可能在原对象上修改|

**在Java中的关键区别：类型转换**
在Java中，当 `a`是 `byte`、`short`或 `char`类型时，`a + b`的运算结果会**自动提升为 `int`类型**。因此，直接将结果赋回给 `a`会导致编译错误，必须进行显式的强制类型转换。而 `a += b`则由编译器自动完成类型转换。

- **示例 (Java):**

    ```java
    byte a = 10;
    byte b = 20;
    
    // a = a + b; // 编译错误！需要强制转换: a = (byte)(a + b);
    a += b; // 正确！编译器自动转换为: a = (byte)(a + b);
    ```
**在Python中的关键区别：可变与不可变对象**
Python中的区别更为显著，取决于操作对象是可变的（如列表）还是不可变的（如整数、元组、字符串）。
- **对于不可变对象（如整数）**：两者效果类似，都会创建新对象。
  ```python
    a = 5
    print(id(a))  # 输出一个内存地址
    a = a + 3
    print(id(a))  # 输出新的内存地址，a指向了新对象
    ```
  ```python
    a = 5
    print(id(a))
    a += 3
    print(id(a))  # 同样输出新的内存地址
    ```
- **对于可变对象（如列表）**：两者行为有重大差异。
  ```python
    # 使用 a = a + b
    list_a = [1, 2]
    list_b = [3, 4]
    print(id(list_a))  # 输出内存地址X
    list_a = list_a + list_b  # 调用 __add__，创建新列表
    print(id(list_a))  # 输出新的内存地址Y，list_a指向新对象
    ```
    ```python
    # 使用 a += b
    list_a = [1, 2]
    list_b = [3, 4]
    print(id(list_a))  # 输出内存地址X
    list_a += list_b   # 调用 __iadd__，在原列表上扩展
    print(id(list_a))  # 输出相同的内存地址X，原对象被修改
    ```
这是因为 `+=`运算符会尝试调用方法的 `__iadd__`方法（就地修改），如果没有则退而调用 `__add__`方法（创建新对象）。而 `+`运算符直接调用 `__add__`方法。因此，对于列表，`a += b`的性能通常优于 `a = a + b`，因为它避免了创建新对象的开销。
###### 9. 熟悉 instanceOf 关键字的作用吗？⁠⁠​
`instanceof`是Java中的一个二元运算符，用于**在运行时检查一个对象是否属于某个特定类（或接口），或者是否属于其子类**。它返回一个布尔值（`true`或 `false`）。
**基本语法：**
```java
object instanceof ClassName
```
**主要作用与示例：**
1. **类型检查**：在向下转型前进行安全检查，避免 `ClassCastException`。
```java
    Object obj = "Hello";
    if (obj instanceof String) {
        String str = (String) obj; // 安全的向下转型
        System.out.println(str.length());
    }
    ```
2. **多态中的类型判断**：在处理继承体系时，根据具体类型执行不同逻辑。
    ```java
    class Animal {}
    class Dog extends Animal {}
    class Cat extends Animal {}
    
    Animal animal = new Dog();
    
    if (animal instanceof Dog) {
        System.out.println("这是一只狗");
    } else if (animal instanceof Cat) {
        System.out.println("这是一只猫");
    }
    ```
2. **处理泛型集合**：从无泛型的集合（如 `List`）中取出元素时，判断其具体类型。
```java
    List mixedList = new ArrayList();
    mixedList.add("String");
    mixedList.add(new Integer(10));
    
    for (Object item : mixedList) {
        if (item instanceof String) {
            // 处理字符串
        } else if (item instanceof Integer) {
            // 处理整数
        }
    }
    ```
**重要注意事项：**
- 如果被检测的 `object`为 `null`，`instanceof`会返回 `false`，因为 `null`不是任何类的实例。
- `instanceof`考虑了继承关系，如果 `object`是 `ClassName`的子类实例，也会返回 `true`。
###### 10. transient 关键字的作用是什么？
`transient`关键字的主要作用是**在对象序列化时，标记一个成员变量不被序列化**。
当一个类实现了 `java.io.Serializable`接口后，它的对象就可以被序列化（即转换成字节流以便存储或传输）。默认情况下，对象的所有非静态和非 `transient`的成员变量都会被序列化。使用 `transient`修饰变量，可以将其排除在序列化过程之外。
**为什么要使用 transient？**
1. **敏感信息保护**：如密码、银行卡号等字段，不希望被持久化到磁盘或通过网络传输。
2. **节省空间与提升性能**：对于某些可以由其他字段推导出的派生数据或大型临时数据，无需序列化。
3. **序列化无意义的字段**：如线程句柄等依赖于特定JVM运行环境的字段，序列化它们没有意义。
**示例：**
```java
import java.io.Serializable;

public class User implements Serializable {
    private String username;
    private transient String password; // 密码不被序列化

    // ... 构造方法、getter、setter ...
}
```
当序列化一个 `User`对象后，再反序列化回来，`password`字段的值将是 `null`（对于基本数据类型，则是其默认值，如 `0`、`false`等）。
**关键点：**
- `transient`只能修饰变量，不能修饰方法和类。
- 静态变量（`static`）无论是否被 `transient`修饰，都不会被序列化，因为序列化是针对对象实例状态的。
- 如果类实现的是 `Externalizable`接口（而非 `Serializable`），序列化过程完全由程序员控制的 `writeExternal`和 `readExternal`方法决定，`transient`关键字在此无效。
###### 11. volatile 关键字的作用是什么？
`volatile`是Java中用于修饰变量的一种轻量级同步机制。它的作用主要体现在**可见性**和**禁止指令重排序**上，但**不保证原子性**。
1. **保证可见性**：当一个线程修改了被 `volatile`修饰的变量时，这个新值会立即被刷新到主内存中。同时，其他线程在使用这个变量前，会强制从主内存重新读取最新值，而不是使用自己工作内存中的缓存旧值。这确保了多线程环境下，一个线程对变量的修改对其他线程是立即可见的。
2. **禁止指令重排序**：编译器和在执行程序时，为了优化性能，可能会对指令的执行顺序进行重排。`volatile`关键字通过插入内存屏障来禁止这种重排序优化，从而保证代码的执行顺序与程序的预期顺序一致。
**典型应用场景：**
- **状态标志位**：作为一个简单的线程间通信信号。
```java
    public class TaskRunner implements Runnable {
        private volatile boolean running = true; // 状态标志
    
        public void run() {
            while (running) { // 一个线程检查标志
                // 执行任务...
            }
        }
    
        public void stop() {
            running = false; // 另一个线程修改标志
        }
    }
    ```
如果没有 `volatile`，`running`变量的更新可能对执行循环的线程不可见，导致循环无法停止。
**volatile 的局限性：不保证原子性**
`volatile`无法保证复合操作的原子性。例如，`count++`这个操作看似一步，实则包含读取、加1、写入三个步骤。在多线程下，可能发生多个线程同时读取到旧值，然后分别加1再写回，导致最终结果小于预期。
```java
public class Counter {
    private volatile int count = 0;
    // 即使使用volatile，下面的操作在多线程下仍不安全
    public void increment() {
        count++; // 非原子操作
    }
}
```
对于需要原子性的操作，应使用 `synchronized`关键字或 `java.util.concurrent.atomic`包下的原子类（如 `AtomicInteger`）。
### 五、String 与常用类
###### 1. String、StringBuffer 和 StringBuilder⁠？⁠​
|特性|String|StringBuffer|StringBuilder|
|---|---|---|---|
|**可变性**​|**不可变**​|**可变**​|**可变**​|
|**线程安全**​|是（因不可变）|**是**（方法同步）|**否**​|
|**性能**​|低（频繁修改时）|中|**高**​|
|**使用场景**​|少量字符串操作、常量|多线程环境下大量字符串操作|**单线程**环境下大量字符串操作|

**核心区别与使用策略：**
- **String的不可变性**：String对象一旦创建，其内容（字符序列）就**不能被更改**。任何看似修改的操作（如拼接、替换）实际上都是**创建了一个新的String对象**。这是它和StringBuffer/StringBuilder最根本的区别。
- **性能考量**：由于String的不可变性，在需要频繁修改字符串的场景（如循环拼接）下，会产生大量临时对象，给垃圾回收（GC）带来压力，性能较差。而StringBuffer和StringBuilder直接在原字符数组上进行修改，避免了这个问题。
- **线程安全**：StringBuffer的方法大都使用了`synchronized`关键字进行同步，因此是**线程安全**的，可以在多线程环境下安全使用。StringBuilder则没有同步控制，效率更高，但**非线程安全**。在单线程环境下，**StringBuilder的性能通常优于StringBuffer**。
- **使用建议**：
	- **操作少量数据**或**字符串不需改变**时，使用String。
    - **单线程**下操作大量数据，**优先使用StringBuilder**。
    - **多线程**下操作大量数据，使用StringBuffer。
###### 2. String s = new String ("abc") 创建了几个 String 对象?⁠​
`String s = new String("abc")`这行代码创建的String对象数量**取决于字符串常量池中是否已存在内容为`"abc"`的字面量**。
- **情况一：常量池中尚无`"abc"`，创建2个对象。**
    1. **字面量对象**：首先，JVM会在**字符串常量池**中创建内容为`"abc"`的String对象。
    2. **new出来的对象**：然后，`new String(...)`会在**堆内存**中创建另一个新的、独立的String对象，它会将常量池中`"abc"`的内容复制到自己的字符数组里（在早期JDK版本中），最终变量`s`指向这个堆中的对象。
- **情况二：常量池中已存在`"abc"`，创建1个对象。**
    如果之前已有代码（如 `String temp = "abc";`）使得`"abc"`字面量已存在于常量池中，则本行代码**只会创建1个对象**，即堆中的那个`new String("abc")`对象。
**验证代码：**
```java
String temp = "abc"; // 确保常量池已有"abc"
String s1 = new String("abc");
String s2 = new String("abc");
System.out.println(s1 == s2); // 输出false，s1和s2指向堆中两个不同的对象
```
###### 3. 说说你对 String 类的 intern () 方法的理解?⁠​
`intern()`是一个本地方法，它的作用是**主动将字符串对象放入字符串常量池并返回池中对应字符串的引用**。
它的行为在**JDK 1.7及以上版本**有了重要优化：
- **调用`intern()`时**：JVM会检查常量池中是否存在与当前String对象内容相等的字符串。
    - **如果存在**：直接返回常量池中那个字符串的引用。
    - **如果不存在**：**不会**像JDK 1.6那样在常量池中复制一个该字符串的副本，而是**在常量池中记录当前堆中此对象的一个引用**，并返回这个引用。这意味着常量池和堆中的对象实际上是同一个。
**示例（JDK 1.7+）：**
```java
String s1 = new String("a") + new String("a"); // s1指向堆中的一个对象，内容为"aa"，注意此时常量池中还没有"aa"
s1.intern();  // 将s1的引用记录到常量池
String s2 = "aa"; // s2直接获取到的是常量池中记录的s1的引用
System.out.println(s1 == s2); // 输出true，因为s1和s2指向堆中同一个对象
```
**主要用途**：`intern()`方法可以**节省内存**，特别是当程序中存在大量重复内容的字符串时，通过池化可以只保留一份，减少内存占用。但也不可滥用，需根据实际情况评估。
###### 4. String 类的常用方法都有那些？⁠⁠​
String类提供了丰富的方法，以下是一些最常用的：

|方法类别|方法签名（示例）|作用|
|---|---|---|
|**获取信息**​|`int length()`|返回字符串长度|
||`boolean isEmpty()`/ `boolean isBlank()`|判断是否为空/空白符|
||`char charAt(int index)`|获取指定索引处的字符|
|**比较判断**​|`boolean equals(Object anObject)`|比较内容是否相等|
||`int compareTo(String anotherString)`|按字典顺序比较字符串|
||`boolean startsWith(String prefix)`|判断是否以指定前缀开头|
||`boolean contains(CharSequence s)`|判断是否包含指定字符序列|
|**操作子串**​|`String substring(int beginIndex, int endIndex)`|截取子串|
||`String concat(String str)`|连接字符串（等效于`+`）|
|**查找索引**​|`int indexOf(String str)`|返回指定子串第一次出现的索引|
||`int lastIndexOf(String str)`|返回指定子串最后一次出现的索引|
|**修改替换**​|`String replace(char oldChar, char newChar)`|替换字符|
||`String toLowerCase()`/ `toUpperCase()`|转换大小写|
||`String trim()`|去除首尾空白符|
|**切割转换**​|`String[] split(String regex)`|根据正则表达式切割字符串|
||`char[] toCharArray()`|转换为字符数组|
||`static String valueOf(基本类型/对象)`|将其他类型转换为String|
###### 5. String 字符串为什么说是不可变？⁠​
String的不可变性体现在三个方面：
1. **`final`修饰的类**：String类被`final`修饰，**不可被继承**，防止子类破坏不可变性。
2. **`final`修饰的底层数组**：String实际存储数据的是一个`private final char value[]`（JDK 8及之前）或`byte[]`（后续JDK为优化内存）。这个数组被声明为`final`，意味着**一旦初始化，该引用不能再指向其他数组**。
3. **没有公开的修改方法**：String类**没有提供任何能修改`value`数组内容**的公共方法（如`setChar`）。所有看似修改的方法都是创建新对象。
**这种设计带来的好处包括**：
- **实现字符串常量池**，提升性能，减少内存开销。
- **保证HashCode的稳定性**，使得String非常适合作为HashMap等容器的Key。
- **天然线程安全**，可在多线程中安全共享。
- **提高了安全性**，如在网络连接、文件路径等场景中，避免被意外修改。
###### 6. Object 有哪些常用方法？大致说一下每个方法的含义?⁠⁠​
Object是所有类的超类，其常用方法及含义如下：

|方法|含义|
|---|---|
|`protected Object clone()`|创建并返回此对象的一个副本。需实现`Cloneable`接口。|
|`boolean equals(Object obj)`|**核心方法**，用于判断两个对象在**逻辑上**是否“相等”（默认比较地址，通常需要重写）。|
|`protected void finalize()`|当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。**不推荐使用**。|
|`Class<?> getClass()`|返回此对象的运行时类。|
|`int hashCode()`|**核心方法**，返回对象的哈希码值。重写`equals`时必须重写此方法。|
|`String toString()`|返回该对象的字符串表示。强烈建议为所有子类重写此方法。|
|`void notify()`|唤醒在此对象监视器上等待的单个线程。|
|`void notifyAll()`|唤醒在此对象监视器上等待的所有线程。|
|`void wait()`|导致当前线程等待，直到另一个线程调用此对象的`notify()`或`notifyAll()`方法。|
###### 7. 一个空 Object 对象的占多大空间？⁠⁠​
在Java中，一个空`Object`对象（即`new Object()`）在堆中占用的空间大小通常是**8字节**。
这8字节是对象头（Mark Word），用于存储对象的元数据，如哈希码、锁状态、GC年龄等。
需要注意的是，这仅仅是对象本身的开销。一个引用变量（如 `Object obj;`）在32位JVM上占4字节，在64位JVM上通常占4或8字节（取决于指针压缩是否开启），但这部分空间不属于堆中的对象本身。
另外，Java内存管理有**字节对齐**的要求，为了高效访问，JVM会以8字节的整数倍来分配内存。所以，一个空Object对象实际占用的空间可能就是8字节。
###### 8. 说说你对 equals 与== 的理解？⁠​
|操作符/方法|`==`|`equals`|
|---|---|---|
|**比较本质**​|**比较的是值（Value）**​|**比较的是对象的内容（Content）**​|
|**对于基本类型**​|比较的是**变量中存储的数值**是否相等。`int a=10; int b=10; a==b // true`|基本类型不能调用`equals`方法。|
|**对于引用类型**​|比较的是**两个引用是否指向内存中的同一个对象**（即比较内存地址）。|默认行为与`==`相同（Object类中的实现）。但绝大多数类（如String、Integer）会**重写**此方法，用于比较两个对象**在逻辑上是否等价**。|

**示例：**
```java
String str1 = new String("hello");
String str2 = new String("hello");
String str3 = str1;

System.out.println(str1 == str2);   // false，比较地址，不是同一个对象
System.out.println(str1 == str3);   // true，指向同一个对象
System.out.println(str1.equals(str2)); // true，比较内容，内容相同
```
###### 9. 说说 Hash Code 的作用⁠？⁠​
哈希码（Hash Code）是一个由对象导出的**整型值**。它的主要作用是：
1. **提高哈希表（如HashMap、HashSet）的性能**：这是其最重要的用途。哈希表通过哈希码可以快速定位到对象可能存储的“桶”（bucket），大大减少了需要调用`equals`方法进行逐个比较的次数，使得查找、插入等操作的时间复杂度接近O(1)。
2. **用于对象的散列存储**。
**规范（重要）：**
- 如果两个对象根据`equals`方法是相等的，那么它们的**哈希码必须相同**。
- 如果两个对象根据`equals`方法不相等，它们的哈希码**不一定需要不同**。但好的哈希函数应尽可能产生不同的哈希码，以提升哈希表性能。
###### 10. 有没有可能两个不相等的对象有相同的 Hash Code⁠？⁠​
**有可能。这种情况被称为哈希冲突**。
即使两个对象不相等，它们也有可能产生相同的哈希码。一个好的哈希函数会尽量减少冲突，但由于哈希码是int类型，只有2^32种可能，而对象的状态组合是无限的，所以冲突是不可避免的。
哈希表（如HashMap）通过“链地址法”或“开放地址法”等技术来解决哈希冲突。
###### 11. 两个对象值相同 (x.equals (y) == true)，但却可有不同的 Hash Code，这句话对不对？⁠​
**不对。这句话严重违反了`equals`和`hashCode`方法的契约。
正确的规定是：如果`x.equals(y) == true`，那么`x.hashCode() == y.hashCode()`必须为`true`。**
反之则不一定：如果两个对象的hashCode相同，它们不一定equals。
如果违反了这条规则，当把这个对象放入基于哈希的集合（如HashSet）时，会导致无法正确找到对象等严重问题。因此，**当你重写`equals`方法时，必须同时重写`hashCode`方法**，以确保契约成立。
###### 12. StringBuilder 和 StringBuffer 的底层实现原理是什么？
StringBuilder和StringBuffer都继承自`AbstractStringBuilder`类。它们的底层实现原理基本一致：
1. **可变字符序列**：它们内部维护了一个**可变的字符数组**（`char[] value`，在JDK 8中）。这个数组没有被`final`修饰，因此可以改变。
2. **动态扩容**：当进行追加（`append`）操作时，如果当前字符数组的容量不够，会创建一个**更大的新数组**，然后将旧数组的内容复制过去。这类似于`ArrayList`的扩容机制。在创建时如果能够预估大小，通过构造函数指定初始容量（如 `new StringBuilder(100)`）可以有效减少扩容次数，提升性能。
3. **方法区别**：StringBuffer的方法都使用了`synchronized`关键字进行同步，从而保证线程安全；而StringBuilder的方法则没有，因此效率更高。
###### 13. String 为什么要设计成不可变的？
1. **实现字符串常量池**：这是最直接的原因。只有不可变，字符串常量池才能实现。不同的字符串变量可以指向池中的同一个对象，极大节省了内存空间并提高了性能。如果字符串可变，一个引用对内容的修改会影响到所有共享该对象的引用。
2. **安全性**：字符串被广泛用于类名、方法名、URL、文件名、网络连接参数等。不可变性可以防止这些关键信息被意外修改，提升了程序的安全性。例如，在数据库连接中，如果用户名和密码是可变的，可能会在建立连接后被恶意代码修改。
3. **线程安全**：由于不可变，String对象天生就是线程安全的，可以在多线程环境中安全地共享，无需额外的同步开销。
4. **作为HashMap的Key**：String的不可变性保证了其哈希码的稳定性。一旦被创建，其`hashCode`就不会改变，这使它成为HashMap等集合中Key的绝佳选择。如果Key的哈希值会变，那么在HashMap中将无法正确定位到对应的值。
5. **哈希码缓存**：String类内部有一个`hash`成员变量用于缓存第一次调用`hashCode()`计算出的结果。因为字符串内容不变，所以这个哈希码可以缓存起来反复使用，提高了像HashMap这类容器的性能。
### 六、对象与内存
###### 1. 什么是构造函数？构造函数有什么特点？⁠⁠​
构造函数是一种特殊的成员方法，**在创建对象时被自动调用**，主要用于初始化对象的成员变量。
其主要特点包括：
1. **必须与类同名**。
2. **不能有返回类型**，即使是 `void`也不可以。
3. **支持重载**：一个类中可以有多个参数列表不同的构造函数，根据 `new`时传入的参数决定调用哪一个。
4. **自动调用**：使用 `new`关键字创建对象时，JVM 会自动调用相应的构造函数。
5. **默认构造函数**：如果一个类没有显式定义任何构造函数，编译器会自动提供一个无参数的默认构造函数。一旦定义了任何构造函数，默认构造函数便不再自动提供。
6. **继承中的调用**：在继承关系中，创建子类对象时，**会首先调用父类的构造函数**（默认调用无参构造，可使用 `super(args)`显式调用有参构造），然后再调用子类的构造函数。
###### 2. 说说 Java 代码初始化顺序?⁠⁠​
理解Java程序中各类成员（静态/非静态、变量/代码块）以及构造函数的初始化顺序至关重要。对于一个继承结构，其初始化顺序遵循明确的规则：
1. **父类静态成员**：先初始化父类的静态变量（包括静态代码块），按代码中定义的顺序执行。
2. **子类静态成员**：然后初始化子类的静态变量（包括静态代码块），按代码中定义的顺序执行。
3. **父类实例成员和构造器**：接着初始化父类的非静态变量（包括实例初始化块），按代码中定义的顺序执行，最后执行父类的构造函数。
4. **子类实例成员和构造器**：最后初始化子类的非静态变量（包括实例初始化块），按代码中定义的顺序执行，最后执行子类的构造函数。
**核心原则**可以概括为：**静态优先于非静态，父类优先于子类，变量和代码块按定义顺序初始化**。静态初始化只在类首次加载时执行一次，而实例初始化每次创建新对象时都会执行。
###### 3. Java 创建对象有几种方式？⁠​
Java中创建对象主要有以下几种方式：
1. **使用 `new`关键字**：最常用、最直接的方式。例如 `MyClass obj = new MyClass();`。
2. **使用反射机制**：通过 `Class`类的 `newInstance()`方法（已过时，不推荐）或 `Constructor`类的 `newInstance()`方法。例如 `MyClass obj = MyClass.class.getDeclaredConstructor().newInstance();`。
3. **使用 `clone()`方法**：需要类实现 `Cloneable`接口并重写 `Object`的 `clone()`方法。实现的是对象的复制。
4. **使用反序列化**：通过 `ObjectInputStream`从文件或网络等字节流中读取并还原对象。
###### 4. 如何实现对象克隆？⁠​
实现对象克隆，需要让类**实现 `Cloneable`标记接口**，并**重写 `Object`类中的 `clone()`方法**，且将其访问修饰符改为 `public`。
```java
class Person implements Cloneable {
    private String name;
    private Address address; // 假设Address是一个引用类型

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone(); // 默认实现是浅拷贝
    }
}
```
###### 5. 深拷贝和浅拷贝的区别是什么?⁠​
|特性|浅拷贝 (Shallow Copy)|深拷贝 (Deep Copy)|
|---|---|---|
|**本质**​|只复制对象本身及其基本类型字段，**不复制其引用的对象**。|复制对象本身及其所有引用的对象（递归地进行复制），创建一个完全独立的副本。|
|**引用字段**​|原对象和副本对象**共享**同一个引用对象。|原对象和副本对象**拥有各自独立**的引用对象。|
|**内存示意图**​|`原对象A -> 对象B`  <br>`副本A' -> 对象B`(共享B)|`原对象A -> 对象B`  <br>`副本A' -> 对象B'`(B的副本)|
|**修改影响**​|修改副本的引用对象内容，会影响原对象。|修改副本的引用对象内容，**不会影响**原对象。|
|**实现复杂度**​|简单，通常 `Object.clone()`默认行为即是。|复杂，需要递归地复制所有引用对象。|
|**性能**​|较高，不创建深层对象。|较低，需要创建整个对象图。|

实现深拷贝主要有两种方式：
1. **重写 `clone()`方法**：在重写的 `clone`方法中，不仅调用 `super.clone()`，还要对每个引用类型的字段递归地调用其 `clone`方法。
2. **通过序列化**：将对象写入字节流，然后再从字节流中读回。这种方式要求对象及其所有引用对象都实现 `Serializable`接口，性能开销较大，但代码相对简洁。
###### 6. 熟悉 Java 的对象引用类型吗？⁠⁠​
Java提供了四种不同强度的引用类型，用于更精细地控制对象的生命周期，帮助管理内存和避免内存泄漏。
1. **强引用**：最常见的引用，例如 `Object obj = new Object()`。只要强引用存在，垃圾回收器就**永远不会**回收被引用的对象。
2. **软引用**：通过 `SoftReference`类实现。当内存不足时，垃圾回收器**会回收**这些软引用指向的对象。常用于实现内存敏感的缓存。
3. **弱引用**：通过 `WeakReference`类实现。无论内存是否充足，只要发生垃圾回收，弱引用指向的对象**就会被回收**。常用于维护一种非强制的映射关系，如 `WeakHashMap`的键。
4. **虚引用**：通过 `PhantomReference`类实现。最弱的一种引用，**无法通过虚引用获取对象实例**。其唯一作用是用于对象被回收时收到一个系统通知，通常与引用队列 `ReferenceQueue`联合使用，用于跟踪对象被垃圾回收的状态。
###### 7. 为什么 Java 中只有值传递？⁠​
关于Java是值传递还是引用传递，是一个经典问题。结论是：**Java中只有值传递**。
- **值传递**：将实际参数的一个**副本**传递给方法。方法内对副本的修改**不会影响**原始变量。
- **引用传递**：将实际参数本身的**引用**（可以理解为内存地址）传递给方法。方法内对形式参数的修改**会影响**原始变量。
在Java中，当传递基本数据类型（如 `int`, `double`）时，传递的是值的副本，这很明显是值传递。当传递引用数据类型（如对象、数组）时，实际上传递的是**引用的副本**（即对象地址的一个拷贝）。这意味着，在方法内部：
- 你可以通过这个副本引用**修改对象的状态**（因为指向的是同一个对象）。
- 但**你不能通过这个副本引用来改变原始引用所指向的对象**（例如，让它指向一个新的对象），因为你操作的只是地址的一个副本。
```java
public class Test {
    public static void changeValue(int num, String str, StringBuilder sb) {
        num = 100; // 修改基本类型副本，不影响原值
        str = "Changed"; // 让副本引用指向新字符串对象，不影响原引用
        sb.append(" World"); // 通过副本引用修改共享对象的内容，原对象被修改
        // sb = new StringBuilder("New"); // 如果让副本引用指向新对象，则不影响原引用
    }

    public static void main(String[] args) {
        int a = 10;
        String s = "Hello";
        StringBuilder builder = new StringBuilder("Hello");
        changeValue(a, s, builder);
        System.out.println(a); // 输出 10
        System.out.println(s); // 输出 "Hello"
        System.out.println(builder); // 输出 "Hello World"
    }
}
```
###### 8. Java 对象的内存布局是怎样的？
在HotSpot虚拟机中，一个对象在堆内存中的存储布局可以分为三个部分：
1. **对象头**：包含两类信息。
    - **Mark Word**：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等。这部分数据在32位和64位虚拟机上长度分别为32bit和64bit。
    - **类型指针**：指向对象的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
2. **实例数据**：对象真正存储的有效信息，即程序代码中定义的各种类型的字段内容（包括从父类继承下来的）。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。
3. **对齐填充**：起占位符作用。HotSpot VM要求对象起始地址必须是8字节的整数倍，因此当实例数据部分没有对齐时，需要通过对齐填充来补全。
###### 9. 什么是对象的逃逸分析？
逃逸分析是JVM的一种**分析技术**，用于分析**对象的作用域**是否会逃逸出方法或线程。具体来说，JVM会分析：
- **方法逃逸**：一个对象在方法内被定义后，可能被外部方法引用（例如作为参数传递给其他方法，或赋值给类变量）。
- **线程逃逸**：一个对象可能被其他线程访问到。
如果通过逃逸分析，JVM发现一个对象**没有逃逸**出当前方法或线程，那么JVM可能会进行一些高效的优化：
1. **栈上分配**：将对象的内存分配在Java虚拟机栈上（而不是堆上）。这样，对象所占用的内存空间就可以随着栈帧的出栈而被销毁，减轻了垃圾回收的压力。
2. **标量替换**：将对象“拆解”成若干个其包含的基本数据类型（标量），并将这些标量分配在栈上或寄存器中。这样就完全不会创建这个对象，从而避免了对象头的内存开销。
3. **同步消除**：如果发现该对象只能被一个线程访问，那么对这个对象实施的同步措施（如`synchronized`）就可以被安全地消除。
逃逸分析在服务器端编译器（C2）中是默认开启的（`-XX:+DoEscapeAnalysis`），它是一项重要的即时编译器优化技术。
### 七、内部类

###### 1. 什么是内部类？
| 特性维度      | 内部类概览                                      |
| --------- | ------------------------------------------ |
| **核心定义**​ | 定义在另一个类（外部类）内部的类，是其外部类的一个成员。               |
| **主要类型**​ | 成员内部类、静态内部类、局部内部类、匿名内部类。                   |
| **核心优点**​ | 增强封装、逻辑聚合、代码精简、解决特定问题（如多继承局限）。             |
| **访问权限**​ | 内部类可以访问外部类的所有成员（包括私有成员），静态内部类只能访问外部类的静态成员。 |
| **对象创建**​ | 非静态内部类实例依赖外部类实例；静态内部类实例可独立创建。              |
###### 2. 内部类有什么优点？⁠​
内部类之所以被广泛使用，主要归功于以下几个关键优点：
- **增强封装性**：内部类可以访问其外部类的所有成员（包括`private`私有成员），这使得你可以将一些高度关联、仅为外部类服务的逻辑完全隐藏在外部类内部，对外部类的使用者不可见，从而实现了更彻底的封装。
- **优化代码组织**：内部类允许你将逻辑上紧密相关的类组织在一起。例如，一个`User`类内部定义一个`Address`类，这比将两个类完全分开定义更清晰，减少了类文件的扩散，提高了代码的可读性和可维护性。
- **使代码更紧凑**：特别是**局部内部类**和**匿名内部类**，它们允许你在需要的地方（如方法内部）即时定义和使用一个类，避免了为只使用一次的类单独创建文件的麻烦，让代码更加简洁。
###### 3. 内部类有哪些应用场景？⁠​
不同的内部类各有其适用的场景：
- **成员内部类**：适用于与外部类实例有**强依赖关系**的场景，需要直接访问外部类的实例成员。例如，一个`BankAccount`（银行账户）类内部的`Transaction`（交易）类，交易需要直接操作账户的余额。
- **静态内部类**：当你需要定义一个与外部类关联但**不依赖其具体实例**的辅助类时，静态内部类是最佳选择。它常用于工具类或表示外部类的组件，例如，一个`Utility`类内部的`MathHelper`静态工具类。
- **局部内部类**：当某个类的功能**只在一个方法内部需要**时，可以使用局部内部类。它有助于进一步限制作用域，例如在`calculate`方法内定义一个临时的`Addition`（加法）类。
- **匿名内部类**：广泛应用于需要**快速实现接口或继承类**，且这个实现**只使用一次**的场景。最常见的就是图形用户界面（GUI）编程中的事件监听器，以及多线程中`Runnable`接口的即时实现。
###### 4. 为什么匿名内部类只能使用成员变量或者被 final 修饰的局部变量呢？⁠​
这是一个深入且重要的问题。匿名内部类只能访问**最终效果（Effectively Final）的局部变量（即事实不可变的变量，无论是否显式声明为`final`），但可以自由访问成员变量。这主要是由**生命周期差异**和**数据一致性**决定的。
- **生命周期差异**：局部变量随着方法的执行结束而被销毁。而通过`new`创建的匿名内部类对象（位于堆内存）其生命周期可能远长于方法（其栈帧）。如果允许内部类直接修改局部变量，就会造成一个矛盾：内部类对象可能试图去访问一个已经不复存在的变量。
- **数据一致性**：为了解决这个矛盾，Java采取了“值复制”的策略。当匿名内部类引用一个局部变量时，Java会**将局部变量的值复制一份**给内部类。为了确保在整个生命周期内，内部类看到的这个值始终一致，就必须要求该局部变量的值初始化后不能再改变，即它是**最终效果不可变的（Effectively Final）**。
- **成员变量为何不受限**：成员变量的生命周期与对象实例绑定，都存在于堆内存中，因此不存在生命周期不匹配的问题。
###### 5. 静态内部类和非静态内部类的区别？
静态内部类和非静态内部类（即普通的成员内部类）的核心区别在于它们与外部类实例的关联方式，这导致了多方面的差异：

| 特性          | 非静态内部类（成员内部类）                                                   | 静态内部类                                                        |
| ----------- | --------------------------------------------------------------- | ------------------------------------------------------------ |
| **依赖关系**​   | **依赖**于外部类的具体实例。                                                | **独立**于外部类的实例。                                               |
| **创建方式**​   | `OuterClass.InnerClass inner = outerInstance.new InnerClass();` | `OuterClass.InnerClass inner = new OuterClass.InnerClass();` |
| **访问权限**​   | 可自由访问外部类的**所有成员**（实例和静态）。                                       | 只能访问外部类的**静态成员**。                                            |
| **包含静态成员**​ | 在新版JDK中可包含静态成员，但通常不推荐。                                          | 可以正常包含静态和非静态成员。                                              |
| **内存泄漏风险**​ | 隐式持有外部类引用，使用不当可能引起。                                             | 无此风险，更安全。                                                    |
###### 6. 局部内部类有什么特点？
局部内部类具有一些独特的特性，使其在特定场景下非常有用：
- **作用域受限**：局部内部类定义在方法或代码块内部，其作用范围被严格限制在**定义它的方法或代码块之内**，外界无法访问，这提供了最强的封装性。
- **访问局部变量的限制**：和匿名内部类类似，局部内部类访问的局部变量也必须是**最终效果不可变的（Effectively Final）**，原因同样是生命周期和数据一致性的考量。
- **有限的修饰符**：局部内部类**不能被`public`, `protected`, `private`, `static`等访问修饰符修饰**。它就像是方法里的一个局部“对象”，其地位类似于一个局部变量。
- **编译文件**：编译后，局部内部类会生成独立的字节码文件，文件名格式为：`外部类名$数字局部内部类名.class`（其中的数字用于区分同一外部类中同名的不同局部内部类）。
### 八、异常处理

###### 1. Java中的异常体系是怎样的？⁠⁠​
Java的异常体系结构清晰地区分了不同类型的错误和异常。下图描绘了其核心框架：
```mermaid
flowchart TD
    A[Throwable] --> B[Error]
    A --> C[Exception]
    
    B --> B1[VirtualMachineError<br>OutOfMemoryError...]
    B --> B2[...]
    
    C --> C1[RuntimeException<br>（Unchecked/非受检）]
    C --> C2[Checked Exception<br>（受检异常）]
    
    C1 --> C11[NullPointerException]
    C1 --> C12[ArrayIndexOutOfBoundsException]
    C1 --> C13[IllegalArgumentException]
    C1 --> C14[...]
    
    C2 --> C21[IOException]
    C2 --> C22[SQLException]
    C2 --> C23[...]
```

- **`Throwable`**：所有错误和异常的顶级父类。
- **`Error`​ (错误)：指程序**无法处理**的严重系统级问题，通常与代码逻辑无关，而是运行时环境（如JVM）出现问题。例如 `OutOfMemoryError`（内存溢出）或 `StackOverflowError`（栈溢出）。应用通常无法处理或恢复，只能尽量安全地终止。
- **`Exception` (异常)：指程序**可以且应该处理**的各种意外情况，是异常处理的核心。它主要分为两类：
    - **`RuntimeException`及其子类 (运行时异常/非受检异常)**：如空指针、数组越界等。通常是编程逻辑错误，编译器不强制要求处理，应由代码质量保证。
    - **其他`Exception`子类 (受检异常)**：如`IOException`、`SQLException`。编译器要求必须处理（捕获或声明抛出），否则编译不通过。
###### 2. 说说你对 Excption 与 Error 包的理解?⁠​
| 特性            | `Exception`(异常)                                                            | `Error`(错误)                                          |
| ------------- | -------------------------------------------------------------------------- | ---------------------------------------------------- |
| **可预见/可恢复性**​ | 程序可预料、可恢复的情况。                                                              | 系统级别严重问题，程序通常无法处理或恢复。                                |
| **处理强制力**​    | **检查异常（Checked）**​ 必须显式处理（`try-catch`或`throws`），**运行时异常（Unchecked）**​ 非强制。 | 通常**不强制**捕获处理。                                       |
| **来源**​       | 主要源于程序逻辑或外部交互（如用户输入、I/O操作）。                                                | 通常由JVM或底层系统资源问题引发。                                   |
| **最佳实践**​     | **检查异常**：捕获并尝试恢复或转译。  <br>**运行时异常**：优先通过代码逻辑避免。                            | 通常难以在代码中处理。应记录日志并尝试优雅终止程序，避免随意捕获`Error`或`Throwable`。 |
###### 3. try catch finally，try 里有 return，finally 还执行么？⁠​
**`finally`块中的代码一定会执行**，即使在`try`或`catch`块中遇到了`return`语句。
执行顺序是：先执行`try`或`catch`块中的代码，直到遇到`return`语句时，计算`return`表达式的值（此时值已被暂存，但方法并未立即返回），然后去执行`finally`块中的代码。最后，`try`或`catch`块再带着之前暂存的返回值结束方法。
如果`finally`块中也包含`return`语句，那么它会**覆盖**`try`或`catch`块中的返回值。但**强烈不推荐**在`finally`中使用`return`，因为这会导致`try`或`catch`块中的返回值丢失，且可能抑制其他异常，极易引发难以调试的问题。
###### 4. throw 和 throws 的区别是什么？
| 方面          | `throw`                                    | `throws`                                                               |
| ----------- | ------------------------------------------ | ---------------------------------------------------------------------- |
| **语法位置**​   | 用于**方法体内部**。                               | 用于**方法声明处**，参数列表之后。                                                    |
| **后面跟随内容**​ | 一个**异常对象实例**，如 `throw new IOException();`。 | 一个或多个**异常类的类型**，如 `void method() throws IOException, SQLException {}`。 |
| **语义作用**​   | **主动抛出**一个具体的异常，表示异常在此处发生。                 | **声明**该方法可能抛出的异常类型，提醒调用者需要处理这些异常。                                      |
| **异常数量**​   | 一次只能抛出一个异常对象。                              | 可以声明抛出多个异常类型（用逗号分隔）。                                                   |
###### 5. 如何自定义异常？
当Java标准异常类无法清晰表达特定业务逻辑错误时，可以自定义异常。
1. **选择父类**：
    - 如果希望异常是**受检异常**（强制调用者处理），则继承 `Exception`类。
    - 如果希望异常是**运行时异常**（非强制处理），则继承 `RuntimeException`类。
2. **添加构造方法**：通常需要提供多个构造方法以确保可用性。
  ```java
    public class MyBusinessException extends RuntimeException { // 或 extends Exception
        // 无参构造
        public MyBusinessException() {
            super();
        }
        // 带详细消息的构造
        public MyBusinessException(String message) {
            super(message);
        }
        // 带详细消息和原因的构造（支持异常链，推荐）
        public MyBusinessException(String message, Throwable cause) {
            super(message, cause);
        }
        // 带原因的构造
        public MyBusinessException(Throwable cause) {
            super(cause);
        }
    }
    ```
3. **（可选）添加自定义属性**：根据业务需要，可以定义额外的属性，如错误码。
**最佳实践**：
- 命名以 `Exception`结尾。
- 提供有意义的错误信息。
- 利用异常链（传入 `cause`参数）保留原始异常信息，便于排查根因。
- 避免为琐碎或可恢复的错误创建过多自定义异常。
###### 6. finally 块中的代码一定会执行吗？
虽然一般情况下 `finally`块都会执行，但在一些极端场景下，它**可能不会执行**：
1. **JVM 非正常退出**：如果在 `try`或 `catch`块中调用了 `System.exit(int status)`方法，JVM 将立即终止，`finally`块没有机会执行。
2. **所在线程死亡**：如果执行 `try-catch`的线程被中断（`interrupt`）或死亡（`kill`），`finally`块可能无法执行。
3. **CPU 死循环或崩溃**：在 `try`或 `catch`块中进入无限循环，或者底层系统/CPU出现严重问题。
因此，**不能说 `finally`块是绝对百分百执行的**，但在正常的程序流程控制下（无 `System.exit`，线程正常），它是肯定会执行的。
### 九、泛型

###### 1. 为什么需要泛型？⁠⁠​
在泛型出现之前，Java 代码（尤其是集合类）普遍使用 `Object`来实现“通用”编程，但这带来了三个主要问题：
1. **类型不安全**：编译器无法检查存入集合的元素类型，任何对象都能放入。当将其强制转换为期望的类型时，如果类型不匹配，就会在**运行时**抛出 `ClassCastException`，这是一个重大的安全隐患。
 ```java
    // 泛型之前的代码（危险！）
    List list = new ArrayList();
    list.add("hello");
    list.add(100); // 编译器不报错
    String item = (String) list.get(1); // 运行时抛出 ClassCastException
    ```
2. **繁琐的强制类型转换**：每次从集合中取出元素，都需要进行显式的类型转换，代码冗余且容易出错。
3. **代码可读性差**：无法从代码声明中直观看出集合 intended 要存储的元素类型。
**泛型的引入，完美地解决了这些问题：**
- **类型安全**：编译器在编译期就能进行类型检查。一旦指定 `List<String>`，尝试存入一个 `Integer`对象将导致**编译错误**，将错误发现提前到了编译阶段。
  ```java
    // 使用泛型
    List<String> list = new ArrayList<>();
    list.add("hello");
    // list.add(100); // 编译错误！IDE和编译器都会立即报错
    String item = list.get(0); // 无需强制转换
    ```
- **消除强制转换**：编译器知晓具体类型，会自动加入必要的类型转换，代码更简洁。
- **提高代码复用性**：可以编写通用的算法和数据结构，适用于多种类型。
###### 2. 如何使用泛型？⁠⁠​
泛型可以应用于类、接口和方法。
1. **泛型类/接口**
    在类名或接口名后使用尖括号 `<T>`声明类型参数。`T`是一个占位符，可以是任何大写字母（如 K, V, E 等）。在类体或接口体内，`T`可以像普通类型一样使用。
    ```java
    // 泛型类
    public class Box<T> {
        private T value;
        public void setValue(T value) { this.value = value; }
        public T getValue() { return value; }
    }
    // 泛型接口
    public interface Pair<K, V> {
        K getKey();
        V getValue();
    }
    // 使用
    Box<String> stringBox = new Box<>();
    stringBox.setValue("Generic");
    String value = stringBox.getValue(); // 类型安全，无需转换
    ```
2. **泛型方法**
    在方法的返回值前声明类型参数 `<T>`。泛型方法可以存在于普通类中，也可以存在于泛型类中。它的类型参数 `<T>`与类的类型参数 `<T>`无关。
    ```java
    public class Utility {
        // 泛型方法，将数组转换为列表
        public static <T> List<T> fromArrayToList(T[] array) {
            return Arrays.asList(array);
        }
    }
    // 使用
    Integer[] intArray = {1, 2, 3};
    List<Integer> intList = Utility.fromArrayToList(intArray); // 类型推断
    ```
###### 3. 泛型的上限和下限是什么？⁠⁠​
为了增加对类型参数的灵活性和控制，泛型提供了边界（Bounds）机制。
- **上界通配符 `<? extends T>`**
    表示“未知的某种类型，它是 `T`类型或其子类型”。因为它能安全地**读取**为 `T`（多态性），所以通常用于**生产**数据的场景。
  ```java
    // 此方法可以接受一个装载了Number或其子类（如Integer, Double）对象的列表
    public static double sumOfList(List<? extends Number> list) {
        double sum = 0.0;
        for (Number num : list) { // 可以安全地读取为Number
            sum += num.doubleValue();
        }
        return sum;
    }
    // 但你不能向这个列表添加元素（null除外），因为编译器不知道具体是哪种子类型
    // list.add(new Integer(1)); // 编译错误！
    ```
- **下界通配符 `<? super T>`**
    表示“未知的某种类型，它是 `T`类型或其父类型”。因为它能安全地**写入**​ `T`类型的对象（父类引用可以指向子类对象），所以通常用于**消费**数据的场景。
```java
    // 此方法可以向一个装载了Integer或其父类（如Number, Object）对象的列表写入Integer
    public static void addNumbers(List<? super Integer> list) {
        for (int i = 1; i <= 5; i++) {
            list.add(i); // 可以安全地写入Integer及其子类
        }
    }
    // 但从这个列表读取时，只能将其视为Object，因为父类型不确定
    // Integer num = list.get(0); // 编译错误！
    // Object obj = list.get(0); // 正确
    ```
###### 4. Java中的泛型为什么是伪泛型？⁠​什么是类型擦除？
Java 的泛型是通过 **类型擦除**​ 来实现的，这是理解 Java 泛型底层机制的关键。
- **什么是类型擦除？**
    编译器在编译 Java 源码时，会**移除所有泛型类型信息**。类型参数 `<T>`会被替换为其**上限**（未指定上限时默认为 `Object`），并在必要的地方插入强制类型转换。
```java
    // 编译前
    List<String> list = new ArrayList<>();
    list.add("Hello");
    String s = list.get(0);
    
    // 编译后（类型擦除后的近似效果）
    List list = new ArrayList(); // <String> 被擦除
    list.add("Hello");
    String s = (String) list.get(0); // 编译器自动插入转换
    ```
- **为什么说 Java 泛型是“伪泛型”？**
    因为泛型信息只存在于编译期，**运行时是没有泛型类型信息的**。例如，`List<String>`和 `List<Integer>`在运行时都是 `List`类，无法通过反射在运行时判断一个 `List`到底包含什么类型的元素。这与 C# 等语言在运行时保留类型信息的“真泛型”有本质区别，故被称为伪泛型。
    ```java
    List<String> strList = new ArrayList<>();
    List<Integer> intList = new ArrayList<>();
    System.out.println(strList.getClass() == intList.getClass()); // 输出 true
    ```
- **类型擦除带来的限制**
    - **不能使用基本类型作为类型参数**：如 `List<int>`是错误的，必须使用包装类 `List<Integer>`，因为擦除后 `T`是 `Object`，而基本类型不是对象。
    - **不能实例化类型参数**：`new T()`是非法的，因为擦除后 `T`变成 `Object`，这没有意义。
    - **不能创建泛型数组**：如 `new List<String>[10]`通常是非法的，因为数组需要在运行时知道其元素的确切类型。
    - **`instanceof`检查失效**：不能使用 `obj instanceof T<String>`。
###### 5. 泛型中 extends 和 super 的区别（PECS 原则）？
PECS 的全称是 **"Producer-Extends, Consumer-Super"**。这个原则是 Joshua Bloch 在《Effective Java》中提出的，用于指导在方法参数中何时使用 `extends`通配符，何时使用 `super`通配符。
- **Producer (生产者) - 使用 `extends`**：如果你需要一个**提供（生产）`T`类型对象的数据源，应该使用 `<? extends T>`。因为你主要目的是从结构中**读取**数据。
- **Consumer (消费者) - 使用 `super`**：如果你需要一个**接收（消费）`T`类型对象的数据池，应该使用 `<? super T>`。因为你主要目的是向结构中**写入**数据。
**经典示例：`java.util.Collections.copy`方法**
```java
public static <T> void copy(List<? super T> dest, List<? extends T> src) {
    // dest 是消费者，我们向其中写入T类型的元素，所以用 ? super T
    // src 是生产者，我们从中读取T类型的元素，所以用 ? extends T
    for (int i=0; i<src.size(); i++) {
        dest.set(i, src.get(i));
    }
}
```
### 十、序列化

###### 1. 什么是序列化和反序列化？Serializable 接口的作用是什么？⁠​
- **序列化**：指的是将内存中的Java对象转换成与平台无关的字节序列的过程。这个字节序列可以保存到磁盘文件（实现数据持久化），也可以通过网络传输到另一个主机（用于远程方法调用，如RMI）。
- **反序列化**：是序列化的逆过程，它将字节序列从存储介质或网络中读取出来，重新构造成一个与原始对象状态完全相同的Java对象。
`Serializable`接口是Java提供的一个**标记接口**。所谓标记接口，是指内部没有定义任何方法的接口。它的作用非常简单，却至关重要：**它声明实现它的类允许其对象被序列化**。
Java的序列化机制（如 `ObjectOutputStream`）在运行时会检查一个对象是否实现了此接口。只有实现了 `Serializable`接口的类的对象，才可以被合法地序列化和反序列化，否则会抛出 `NotSerializableException`异常。
###### 2. Java 序列化中如果有些字段不想进行序列化，怎么办？⁠​
如果你希望类的某些成员变量不被序列化，有几种方法可以实现：
1. **使用 `transient`关键字**：这是最常用和直接的方式。用一个例子来说明，对于一个 `User`类，密码字段非常敏感，我们不希望它被序列化后保存或传输
```java
    public class User implements Serializable {
        private String name;
        private transient String password; // 使用transient修饰，不会被序列化
    
        // ... 构造方法、getter、setter ...
    }
    ```
被 `transient`修饰的字段，在序列化时会被完全忽略。在反序列化后，这些字段的值会被设置为对应类型的默认值（例如，对象引用为 `null`，`int`为 `0`，`boolean`为 `false`）。
2. **使用 `static`修饰符**：静态变量属于类本身，而不属于任何一个对象实例。而序列化是针对对象实例状态的。因此，**静态变量不会被序列化**。
3. **自定义序列化过程**：对于需要更精细控制的场景，可以实现 `Externalizable`接口（它继承自 `Serializable`），并重写 `writeExternal`和 `readExternal`方法，完全自主地决定哪些字段需要被序列化和如何序列化。此外，即使使用 `Serializable`接口，也可以通过在类中定义 `writeObject`和 `readObject`方法来实现自定义序列化逻辑。
###### 3. serialVersionUID 的作用是什么？
`serialVersionUID`是一个名为**序列化版本统一标识符**的 `private static final long`常量。它的核心作用是**确保序列化和反序列化过程中，类的版本是兼容的**。
- **工作机制**：当对象被序列化时，JVM会将当前类的 `serialVersionUID`值一并写入字节流。当反序列化时，JVM会拿字节流中的 `serialVersionUID`与本地当前类的 `serialVersionUID`进行比较。
    - 如果两者一致，反序列化成功。
    - 如果两者不一致，则会抛出 `InvalidClassException`，反序列化失败 。
- **显式声明的重要性**：如果你没有在类中显式地声明 `serialVersionUID`，JVM会根据类的各种内部细节（如类名、方法、字段等）自动生成一个。**一旦类的结构发生任何微小的改变（比如增加一个方法），这个自动生成的ID就会发生变化，导致之前序列化的对象无法被反序列化**。因此，为了保持版本兼容性（例如，在类增加了新字段但希望仍能反序列化旧对象时），**强烈建议在可序列化的类中显式声明一个固定的 `serialVersionUID`值**。
###### 4. 序列化的底层实现原理是什么？
Java序列化的底层实现涉及`ObjectOutputStream`和`ObjectInputStream`这两个类，它们遵循一套特定的二进制协议。
1. **递归与对象图**：当你调用 `ObjectOutputStream.writeObject(Object)`时，序列化过程并不仅仅处理单个对象。它会递归地遍历该对象所引用的所有其他对象（除非被`transient`或`static`修饰，或某些对象不可序列化），直到所有关联的基本数据类型和对象都被处理完毕，从而形成一个完整的对象图。
2. **写入流程与数据格式**：写入流的数据有特定的结构：
    - **魔数（Magic Number）和版本号**：标识这是一个Java序列化流。
    - **类的描述信息（ObjectStreamClass）**：包括类的完整名称、`serialVersionUID`、字段的数量、类型和名称等元数据。这部分信息非常重要，它告诉反序列化方如何"重建"这个对象。
    - **对象的实际数据值**：即对象实例中各个非`transient`、非`static`字段的值。
    - 如果同一个对象在对象图中被多次引用，序列化机制有优化处理，只会保存一份该对象的实际数据，并通过句柄来表示引用关系，以避免循环引用和重复数据。
3. **反射机制**：在反序列化过程中，JVM首先会通过类的全限定名找到或动态加载对应的Class对象。然后，**它并不会调用类的任何公共构造方法**，而是直接使用底层机制（可理解为在JVM层面直接分配内存并设置对象头）来创建一个空的原始对象。接着，利用**反射**将字节流中读取到的字段值逐一填充到这个新创建对象的对应字段中。这正是为什么反序列化不需要通过构造函数就能创建对象的原因。
4. **自定义行为**：如前所述，如果类中定义了 `writeObject`和 `readObject`方法，序列化引擎会通过反射调用这些方法，将控制权交给类自己，从而实现自定义的序列化逻辑。对于实现 `Externalizable`接口的类，则会调用其 `writeExternal`和 `readExternal`方法，并且反序列化时会先调用类的无参构造函数。
### 十一、IO 流

###### 1. 说说 Java 中 IO 流?⁠⁠​
关于Java IO流，它就像是程序与外界（文件、网络、控制台等）进行数据交流的桥梁。

|特性|字节流 (Byte Streams)|字符流 (Character Streams)|
|---|---|---|
|**数据单位**​|字节 (8-bit)|字符 (16-bit Unicode)|
|**基类**​|`InputStream`/ `OutputStream`|`Reader`/ `Writer`|
|**处理范围**​|所有二进制数据（如图片、视频、音频）|文本数据|
|**编码处理**​|不涉及字符编码，直接操作原始字节|**自动处理编码转换**，依赖指定或默认的字符集（如UTF-8）|
|**核心用途**​|处理非文本文件，保证数据精确无误|处理文本文件，简化字符操作，避免乱码|
|**典型类**​|`FileInputStream`, `FileOutputStream`  <br>`BufferedInputStream`, `BufferedOutputStream`  <br>`ObjectInputStream`（对象序列化）|`FileReader`, `FileWriter`  <br>`BufferedReader`, `BufferedWriter`  <br>`InputStreamReader`（转换流）|
###### 2. 既然有了字节流, 为什么还要有字符流?⁠⁠​
这是一个很好的问题。字符流的出现，主要是为了解决**文本处理**的痛点。
想象一下，一个中文字符在UTF-8编码下可能占3个字节。如果只用字节流读取文本，你需要自己处理这些字节的拼接和编码转换，非常繁琐且容易出错（尤其是当字符跨字节数组边界时）。字符流则将这些底层复杂性封装了起来，它内部会帮你完成字节到字符的解码（读取时）和字符到字节的编码（写入时），让你能直接以“字符”这个逻辑单位来操作文本，大大简化了编程，并有效防止了乱码。
简单来说：**字节流是基础，能处理一切；字符流是上层建筑，为文本处理提供了极大便利**。
###### 3. 字节流如何转为字符流？⁠⁠​
字节流和字符流之间可以通过 **“转换流” 进行桥梁式的连接。核心类是 `InputStreamReader`和 `OutputStreamWriter`。
- **`InputStreamReader`**：承上启下，将一个字节输入流（如 `FileInputStream`）转换为字符输入流（`Reader`）。你可以在构造时**显式指定字符编码**，这是解决乱码问题的关键。
 ```java
    // 指定UTF-8编码读取文件，避免乱码
    try (BufferedReader reader = new BufferedReader(
            new InputStreamReader(
                new FileInputStream("source.txt"), StandardCharsets.UTF_8))) {
        String line;
        while ((line = reader.readLine()) != null) {
            // 处理每一行文本
        }
    }
    ```
- **`OutputStreamWriter`**：将一个字符输出流（`Writer`）转换为字节输出流（如 `FileOutputStream`）。
 ```java
    try (BufferedWriter writer = new BufferedWriter(
            new OutputStreamWriter(
                new FileOutputStream("output.txt"), StandardCharsets.UTF_8))) {
        writer.write("Hello, 世界！");
    }
    ```
你可能注意到 `FileReader`和 `FileWriter`是直接操作文件的字符流，但它们本质上是转换流的便捷类，只不过它们使用的是系统默认的字符编码。因此，在需要明确指定编码的跨环境场景下，更推荐使用转换流。
###### 4. Files 的常用方法都有哪些？⁠​
在Java 7中引入的 `java.nio.file.Files`类，提供了大量静态方法来操作文件，极大简化了IO操作，是现代Java开发的首选。

| 操作类型      | 常用方法                                                             | 说明                    |
| --------- | ---------------------------------------------------------------- | --------------------- |
| **读写文件**​ | `Files.readAllBytes(Path path)`                                  | 一次性读取所有字节，适用于小文件。     |
|           | `Files.readAllLines(Path path)`                                  | 读取所有行到一个List<String>。 |
|           | `Files.write(Path path, byte[] bytes)`                           | 将字节数组写入文件。            |
|           | `Files.write(Path path, Iterable<? extends CharSequence> lines)` | 将字符串集合逐行写入文件。         |
|           | `Files.newBufferedReader(Path path)`                             | 创建高效的BufferedReader。  |
| **文件操作**​ | `Files.exists(Path path)`                                        | 检查文件或目录是否存在。          |
|           | `Files.createFile(Path path)`                                    | 创建新文件。                |
|           | `Files.createDirectories(Path path)`                             | 创建目录（包括不存在的父目录）。      |
|           | `Files.copy(InputStream in, Path target)`                        | 从输入流复制到文件。            |
|           | `Files.move(Path source, Path target)`                           | 移动或重命名文件。             |
|           | `Files.delete(Path path)`                                        | 删除文件或目录（不存在则抛异常）。     |
|           | `Files.deleteIfExists(Path path)`                                | 安全删除。                 |
| **获取信息**​ | `Files.size(Path path)`                                          | 返回文件大小（字节）。           |
|           | `Files.isDirectory(Path path)`                                   | 判断是否是目录。              |
|           | `Files.getLastModifiedTime(Path path)`                           | 获取最后修改时间。             |
###### 5. FileInputStream 和 FileReader 的区别是什么？⁠​
这个区别直接源于字节流和字符流的根本不同。

|方面|`FileInputStream`|`FileReader`|
|---|---|---|
|**继承体系**​|`InputStream`(字节流)|`Reader`(字符流)|
|**读取单位**​|**字节**​ (byte)|**字符**​ (char)|
|**返回值**​|`int`类型，表示字节数据（0-255）|`int`类型，表示字符的Unicode码点|
|**编码处理**​|**不处理**，读到的就是文件的原始字节。|**自动处理**，根据默认或指定的编码将字节解码为字符。|
|**适用场景**​|复制图片、视频，或需要精确处理文件原始字节的场景。|读取文本文件内容，如配置文件、日志文件等。|

**核心结论**：处理非文本文件用 `FileInputStream`，处理文本文件用 `FileReader`（或更好指定编码的 `InputStreamReader`）。
###### 6. 简单说说 Java IO 与 NIO 的区别⁠？⁠​
传统IO（常被称为BIO, Blocking IO）和NIO（New IO）是两套不同的IO API。

|特性|Java IO (BIO)|Java NIO|
|---|---|---|
|**数据流与块**​|**面向流**：逐个字节/字符地处理数据。|**面向缓冲区**：数据先读到一个缓冲区（Buffer），然后在缓冲区中处理。|
|**阻塞与非阻塞**​|**阻塞IO**：线程在读/写操作完成前会被挂起。|**非阻塞IO**：线程可做其他事，通过选择器（Selector）轮询通道（Channel）的状态。|
|**核心组件**​|`InputStream`, `OutputStream`, `Reader`, `Writer`|**Channel**（通道），**Buffer**（缓冲区），**Selector**（选择器）|
|**工作模式**​|一个连接一个线程。成百上千连接会导致线程资源耗尽。|一个线程处理多个连接。Selector监控多个Channel上的事件，适合高并发。|
|**适用场景**​|连接数较少且固定的架构。|连接数多且连接时间短的场景，如聊天服务器、即时通讯。|

简单比喻：IO像一杯一杯接水喝（流），NIO像先拿一个桶接满水，再从桶里喝（缓冲区）。
###### 7. BIO、NIO、AIO 有什么区别？⁠​
这三者代表了Java处理IO的三种模型。

|模型|全称|含义与特点|适用场景|
|---|---|---|---|
|**BIO**​|Blocking IO (同步阻塞IO)|应用程序发起IO调用后，**线程会一直阻塞**，直到数据准备好或操作完成。|连接数少、逻辑简单的应用。|
|**NIO**​|Non-blocking IO (同步非阻塞IO)|应用程序发起IO调用后，**线程可立即返回做别的事**，并通过轮询（或Selector事件通知）来检查数据是否就绪。|高并发、连接数多的网络应用。|
|**AIO**​|Asynchronous IO (异步非阻塞IO)|应用程序发起IO调用后**立即返回**。当内核数据完全准备好后，**会主动回调**通知应用程序进行处理。|适用于需要高性能异步处理的应用，如图像处理、大规模文件IO。|

**关键理解**：BIO和NIO都是**同步**的。同步/异步关注的是**消息通信机制**：同步指调用者主动等待结果，异步指被调用者通过回调等方式通知调用者。阻塞/非阻塞关注的是**等待结果时线程的状态**。
###### 8. Java IO 中用到了哪些设计模式？⁠⁠​
Java IO流是学习设计模式的绝佳范例，主要用到了以下两种：
1. **装饰器模式**：这是IO流的核心模式。它通过**组合**而非继承的方式动态地给一个对象添加额外功能。例如，你可以给一个基础的 `FileInputStream`套上 `BufferedInputStream`来增加缓冲功能，再套上 `ObjectInputStream`来反序列化对象。这种模式比继承更灵活，各种流可以像搭积木一样自由组合。
2. **适配器模式**：转换流 `InputStreamReader`和 `OutputStreamWriter`就是适配器，它们**适配**了字节流和字符流这两个不兼容的接口，让它们可以协同工作。
###### 9. 如何正确关闭 IO 流？⁠⁠​
关闭流是为了释放系统资源（如文件句柄），否则会导致资源泄漏。有几种方式：
1. **传统的 try-catch-finally**（繁琐，不推荐）：
```java
    FileInputStream fis = null;
    try {
        fis = new FileInputStream("file.txt");
        // ... 使用流
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (fis != null) {
            try {
                fis.close(); // 确保在finally块中关闭
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ```
2. **Try-with-Resources**（**强烈推荐**，Java 7+）：这是现代Java的标准做法。只要资源（如流）实现了 `AutoCloseable`接口，就可以在try后的括号中声明，JVM会**自动**在try块结束后正确关闭它们，即使发生异常也会关闭，代码非常简洁。
```java
    try (FileInputStream fis = new FileInputStream("source.jpg");
         FileOutputStream fos = new FileOutputStream("target.jpg")) {
        // ... 使用流
    } catch (IOException e) {
        e.printStackTrace();
    } // 无需显式关闭，自动处理
    ```
###### 10. Java 有几种文件拷贝方式，哪一种效率最高？⁠​
|方式|描述|适用场景|
|---|---|---|
|**基础字节流**​|使用 `FileInputStream`和 `FileOutputStream`，配合字节数组缓冲区。|通用，但性能非最优。|
|**缓冲字节流**​|使用 `BufferedInputStream`和 `BufferedOutputStream`包装基础流。利用缓冲区减少系统调用次数，**性能显著优于基础流**。|**大多数场景下的推荐选择**，在小文件拷贝中效率很高<br><br>。|
|**NIO 的 `FileChannel`**​|使用 `FileChannel.transferTo()`或 `transferFrom()`方法。|大文件拷贝。|
|**`Files.copy()`**​|Java 7+ 提供的一站式方法，底层会优化实现。|**代码最简洁**，日常开发首选。|

**效率最高**：对于**大文件**，**NIO的`FileChannel.transferTo()`方法通常效率最高**，因为它可能用到操作系统层面的“零拷贝”技术，避免了数据在内核缓冲区和用户缓冲区之间的不必要的拷贝。
###### 11. 什么是零拷贝技术？
零拷贝是一种旨在减少数据拷贝次数、提升IO性能的优化技术。在传统的文件拷贝中，数据需要经历多次复制：
1. 从磁盘文件通过DMA拷贝到内核空间的缓冲区。
2. 从内核缓冲区拷贝到用户空间的应用程序缓冲区。
3. 应用程序处理后再从用户缓冲区拷贝到内核空间的Socket缓冲区。
4. 最后通过DMA从Socket缓冲区拷贝到网卡。
这其中有四次上下文切换和四次数据拷贝。而NIO的 `FileChannel.transferTo()`方法在底层支持零拷贝，它允许操作系统直接将数据从文件通道传输到目标通道（如Socket通道），**避免了数据在用户态和内核态之间的来回拷贝**，通常只需要两次DMA拷贝，极大地降低了CPU开销和上下文切换次数，从而提升了性能。
DMA（直接内存访问）：一种通过专用控制器实现存储器与外设间直接数据传输的技术，无需中央处理器（CPU）全程介入
###### 12. RandomAccessFile 的使用场景是什么？
`RandomAccessFile`是一个功能独特的类，它支持对文件进行“随机访问”。
它的特点是可以**自由移动文件指针**到任意位置进行读写。这打破了普通流只能顺序读写的限制。
**典型使用场景**：
- **断点续传**：下载文件时，记录已下载的位置（文件指针）。下次续传时，直接移动指针到该位置继续写入。
- **多线程下载**：将文件分成若干块，每个线程负责下载其中一块，通过移动指针到不同位置并行写入。
- **日志系统**：在文件末尾追加内容，或者读取特定位置的日志记录。
- **简单的数据库**：存储固定长度的记录，可以通过计算偏移量直接定位到某条记录进行修改。
### 十二、反射

###### 1. 说说你对 Java 反射的理解⁠？⁠​
反射机制允许程序在**运行时**（Runtime）动态地获取任何一个类的完整结构信息（如类名、方法、字段、构造器、注解等），并且能够直接操作这些成员（如调用方法、访问字段、创建对象）。
它的核心价值在于**动态性**，打破了“编译期绑定”的限制，使得程序无需在编码时硬编码具体类，从而具备了极高的灵活性，这也是 Spring、Hibernate 等众多主流框架能够实现的核心技术。
###### 2. 说说反射机制的优缺点？⁠​
反射是一把强大的“双刃剑”，其优缺点对比如下：

| 特性           | 优点                                  | 缺点                                        |
| ------------ | ----------------------------------- | ----------------------------------------- |
| **动态性与灵活性**​ | **高**。允许运行时动态加载和操作类，是实现框架和插件化架构的基础。 | **低**。代码行为在运行时才能确定，编译期无法检查，增加了复杂度和调试难度。   |
| **性能**​      | -                                   | **较低**。反射操作涉及动态解析，比直接调用慢数倍至数十倍，且会绕过JIT优化。 |
| **封装性**​     | 可突破访问限制，访问私有成员，用于测试、序列化等特殊场景。       | **破坏封装**。可能破坏类的设计初衷，导致对象状态不一致等安全隐患。       |
| **安全性**​     | -                                   | **有风险**。可能绕过安全管理器限制，访问内部API。              |

**最佳实践建议**：在普通的业务代码开发中应**谨慎使用**反射。它的主战场是构建**通用性框架、开发工具和进行系统集成**。如果必须使用，务必注意性能优化和安全控制。
###### 3. 获取一个类 Class 对象的方式有哪些？⁠​
要进行任何反射操作，第一步都是获取该类的 `Class`对象。一个类在 JVM 中只有唯一的一个 `Class`对象。主要有三种核心方式：
1. **`类名.class`（类字面常量）**
    这是最安全、性能最好的方式，因为在编译期就能确定。
```java
    Class<String> stringClass = String.class;
    Class<Integer> intClass = int.class; // 也适用于基本数据类型
    ```
2. **`对象实例.getClass()`**
    ```java
    String str = "Hello";
    Class<? extends String> strClass = str.getClass();
    ```
3. **`Class.forName("类的全限定名")`**
    这是**最常用**的方式，尤其适用于框架开发。你可以通过配置文件、数据库等外部资源传入类的完整路径名，实现动态加载。
    ```java
    // 可能会抛出 ClassNotFoundException
    Class<?> aClass = Class.forName("java.lang.String");
    ```
此外，还可以通过类加载器（`ClassLoader`）的 `loadClass`方法获取，这提供了更底层的控制。
###### 4. Class. forName 和 ClassLoader 有什么区别 ？⁠​
`Class.forName`和通过 `ClassLoader.loadClass`都能加载类，但有一个关键区别：**初始化策略**。

|方法|初始化策略|说明|
|---|---|---|
|**`Class.forName(className)`**​|**默认执行类的初始化**​|此方法加载类的同时，会链接并**初始化**这个类（即执行类的静态代码块和静态变量的赋值）。|
|**`ClassLoader.loadClass(className)`**​|**默认不执行初始化**​|此方法仅完成**加载**阶段，不会进行链接阶段的准备和初始化，直到类被首次主动使用时才初始化。|

`Class.forName`有一个重载方法 `Class.forName(String name, boolean initialize, ClassLoader loader)`，你可以通过第二个参数显式控制是否初始化。
**简单来说**：如果你希望类被立即初始化（例如，JDBC 驱动注册就需要在初始化时完成），用 `forName`。如果只是想提前加载类到内存，用 `loadClass`性能更好。
###### 5. 反射机制的应用场景有哪些？⁠​
反射的真正威力体现在以下场景中：
- **框架开发**：这是反射最核心的应用。
    - **Spring IOC**：容器通过读取配置（如注解`@Component`），利用反射动态创建和管理 Bean 对象，并完成依赖注入（`@Autowired`）。
    - **MyBatis/Hibernate**：将数据库查询结果集映射到 Java 实体对象时，通过反射为对象的属性赋值。
- **动态代理**：JDK 动态代理（`java.lang.reflect.Proxy`）在运行时生成代理类，通过 `InvocationHandler`的 `invoke`方法拦截并增强目标方法，这是 AOP 面向切面编程的基础。
- **注解处理**：许多框架（如 JUnit、Spring MVC）通过反射读取类、方法、字段上的注解，并根据注解信息执行相应逻辑。
- **开发工具**：IDE 的代码提示、调试器查看对象结构等功能，都依赖于反射来获取类的信息。
###### 6. 如何通过反射创建对象？
获取 `Class`对象后，有两种主要方式创建实例：
1. **通过 `Class.newInstance()`(已过时)**
    此方法在早期版本中使用，但只能调用**无参构造器**，且要求构造器是可见的。在 Java 9 后被标记为过时，不推荐使用。
2. **通过 `Constructor.newInstance()`(推荐)**
    这是现代 Java 开发的标准做法，功能更强大，可以调用**任意参数类型的构造器**，包括私有构造器（需先设置可访问）。
    ```java
    Class<?> clazz = Class.forName("com.example.Person");
    
    // 1. 调用无参构造器（最常用）
    Object obj1 = clazz.getDeclaredConstructor().newInstance();
    
    // 2. 调用有参构造器
    Constructor<?> constructor = clazz.getDeclaredConstructor(String.class, int.class);
    Object obj2 = constructor.newInstance("Alice", 25);
    
    // 3. 调用私有构造器
    Constructor<?> privateConstructor = clazz.getDeclaredConstructor(String.class);
    privateConstructor.setAccessible(true); // 突破私有访问限制！
    Object obj3 = privateConstructor.newInstance("Secret");
    ```
###### 7. 如何通过反射调用私有方法？
调用私有方法的关键在于使用 `setAccessible(true)`方法来暂时关闭 Java 语言的访问检查。步骤如下：
1. 获取类的 `Class`对象。
2. 通过 `getDeclaredMethod`获取私有 `Method`对象（注意是 `getDeclaredMethod`，不是 `getMethod`）。
3. 调用 `method.setAccessible(true)`。
4. 使用 `method.invoke(obj, args...)`执行方法。
```java
// 假设有一个类，其中包含私有方法
class SecretService {
    private String getSecretCode() {
        return "TopSecret123";
    }
}

// 通过反射调用私有方法
SecretService service = new SecretService();
Class<?> clazz = service.getClass();

// 获取私有方法对象 (getDeclaredMethod 可以获取类声明的所有方法，包括私有方法)
Method secretMethod = clazz.getDeclaredMethod("getSecretCode");

// 关键：设置可访问性为 true，绕过 private 检查
secretMethod.setAccessible(true);

// 调用方法，由于是无参方法，invoke 的第二个参数为 null
String result = (String) secretMethod.invoke(service); // result 的值为 "TopSecret123"
System.out.println(result);
```

**重要提示**：`setAccessible(true)`是一把“破窗锤”。它能让你突破封装，但也带来了破坏对象状态稳定性和安全性的风险，应**仅在充分理解后果的情况下谨慎使用**，例如在单元测试、框架开发或序列化等特定场景中。
### 十三、注解

###### 1. Java 中的注解的作用是什么？⁠​
Java 注解本质上是代码的**元数据**，即“关于数据的数据”。它们本身不会直接改变代码的逻辑，而是作为一种**标记**或**说明信息**附着在代码元素（如类、方法、字段、参数等）上。这些信息可以被编译器、开发工具或运行时环境（JVM）读取并用于特定目的。
其主要作用可以归纳为以下三个方面：
1. **编译检查**：注解能为编译器提供额外信息，协助进行静态代码检查。最典型的例子是 `@Override`。当你使用它修饰一个方法时，编译器会严格检查该方法是否正确地重写了父类中的方法。如果签名不一致，编译器就会报错，帮助你在早期发现潜在问题。`@Deprecated`则用于标记元素已过时，编译器会生成警告提示开发者。
2. **框架配置与代码生成**：这是注解在现代Java开发中最重要的作用，特别是在Spring、Hibernate等框架中。注解可以替代繁琐的XML配置文件，将配置信息直接写在代码上，使得配置更集中、更直观。
    - **依赖注入**：如Spring中的 `@Autowired`，框架在运行时读取此注解，会自动寻找合适的Bean并注入到指定位置。
    - **对象关系映射**：如JPA中的 `@Entity`, `@Table`，框架根据这些注解将Java类与数据库表映射起来。
    - **生成代码**：一些工具（如Lombok）可以通过注解在编译期自动生成`getter`、`setter`等方法，极大减少样板代码。
3. **生成帮助文档**：通过 `@Documented`元注解修饰的自定义注解，其信息会被Javadoc工具捕捉，并包含在生成的API文档中，方便他人理解代码的用途和约定。
###### 2. Java注解的常见分类？⁠⁠​
注解可以按照不同的维度进行分类，常见的分类方式包括：
**1. 按来源分类**
- **内置注解**：JDK自带的注解，如 `@Override`, `@Deprecated`, `@SuppressWarnings`, `@FunctionalInterface`等。
- **元注解**：用于定义其他注解的注解，是注解的“语法”，如 `@Target`, `@Retention`, `@Documented`, `@Inherited`, `@Repeatable`。
- **自定义注解**：用户根据业务需求自己定义的注解。
**2. 按注解本身包含的成员变量数量分类**​
- **标记注解**：没有定义任何成员的注解，仅通过自身存在与否来提供信息，如 `@Override`。
- **单值注解**：仅包含一个成员的注解。
- **全值注解**：包含多个成员的注解。
**3. 按生命周期和保留策略分类（由 `@Retention`指定）**​
- **SOURCE**：仅在源码级别保留，编译时将被丢弃（如 `@Override`）。主要用于编译期检查。
- **CLASS**：被保留在编译生成的 `.class`文件中，但不会被JVM加载到运行时。这是**默认策略**。
- **RUNTIME**：在运行时依然存在，因此可以通过反射机制读取。这是**最常用**的策略，框架配置通常使用此类注解。
###### 3. 如何自定义注解？
创建自定义注解非常简单，其本质是声明一个接口，但使用关键字 `@interface`。定义注解时，通常需要使用**元注解**来修饰它，以指定其行为。
以下是创建一个自定义注解的详细步骤：
**1. 定义注解**
使用 `@interface`关键字。注解内部的成员以无参数方法的形式来声明，方法名即为成员名，可以指定默认值。
```java
// 导入必要的元注解
import java.lang.annotation.*;

// 使用元注解定义新注解的行为
@Retention(RetentionPolicy.RUNTIME) // 注解在运行时保留
@Target(ElementType.METHOD)         // 注解只能用于方法上
@Documented                          // 生成到Javadoc中
public @interface MyCustomAnnotation {
    // 定义成员变量，看起来像方法，用起来像属性
    String value() default "default value"; // 名为value的成员，可指定默认值
    String description() default "";       // 另一个成员
}
```
**2. 使用注解**
将定义好的注解应用到代码的相应元素上。
```java
public class MyService {
    
    @MyCustomAnnotation(value = "这是一个测试方法", description = "用于演示自定义注解")
    public void myBusinessMethod() {
        // ... 业务逻辑
    }
    
    @MyCustomAnnotation // 使用默认值
    public void anotherMethod() {
        // ...
    }
}
```
**3. 处理注解（通过反射）**
定义和使用注解本身不产生任何效果，关键在于**编写代码来读取并处理这些注解**。
```java
import java.lang.reflect.Method;

public class AnnotationProcessor {
    public static void main(String[] args) throws Exception {
        // 1. 获取类的Class对象
        Class<MyService> clazz = MyService.class;
        
        // 2. 获取目标方法
        Method method = clazz.getMethod("myBusinessMethod");
        
        // 3. 判断方法上是否存在特定注解
        if (method.isAnnotationPresent(MyCustomAnnotation.class)) {
            // 4. 获取注解实例
            MyCustomAnnotation annotation = method.getAnnotation(MyCustomAnnotation.class);
            
            // 5. 从注解实例中获取成员的值
            String value = annotation.value();
            String desc = annotation.description();
            
            System.out.println("Value: " + value);
            System.out.println("Description: " + desc);
            
            // 这里可以根据注解信息执行特定逻辑，例如权限检查、日志记录等
        }
    }
}
```
###### 4. 元注解有哪些？各自的作用是什么？
元注解是Java提供用于修饰其他注解的注解。它们就像是注解世界的“语法规则”，规定了自定义注解的基本行为。Java 5种主要的元注解如下：

| 元注解                | 作用                                         | 可选值/说明                                                                    |
| ------------------ | ------------------------------------------ | ------------------------------------------------------------------------- |
| **`@Target`**​     | **指定注解可以应用在哪些程序元素上。**​                     | `ElementType.TYPE`（类/接口/枚举）, `METHOD`（方法）, `FIELD`（字段）, `PARAMETER`（参数）等。 |
| **`@Retention`**​  | **指定注解的生命周期，即注解信息保留到哪个阶段。**​               | `RetentionPolicy.SOURCE`（源码）, `CLASS`（类文件）, **`RUNTIME`（运行时）**​。          |
| **`@Documented`**​ | **指明该注解应被Javadoc工具记录，包含在生成的API文档中。**​      | 它是一个标记注解，没有成员。                                                            |
| **`@Inherited`**​  | **指明被它修饰的注解具有继承性。如果父类使用了该注解，子类将自动具有此注解。**​ | 只对类继承有效，对接口实现无效。是标记注解。                                                    |
| **`@Repeatable`**​ | **允许在同一程序元素上多次使用相同的注解。**​                  | Java 8引入，需要配套一个“容器注解”。                                                    |
###### 5. 注解和反射的关系是什么？
**注解和反射是相辅相成、紧密结合的两大特性。简单来说，反射是运行时读取和处理注解信息的“手电筒”和“手术刀”**​。
- **注解提供元数据**：注解在代码上做标记，存储配置信息。
- **反射提供动态读取能力**：反射API（在 `java.lang.reflect`包中）允许程序在**运行时**检查类、方法、字段等结构，并能获取它们上面的注解信息。
这种结合是实现各种框架功能的基石：
- **Spring框架**：在启动时，Spring会扫描类路径，通过反射检查类上的注解（如 `@Component`, `@Service`），从而自动创建和管理Bean。`@Autowired`也是通过反射机制实现依赖的自动注入。
- **JUnit测试框架**：通过反射查找被 `@Test`注解的方法，然后动态调用它们来执行测试。
- **序列化/反序列化**（如Jackson/Gson）：通过反射读取对象字段上的注解（如 `@JsonProperty`），来确定如何将JSON字段映射到Java对象。
**核心流程可以概括为**：**定义注解 → 使用注解标记 → 通过反射读取注解信息 → 根据注解信息执行相应逻辑**。如果没有反射，运行时的注解就只是一段无用的注释；而没有注解，反射的很多高级应用（如灵活的配置）将难以实现。
### 十四、代理

###### 1. 什么是 Java 中的动态代理？⁠⁠​
**动态代理**是一种在**程序运行时**动态创建代理对象的技术。你可以把它想象成一个“智能替身”。这个替身和真实对象实现了相同的接口（或继承自同一类），当客户端调用这个替身的方法时，调用不会直接到达真实对象，而是先被一个“调用处理器”拦截。在这个处理器中，你可以在执行真实方法的前后插入自己的逻辑，比如记录日志、检查权限、管理事务等，从而实现对原始功能的增强（AOP），而无需修改原始类的代码。
它的核心价值在于**解耦**和**扩展性**。它将那些与核心业务逻辑无关的通用功能（即“横切关注点”）从业务代码中剥离出来，使得代码更清晰、更易于维护和复用。
###### 2. JDK 动态代理和 CGLIB 动态代理有什么区别？⁠​
JDK动态代理和CGLIB动态代理是Java中实现动态代理的两种主要技术，它们在工作原理和应用场景上有显著区别，下图直观展示了它们各自的工作流程及典型应用场景。

复制

```mermaid
flowchart TD
    A[客户端调用] --> B{代理创建方式}
    B --> C[JDK动态代理]
    B --> D[CGLIB动态代理]
    
    subgraph C [JDK动态代理]
        C1[目标类必须实现接口] --> C2[Proxy类创建代理实例]
        C2 --> C3[InvocationHandler.invoke<br>进行增强]
        C3 --> C4[反射调用目标方法]
    end
    
    subgraph D [CGLIB动态代理]
        D1[可代理普通类] --> D2[Enhancer创建子类代理]
        D2 --> D3[MethodInterceptor.intercept<br>进行增强]
        D3 --> D4[方法索引快速调用]
    end
    
    C4 --> E[执行核心业务逻辑]
    D4 --> E
    
    C --> F[典型场景：<br>Spring AOP（默认基于接口）]
    D --> G[典型场景：<br>Spring AOP（需代理类时）<br>Hibernate（延迟加载）]
```

JDK动态代理和CGLIB动态代理是Java中实现动态代理的两种主要技术，它们在工作原理和应用场景上有显著区别。
**JDK 动态代理**​ 基于Java反射机制，要求被代理的类**必须至少实现一个接口**。其核心是`java.lang.reflect.Proxy`类和`java.lang.reflect.InvocationHandler`接口。代理对象是在运行时动态生成的，实现了目标接口。由于JDK代理在方法调用时使用了反射机制，在早期版本中其性能开销相对较大，但新版本JDK的性能已有显著提升。
**CGLIB (Code Generation Library) 动态代理**​ 是一个第三方库，它通过**继承**目标类并生成其子类的方式来实现代理。因为它是通过继承实现的，所以**不需要**目标类实现任何接口。CGLIB在运行时动态生成一个子类，并重写父类的方法。在调用方法时，它通常通过方法索引直接调用，避免了反射开销，因此通常比JDK动态代理的反射调用性能更高。
```java
//JDK动态代理demo
// 1. 接口（同上）
public interface UserService {
    void saveUser();
}

// 2. 原始类（同上）
public class UserServiceImpl implements UserService {
    @Override
    public void saveUser() {
        System.out.println("核心业务：用户数据已保存至数据库");
    }
}

// 3. 调用处理器（定义增强逻辑）
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class UserServiceInvocationHandler implements InvocationHandler {
    private Object target; // 目标对象

    public UserServiceInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 在目标方法执行前添加逻辑
        System.out.println("动态代理-前置操作：权限检查...");

        // 通过反射调用目标对象的方法
        Object returnValue = method.invoke(target, args);

        // 在目标方法执行后添加逻辑
        System.out.println("动态代理-后置操作：记录日志...");
        return returnValue;
    }
}

// 4. 测试类：使用Proxy类动态生成代理对象
import java.lang.reflect.Proxy;

public class Test {
    public static void main(String[] args) {
        UserService target = new UserServiceImpl(); // 目标对象

        // 创建动态代理实例
        UserService proxy = (UserService) Proxy.newProxyInstance(
                target.getClass().getClassLoader(), // 1. 目标类的类加载器
                target.getClass().getInterfaces(),  // 2. 目标类实现的所有接口
                new UserServiceInvocationHandler(target) // 3. 调用处理器实例
        );

        proxy.saveUser(); // 调用代理对象的方法
        System.out.println("代理对象的实际类型：" + proxy.getClass().getName());
    }
}
```
首先，需要在项目中引入CGLIB依赖。如果使用Maven，可以在`pom.xml`中添加：
```xml
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.3.0</version> <!-- 请使用最新版本 -->
</dependency>
```
```java
//CGLib动态代理demo
// 1. 目标类（这次没有实现接口！）
public class UserService {
    public void saveUser() {
        System.out.println("核心业务（CGLIB代理）：用户数据已保存至数据库");
    }
}

// 2. 方法拦截器
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;

public class UserServiceMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        // 在目标方法执行前添加逻辑
        System.out.println("CGLIB代理-前置操作：性能监控开始...");

        // 调用目标类（父类）的方法
        Object returnValue = proxy.invokeSuper(obj, args);

        // 在目标方法执行后添加逻辑
        System.out.println("CGLIB代理-后置操作：性能监控结束...");
        return returnValue;
    }
}

// 3. 测试类：使用Enhancer创建代理对象
import net.sf.cglib.proxy.Enhancer;

public class Test {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserService.class); // 设置目标类为父类
        enhancer.setCallback(new UserServiceMethodInterceptor()); // 设置回调（拦截器）

        UserService proxy = (UserService) enhancer.create(); // 创建代理对象
        proxy.saveUser();
        System.out.println("CGLIB代理对象的实际类型：" + proxy.getClass().getSuperclass());
    }
}
```
###### 3. 什么是静态代理？
**静态代理**是指在**程序编译期**就确定代理关系的代理模式。你需要手动编写一个代理类，这个代理类与被代理类实现相同的接口，并在内部持有被代理对象的引用。代理类中的每个方法都会调用被代理对象的相应方法，并可以在调用前后添加额外的逻辑。
静态代理的主要优点是简单、直观。但其致命缺点是**灵活性极差**。如果被代理的接口增加或修改方法，那么代理类和所有相关的类都需要同步修改，容易造成“类爆炸”。
```java
// 1. 定义接口
public interface UserService {
    void saveUser();
}

// 2. 原始类（目标对象）
public class UserServiceImpl implements UserService {
    @Override
    public void saveUser() {
        System.out.println("核心业务：用户数据已保存至数据库");
    }
}

// 3. 代理类（也实现相同接口）
public class UserServiceProxy implements UserService {
    private UserService target; // 持有目标对象的引用

    public UserServiceProxy(UserService target) {
        this.target = target;
    }

    @Override
    public void saveUser() {
        System.out.println("代理前置操作：开启事务..."); // 增强功能
        target.saveUser(); // 调用目标对象的方法
        System.out.println("代理后置操作：提交事务..."); // 增强功能
    }
}

// 4. 测试类
public class Test {
    public static void main(String[] args) {
        UserService target = new UserServiceImpl(); // 创建目标对象
        UserService proxy = new UserServiceProxy(target); // 创建代理对象，传入目标对象
        proxy.saveUser(); // 调用的是代理对象的方法
    }
}
```
###### 4. 动态代理的实现原理是什么？
**JDK 动态代理原理**
- **字节码生成**：当你调用 `Proxy.newProxyInstance()`时，JDK会**动态地在内存中生成一个代理类的字节码**（类名通常为 `$ProxyN`）。这个代理类实现了你指定的所有接口。
- **方法路由**：生成的代理类会将所有接口方法的调用，都路由到其内部持有的 `InvocationHandler`实例的 `invoke`方法。你可以在这个 `invoke`方法中实现增强逻辑。
- **反射调用**：在 `invoke`方法内部，你通过 `Method.invoke(target, args)`利用反射机制调用目标对象的具体方法。
**CGLIB 动态代理原理**
- **子类化**：CGLIB使用底层的**字节码操作库（如ASM）**​ 动态生成一个**继承自目标类的子类**作为代理类。
- **方法重写**：代理类会重写目标类的所有**非 final 方法**。在重写的方法中，会调用绑定的 `MethodInterceptor`的 `intercept`方法。
- **快速调用**：在 `intercept`方法中，CGLIB通过生成的 `MethodProxy`对象来调用父类（即目标类）的方法。这种方式比JDK的反射调用更高效。
### 十五、SPI 机制

###### 1. 什么是 SPI?⁠⁠​

###### 2. SPI 和 API 的区别是什么？

###### 3. SPI 的实现原理是什么？

### 十六、JDK 常用包与新特性

###### 1. 熟悉 JDK 哪些包？⁠⁠​

###### 2. JDK 1.8 有哪些新特性？⁠⁠​

###### 3. Java 8-22 新特性总结?⁠⁠​

###### 4. Stream API 的常用操作有哪些？

###### 5. Optional 类的作用是什么？如何使用？

###### 6. Lambda 表达式的底层实现原理是什么？