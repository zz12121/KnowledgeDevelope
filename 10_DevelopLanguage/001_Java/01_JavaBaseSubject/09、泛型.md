###### 1. 为什么需要泛型？⁠⁠​
在泛型出现之前，Java 代码（尤其是集合类）普遍使用 `Object`来实现“通用”编程，但这带来了三个主要问题：
1. **类型不安全**：编译器无法检查存入集合的元素类型，任何对象都能放入。当将其强制转换为期望的类型时，如果类型不匹配，就会在**运行时**抛出 `ClassCastException`，这是一个重大的安全隐患。
 ```java
    // 泛型之前的代码（危险！）
    List list = new ArrayList();
    list.add("hello");
    list.add(100); // 编译器不报错
    String item = (String) list.get(1); // 运行时抛出 ClassCastException
    ```
2. **繁琐的强制类型转换**：每次从集合中取出元素，都需要进行显式的类型转换，代码冗余且容易出错。
3. **代码可读性差**：无法从代码声明中直观看出集合 intended 要存储的元素类型。
**泛型的引入，完美地解决了这些问题：**
- **类型安全**：编译器在编译期就能进行类型检查。一旦指定 `List<String>`，尝试存入一个 `Integer`对象将导致**编译错误**，将错误发现提前到了编译阶段。
  ```java
    // 使用泛型
    List<String> list = new ArrayList<>();
    list.add("hello");
    // list.add(100); // 编译错误！IDE和编译器都会立即报错
    String item = list.get(0); // 无需强制转换
    ```
- **消除强制转换**：编译器知晓具体类型，会自动加入必要的类型转换，代码更简洁。
- **提高代码复用性**：可以编写通用的算法和数据结构，适用于多种类型。
###### 2. 如何使用泛型？⁠⁠​
泛型可以应用于类、接口和方法。
1. **泛型类/接口**
    在类名或接口名后使用尖括号 `<T>`声明类型参数。`T`是一个占位符，可以是任何大写字母（如 K, V, E 等）。在类体或接口体内，`T`可以像普通类型一样使用。
    ```java
    // 泛型类
    public class Box<T> {
        private T value;
        public void setValue(T value) { this.value = value; }
        public T getValue() { return value; }
    }
    // 泛型接口
    public interface Pair<K, V> {
        K getKey();
        V getValue();
    }
    // 使用
    Box<String> stringBox = new Box<>();
    stringBox.setValue("Generic");
    String value = stringBox.getValue(); // 类型安全，无需转换
    ```
2. **泛型方法**
    在方法的返回值前声明类型参数 `<T>`。泛型方法可以存在于普通类中，也可以存在于泛型类中。它的类型参数 `<T>`与类的类型参数 `<T>`无关。
    ```java
    public class Utility {
        // 泛型方法，将数组转换为列表
        public static <T> List<T> fromArrayToList(T[] array) {
            return Arrays.asList(array);
        }
    }
    // 使用
    Integer[] intArray = {1, 2, 3};
    List<Integer> intList = Utility.fromArrayToList(intArray); // 类型推断
    ```
###### 3. 泛型的上限和下限是什么？⁠⁠​
为了增加对类型参数的灵活性和控制，泛型提供了边界（Bounds）机制。
- **上界通配符 `<? extends T>`**
    表示“未知的某种类型，它是 `T`类型或其子类型”。因为它能安全地**读取**为 `T`（多态性），所以通常用于**生产**数据的场景。
  ```java
    // 此方法可以接受一个装载了Number或其子类（如Integer, Double）对象的列表
    public static double sumOfList(List<? extends Number> list) {
        double sum = 0.0;
        for (Number num : list) { // 可以安全地读取为Number
            sum += num.doubleValue();
        }
        return sum;
    }
    // 但你不能向这个列表添加元素（null除外），因为编译器不知道具体是哪种子类型
    // list.add(new Integer(1)); // 编译错误！
    ```
- **下界通配符 `<? super T>`**
    表示“未知的某种类型，它是 `T`类型或其父类型”。因为它能安全地**写入**​ `T`类型的对象（父类引用可以指向子类对象），所以通常用于**消费**数据的场景。
```java
    // 此方法可以向一个装载了Integer或其父类（如Number, Object）对象的列表写入Integer
    public static void addNumbers(List<? super Integer> list) {
        for (int i = 1; i <= 5; i++) {
            list.add(i); // 可以安全地写入Integer及其子类
        }
    }
    // 但从这个列表读取时，只能将其视为Object，因为父类型不确定
    // Integer num = list.get(0); // 编译错误！
    // Object obj = list.get(0); // 正确
    ```
###### 4. Java中的泛型为什么是伪泛型？⁠​什么是类型擦除？
Java 的泛型是通过 **类型擦除**​ 来实现的，这是理解 Java 泛型底层机制的关键。
- **什么是类型擦除？**
    编译器在编译 Java 源码时，会**移除所有泛型类型信息**。类型参数 `<T>`会被替换为其**上限**（未指定上限时默认为 `Object`），并在必要的地方插入强制类型转换。
```java
    // 编译前
    List<String> list = new ArrayList<>();
    list.add("Hello");
    String s = list.get(0);
    
    // 编译后（类型擦除后的近似效果）
    List list = new ArrayList(); // <String> 被擦除
    list.add("Hello");
    String s = (String) list.get(0); // 编译器自动插入转换
    ```
- **为什么说 Java 泛型是“伪泛型”？**
    因为泛型信息只存在于编译期，**运行时是没有泛型类型信息的**。例如，`List<String>`和 `List<Integer>`在运行时都是 `List`类，无法通过反射在运行时判断一个 `List`到底包含什么类型的元素。这与 C# 等语言在运行时保留类型信息的“真泛型”有本质区别，故被称为伪泛型。
    ```java
    List<String> strList = new ArrayList<>();
    List<Integer> intList = new ArrayList<>();
    System.out.println(strList.getClass() == intList.getClass()); // 输出 true
    ```
- **类型擦除带来的限制**
    - **不能使用基本类型作为类型参数**：如 `List<int>`是错误的，必须使用包装类 `List<Integer>`，因为擦除后 `T`是 `Object`，而基本类型不是对象。
    - **不能实例化类型参数**：`new T()`是非法的，因为擦除后 `T`变成 `Object`，这没有意义。
    - **不能创建泛型数组**：如 `new List<String>[10]`通常是非法的，因为数组需要在运行时知道其元素的确切类型。
    - **`instanceof`检查失效**：不能使用 `obj instanceof T<String>`。
###### 5. 泛型中 extends 和 super 的区别（PECS 原则）？
PECS 的全称是 **"Producer-Extends, Consumer-Super"**。这个原则是 Joshua Bloch 在《Effective Java》中提出的，用于指导在方法参数中何时使用 `extends`通配符，何时使用 `super`通配符。
- **Producer (生产者) - 使用 `extends`**：如果你需要一个**提供（生产）`T`类型对象的数据源，应该使用 `<? extends T>`。因为你主要目的是从结构中**读取**数据。
- **Consumer (消费者) - 使用 `super`**：如果你需要一个**接收（消费）`T`类型对象的数据池，应该使用 `<? super T>`。因为你主要目的是向结构中**写入**数据。
**经典示例：`java.util.Collections.copy`方法**
```java
public static <T> void copy(List<? super T> dest, List<? extends T> src) {
    // dest 是消费者，我们向其中写入T类型的元素，所以用 ? super T
    // src 是生产者，我们从中读取T类型的元素，所以用 ? extends T
    for (int i=0; i<src.size(); i++) {
        dest.set(i, src.get(i));
    }
}
```