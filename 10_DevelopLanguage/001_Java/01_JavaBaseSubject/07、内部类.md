###### 1. 什么是内部类？
| 特性维度      | 内部类概览                                      |
| --------- | ------------------------------------------ |
| **核心定义**​ | 定义在另一个类（外部类）内部的类，是其外部类的一个成员。               |
| **主要类型**​ | 成员内部类、静态内部类、局部内部类、匿名内部类。                   |
| **核心优点**​ | 增强封装、逻辑聚合、代码精简、解决特定问题（如多继承局限）。             |
| **访问权限**​ | 内部类可以访问外部类的所有成员（包括私有成员），静态内部类只能访问外部类的静态成员。 |
| **对象创建**​ | 非静态内部类实例依赖外部类实例；静态内部类实例可独立创建。              |
###### 2. 内部类有什么优点？⁠​
内部类之所以被广泛使用，主要归功于以下几个关键优点：
- **增强封装性**：内部类可以访问其外部类的所有成员（包括`private`私有成员），这使得你可以将一些高度关联、仅为外部类服务的逻辑完全隐藏在外部类内部，对外部类的使用者不可见，从而实现了更彻底的封装。
- **优化代码组织**：内部类允许你将逻辑上紧密相关的类组织在一起。例如，一个`User`类内部定义一个`Address`类，这比将两个类完全分开定义更清晰，减少了类文件的扩散，提高了代码的可读性和可维护性。
- **使代码更紧凑**：特别是**局部内部类**和**匿名内部类**，它们允许你在需要的地方（如方法内部）即时定义和使用一个类，避免了为只使用一次的类单独创建文件的麻烦，让代码更加简洁。
###### 3. 内部类有哪些应用场景？⁠​
不同的内部类各有其适用的场景：
- **成员内部类**：适用于与外部类实例有**强依赖关系**的场景，需要直接访问外部类的实例成员。例如，一个`BankAccount`（银行账户）类内部的`Transaction`（交易）类，交易需要直接操作账户的余额。
- **静态内部类**：当你需要定义一个与外部类关联但**不依赖其具体实例**的辅助类时，静态内部类是最佳选择。它常用于工具类或表示外部类的组件，例如，一个`Utility`类内部的`MathHelper`静态工具类。
- **局部内部类**：当某个类的功能**只在一个方法内部需要**时，可以使用局部内部类。它有助于进一步限制作用域，例如在`calculate`方法内定义一个临时的`Addition`（加法）类。
- **匿名内部类**：广泛应用于需要**快速实现接口或继承类**，且这个实现**只使用一次**的场景。最常见的就是图形用户界面（GUI）编程中的事件监听器，以及多线程中`Runnable`接口的即时实现。
###### 4. 为什么匿名内部类只能使用成员变量或者被 final 修饰的局部变量呢？⁠​
这是一个深入且重要的问题。匿名内部类只能访问**最终效果（Effectively Final）的局部变量（即事实不可变的变量，无论是否显式声明为`final`），但可以自由访问成员变量。这主要是由**生命周期差异**和**数据一致性**决定的。
- **生命周期差异**：局部变量随着方法的执行结束而被销毁。而通过`new`创建的匿名内部类对象（位于堆内存）其生命周期可能远长于方法（其栈帧）。如果允许内部类直接修改局部变量，就会造成一个矛盾：内部类对象可能试图去访问一个已经不复存在的变量。
- **数据一致性**：为了解决这个矛盾，Java采取了“值复制”的策略。当匿名内部类引用一个局部变量时，Java会**将局部变量的值复制一份**给内部类。为了确保在整个生命周期内，内部类看到的这个值始终一致，就必须要求该局部变量的值初始化后不能再改变，即它是**最终效果不可变的（Effectively Final）**。
- **成员变量为何不受限**：成员变量的生命周期与对象实例绑定，都存在于堆内存中，因此不存在生命周期不匹配的问题。
###### 5. 静态内部类和非静态内部类的区别？
静态内部类和非静态内部类（即普通的成员内部类）的核心区别在于它们与外部类实例的关联方式，这导致了多方面的差异：

| 特性          | 非静态内部类（成员内部类）                                                   | 静态内部类                                                        |
| ----------- | --------------------------------------------------------------- | ------------------------------------------------------------ |
| **依赖关系**​   | **依赖**于外部类的具体实例。                                                | **独立**于外部类的实例。                                               |
| **创建方式**​   | `OuterClass.InnerClass inner = outerInstance.new InnerClass();` | `OuterClass.InnerClass inner = new OuterClass.InnerClass();` |
| **访问权限**​   | 可自由访问外部类的**所有成员**（实例和静态）。                                       | 只能访问外部类的**静态成员**。                                            |
| **包含静态成员**​ | 在新版JDK中可包含静态成员，但通常不推荐。                                          | 可以正常包含静态和非静态成员。                                              |
| **内存泄漏风险**​ | 隐式持有外部类引用，使用不当可能引起。                                             | 无此风险，更安全。                                                    |
###### 6. 局部内部类有什么特点？
局部内部类具有一些独特的特性，使其在特定场景下非常有用：
- **作用域受限**：局部内部类定义在方法或代码块内部，其作用范围被严格限制在**定义它的方法或代码块之内**，外界无法访问，这提供了最强的封装性。
- **访问局部变量的限制**：和匿名内部类类似，局部内部类访问的局部变量也必须是**最终效果不可变的（Effectively Final）**，原因同样是生命周期和数据一致性的考量。
- **有限的修饰符**：局部内部类**不能被`public`, `protected`, `private`, `static`等访问修饰符修饰**。它就像是方法里的一个局部“对象”，其地位类似于一个局部变量。
- **编译文件**：编译后，局部内部类会生成独立的字节码文件，文件名格式为：`外部类名$数字局部内部类名.class`（其中的数字用于区分同一外部类中同名的不同局部内部类）。