###### 1. final 有哪些用法?⁠⁠​
`final`关键字在 Java 中用途广泛，用于表示“不可改变”，可以修饰变量、方法和类。
1. **final 变量（常量）**：
    - 修饰基本类型变量：值一旦初始化就不能再改变。
    - 修饰引用类型变量：引用地址不能改变，但其所指向对象内部的状态（属性值）是可以改变的。
    - 常与 `static`联用定义类常量，如 `public static final double PI = 3.14;`。
2. **final 方法**：
    - 被 `final`修饰的方法不能被子类**重写**。
    - 用于防止继承类改变方法的核心逻辑，或用于效率优化（早期版本，现在已不明显）。
3. **final 类**：
    - 被 `final`修饰的类不能被**继承**。
    - 用于表示这个类已经是“最终”形态，不需要或不允许被扩展，例如 Java 中的 `String`类。
###### 2. 说说 this 关键字的用法?⁠⁠​
`this`关键字在 Java 中是一个指向**当前对象实例**的引用。它的核心用途是帮助在类的内部明确地访问当前对象的成员（变量和方法），尤其在处理命名冲突或需要在多个构造方法之间进行调用时非常有用。
其主要用法可以归纳为以下四个方面：
1. **区分成员变量与局部变量**：当方法的参数名或局部变量名与类的成员变量名相同时，使用 `this.变量名`来明确指定要访问的是当前对象的成员变量，而不是局部变量。这避免了赋值无效或逻辑错误，是 `this`最常用的场景。
  ```java
   public class Person {
     private String name;
      public void setName(String name) {
      this.name = name;// 等号左边的this.name是成员变量，右边的name是方法参数
       }
    }
    ```
2. **在构造方法中调用其他构造方法**：在一个构造方法中，可以使用 `this()`或 `this(参数列表)`来调用同一个类中的其他构造方法。这种调用**必须位于构造方法的第一条语句**，目的是实现代码复用，避免在多个构造方法中编写重复的初始化逻辑。
```java
    public class Person {
       private String name;
       private int age;
    
    public Person() {
        this("未知", 0);// 调用带两个参数的构造器
      }
    
    public Person(String name, int age) {
       this.name = name;
        this.age = age;
	    }
    }
    ```
3. **将当前对象作为参数传递**：在需要将自身实例传递给其他方法或对象的场景下（例如事件监听、回调机制），可以使用 `this`来代表当前对象。
```java
    public class Button {
        public void click() {
            EventManager.register(this);// 将当前按钮对象注册到事件管理器
        }
    }
    ```
    
4. **实现链式调用（Method Chaining）**：通过在方法中返回当前对象（即 `return this;`），可以使多个方法调用连续进行，让代码更加简洁流畅。
```java
    public class Calculator {
        private int result;
        public Calculator add(int value) {
            this.result += value;
            return this;// 返回当前对象，支持链式调用
        }
        public Calculator multiply(int value) {
            this.result *= value;
            return this;
        }
    }
    // 使用方式：
    new Calculator().add(5).multiply(2).getResult();
```

**重要注意事项**：`this`关键字指向的是当前对象的实例，因此它**不能在静态方法（`static`方法）中使用**，因为静态方法属于类本身，不依赖于任何对象实例。
###### 3. 说说 super 关键字的用法?⁠​
`super`关键字在 Java 中是一个指向**当前对象的直接父类**的引用。
它主要用于在子类中访问和调用那些被子类覆盖或隐藏了的父类成员（变量、方法和构造方法）。
其主要用法有以下三种：
1. **调用父类的构造方法**：在子类的构造方法中，必须首先调用父类的构造方法以确保父类部分被正确初始化。这是通过 `super()`或 `super(参数列表)`实现的，并且**这条语句必须位于子类构造方法的第一行**。如果子类构造方法中没有显式写出，编译器会自动加上一个 `super()`调用父类的无参构造方法。
```java
    class Animal {
        public Animal(String type) {
            System.out.println("Animal constructor: " + type);
        }
    }
    class Dog extends Animal {
        public Dog(String name) {
            super("Dog");// 调用父类的有参构造方法，必须放在第一行
            System.out.println("Dog name: " + name);
        }
    }
```
2. **调用父类中被重写的方法**：当子类重写了父类的方法后，如果需要在子类方法中再次使用父类该方法的原始实现，可以使用 `super.方法名()`进行调用。
```java
    class Parent {
        public void display() {
            System.out.println("Parent's display method");
        }
    }
    class Child extends Parent {
        @Override
        public void display() {
            super.display();// 先调用父类的display方法
            System.out.println("Child's display method");
        }
    }
```
3. **访问父类中被隐藏的成员变量**：如果子类中声明的成员变量与父类中的成员变量同名，则父类的变量会被"隐藏"。此时，可以使用 `super.变量名`来访问父类中的那个变量。
``` java
	class Parent {
	    String name = "Parent";
	}
	class Child extends Parent {
	    String name = "Child";
	    void printNames() {
	        System.out.println(super.name);// 输出 "Parent"
	        System.out.println(this.name);// 输出 "Child"
	    }
	}
```
###### 4. this() & super()在构造方法中的区别？⁠​
`this()`和 `super()`都用于构造方法中，且都必须作为构造方法的第一条语句，但它们的目的是完全不同的。

| **特性**   | **`this()`**                   | **`super()`**                 |
| -------- | ------------------------------ | ----------------------------- |
| **调用对象** | 调用**当前类**的其他构造方法               | 调用**父类**的构造方法                 |
| **目的**   | 实现当前类内**构造方法的重用**，减少代码重复       | **初始化从父类继承来的部分**，确保父类被正确构造    |
| **语法要求** | 必须是构造方法中的**第一条语句**             | 必须是构造方法中的**第一条语句**            |
| **共存性**  | **不能**与 `super()`在同一个构造方法中同时出现 | **不能**与 `this()`在同一个构造方法中同时出现 |

**核心区别与选择**：
- 使用 `this()`是为了在本类的多个构造方法之间实现链式调用，目的是让代码更简洁。
- 使用 `super()`是为了显式地调用父类的特定构造方法，这是继承机制中保证对象初始化正确性的基石。
- 在一个构造方法中，你只能选择使用 `this()`或 `super()`其中之一，因为它们都必须占据第一行的位置。如果两者都不写，编译器会默认插入 `super()`。
###### 5. static 都有哪些用法?⁠⁠​
`static`关键字用于修饰类的成员（变量、方法、代码块以及内部类），表示这些成员属于**类本身**，而不是属于类的某个具体实例。因此，静态成员也被称为**类成员**。
1. **静态变量（类变量）**
    - 特点：在内存中只有一份拷贝，在类加载时被初始化。所有该类的实例共享同一份静态变量。
    - 访问方式：推荐通过**类名.变量名**直接访问（如 `Math.PI`），也可以通过对象实例访问（但不推荐）。
    - 与实例变量区别：实例变量是每个对象独有的，互不影响。
2. **静态方法（类方法）**
    - 特点：不依赖于任何对象实例，可以直接通过**类名.方法名()** 调用（如 `Arrays.sort()`）。
    - 限制：静态方法内部**不能直接访问**类的非静态成员（实例变量和实例方法），因为非静态成员需要先创建对象才能存在。静态方法内也不能使用 `this`和 `super`关键字。
    - 常见例子：`main`方法必须是静态的，因为程序启动时还没有创建任何对象。
3. **静态代码块**
    - 特点：用 `static { ... }`定义。在**类被加载到内存时执行一次**，且仅执行一次。执行顺序优先于实例代码块和构造方法。
    - 用途：用于对静态变量进行复杂的初始化，或执行只需进行一次的初始化操作（如加载驱动、建立连接）。
4. **静态内部类**
    - 特点：使用 `static`修饰的内部类。它不依赖于外部类的实例，可以独立创建。静态内部类不能直接访问外部类的非静态成员。
**核心理解**：`static`将成员提升到类级别，使其与实例解耦。静态成员的生命周期与类相同，从类加载开始，到类被卸载结束。
###### 6. &和&&的区别？⁠⁠​
`&`和 `&&`在 Java 中都表示逻辑"与"操作，但它们在行为上有根本性的不同，主要体现在**是否具有"短路"特性**上。

| **运算符**  | **名称**             | **短路特性**                                                          | **用途**                                    |
| -------- | ------------------ | ----------------------------------------------------------------- | ----------------------------------------- |
| **`&&`** | **短路与**            | **有**。如果**第一个操作数为 `false`**，则整个表达式结果必定为 `false`，**不会再去计算第二个操作数**。 | 仅用于**布尔值**的逻辑判断。                          |
| **`&`**  | **逻辑与**（当操作数为布尔值时） | **无**。无论第一个操作数是 `true`还是 `false`，**都会计算两个操作数**。                   | 1. 用于**布尔值**的逻辑判断。 2. 用于**整数**的**按位与**运算。 |

**核心区别与示例**：
- **短路特性是关键**：`&&`的效率通常更高，并且可以避免一些潜在的错误。例如，在检查一个对象不为 `null`后再调用其方法时，使用 `&&`是安全且高效的。
```java
    if (obj != null && obj.isValid()) {// 如果obj为null，&& 不会执行后面的方法，避免NullPointerException
	    // ...
    }
```
	如果使用 `&`，即使 `obj`为 `null`，它也会执行 `obj.isValid()`，从而抛出 `NullPointerException`。
- **`&`的额外功能**：`&`还可以作为按位运算符，对两个整数的二进制每一位进行"与"操作。
```java
    int a = 5;// 二进制 0101
    int b = 3;// 二进制 0011
    int c = a & b;// 结果 0001，即十进制 1
```
**总结**：在绝大多数需要进行逻辑"与"判断的场景下，都应优先使用 `&&`，以利用其短路特性保证效率和安全性。只有在需要确保两边操作数都被执行，或进行按位运算时，才使用 `&`。
###### 7. switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？⁠⁠​
`switch`语句的表达式的类型是有限制的。以下是具体规则：
- **能作用在 `byte`上**：**可以**。`switch`支持 `byte`类型，以及 `short`、`char`、`int`这些整数类型。
- **不能作用在 `long`上**：**不可以**。所有比 `int`大的整数类型，如 `long`，都不能作为 `switch`的表达式的类型。
- **能作用在 `String`上**：**可以（从 Java 7 开始）**。从 Java 7 开始，`switch`支持 `String`类型。
- **其他支持的类型**：还支持枚举（`enum`）类型和它们的包装类（如 `Integer`, `Character`）。
**底层原理**：对于 `String`类型的 `switch`，编译器在底层是通过调用 `hashCode()`和 `equals()`方法将其转换为 `int`值来实现的，从而保持高效性。
###### 8. a=a+b 与 a+=b 有什么区别吗?⁠​
`a = a + b`和 `a += b`的核心区别在于**类型转换**和**底层操作**。

|特性|`a = a + b`|`a += b`|
|---|---|---|
|**操作本质**​|先执行加法运算，再进行赋值操作|复合赋值运算符，是一个单一操作|
|**类型转换**​|需要显式类型转换（针对特定类型）|**自动隐式类型转换**​|
|**底层实现 (Python示例)**​|调用对象的 `__add__`方法|优先调用对象的 `__iadd__`方法|
|**对象影响 (Python示例)**​|对于可变对象，通常创建新对象|对于可变对象，可能在原对象上修改|

**在Java中的关键区别：类型转换**
在Java中，当 `a`是 `byte`、`short`或 `char`类型时，`a + b`的运算结果会**自动提升为 `int`类型**。因此，直接将结果赋回给 `a`会导致编译错误，必须进行显式的强制类型转换。而 `a += b`则由编译器自动完成类型转换。

- **示例 (Java):**

    ```java
    byte a = 10;
    byte b = 20;
    
    // a = a + b; // 编译错误！需要强制转换: a = (byte)(a + b);
    a += b; // 正确！编译器自动转换为: a = (byte)(a + b);
    ```
**在Python中的关键区别：可变与不可变对象**
Python中的区别更为显著，取决于操作对象是可变的（如列表）还是不可变的（如整数、元组、字符串）。
- **对于不可变对象（如整数）**：两者效果类似，都会创建新对象。
  ```python
    a = 5
    print(id(a))  # 输出一个内存地址
    a = a + 3
    print(id(a))  # 输出新的内存地址，a指向了新对象
    ```
  ```python
    a = 5
    print(id(a))
    a += 3
    print(id(a))  # 同样输出新的内存地址
    ```
- **对于可变对象（如列表）**：两者行为有重大差异。
  ```python
    # 使用 a = a + b
    list_a = [1, 2]
    list_b = [3, 4]
    print(id(list_a))  # 输出内存地址X
    list_a = list_a + list_b  # 调用 __add__，创建新列表
    print(id(list_a))  # 输出新的内存地址Y，list_a指向新对象
    ```
    ```python
    # 使用 a += b
    list_a = [1, 2]
    list_b = [3, 4]
    print(id(list_a))  # 输出内存地址X
    list_a += list_b   # 调用 __iadd__，在原列表上扩展
    print(id(list_a))  # 输出相同的内存地址X，原对象被修改
    ```
这是因为 `+=`运算符会尝试调用方法的 `__iadd__`方法（就地修改），如果没有则退而调用 `__add__`方法（创建新对象）。而 `+`运算符直接调用 `__add__`方法。因此，对于列表，`a += b`的性能通常优于 `a = a + b`，因为它避免了创建新对象的开销。
###### 9. 熟悉 instanceOf 关键字的作用吗？⁠⁠​
`instanceof`是Java中的一个二元运算符，用于**在运行时检查一个对象是否属于某个特定类（或接口），或者是否属于其子类**。它返回一个布尔值（`true`或 `false`）。
**基本语法：**
```java
object instanceof ClassName
```
**主要作用与示例：**
1. **类型检查**：在向下转型前进行安全检查，避免 `ClassCastException`。
```java
    Object obj = "Hello";
    if (obj instanceof String) {
        String str = (String) obj; // 安全的向下转型
        System.out.println(str.length());
    }
    ```
2. **多态中的类型判断**：在处理继承体系时，根据具体类型执行不同逻辑。
    ```java
    class Animal {}
    class Dog extends Animal {}
    class Cat extends Animal {}
    
    Animal animal = new Dog();
    
    if (animal instanceof Dog) {
        System.out.println("这是一只狗");
    } else if (animal instanceof Cat) {
        System.out.println("这是一只猫");
    }
    ```
2. **处理泛型集合**：从无泛型的集合（如 `List`）中取出元素时，判断其具体类型。
```java
    List mixedList = new ArrayList();
    mixedList.add("String");
    mixedList.add(new Integer(10));
    
    for (Object item : mixedList) {
        if (item instanceof String) {
            // 处理字符串
        } else if (item instanceof Integer) {
            // 处理整数
        }
    }
    ```
**重要注意事项：**
- 如果被检测的 `object`为 `null`，`instanceof`会返回 `false`，因为 `null`不是任何类的实例。
- `instanceof`考虑了继承关系，如果 `object`是 `ClassName`的子类实例，也会返回 `true`。
###### 10. transient 关键字的作用是什么？
`transient`关键字的主要作用是**在对象序列化时，标记一个成员变量不被序列化**。
当一个类实现了 `java.io.Serializable`接口后，它的对象就可以被序列化（即转换成字节流以便存储或传输）。默认情况下，对象的所有非静态和非 `transient`的成员变量都会被序列化。使用 `transient`修饰变量，可以将其排除在序列化过程之外。
**为什么要使用 transient？**
1. **敏感信息保护**：如密码、银行卡号等字段，不希望被持久化到磁盘或通过网络传输。
2. **节省空间与提升性能**：对于某些可以由其他字段推导出的派生数据或大型临时数据，无需序列化。
3. **序列化无意义的字段**：如线程句柄等依赖于特定JVM运行环境的字段，序列化它们没有意义。
**示例：**
```java
import java.io.Serializable;

public class User implements Serializable {
    private String username;
    private transient String password; // 密码不被序列化

    // ... 构造方法、getter、setter ...
}
```
当序列化一个 `User`对象后，再反序列化回来，`password`字段的值将是 `null`（对于基本数据类型，则是其默认值，如 `0`、`false`等）。
**关键点：**
- `transient`只能修饰变量，不能修饰方法和类。
- 静态变量（`static`）无论是否被 `transient`修饰，都不会被序列化，因为序列化是针对对象实例状态的。
- 如果类实现的是 `Externalizable`接口（而非 `Serializable`），序列化过程完全由程序员控制的 `writeExternal`和 `readExternal`方法决定，`transient`关键字在此无效。
###### 11. volatile 关键字的作用是什么？
`volatile`是Java中用于修饰变量的一种轻量级同步机制。它的作用主要体现在**可见性**和**禁止指令重排序**上，但**不保证原子性**。
1. **保证可见性**：当一个线程修改了被 `volatile`修饰的变量时，这个新值会立即被刷新到主内存中。同时，其他线程在使用这个变量前，会强制从主内存重新读取最新值，而不是使用自己工作内存中的缓存旧值。这确保了多线程环境下，一个线程对变量的修改对其他线程是立即可见的。
2. **禁止指令重排序**：编译器和在执行程序时，为了优化性能，可能会对指令的执行顺序进行重排。`volatile`关键字通过插入内存屏障来禁止这种重排序优化，从而保证代码的执行顺序与程序的预期顺序一致。
**典型应用场景：**
- **状态标志位**：作为一个简单的线程间通信信号。
```java
    public class TaskRunner implements Runnable {
        private volatile boolean running = true; // 状态标志
    
        public void run() {
            while (running) { // 一个线程检查标志
                // 执行任务...
            }
        }
    
        public void stop() {
            running = false; // 另一个线程修改标志
        }
    }
    ```
如果没有 `volatile`，`running`变量的更新可能对执行循环的线程不可见，导致循环无法停止。
**volatile 的局限性：不保证原子性**
`volatile`无法保证复合操作的原子性。例如，`count++`这个操作看似一步，实则包含读取、加1、写入三个步骤。在多线程下，可能发生多个线程同时读取到旧值，然后分别加1再写回，导致最终结果小于预期。
```java
public class Counter {
    private volatile int count = 0;
    // 即使使用volatile，下面的操作在多线程下仍不安全
    public void increment() {
        count++; // 非原子操作
    }
}
```
对于需要原子性的操作，应使用 `synchronized`关键字或 `java.util.concurrent.atomic`包下的原子类（如 `AtomicInteger`）。