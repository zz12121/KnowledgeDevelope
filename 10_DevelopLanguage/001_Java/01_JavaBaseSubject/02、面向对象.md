###### 1. 面向对象和面向过程的区别?
| 特性         | 面向对象编程 (OOP)                                      | 面向过程编程 (POP)                                 |
| ---------- | ------------------------------------------------- | -------------------------------------------- |
| **编程思想**​  | 以**对象**为中心，对象是数据和行为的封装体。分析问题由哪些实体参与，这些实体有哪些属性和方法。 | 以**过程/步骤**为中心。将问题分解成一系列步骤，然后用函数实现这些步骤，按顺序调用。 |
| **数据与功能**​ | **封装**在一起，数据和对数据的操作绑定在对象中。                        | **相分离**，数据通常作为全局变量或参数传递给函数。                  |
| **程序结构**​  | 使用**类**和**对象**组织代码，更易于模拟现实世界，适合复杂、需协作的系统。         | 使用**函数**作为组织代码的基本单元。                         |
| **抽象级别**​  | 抽象级别更高，通过类和对象隐藏实现细节。                              | 抽象级别较低，更直接地操作数据和逻辑。                          |
| **核心特性**​  | 封装、继承、多态。                                         | 不支持继承和多态。                                    |
| **优势**​    | 代码**易维护、易复用、易扩展**，更适合应对复杂和变化的系统需求。                | **性能**通常更优，流程控制直接，适合性能敏感的场景（如嵌入式系统）或简单任务。    |
| **典型语言**​  | Java, C++, Pytho。                                 | C, Fortran。                                  |
###### 2. 说说面向对象编程三大特性⁠?
面向对象编程的三大基本特性是封装、继承和多态。
1. **封装（Encapsulation）**
    封装是将对象的**数据（属性）和行为（方法）捆绑在一起成为一个独立的单位（即类），并隐藏对象的内部实现细节**。通常，对象的属性会被设置为私有（private），只通过公共（public）的方法提供给外部访问和操作。这样做的好处是控制了外部代码对对象内部状态的随意修改，提高了代码的安全性和可维护性。
2. **继承（Inheritance）**
    继承是一种机制，它允许创建一个新类（子类或派生类）来**继承**另一个现有类（父类或基类）的**属性和方法**。这样可以实现代码的复用，并且子类可以在继承的基础上进行扩展，添加新的属性和方法，或修改父类的方法（重写）。继承清晰地描述了类与类之间“是（is-a）”的关系。
3. **多态（Polymorphism）**
    多态是指**同一个行为具有多个不同表现形式**的能力。在OOP中，它通常表现为：父类的引用变量可以指向子类的对象，且通过这个父类引用调用方法时，实际执行的是子类重写的方法。多态增强了程序的灵活性和可扩展性。
###### 3. 什么是多态机制？
多态机制是面向对象编程的核心特性之一，它允许**同一操作作用于不同的对象，可以产生不同的执行结果**。简单来说，就是“用一个接口，实现多种功能”。
多态的存在主要依赖于以下两点：
- **继承关系**：存在继承关系的类层次结构。
- **方法重写**：子类对父类的方法进行重新定义。
在程序运行时，JVM会根据实际对象的类型来动态决定调用哪个方法，这种行为称为**动态绑定**或**晚期绑定**。多态的最大意义在于，它允许程序在编写时面向父类（或接口）等通用类型编程，而在运行时却可以执行子类的具体实现，从而提高了代码的通用性和可扩展性。例如，一个“动物”父类有“叫”的方法，其子类“狗”和“猫”都重写了“叫”的方法。当使用“动物”引用指向一个“狗”对象并调用“叫”的方法时，实际执行的是狗的叫声，这便是多态的体现。
###### 4. 说说重载和重写的区别⁠?
重载（Overload）和重写（Override）都是实现多态的方式，但二者有本质区别。

| 特性        | 方法重载 (Overload)                    | 方法重写 (Override)                           |
| --------- | ---------------------------------- | ----------------------------------------- |
| **发生范围**​ | 发生在**同一个类内部**。                     | 发生在**具有继承关系的父类和子类之间**。                    |
| **方法名**​  | **必须相同**。                          | **必须相同**。                                 |
| **参数列表**​ | **必须不同**（参数类型、个数或顺序不同）。            | **必须完全相同**。                               |
| **返回类型**​ | **可以修改**，不能仅以返回类型不同作为重载的标准。        | 返回类型需要**相同或是父类方法返回类型的子类**。                |
| **访问权限**​ | **可以修改**，可以改变方法的访问修饰符。             | 子类方法的访问权限**不能比父类方法更严格**（即要大于等于父类权限）。      |
| **异常抛出**​ | **可以修改**，可以声明新的或更广的检查异常。           | 子类方法抛出的异常类型**不能比父类方法声明的更宽泛**（即要小于等于父类异常）。 |
| **本质**​   | 一个类中**同名不同参**的方法，是**编译时多态**（静态多态）。 | 子类对父类方法的**重新实现**，是**运行时多态**（动态多态）。        |
###### 5. 重载的方法能否根据返回类型进行区分?⁠
**不能。重载的方法**不能仅根据返回类型的不同来区分。
因为编译器在决定调用哪个重载方法时，是**根据方法调用的实参列表来匹配的**，与方法的返回类型无关。如果在同一个类中定义了两个方法名相同、参数列表也完全相同，仅返回类型不同的方法，编译器将无法区分，会导致编译错误。
例如，以下代码是错误的：
```java
public class Example {
    public int calculate(int a, int b) { ... }
    public double calculate(int a, int b) { ... } // 编译错误：已存在 calculate(int, int) 的方法
}
```
###### 6. 简单说说 Java 中接口和抽象类的区别?
| 特性         | 接口 (Interface)                                                                                | 抽象类 (Abstract Class)                                 |
| ---------- | --------------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| **定义关键字**​ | `interface`                                                                                   | `abstract class`                                     |
| **方法实现**​  | 在 Java 8 之前，所有方法都是**抽象方法**（隐式 `public abstract`），不能有具体实现。Java 8 后允许有 `default`和 `static`方法实现。 | 可以包含**抽象方法**（无方法体）和**具体实现的方法**。                      |
| **成员变量**​  | 变量默认为 `public static final`（常量）。                                                              | 变量可以是各种访问权限的普通成员变量。                                  |
| **构造方法**​  | **没有**构造方法。                                                                                   | **有**构造方法（虽然不能实例化，但可用于子类初始化）。                        |
| **继承方式**​  | 一个类可以**实现多个接口**（`implements Interface1, Interface2`）。                                         | 一个类只能**继承一个抽象类**（`extends AbstractClass`），Java 是单继承。 |
| **设计目的**​  | 定义一套**行为规范**，强调“能做什么”的契约。核心是 **"has-a"**​ （具有某种能力）的关系。                                        | 表示一种 **"is-a"**​ （是一种）的层次关系，用于代码复用和模板设计。             |
###### 7. 抽象类能使用 final 修饰吗？⁠
**不能。不能**被 `final`修饰。
因为 `abstract`和 `final`关键字的设计目的本质上是**冲突**的：
- `abstract`修饰的类**必须被继承**才能使用，它的价值需要子类来实现其抽象方法并创建实例来体现。
- `final`修饰的类表示**不可被继承**，是最终形态。
如果一个类被同时声明为 `abstract final`，则意味着它既需要被子类继承，又不允许被子类继承，这会产生矛盾，所以 Java 语法不允许这样做。
###### 8. 抽象的（abstract）方法是否可同时是静态的?⁠
**不能。 `abstract`方法和 `static`方法不能同时修饰一个方法。
原因如下：
- `abstract`方法是一个**没有方法体的抽象方法**，它**必须被子类重写**才能使用。它的调用是与具体的对象实例动态绑定在一起的（多态）。
- `static`方法（静态方法）是**属于类本身**的，它可以通过类名直接调用，**不需要创建对象实例**。静态方法也不能被重写（Override），只可以被隐藏。
由于 `abstract`方法要求被子类实现，而 `static`方法与具体实例无关，二者在语义上是矛盾的。因此，Java 不允许定义一个抽象静态方法。
###### 9. 什么是封装？如何实现封装？
封装是面向对象编程的核心理念之一，它有两个基本含义：
- **将数据（属性）和操作数据的行为（方法）捆绑在一起**，形成一个独立的单元（即类）。
- **隐藏对象的内部实现细节**，仅对外提供有限的、可控的访问方式。
实现封装通常通过以下步骤：
- **使用访问修饰符**：将类的成员变量（属性）声明为 **`private`**。这样，这些属性就不能被该类以外的代码直接访问，实现了信息的隐藏。
- **提供公共的访问方法**：为需要被外部访问或修改的私有属性，提供公共的（`public`）getter（获取值）和 setter（设置值）方法。在这些方法中，可以加入逻辑控制，对数据的有效性进行验证，确保对象的状态始终是安全有效的。
例如，一个 `BankAccount`类的封装实现：
```java
public class BankAccount {
    // 1. 将关键数据私有化
    private double balance;

    // 2. 通过构造方法初始化，也可控制逻辑
    public BankAccount(double initialBalance) {
        if (initialBalance >= 0) {
            this.balance = initialBalance;
        } else {
            this.balance = 0;
        }
    }

    // 3. 提供公共的方法来访问和修改数据，并加入控制逻辑
    public void deposit(double amount) { // 存款
        if (amount > 0) {
            balance += amount;
        }
    }

    public boolean withdraw(double amount) { // 取款，加入业务逻辑
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            return true;
        }
        return false;
    }

    public double getBalance() { // 获取余额，只提供读权限
        return balance;
    }
    // 不提供 setBalance 方法，防止余额被随意修改
}
```
封装的好处在于提高了代码的**安全性**和**可维护性**。内部实现的改变只要不影响到公共方法的签名，就不会影响外部调用者。
###### 10. 接口和抽象类各自的使用场景是什么？
选择使用接口还是抽象类，取决于具体的设计需求：
**优先考虑使用接口的场景：**
- **定义行为契约**：当需要定义一组不相关的类**都应该遵循的某种行为规范**时。例如，`Flyable`（可飞行的）、`Serializable`（可序列化的），这些能力与类的本身层次关系不大。
- **需要多重继承**：由于 Java 的单继承限制，当一个类需要具备多种不同能力时，通过实现多个接口来扩展功能是最佳选择。
- **作为架构的骨架**：在框架设计中，接口常用于定义模块之间的通信契约，降低耦合，提高系统的灵活性和可扩展性。
**优先考虑使用抽象类的场景：**
- **代码复用和模板设计**：当多个相关的类**共享一些通用的状态或行为**时，可以将这些共性的内容放在抽象类中实现，让子类继承，避免代码重复。抽象类可以提供一些部分实现的方法，作为模板。
- **定义紧密的类层次结构**：当要描述的是一种严格的 **"is-a"**​ （是一种）关系，并且这些类有很强的内在联系时。例如，`Animal`作为抽象类，其子类 `Dog`, `Cat`都是动物。
简单来说，**接口关注于功能，抽象类关注于共性**。在现代设计中，有一种“面向接口编程”的趋势，即优先使用接口来定义类型，以获得最大的灵活性，然后用抽象类或具体类去实现它，结合二者的优点。