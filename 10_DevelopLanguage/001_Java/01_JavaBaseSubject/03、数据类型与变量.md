###### 1. 说说八种基本数据类型的大小，以及他们的封装类⁠？⁠​
Java 的八种基本数据类型及其封装类如下：

|**基本数据类型**|**大小（字节）**|**封装类**|**取值范围/说明**|
|---|---|---|---|
|`byte`|1|`Byte`|-128 ~ 127|
|`short`|2|`Short`|-32768 ~ 32767|
|`int`|4|`Integer`|-2^31 ~ 2^31-1|
|`long`|8|`Long`|-2^63 ~ 2^63-1|
|`float`|4|`Float`|单精度浮点数|
|`double`|8|`Double`|双精度浮点数|
|`char`|2|`Character`|Unicode字符，0~65535|
|`boolean`|未严格定义（通常1位）|`Boolean`|true/false|

###### 2. char 型变量中能不能存贮一个中文汉字? 为什么?⁠⁠​
**可以**。原因在于：
- Java 的 `char`类型采用 **Unicode 编码**，占 **2 字节（16 位）**，可表示的范围是 0~65535（即 Unicode 字符集）。
- 中文汉字属于 Unicode 字符集的一部分（如常用汉字在 CJK 统一编码区间），每个汉字对应一个 Unicode 码点，因此可以被 `char`变量存储。
例如：

```java
char ch = '中';// 合法，存储汉字'中'
```

但需注意：某些生僻字或表情符号可能超出 Basic Multilingual Plane（BMP），需使用两个 `char`（即 `String`）表示。
###### 3. Java 中包装类型和基本类型的区别是什么⁠​？
Java 中的基本类型（Primitive Types）和包装类型（Wrapper Classes）在设计目的和特性上有显著区别，主要体现在以下几个方面：

| **特性**     | **基本类型**                            | **包装类型**                                                    |
| ---------- | ----------------------------------- | ----------------------------------------------------------- |
| **本质**     | 是 Java 预定义的简单数据类型，不是对象              | 是对基本类型的封装，是真正的类                                             |
| **声明与初始化** | 直接使用（如 `int num = 10;`），无需 `new`    | 通常需要使用 `new`关键字（如 `Integer num = new Integer(10);`），但支持自动装箱 |
| **存储方式**   | 变量直接存储**数据值**，通常在栈内存中               | 变量存储的是对象的**引用（地址）**，对象本身存储在堆内存中                             |
| **默认值**    | 有默认值（如 `int`为 0，`boolean`为 `false`） | 默认值为 `null`                                                 |
| **可空性**    | **不能**为 `null`                      | **可以**为 `null`                                              |
| **功能方法**   | 没有方法，只是一个数据值                        | 提供了丰富的实用方法（如 `Integer.parseInt()`、`Integer.valueOf()`）      |
| **泛型支持**   | **不能**用于泛型（如 `List<int>`是错误的）       | **可以**用于泛型（如 `List<Integer>`是正确的）                           |
| **性能**     | 更高效，因为直接在栈上分配，开销小                   | 相对较低，因为需要在堆上创建和回收对象，有额外开销                                   |
| **适用场景**   | 适用于大量计算、性能要求高的场景                    | 适用于集合框架、需要对象特性的场景（如可空性、作为方法参数传递对象）                          |

###### 4. 说说 Java 自动装箱与拆箱⁠⁠​？
自动装箱（Auto-boxing）和自动拆箱（Auto-unboxing）是 Java 5 引入的语法糖，用于简化基本类型和对应包装类型之间的转换
- **自动装箱**：指基本数据类型**自动转换**为对应的包装类对象。
``` java
// 手动装箱 (Java 5 之前)
Integer num1 = Integer.valueOf(100);
// 自动装箱 (Java 5 之后)
Integer num2 = 100;// 编译器自动转换为 Integer.valueOf(100)
```
- **自动拆箱**：指包装类对象**自动转换**为对应的基本数据类型。
```java
// 手动拆箱
int value1 = num1.intValue();
// 自动拆箱
int value2 = num2;// 编译器自动转换为 num2.intValue()
```
**实现原理**：这本质上是编译器在编译期帮我们完成的代码转换。自装箱时调用的是包装类的 `valueOf()`方法，自动拆箱时调用的是对应的 `xxxValue()`方法（如 `intValue()`。
**主要应用场景**：
- **集合框架（Collection）**：集合（如 `ArrayList`）只能存储对象，当我们添加基本类型时会发生自动装箱。
``` java
List<Integer> list = new ArrayList<>();
list.add(10);// 自动装箱：int -> Integerint 
first = list.get(0);// 自动拆箱：Integer -> int
```
- **泛型（Generics）**：泛型类型参数必须是引用类型。
- **方法参数和返回值传递**。
**注意事项**：
- **空指针异常（NullPointerException）**：如果一个包装类对象为 `null`，对其进行自动拆箱操作会抛出异常。
``` java
Integer nullInteger = null;
int num = nullInteger;// 运行时抛出 NullPointerException
```
- **性能开销**：在循环或大量数据操作中，频繁的装箱和拆箱会创建大量临时对象，增加垃圾回收（GC）压力，影响性能。在性能敏感的场景应谨慎使用 。
- **比较陷阱**：使用 `==`比较包装对象时，需要注意缓存范围。
###### 5. Integer a= 127 与 Integer b = 127 相等吗？⁠​
**相等（使用 `==`比较结果为 `true`）。**
**原因是 Integer 类的缓存机制（Integer Cache）**。默认情况下，Integer 类会缓存 **-128 到 127**之间的所有整数对象。
当通过自动装箱（即直接赋值）或调用 Integer.valueOf(int i) 方法创建 Integer 对象时，如果数值在这个范围内，就会直接返回缓存池中已存在的同一个对象的引用。
```java
Integer a = 127;// 相当于 Integer.valueOf(127)
Integer b = 127;// 相当于 Integer.valueOf(127)
System.out.println(a == b);// true，因为 a 和 b 指向缓存中的同一个对象
```
**但是，如果数值超出缓存范围，结果就不同了**：
```java
Integer c = 128;
Integer d = 128;
System.out.println(c == d);// false，因为 128 超出了默认缓存范围，会创建新的 Integer 对象
```
**要点**：
- 这种缓存机制是一种性能优化，避免频繁创建和销毁小整数对象。
- ==使用 `new Integer(int)`构造器会强制创建新对象，不会使用缓存==。
- 其他包装类也有类似的缓存机制，如 `Byte`缓存所有值（范围是-128 到 127），`Short`、`Long`缓存 -128 到 127，`Character`缓存 0 到 127，`Boolean`缓存 `TRUE`和 `FALSE`。
- 可以使用 `XX:AutoBoxCacheMax=<size>`JVM 参数来调整 Integer 缓存的上限 。
###### 6. 成员变量与局部变量有什么区别？⁠​
| **特性**    | **成员变量**                                                 | **局部变量**                         |
| --------- | -------------------------------------------------------- | -------------------------------- |
| **声明位置**  | 类内部，方法体外。                                                | 方法体、构造方法或代码块内部。                  |
| **生命周期**  | 伴随对象的存在而存在。实例变量随对象创建而诞生，随对象被回收而消亡；静态变量随类的加载而诞生，随类的卸载而消亡。 | 伴随方法的调用而存在，方法调用结束，栈帧弹出，局部变量随之销毁。 |
| **存储位置**  | 实例变量存储在堆内存的对象实体中；静态变量存储在方法区。                             | 存储在栈内存的方法栈帧中。                    |
| **默认值**   | **有默认值**。如数值类型为0，布尔型为false，引用类型为null。                    | **没有默认值**，必须先显式初始化后才能使用，否则编译报错。  |
| **访问修饰符** | 可以使用 `public`, `protected`, `private`, `static`等修饰。      | 不能使用访问修饰符，但可以被 `final`修饰。        |
| **作用域**   | 在整个类内部基本都可以直接访问（静态变量可通过类名访问）。                            | 仅限于定义它的方法、构造方法或代码块内部，出了这个范围即失效。  |
###### 7. 静态变量和实例变量区别?⁠⁠​
静态变量和实例变量是成员变量的两种类型。

|**特性**|**静态变量（类变量）**|**实例变量**|
|---|---|---|
|**归属**|属于**类**，所有对象共享同一份数据。|属于**对象实例**，每个对象都有自己独立的一份副本。|
|**内存分配**|在类加载的初始化阶段分配内存于方法区，仅分配一次。|在每次创建对象实例时，在堆内存中随对象一起分配内存。|
|**调用方式**|既可以通过**类名**直接访问，也可以通过对象引用访问（但不推荐）。|只能通过**对象引用**来访问。|
|**生命周期**|最长，随类的加载而存在，随类的卸载而消亡。|随对象的创建而存在，随对象的垃圾回收而消亡。|
###### 8. 静态变量与普通变量（局部变量）区别?⁠⁠​
|**方面**|**静态变量**|**局部变量**|
|---|---|---|
|**声明位置与作用域**|类内方法外，类级别作用域。|方法或代码块内，块级别作用域。|
|**内存与生命周期**|方法区，生命周期与类相同。|栈内存，生命周期与方法调用相同。|
|**初始化与访问**|有默认值，可通过类名或对象访问。|必须显式初始化，只能在作用域内访问。|
|**修饰符**|可用 `public`, `static`等。|仅可用 `final`。|
###### 9. 3 * 0.1 == 0.3 将会返回什么? true 还是 false?⁠⁠​
这个表达式将返回 **`false`**。
**原因**：这是由**浮点数在计算机中的表示方式**决定的。Java 中的 `float`和 `double`类型遵循 IEEE 754 标准，该标准使用二进制小数来近似表示十进制小数。有些十进制小数（如 `0.1`）无法用二进制小数精确表示。
- 在计算 `3 * 0.1`时，实际结果是一个非常接近但不完全等于 `0.3`的值（例如 `0.30000000000000004`）。
- 当使用 `==`运算符直接比较时，是在比较两个值的精确二进制表示，由于微小的误差，比较结果自然为 `false`。
**正确处理方式**：比较浮点数时，不应使用 `==`，而应检查两数之差的绝对值是否在一个极小的误差范围（epsilon）内。
```java
double result = 3 * 0.1;
double epsilon = 1e-10;// 定义一个极小的误差阈值
boolean isEqual = Math.abs(result - 0.3) < epsilon;// 返回 true
```
对于需要精确计算的场景（如金融），应使用 `BigDecimal`类。
###### 10. 什么是类型转换？自动类型转换和强制类型转换的区别？
类型转换是Java中将一个数据类型的值转换为另一种数据类型的过程。这对于处理不同数据类型之间的赋值、运算和方法调用至关重要。

|特性|自动类型转换 (隐式转换)|强制类型转换 (显式转换)|
|---|---|---|
|**转换方向**|小范围类型 → 大范围类型 (`byte`-> `int`等)|大范围类型 → 小范围类型 (`double`-> `int`等)|
|**语法要求**|自动完成，无需特殊语法|必须显式使用 `(目标类型)`进行转换|
|**数据风险**|安全，通常不会丢失信息|**可能丢失精度**（如小数部分）或**溢出**（超出目标类型范围）|
|**典型场景**|将`int`常量赋值给`long`变量|将`double`转换为`int`（取整）|
|**转换原则**|由编译器自动完成，保证安全性|开发者显式干预，**“后果自负”**|
**自动类型转换（隐式转换）**
自动类型转换就像是将一小杯水倒入一个大桶中，因为目标容器的容量足够大，所以这个过程是安全且自动完成的。
- **发生时机**：当将**数据范围较小**的类型（如 `byte`、`short`）赋值给**数据范围较大**的类型（如 `int`、`long`、`double`）时，编译器会自动进行转换。基本数据类型的转换方向通常遵循：`byte`-> `short`-> `int`-> `long`-> `float`-> `double`，以及 `char`-> `int`。
- **安全性**：这种转换是**安全**的，因为更大范围的类型足以容纳小范围类型的所有信息，通常不会导致数据丢失。
**强制类型转换（显式转换）**
强制类型转换则像是试图将一大桶水强行倒入一个小杯子，你必须明确下指令，并且必须承担可能溢出或洒掉（数据丢失）的风险。
- **发生时机与语法**：当需要将**数据范围较大**的类型赋值给**数据范围较小**的类型时，必须使用强制类型转换。语法是在需要转换的值或变量前加上`(目标类型)`，例如 `int i = (int) 10.5;`。
- **风险与后果**：这是**不安全**的转换，可能导致：
    - **精度丢失**：最常见的是浮点数转换为整数，小数部分会**直接舍弃**，而不是四舍五入。例如，`(int) 10.9`的结果是 `10`。
    - **数据溢出**：如果值超出了目标类型的表示范围，结果将不可预测。例如，将 `128`强制转换为 `byte`（范围-128~127）会得到错误的值 `-128`。
*关键场景与最佳实践*
- **表达式中的自动提升**
	在表达式中，如果存在不同数据类型一起运算，Java会自动将所有操作数提升到表达式中范围最大的那个类型。特别需要注意的是，`byte`、`short`、`char`在参与运算时，会**先自动提升为 `int`类型**。这就是为什么 `byte a = 1; byte b = a + 1;`会编译报错，因为 `a + 1`的结果已经是 `int`类型，不能自动赋值给 `byte`。
- **谨慎使用强制转换**
	由于强制转换存在风险，使用时务必确保你清楚可能的数据丢失后果，并确保转换后的值在目标类型的合理范围内。
- **注意扩展赋值运算符**
    类似 `+=`、`*=`这样的运算符内部**隐含了强制类型转换**。例如 `short s = 1; s += 1;`能正确编译，因为它等价于 `s = (short) (s + 1);`。
- **不相容类型的转换**
    `boolean`类型与其他7种基本数据类型**互不兼容**，不能进行任何形式的类型转换。
###### 11. 为什么浮点数运算会有精度问题？
浮点数运算的精度问题确实常让人困惑。其根源在于，**有些十进制小数无法用二进制精确表示**，以及计算机使用**IEEE 754标准**这类格式，以有限内存来近似表示实数。
下面这个表格汇总了常见精度问题的场景和原因，帮你快速了解：

| 问题场景                 | 示例 (Java代码)                                | 实际输出/结果                | 核心原因                                               |
| -------------------- | ------------------------------------------ | ---------------------- | -------------------------------------------------- |
| **简单加法**             | `System.out.println(0.05 + 0.01);`         | `0.060000000000000005` | 0.05和0.1的二进制表示是无限循环小数，存在舍入误差<br><br>。              |
| **简单减法**             | `System.out.println(1.0 - 0.42);`          | `0.5800000000000001`   | 参与计算的数值在二进制下已存在误差<br><br>。                         |
| **乘法运算**             | `System.out.println(4.015 * 100);`         | `401.49999999999994`   | 二进制表示不精确与运算过程中的舍入误差共同导致<br><br>。                   |
| **循环累加**             | `for (int i=0; i<10; i++) { sum += 0.1; }` | `0.9999999999999999`   | 误差在多次运算中不断累积<br><br>。                              |
| **数值比较**             | `if (0.1 + 0.2 == 0.3)`                    | `false`                | 运算结果的实际二进制表示与0.3的二进制表示不同。                          |
| **构造BigDecimal(错误)** | `new BigDecimal(0.1)`                      | 内部值并非精确的0.1            | `BigDecimal(double)`构造器直接继承了double本身的精度误差<br><br>。 |
*深入理解精度根源*
浮点数精度问题的根源可以归结为以下几个方面：
1. **二进制表示的“先天不足”**
    计算机使用二进制存储数据。对于小数，我们通常采用"乘2取整"的方法将十进制小数转换为二进制，但**很多在十进制下有限的小数，在二进制中会是无限循环的**。
    例如，十进制的0.1在二进制中是一个无限循环小数：`0.0001100110011...`。由于计算机的存储空间有限（float有23位尾数，double有52位尾数），必须对无限小数进行**截断和舍入**，这就引入了最初的误差。这类似于在十进制中无法精确表示1/3（0.333...）一样。
2. **IEEE 754标准与内存表示**
    浮点数在计算机中遵循IEEE 754标准，其表示格式可概括为 `(-1)^s * M * 2^E`，包括符号位（s）、阶码（E）和尾数（M）三部分。以32位的float类型为例，其内存布局如下：
    - **符号位 (s)**: 占1位（第31位），0代表正数，1代表负数。
    - **指数位 (E)**: 占8位（第23-30位），采用**偏移码**（float的偏移量是127）表示，目的是为了表示负指数。
    - **尾数位 (M)**: 占23位（第0-22位），存储的是规格化后二进制小数**小数点后的部分**。因为规格化后总可以表示为1.xxx...的形式，所以最高位的1被隐含，不直接存储，这样实际上获得了24位有效数字的精度。这种基于有限精度和指数表示的模型，本质上是实数的一种**离散化近似**，决定了浮点数无法精确表示所有实数。
3. **误差的累积与放大**
    单个浮点数的表示误差可能很小，但在运算（尤其是连续运算如累加`sum += 0.1`）过程中，这些微小的误差会**不断累积和放大**，最终导致计算结果与理论值出现明显偏差。在科学计算、金融等领域，这种累积误差可能带来严重后果。
*应对精度问题的策略*
核心原则是：**在需要精确计算的场景（特别是商业计算、金融领域），避免直接使用float和double进行计算**。
4. **使用 `BigDecimal`进行精确计算**
    Java提供了`BigDecimal`类来表示和计算精确的小数。它通过一个**未缩放整数值（BigInteger）**和一个**缩放因子（scale）**来表示小数（例如，`BigDecimal`可表示为 `unscaledValue × 10^(-scale)`），从而避免二进制表示问题。
    - **关键点：使用String构造器**
        务必使用`BigDecimal(String val)`构造器，而不是`BigDecimal(double val)`。因为使用double构造器时，不精确的二进制表示已经被带入，无法得到精确值。正确做法是：			
        `// 错误做法：精度已污染`
        `BigDecimal bad = new BigDecimal(0.1);`
        `// 正确做法：精确表示`
        `BigDecimal good = new BigDecimal("0.1");`
    - **比较值：使用 `compareTo()`**
        比较两个`BigDecimal`数值是否相等时，应使用`compareTo()`方法而非`equals()`方法。因为`equals()`还会比较缩放比例（scale），而`compareTo()`仅比较数值本身。
    - **除法运算：指定精度和舍入模式**
        进行除法运算时，如果结果是无限小数，必须指定精度（scale）和舍入模式（RoundingMode），否则会抛出`ArithmeticException`。
        BigDecimal a = new BigDecimal("10");
        BigDecimal b = new BigDecimal("3");
        // 正确：指定保留3位小数，采用四舍五入
        BigDecimal result = a.divide(b, 3, RoundingMode.HALF_UP);
5. **使用整数类型表示最小单位**
    在处理货币时，一个常见且高效的实践是使用**整数类型（如long）来表示金额的最小单位**（例如，用“分”而不是“元”）。这样可以完全避免小数运算。`long priceInCents = 199; // 表示1.99元`
6. **利用工具类简化 `BigDecimal`操作**
    为了方便使用，可以封装一个类似`ArithUtil`的工具类，将基本的四则运算封装起来，内部使用`BigDecimal`并处理字符串转换和精度控制。