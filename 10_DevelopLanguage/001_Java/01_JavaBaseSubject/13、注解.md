###### 1. Java 中的注解的作用是什么？⁠​
Java 注解本质上是代码的**元数据**，即“关于数据的数据”。它们本身不会直接改变代码的逻辑，而是作为一种**标记**或**说明信息**附着在代码元素（如类、方法、字段、参数等）上。这些信息可以被编译器、开发工具或运行时环境（JVM）读取并用于特定目的。
其主要作用可以归纳为以下三个方面：
1. **编译检查**：注解能为编译器提供额外信息，协助进行静态代码检查。最典型的例子是 `@Override`。当你使用它修饰一个方法时，编译器会严格检查该方法是否正确地重写了父类中的方法。如果签名不一致，编译器就会报错，帮助你在早期发现潜在问题。`@Deprecated`则用于标记元素已过时，编译器会生成警告提示开发者。
2. **框架配置与代码生成**：这是注解在现代Java开发中最重要的作用，特别是在Spring、Hibernate等框架中。注解可以替代繁琐的XML配置文件，将配置信息直接写在代码上，使得配置更集中、更直观。
    - **依赖注入**：如Spring中的 `@Autowired`，框架在运行时读取此注解，会自动寻找合适的Bean并注入到指定位置。
    - **对象关系映射**：如JPA中的 `@Entity`, `@Table`，框架根据这些注解将Java类与数据库表映射起来。
    - **生成代码**：一些工具（如Lombok）可以通过注解在编译期自动生成`getter`、`setter`等方法，极大减少样板代码。
3. **生成帮助文档**：通过 `@Documented`元注解修饰的自定义注解，其信息会被Javadoc工具捕捉，并包含在生成的API文档中，方便他人理解代码的用途和约定。
###### 2. Java注解的常见分类？⁠⁠​
注解可以按照不同的维度进行分类，常见的分类方式包括：
**1. 按来源分类**
- **内置注解**：JDK自带的注解，如 `@Override`, `@Deprecated`, `@SuppressWarnings`, `@FunctionalInterface`等。
- **元注解**：用于定义其他注解的注解，是注解的“语法”，如 `@Target`, `@Retention`, `@Documented`, `@Inherited`, `@Repeatable`。
- **自定义注解**：用户根据业务需求自己定义的注解。
**2. 按注解本身包含的成员变量数量分类**​
- **标记注解**：没有定义任何成员的注解，仅通过自身存在与否来提供信息，如 `@Override`。
- **单值注解**：仅包含一个成员的注解。
- **全值注解**：包含多个成员的注解。
**3. 按生命周期和保留策略分类（由 `@Retention`指定）**​
- **SOURCE**：仅在源码级别保留，编译时将被丢弃（如 `@Override`）。主要用于编译期检查。
- **CLASS**：被保留在编译生成的 `.class`文件中，但不会被JVM加载到运行时。这是**默认策略**。
- **RUNTIME**：在运行时依然存在，因此可以通过反射机制读取。这是**最常用**的策略，框架配置通常使用此类注解。
###### 3. 如何自定义注解？
创建自定义注解非常简单，其本质是声明一个接口，但使用关键字 `@interface`。定义注解时，通常需要使用**元注解**来修饰它，以指定其行为。
以下是创建一个自定义注解的详细步骤：
**1. 定义注解**
使用 `@interface`关键字。注解内部的成员以无参数方法的形式来声明，方法名即为成员名，可以指定默认值。
```java
// 导入必要的元注解
import java.lang.annotation.*;

// 使用元注解定义新注解的行为
@Retention(RetentionPolicy.RUNTIME) // 注解在运行时保留
@Target(ElementType.METHOD)         // 注解只能用于方法上
@Documented                          // 生成到Javadoc中
public @interface MyCustomAnnotation {
    // 定义成员变量，看起来像方法，用起来像属性
    String value() default "default value"; // 名为value的成员，可指定默认值
    String description() default "";       // 另一个成员
}
```
**2. 使用注解**
将定义好的注解应用到代码的相应元素上。
```java
public class MyService {
    
    @MyCustomAnnotation(value = "这是一个测试方法", description = "用于演示自定义注解")
    public void myBusinessMethod() {
        // ... 业务逻辑
    }
    
    @MyCustomAnnotation // 使用默认值
    public void anotherMethod() {
        // ...
    }
}
```
**3. 处理注解（通过反射）**
定义和使用注解本身不产生任何效果，关键在于**编写代码来读取并处理这些注解**。
```java
import java.lang.reflect.Method;

public class AnnotationProcessor {
    public static void main(String[] args) throws Exception {
        // 1. 获取类的Class对象
        Class<MyService> clazz = MyService.class;
        
        // 2. 获取目标方法
        Method method = clazz.getMethod("myBusinessMethod");
        
        // 3. 判断方法上是否存在特定注解
        if (method.isAnnotationPresent(MyCustomAnnotation.class)) {
            // 4. 获取注解实例
            MyCustomAnnotation annotation = method.getAnnotation(MyCustomAnnotation.class);
            
            // 5. 从注解实例中获取成员的值
            String value = annotation.value();
            String desc = annotation.description();
            
            System.out.println("Value: " + value);
            System.out.println("Description: " + desc);
            
            // 这里可以根据注解信息执行特定逻辑，例如权限检查、日志记录等
        }
    }
}
```
###### 4. 元注解有哪些？各自的作用是什么？
元注解是Java提供用于修饰其他注解的注解。它们就像是注解世界的“语法规则”，规定了自定义注解的基本行为。Java 5种主要的元注解如下：

| 元注解                | 作用                                         | 可选值/说明                                                                    |
| ------------------ | ------------------------------------------ | ------------------------------------------------------------------------- |
| **`@Target`**​     | **指定注解可以应用在哪些程序元素上。**​                     | `ElementType.TYPE`（类/接口/枚举）, `METHOD`（方法）, `FIELD`（字段）, `PARAMETER`（参数）等。 |
| **`@Retention`**​  | **指定注解的生命周期，即注解信息保留到哪个阶段。**​               | `RetentionPolicy.SOURCE`（源码）, `CLASS`（类文件）, **`RUNTIME`（运行时）**​。          |
| **`@Documented`**​ | **指明该注解应被Javadoc工具记录，包含在生成的API文档中。**​      | 它是一个标记注解，没有成员。                                                            |
| **`@Inherited`**​  | **指明被它修饰的注解具有继承性。如果父类使用了该注解，子类将自动具有此注解。**​ | 只对类继承有效，对接口实现无效。是标记注解。                                                    |
| **`@Repeatable`**​ | **允许在同一程序元素上多次使用相同的注解。**​                  | Java 8引入，需要配套一个“容器注解”。                                                    |
###### 5. 注解和反射的关系是什么？
**注解和反射是相辅相成、紧密结合的两大特性。简单来说，反射是运行时读取和处理注解信息的“手电筒”和“手术刀”**​。
- **注解提供元数据**：注解在代码上做标记，存储配置信息。
- **反射提供动态读取能力**：反射API（在 `java.lang.reflect`包中）允许程序在**运行时**检查类、方法、字段等结构，并能获取它们上面的注解信息。
这种结合是实现各种框架功能的基石：
- **Spring框架**：在启动时，Spring会扫描类路径，通过反射检查类上的注解（如 `@Component`, `@Service`），从而自动创建和管理Bean。`@Autowired`也是通过反射机制实现依赖的自动注入。
- **JUnit测试框架**：通过反射查找被 `@Test`注解的方法，然后动态调用它们来执行测试。
- **序列化/反序列化**（如Jackson/Gson）：通过反射读取对象字段上的注解（如 `@JsonProperty`），来确定如何将JSON字段映射到Java对象。
**核心流程可以概括为**：**定义注解 → 使用注解标记 → 通过反射读取注解信息 → 根据注解信息执行相应逻辑**。如果没有反射，运行时的注解就只是一段无用的注释；而没有注解，反射的很多高级应用（如灵活的配置）将难以实现。