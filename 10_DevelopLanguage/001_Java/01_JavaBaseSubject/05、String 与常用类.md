###### 1. String、StringBuffer 和 StringBuilder⁠？⁠​
|特性|String|StringBuffer|StringBuilder|
|---|---|---|---|
|**可变性**​|**不可变**​|**可变**​|**可变**​|
|**线程安全**​|是（因不可变）|**是**（方法同步）|**否**​|
|**性能**​|低（频繁修改时）|中|**高**​|
|**使用场景**​|少量字符串操作、常量|多线程环境下大量字符串操作|**单线程**环境下大量字符串操作|

**核心区别与使用策略：**
- **String的不可变性**：String对象一旦创建，其内容（字符序列）就**不能被更改**。任何看似修改的操作（如拼接、替换）实际上都是**创建了一个新的String对象**。这是它和StringBuffer/StringBuilder最根本的区别。
- **性能考量**：由于String的不可变性，在需要频繁修改字符串的场景（如循环拼接）下，会产生大量临时对象，给垃圾回收（GC）带来压力，性能较差。而StringBuffer和StringBuilder直接在原字符数组上进行修改，避免了这个问题。
- **线程安全**：StringBuffer的方法大都使用了`synchronized`关键字进行同步，因此是**线程安全**的，可以在多线程环境下安全使用。StringBuilder则没有同步控制，效率更高，但**非线程安全**。在单线程环境下，**StringBuilder的性能通常优于StringBuffer**。
- **使用建议**：
	- **操作少量数据**或**字符串不需改变**时，使用String。
    - **单线程**下操作大量数据，**优先使用StringBuilder**。
    - **多线程**下操作大量数据，使用StringBuffer。
###### 2. String s = new String ("abc") 创建了几个 String 对象?⁠​
`String s = new String("abc")`这行代码创建的String对象数量**取决于字符串常量池中是否已存在内容为`"abc"`的字面量**。
- **情况一：常量池中尚无`"abc"`，创建2个对象。**
    1. **字面量对象**：首先，JVM会在**字符串常量池**中创建内容为`"abc"`的String对象。
    2. **new出来的对象**：然后，`new String(...)`会在**堆内存**中创建另一个新的、独立的String对象，它会将常量池中`"abc"`的内容复制到自己的字符数组里（在早期JDK版本中），最终变量`s`指向这个堆中的对象。
- **情况二：常量池中已存在`"abc"`，创建1个对象。**
    如果之前已有代码（如 `String temp = "abc";`）使得`"abc"`字面量已存在于常量池中，则本行代码**只会创建1个对象**，即堆中的那个`new String("abc")`对象。
**验证代码：**
```java
String temp = "abc"; // 确保常量池已有"abc"
String s1 = new String("abc");
String s2 = new String("abc");
System.out.println(s1 == s2); // 输出false，s1和s2指向堆中两个不同的对象
```
###### 3. 说说你对 String 类的 intern () 方法的理解?⁠​
`intern()`是一个本地方法，它的作用是**主动将字符串对象放入字符串常量池并返回池中对应字符串的引用**。
它的行为在**JDK 1.7及以上版本**有了重要优化：
- **调用`intern()`时**：JVM会检查常量池中是否存在与当前String对象内容相等的字符串。
    - **如果存在**：直接返回常量池中那个字符串的引用。
    - **如果不存在**：**不会**像JDK 1.6那样在常量池中复制一个该字符串的副本，而是**在常量池中记录当前堆中此对象的一个引用**，并返回这个引用。这意味着常量池和堆中的对象实际上是同一个。
**示例（JDK 1.7+）：**
```java
String s1 = new String("a") + new String("a"); // s1指向堆中的一个对象，内容为"aa"，注意此时常量池中还没有"aa"
s1.intern();  // 将s1的引用记录到常量池
String s2 = "aa"; // s2直接获取到的是常量池中记录的s1的引用
System.out.println(s1 == s2); // 输出true，因为s1和s2指向堆中同一个对象
```
**主要用途**：`intern()`方法可以**节省内存**，特别是当程序中存在大量重复内容的字符串时，通过池化可以只保留一份，减少内存占用。但也不可滥用，需根据实际情况评估。
###### 4. String 类的常用方法都有那些？⁠⁠​
String类提供了丰富的方法，以下是一些最常用的：

|方法类别|方法签名（示例）|作用|
|---|---|---|
|**获取信息**​|`int length()`|返回字符串长度|
||`boolean isEmpty()`/ `boolean isBlank()`|判断是否为空/空白符|
||`char charAt(int index)`|获取指定索引处的字符|
|**比较判断**​|`boolean equals(Object anObject)`|比较内容是否相等|
||`int compareTo(String anotherString)`|按字典顺序比较字符串|
||`boolean startsWith(String prefix)`|判断是否以指定前缀开头|
||`boolean contains(CharSequence s)`|判断是否包含指定字符序列|
|**操作子串**​|`String substring(int beginIndex, int endIndex)`|截取子串|
||`String concat(String str)`|连接字符串（等效于`+`）|
|**查找索引**​|`int indexOf(String str)`|返回指定子串第一次出现的索引|
||`int lastIndexOf(String str)`|返回指定子串最后一次出现的索引|
|**修改替换**​|`String replace(char oldChar, char newChar)`|替换字符|
||`String toLowerCase()`/ `toUpperCase()`|转换大小写|
||`String trim()`|去除首尾空白符|
|**切割转换**​|`String[] split(String regex)`|根据正则表达式切割字符串|
||`char[] toCharArray()`|转换为字符数组|
||`static String valueOf(基本类型/对象)`|将其他类型转换为String|
###### 5. String 字符串为什么说是不可变？⁠​
String的不可变性体现在三个方面：
1. **`final`修饰的类**：String类被`final`修饰，**不可被继承**，防止子类破坏不可变性。
2. **`final`修饰的底层数组**：String实际存储数据的是一个`private final char value[]`（JDK 8及之前）或`byte[]`（后续JDK为优化内存）。这个数组被声明为`final`，意味着**一旦初始化，该引用不能再指向其他数组**。
3. **没有公开的修改方法**：String类**没有提供任何能修改`value`数组内容**的公共方法（如`setChar`）。所有看似修改的方法都是创建新对象。
**这种设计带来的好处包括**：
- **实现字符串常量池**，提升性能，减少内存开销。
- **保证HashCode的稳定性**，使得String非常适合作为HashMap等容器的Key。
- **天然线程安全**，可在多线程中安全共享。
- **提高了安全性**，如在网络连接、文件路径等场景中，避免被意外修改。
###### 6. Object 有哪些常用方法？大致说一下每个方法的含义?⁠⁠​
Object是所有类的超类，其常用方法及含义如下：

|方法|含义|
|---|---|
|`protected Object clone()`|创建并返回此对象的一个副本。需实现`Cloneable`接口。|
|`boolean equals(Object obj)`|**核心方法**，用于判断两个对象在**逻辑上**是否“相等”（默认比较地址，通常需要重写）。|
|`protected void finalize()`|当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。**不推荐使用**。|
|`Class<?> getClass()`|返回此对象的运行时类。|
|`int hashCode()`|**核心方法**，返回对象的哈希码值。重写`equals`时必须重写此方法。|
|`String toString()`|返回该对象的字符串表示。强烈建议为所有子类重写此方法。|
|`void notify()`|唤醒在此对象监视器上等待的单个线程。|
|`void notifyAll()`|唤醒在此对象监视器上等待的所有线程。|
|`void wait()`|导致当前线程等待，直到另一个线程调用此对象的`notify()`或`notifyAll()`方法。|
###### 7. 一个空 Object 对象的占多大空间？⁠⁠​
在Java中，一个空`Object`对象（即`new Object()`）在堆中占用的空间大小通常是**8字节**。
这8字节是对象头（Mark Word），用于存储对象的元数据，如哈希码、锁状态、GC年龄等。
需要注意的是，这仅仅是对象本身的开销。一个引用变量（如 `Object obj;`）在32位JVM上占4字节，在64位JVM上通常占4或8字节（取决于指针压缩是否开启），但这部分空间不属于堆中的对象本身。
另外，Java内存管理有**字节对齐**的要求，为了高效访问，JVM会以8字节的整数倍来分配内存。所以，一个空Object对象实际占用的空间可能就是8字节。
###### 8. 说说你对 equals 与== 的理解？⁠​
|操作符/方法|`==`|`equals`|
|---|---|---|
|**比较本质**​|**比较的是值（Value）**​|**比较的是对象的内容（Content）**​|
|**对于基本类型**​|比较的是**变量中存储的数值**是否相等。`int a=10; int b=10; a==b // true`|基本类型不能调用`equals`方法。|
|**对于引用类型**​|比较的是**两个引用是否指向内存中的同一个对象**（即比较内存地址）。|默认行为与`==`相同（Object类中的实现）。但绝大多数类（如String、Integer）会**重写**此方法，用于比较两个对象**在逻辑上是否等价**。|

**示例：**
```java
String str1 = new String("hello");
String str2 = new String("hello");
String str3 = str1;

System.out.println(str1 == str2);   // false，比较地址，不是同一个对象
System.out.println(str1 == str3);   // true，指向同一个对象
System.out.println(str1.equals(str2)); // true，比较内容，内容相同
```
###### 9. 说说 Hash Code 的作用⁠？⁠​
哈希码（Hash Code）是一个由对象导出的**整型值**。它的主要作用是：
1. **提高哈希表（如HashMap、HashSet）的性能**：这是其最重要的用途。哈希表通过哈希码可以快速定位到对象可能存储的“桶”（bucket），大大减少了需要调用`equals`方法进行逐个比较的次数，使得查找、插入等操作的时间复杂度接近O(1)。
2. **用于对象的散列存储**。
**规范（重要）：**
- 如果两个对象根据`equals`方法是相等的，那么它们的**哈希码必须相同**。
- 如果两个对象根据`equals`方法不相等，它们的哈希码**不一定需要不同**。但好的哈希函数应尽可能产生不同的哈希码，以提升哈希表性能。
###### 10. 有没有可能两个不相等的对象有相同的 Hash Code⁠？⁠​
**有可能。这种情况被称为哈希冲突**。
即使两个对象不相等，它们也有可能产生相同的哈希码。一个好的哈希函数会尽量减少冲突，但由于哈希码是int类型，只有2^32种可能，而对象的状态组合是无限的，所以冲突是不可避免的。
哈希表（如HashMap）通过“链地址法”或“开放地址法”等技术来解决哈希冲突。
###### 11. 两个对象值相同 (x.equals (y) == true)，但却可有不同的 Hash Code，这句话对不对？⁠​
**不对。这句话严重违反了`equals`和`hashCode`方法的契约。
正确的规定是：如果`x.equals(y) == true`，那么`x.hashCode() == y.hashCode()`必须为`true`。**
反之则不一定：如果两个对象的hashCode相同，它们不一定equals。
如果违反了这条规则，当把这个对象放入基于哈希的集合（如HashSet）时，会导致无法正确找到对象等严重问题。因此，**当你重写`equals`方法时，必须同时重写`hashCode`方法**，以确保契约成立。
###### 12. StringBuilder 和 StringBuffer 的底层实现原理是什么？
StringBuilder和StringBuffer都继承自`AbstractStringBuilder`类。它们的底层实现原理基本一致：
1. **可变字符序列**：它们内部维护了一个**可变的字符数组**（`char[] value`，在JDK 8中）。这个数组没有被`final`修饰，因此可以改变。
2. **动态扩容**：当进行追加（`append`）操作时，如果当前字符数组的容量不够，会创建一个**更大的新数组**，然后将旧数组的内容复制过去。这类似于`ArrayList`的扩容机制。在创建时如果能够预估大小，通过构造函数指定初始容量（如 `new StringBuilder(100)`）可以有效减少扩容次数，提升性能。
3. **方法区别**：StringBuffer的方法都使用了`synchronized`关键字进行同步，从而保证线程安全；而StringBuilder的方法则没有，因此效率更高。
###### 13. String 为什么要设计成不可变的？
1. **实现字符串常量池**：这是最直接的原因。只有不可变，字符串常量池才能实现。不同的字符串变量可以指向池中的同一个对象，极大节省了内存空间并提高了性能。如果字符串可变，一个引用对内容的修改会影响到所有共享该对象的引用。
2. **安全性**：字符串被广泛用于类名、方法名、URL、文件名、网络连接参数等。不可变性可以防止这些关键信息被意外修改，提升了程序的安全性。例如，在数据库连接中，如果用户名和密码是可变的，可能会在建立连接后被恶意代码修改。
3. **线程安全**：由于不可变，String对象天生就是线程安全的，可以在多线程环境中安全地共享，无需额外的同步开销。
4. **作为HashMap的Key**：String的不可变性保证了其哈希码的稳定性。一旦被创建，其`hashCode`就不会改变，这使它成为HashMap等集合中Key的绝佳选择。如果Key的哈希值会变，那么在HashMap中将无法正确定位到对应的值。
5. **哈希码缓存**：String类内部有一个`hash`成员变量用于缓存第一次调用`hashCode()`计算出的结果。因为字符串内容不变，所以这个哈希码可以缓存起来反复使用，提高了像HashMap这类容器的性能。