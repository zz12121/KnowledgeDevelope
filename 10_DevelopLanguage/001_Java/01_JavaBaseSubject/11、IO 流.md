###### 1. 说说 Java 中 IO 流?⁠⁠​
关于Java IO流，它就像是程序与外界（文件、网络、控制台等）进行数据交流的桥梁。

|特性|字节流 (Byte Streams)|字符流 (Character Streams)|
|---|---|---|
|**数据单位**​|字节 (8-bit)|字符 (16-bit Unicode)|
|**基类**​|`InputStream`/ `OutputStream`|`Reader`/ `Writer`|
|**处理范围**​|所有二进制数据（如图片、视频、音频）|文本数据|
|**编码处理**​|不涉及字符编码，直接操作原始字节|**自动处理编码转换**，依赖指定或默认的字符集（如UTF-8）|
|**核心用途**​|处理非文本文件，保证数据精确无误|处理文本文件，简化字符操作，避免乱码|
|**典型类**​|`FileInputStream`, `FileOutputStream`  <br>`BufferedInputStream`, `BufferedOutputStream`  <br>`ObjectInputStream`（对象序列化）|`FileReader`, `FileWriter`  <br>`BufferedReader`, `BufferedWriter`  <br>`InputStreamReader`（转换流）|
###### 2. 既然有了字节流, 为什么还要有字符流?⁠⁠​
这是一个很好的问题。字符流的出现，主要是为了解决**文本处理**的痛点。
想象一下，一个中文字符在UTF-8编码下可能占3个字节。如果只用字节流读取文本，你需要自己处理这些字节的拼接和编码转换，非常繁琐且容易出错（尤其是当字符跨字节数组边界时）。字符流则将这些底层复杂性封装了起来，它内部会帮你完成字节到字符的解码（读取时）和字符到字节的编码（写入时），让你能直接以“字符”这个逻辑单位来操作文本，大大简化了编程，并有效防止了乱码。
简单来说：**字节流是基础，能处理一切；字符流是上层建筑，为文本处理提供了极大便利**。
###### 3. 字节流如何转为字符流？⁠⁠​
字节流和字符流之间可以通过 **“转换流” 进行桥梁式的连接。核心类是 `InputStreamReader`和 `OutputStreamWriter`。
- **`InputStreamReader`**：承上启下，将一个字节输入流（如 `FileInputStream`）转换为字符输入流（`Reader`）。你可以在构造时**显式指定字符编码**，这是解决乱码问题的关键。
 ```java
    // 指定UTF-8编码读取文件，避免乱码
    try (BufferedReader reader = new BufferedReader(
            new InputStreamReader(
                new FileInputStream("source.txt"), StandardCharsets.UTF_8))) {
        String line;
        while ((line = reader.readLine()) != null) {
            // 处理每一行文本
        }
    }
    ```
- **`OutputStreamWriter`**：将一个字符输出流（`Writer`）转换为字节输出流（如 `FileOutputStream`）。
 ```java
    try (BufferedWriter writer = new BufferedWriter(
            new OutputStreamWriter(
                new FileOutputStream("output.txt"), StandardCharsets.UTF_8))) {
        writer.write("Hello, 世界！");
    }
    ```
你可能注意到 `FileReader`和 `FileWriter`是直接操作文件的字符流，但它们本质上是转换流的便捷类，只不过它们使用的是系统默认的字符编码。因此，在需要明确指定编码的跨环境场景下，更推荐使用转换流。
###### 4. Files 的常用方法都有哪些？⁠​
在Java 7中引入的 `java.nio.file.Files`类，提供了大量静态方法来操作文件，极大简化了IO操作，是现代Java开发的首选。

| 操作类型      | 常用方法                                                             | 说明                    |
| --------- | ---------------------------------------------------------------- | --------------------- |
| **读写文件**​ | `Files.readAllBytes(Path path)`                                  | 一次性读取所有字节，适用于小文件。     |
|           | `Files.readAllLines(Path path)`                                  | 读取所有行到一个List<String>。 |
|           | `Files.write(Path path, byte[] bytes)`                           | 将字节数组写入文件。            |
|           | `Files.write(Path path, Iterable<? extends CharSequence> lines)` | 将字符串集合逐行写入文件。         |
|           | `Files.newBufferedReader(Path path)`                             | 创建高效的BufferedReader。  |
| **文件操作**​ | `Files.exists(Path path)`                                        | 检查文件或目录是否存在。          |
|           | `Files.createFile(Path path)`                                    | 创建新文件。                |
|           | `Files.createDirectories(Path path)`                             | 创建目录（包括不存在的父目录）。      |
|           | `Files.copy(InputStream in, Path target)`                        | 从输入流复制到文件。            |
|           | `Files.move(Path source, Path target)`                           | 移动或重命名文件。             |
|           | `Files.delete(Path path)`                                        | 删除文件或目录（不存在则抛异常）。     |
|           | `Files.deleteIfExists(Path path)`                                | 安全删除。                 |
| **获取信息**​ | `Files.size(Path path)`                                          | 返回文件大小（字节）。           |
|           | `Files.isDirectory(Path path)`                                   | 判断是否是目录。              |
|           | `Files.getLastModifiedTime(Path path)`                           | 获取最后修改时间。             |
###### 5. FileInputStream 和 FileReader 的区别是什么？⁠​
这个区别直接源于字节流和字符流的根本不同。

|方面|`FileInputStream`|`FileReader`|
|---|---|---|
|**继承体系**​|`InputStream`(字节流)|`Reader`(字符流)|
|**读取单位**​|**字节**​ (byte)|**字符**​ (char)|
|**返回值**​|`int`类型，表示字节数据（0-255）|`int`类型，表示字符的Unicode码点|
|**编码处理**​|**不处理**，读到的就是文件的原始字节。|**自动处理**，根据默认或指定的编码将字节解码为字符。|
|**适用场景**​|复制图片、视频，或需要精确处理文件原始字节的场景。|读取文本文件内容，如配置文件、日志文件等。|

**核心结论**：处理非文本文件用 `FileInputStream`，处理文本文件用 `FileReader`（或更好指定编码的 `InputStreamReader`）。
###### 6. 简单说说 Java IO 与 NIO 的区别⁠？⁠​
传统IO（常被称为BIO, Blocking IO）和NIO（New IO）是两套不同的IO API。

|特性|Java IO (BIO)|Java NIO|
|---|---|---|
|**数据流与块**​|**面向流**：逐个字节/字符地处理数据。|**面向缓冲区**：数据先读到一个缓冲区（Buffer），然后在缓冲区中处理。|
|**阻塞与非阻塞**​|**阻塞IO**：线程在读/写操作完成前会被挂起。|**非阻塞IO**：线程可做其他事，通过选择器（Selector）轮询通道（Channel）的状态。|
|**核心组件**​|`InputStream`, `OutputStream`, `Reader`, `Writer`|**Channel**（通道），**Buffer**（缓冲区），**Selector**（选择器）|
|**工作模式**​|一个连接一个线程。成百上千连接会导致线程资源耗尽。|一个线程处理多个连接。Selector监控多个Channel上的事件，适合高并发。|
|**适用场景**​|连接数较少且固定的架构。|连接数多且连接时间短的场景，如聊天服务器、即时通讯。|

简单比喻：IO像一杯一杯接水喝（流），NIO像先拿一个桶接满水，再从桶里喝（缓冲区）。
###### 7. BIO、NIO、AIO 有什么区别？⁠​
这三者代表了Java处理IO的三种模型。

|模型|全称|含义与特点|适用场景|
|---|---|---|---|
|**BIO**​|Blocking IO (同步阻塞IO)|应用程序发起IO调用后，**线程会一直阻塞**，直到数据准备好或操作完成。|连接数少、逻辑简单的应用。|
|**NIO**​|Non-blocking IO (同步非阻塞IO)|应用程序发起IO调用后，**线程可立即返回做别的事**，并通过轮询（或Selector事件通知）来检查数据是否就绪。|高并发、连接数多的网络应用。|
|**AIO**​|Asynchronous IO (异步非阻塞IO)|应用程序发起IO调用后**立即返回**。当内核数据完全准备好后，**会主动回调**通知应用程序进行处理。|适用于需要高性能异步处理的应用，如图像处理、大规模文件IO。|

**关键理解**：BIO和NIO都是**同步**的。同步/异步关注的是**消息通信机制**：同步指调用者主动等待结果，异步指被调用者通过回调等方式通知调用者。阻塞/非阻塞关注的是**等待结果时线程的状态**。
###### 8. Java IO 中用到了哪些设计模式？⁠⁠​
Java IO流是学习设计模式的绝佳范例，主要用到了以下两种：
1. **装饰器模式**：这是IO流的核心模式。它通过**组合**而非继承的方式动态地给一个对象添加额外功能。例如，你可以给一个基础的 `FileInputStream`套上 `BufferedInputStream`来增加缓冲功能，再套上 `ObjectInputStream`来反序列化对象。这种模式比继承更灵活，各种流可以像搭积木一样自由组合。
2. **适配器模式**：转换流 `InputStreamReader`和 `OutputStreamWriter`就是适配器，它们**适配**了字节流和字符流这两个不兼容的接口，让它们可以协同工作。
###### 9. 如何正确关闭 IO 流？⁠⁠​
关闭流是为了释放系统资源（如文件句柄），否则会导致资源泄漏。有几种方式：
1. **传统的 try-catch-finally**（繁琐，不推荐）：
```java
    FileInputStream fis = null;
    try {
        fis = new FileInputStream("file.txt");
        // ... 使用流
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (fis != null) {
            try {
                fis.close(); // 确保在finally块中关闭
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ```
2. **Try-with-Resources**（**强烈推荐**，Java 7+）：这是现代Java的标准做法。只要资源（如流）实现了 `AutoCloseable`接口，就可以在try后的括号中声明，JVM会**自动**在try块结束后正确关闭它们，即使发生异常也会关闭，代码非常简洁。
```java
    try (FileInputStream fis = new FileInputStream("source.jpg");
         FileOutputStream fos = new FileOutputStream("target.jpg")) {
        // ... 使用流
    } catch (IOException e) {
        e.printStackTrace();
    } // 无需显式关闭，自动处理
    ```
###### 10. Java 有几种文件拷贝方式，哪一种效率最高？⁠​
|方式|描述|适用场景|
|---|---|---|
|**基础字节流**​|使用 `FileInputStream`和 `FileOutputStream`，配合字节数组缓冲区。|通用，但性能非最优。|
|**缓冲字节流**​|使用 `BufferedInputStream`和 `BufferedOutputStream`包装基础流。利用缓冲区减少系统调用次数，**性能显著优于基础流**。|**大多数场景下的推荐选择**，在小文件拷贝中效率很高<br><br>。|
|**NIO 的 `FileChannel`**​|使用 `FileChannel.transferTo()`或 `transferFrom()`方法。|大文件拷贝。|
|**`Files.copy()`**​|Java 7+ 提供的一站式方法，底层会优化实现。|**代码最简洁**，日常开发首选。|

**效率最高**：对于**大文件**，**NIO的`FileChannel.transferTo()`方法通常效率最高**，因为它可能用到操作系统层面的“零拷贝”技术，避免了数据在内核缓冲区和用户缓冲区之间的不必要的拷贝。
###### 11. 什么是零拷贝技术？
零拷贝是一种旨在减少数据拷贝次数、提升IO性能的优化技术。在传统的文件拷贝中，数据需要经历多次复制：
1. 从磁盘文件通过DMA拷贝到内核空间的缓冲区。
2. 从内核缓冲区拷贝到用户空间的应用程序缓冲区。
3. 应用程序处理后再从用户缓冲区拷贝到内核空间的Socket缓冲区。
4. 最后通过DMA从Socket缓冲区拷贝到网卡。
这其中有四次上下文切换和四次数据拷贝。而NIO的 `FileChannel.transferTo()`方法在底层支持零拷贝，它允许操作系统直接将数据从文件通道传输到目标通道（如Socket通道），**避免了数据在用户态和内核态之间的来回拷贝**，通常只需要两次DMA拷贝，极大地降低了CPU开销和上下文切换次数，从而提升了性能。
DMA（直接内存访问）：一种通过专用控制器实现存储器与外设间直接数据传输的技术，无需中央处理器（CPU）全程介入
###### 12. RandomAccessFile 的使用场景是什么？
`RandomAccessFile`是一个功能独特的类，它支持对文件进行“随机访问”。
它的特点是可以**自由移动文件指针**到任意位置进行读写。这打破了普通流只能顺序读写的限制。
**典型使用场景**：
- **断点续传**：下载文件时，记录已下载的位置（文件指针）。下次续传时，直接移动指针到该位置继续写入。
- **多线程下载**：将文件分成若干块，每个线程负责下载其中一块，通过移动指针到不同位置并行写入。
- **日志系统**：在文件末尾追加内容，或者读取特定位置的日志记录。
- **简单的数据库**：存储固定长度的记录，可以通过计算偏移量直接定位到某条记录进行修改。