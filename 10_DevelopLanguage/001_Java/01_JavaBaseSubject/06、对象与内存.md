###### 1. 什么是构造函数？构造函数有什么特点？⁠⁠​
构造函数是一种特殊的成员方法，**在创建对象时被自动调用**，主要用于初始化对象的成员变量。
其主要特点包括：
1. **必须与类同名**。
2. **不能有返回类型**，即使是 `void`也不可以。
3. **支持重载**：一个类中可以有多个参数列表不同的构造函数，根据 `new`时传入的参数决定调用哪一个。
4. **自动调用**：使用 `new`关键字创建对象时，JVM 会自动调用相应的构造函数。
5. **默认构造函数**：如果一个类没有显式定义任何构造函数，编译器会自动提供一个无参数的默认构造函数。一旦定义了任何构造函数，默认构造函数便不再自动提供。
6. **继承中的调用**：在继承关系中，创建子类对象时，**会首先调用父类的构造函数**（默认调用无参构造，可使用 `super(args)`显式调用有参构造），然后再调用子类的构造函数。
###### 2. 说说 Java 代码初始化顺序?⁠⁠​
理解Java程序中各类成员（静态/非静态、变量/代码块）以及构造函数的初始化顺序至关重要。对于一个继承结构，其初始化顺序遵循明确的规则：
1. **父类静态成员**：先初始化父类的静态变量（包括静态代码块），按代码中定义的顺序执行。
2. **子类静态成员**：然后初始化子类的静态变量（包括静态代码块），按代码中定义的顺序执行。
3. **父类实例成员和构造器**：接着初始化父类的非静态变量（包括实例初始化块），按代码中定义的顺序执行，最后执行父类的构造函数。
4. **子类实例成员和构造器**：最后初始化子类的非静态变量（包括实例初始化块），按代码中定义的顺序执行，最后执行子类的构造函数。
**核心原则**可以概括为：**静态优先于非静态，父类优先于子类，变量和代码块按定义顺序初始化**。静态初始化只在类首次加载时执行一次，而实例初始化每次创建新对象时都会执行。
###### 3. Java 创建对象有几种方式？⁠​
Java中创建对象主要有以下几种方式：
1. **使用 `new`关键字**：最常用、最直接的方式。例如 `MyClass obj = new MyClass();`。
2. **使用反射机制**：通过 `Class`类的 `newInstance()`方法（已过时，不推荐）或 `Constructor`类的 `newInstance()`方法。例如 `MyClass obj = MyClass.class.getDeclaredConstructor().newInstance();`。
3. **使用 `clone()`方法**：需要类实现 `Cloneable`接口并重写 `Object`的 `clone()`方法。实现的是对象的复制。
4. **使用反序列化**：通过 `ObjectInputStream`从文件或网络等字节流中读取并还原对象。
###### 4. 如何实现对象克隆？⁠​
实现对象克隆，需要让类**实现 `Cloneable`标记接口**，并**重写 `Object`类中的 `clone()`方法**，且将其访问修饰符改为 `public`。
```java
class Person implements Cloneable {
    private String name;
    private Address address; // 假设Address是一个引用类型

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone(); // 默认实现是浅拷贝
    }
}
```
###### 5. 深拷贝和浅拷贝的区别是什么?⁠​
|特性|浅拷贝 (Shallow Copy)|深拷贝 (Deep Copy)|
|---|---|---|
|**本质**​|只复制对象本身及其基本类型字段，**不复制其引用的对象**。|复制对象本身及其所有引用的对象（递归地进行复制），创建一个完全独立的副本。|
|**引用字段**​|原对象和副本对象**共享**同一个引用对象。|原对象和副本对象**拥有各自独立**的引用对象。|
|**内存示意图**​|`原对象A -> 对象B`  <br>`副本A' -> 对象B`(共享B)|`原对象A -> 对象B`  <br>`副本A' -> 对象B'`(B的副本)|
|**修改影响**​|修改副本的引用对象内容，会影响原对象。|修改副本的引用对象内容，**不会影响**原对象。|
|**实现复杂度**​|简单，通常 `Object.clone()`默认行为即是。|复杂，需要递归地复制所有引用对象。|
|**性能**​|较高，不创建深层对象。|较低，需要创建整个对象图。|

实现深拷贝主要有两种方式：
1. **重写 `clone()`方法**：在重写的 `clone`方法中，不仅调用 `super.clone()`，还要对每个引用类型的字段递归地调用其 `clone`方法。
2. **通过序列化**：将对象写入字节流，然后再从字节流中读回。这种方式要求对象及其所有引用对象都实现 `Serializable`接口，性能开销较大，但代码相对简洁。
###### 6. 熟悉 Java 的对象引用类型吗？⁠⁠​
Java提供了四种不同强度的引用类型，用于更精细地控制对象的生命周期，帮助管理内存和避免内存泄漏。
1. **强引用**：最常见的引用，例如 `Object obj = new Object()`。只要强引用存在，垃圾回收器就**永远不会**回收被引用的对象。
2. **软引用**：通过 `SoftReference`类实现。当内存不足时，垃圾回收器**会回收**这些软引用指向的对象。常用于实现内存敏感的缓存。
3. **弱引用**：通过 `WeakReference`类实现。无论内存是否充足，只要发生垃圾回收，弱引用指向的对象**就会被回收**。常用于维护一种非强制的映射关系，如 `WeakHashMap`的键。
4. **虚引用**：通过 `PhantomReference`类实现。最弱的一种引用，**无法通过虚引用获取对象实例**。其唯一作用是用于对象被回收时收到一个系统通知，通常与引用队列 `ReferenceQueue`联合使用，用于跟踪对象被垃圾回收的状态。
###### 7. 为什么 Java 中只有值传递？⁠​
关于Java是值传递还是引用传递，是一个经典问题。结论是：**Java中只有值传递**。
- **值传递**：将实际参数的一个**副本**传递给方法。方法内对副本的修改**不会影响**原始变量。
- **引用传递**：将实际参数本身的**引用**（可以理解为内存地址）传递给方法。方法内对形式参数的修改**会影响**原始变量。
在Java中，当传递基本数据类型（如 `int`, `double`）时，传递的是值的副本，这很明显是值传递。当传递引用数据类型（如对象、数组）时，实际上传递的是**引用的副本**（即对象地址的一个拷贝）。这意味着，在方法内部：
- 你可以通过这个副本引用**修改对象的状态**（因为指向的是同一个对象）。
- 但**你不能通过这个副本引用来改变原始引用所指向的对象**（例如，让它指向一个新的对象），因为你操作的只是地址的一个副本。
```java
public class Test {
    public static void changeValue(int num, String str, StringBuilder sb) {
        num = 100; // 修改基本类型副本，不影响原值
        str = "Changed"; // 让副本引用指向新字符串对象，不影响原引用
        sb.append(" World"); // 通过副本引用修改共享对象的内容，原对象被修改
        // sb = new StringBuilder("New"); // 如果让副本引用指向新对象，则不影响原引用
    }

    public static void main(String[] args) {
        int a = 10;
        String s = "Hello";
        StringBuilder builder = new StringBuilder("Hello");
        changeValue(a, s, builder);
        System.out.println(a); // 输出 10
        System.out.println(s); // 输出 "Hello"
        System.out.println(builder); // 输出 "Hello World"
    }
}
```
###### 8. Java 对象的内存布局是怎样的？
在HotSpot虚拟机中，一个对象在堆内存中的存储布局可以分为三个部分：
1. **对象头**：包含两类信息。
    - **Mark Word**：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等。这部分数据在32位和64位虚拟机上长度分别为32bit和64bit。
    - **类型指针**：指向对象的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
2. **实例数据**：对象真正存储的有效信息，即程序代码中定义的各种类型的字段内容（包括从父类继承下来的）。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。
3. **对齐填充**：起占位符作用。HotSpot VM要求对象起始地址必须是8字节的整数倍，因此当实例数据部分没有对齐时，需要通过对齐填充来补全。
###### 9. 什么是对象的逃逸分析？
逃逸分析是JVM的一种**分析技术**，用于分析**对象的作用域**是否会逃逸出方法或线程。具体来说，JVM会分析：
- **方法逃逸**：一个对象在方法内被定义后，可能被外部方法引用（例如作为参数传递给其他方法，或赋值给类变量）。
- **线程逃逸**：一个对象可能被其他线程访问到。
如果通过逃逸分析，JVM发现一个对象**没有逃逸**出当前方法或线程，那么JVM可能会进行一些高效的优化：
1. **栈上分配**：将对象的内存分配在Java虚拟机栈上（而不是堆上）。这样，对象所占用的内存空间就可以随着栈帧的出栈而被销毁，减轻了垃圾回收的压力。
2. **标量替换**：将对象“拆解”成若干个其包含的基本数据类型（标量），并将这些标量分配在栈上或寄存器中。这样就完全不会创建这个对象，从而避免了对象头的内存开销。
3. **同步消除**：如果发现该对象只能被一个线程访问，那么对这个对象实施的同步措施（如`synchronized`）就可以被安全地消除。
逃逸分析在服务器端编译器（C2）中是默认开启的（`-XX:+DoEscapeAnalysis`），它是一项重要的即时编译器优化技术。