###### 1. 什么是序列化和反序列化？Serializable 接口的作用是什么？⁠​
- **序列化**：指的是将内存中的Java对象转换成与平台无关的字节序列的过程。这个字节序列可以保存到磁盘文件（实现数据持久化），也可以通过网络传输到另一个主机（用于远程方法调用，如RMI）。
- **反序列化**：是序列化的逆过程，它将字节序列从存储介质或网络中读取出来，重新构造成一个与原始对象状态完全相同的Java对象。
`Serializable`接口是Java提供的一个**标记接口**。所谓标记接口，是指内部没有定义任何方法的接口。它的作用非常简单，却至关重要：**它声明实现它的类允许其对象被序列化**。
Java的序列化机制（如 `ObjectOutputStream`）在运行时会检查一个对象是否实现了此接口。只有实现了 `Serializable`接口的类的对象，才可以被合法地序列化和反序列化，否则会抛出 `NotSerializableException`异常。
###### 2. Java 序列化中如果有些字段不想进行序列化，怎么办？⁠​
如果你希望类的某些成员变量不被序列化，有几种方法可以实现：
1. **使用 `transient`关键字**：这是最常用和直接的方式。用一个例子来说明，对于一个 `User`类，密码字段非常敏感，我们不希望它被序列化后保存或传输
```java
    public class User implements Serializable {
        private String name;
        private transient String password; // 使用transient修饰，不会被序列化
    
        // ... 构造方法、getter、setter ...
    }
    ```
被 `transient`修饰的字段，在序列化时会被完全忽略。在反序列化后，这些字段的值会被设置为对应类型的默认值（例如，对象引用为 `null`，`int`为 `0`，`boolean`为 `false`）。
2. **使用 `static`修饰符**：静态变量属于类本身，而不属于任何一个对象实例。而序列化是针对对象实例状态的。因此，**静态变量不会被序列化**。
3. **自定义序列化过程**：对于需要更精细控制的场景，可以实现 `Externalizable`接口（它继承自 `Serializable`），并重写 `writeExternal`和 `readExternal`方法，完全自主地决定哪些字段需要被序列化和如何序列化。此外，即使使用 `Serializable`接口，也可以通过在类中定义 `writeObject`和 `readObject`方法来实现自定义序列化逻辑。
###### 3. serialVersionUID 的作用是什么？
`serialVersionUID`是一个名为**序列化版本统一标识符**的 `private static final long`常量。它的核心作用是**确保序列化和反序列化过程中，类的版本是兼容的**。
- **工作机制**：当对象被序列化时，JVM会将当前类的 `serialVersionUID`值一并写入字节流。当反序列化时，JVM会拿字节流中的 `serialVersionUID`与本地当前类的 `serialVersionUID`进行比较。
    - 如果两者一致，反序列化成功。
    - 如果两者不一致，则会抛出 `InvalidClassException`，反序列化失败 。
- **显式声明的重要性**：如果你没有在类中显式地声明 `serialVersionUID`，JVM会根据类的各种内部细节（如类名、方法、字段等）自动生成一个。**一旦类的结构发生任何微小的改变（比如增加一个方法），这个自动生成的ID就会发生变化，导致之前序列化的对象无法被反序列化**。因此，为了保持版本兼容性（例如，在类增加了新字段但希望仍能反序列化旧对象时），**强烈建议在可序列化的类中显式声明一个固定的 `serialVersionUID`值**。
###### 4. 序列化的底层实现原理是什么？
Java序列化的底层实现涉及`ObjectOutputStream`和`ObjectInputStream`这两个类，它们遵循一套特定的二进制协议。
1. **递归与对象图**：当你调用 `ObjectOutputStream.writeObject(Object)`时，序列化过程并不仅仅处理单个对象。它会递归地遍历该对象所引用的所有其他对象（除非被`transient`或`static`修饰，或某些对象不可序列化），直到所有关联的基本数据类型和对象都被处理完毕，从而形成一个完整的对象图。
2. **写入流程与数据格式**：写入流的数据有特定的结构：
    - **魔数（Magic Number）和版本号**：标识这是一个Java序列化流。
    - **类的描述信息（ObjectStreamClass）**：包括类的完整名称、`serialVersionUID`、字段的数量、类型和名称等元数据。这部分信息非常重要，它告诉反序列化方如何"重建"这个对象。
    - **对象的实际数据值**：即对象实例中各个非`transient`、非`static`字段的值。
    - 如果同一个对象在对象图中被多次引用，序列化机制有优化处理，只会保存一份该对象的实际数据，并通过句柄来表示引用关系，以避免循环引用和重复数据。
3. **反射机制**：在反序列化过程中，JVM首先会通过类的全限定名找到或动态加载对应的Class对象。然后，**它并不会调用类的任何公共构造方法**，而是直接使用底层机制（可理解为在JVM层面直接分配内存并设置对象头）来创建一个空的原始对象。接着，利用**反射**将字节流中读取到的字段值逐一填充到这个新创建对象的对应字段中。这正是为什么反序列化不需要通过构造函数就能创建对象的原因。
4. **自定义行为**：如前所述，如果类中定义了 `writeObject`和 `readObject`方法，序列化引擎会通过反射调用这些方法，将控制权交给类自己，从而实现自定义的序列化逻辑。对于实现 `Externalizable`接口的类，则会调用其 `writeExternal`和 `readExternal`方法，并且反序列化时会先调用类的无参构造函数。