###### 1. 什么是 AQS？它的作用是什么？
AQS（`AbstractQueuedSynchronizer`）是一个用于构建**锁**和**其他同步组件**（如信号量、栅栏等）的**基础框架**。它位于 `java.util.concurrent.locks`包下。你可以把它想象成一个强大的“脚手架”，JDK中的许多同步工具类，比如 `ReentrantLock`、`CountDownLatch`、`Semaphore`等，都是基于AQS构建的。
它的核心作用是提供了一个**模板**，将复杂的线程排队、阻塞、唤醒等底层机制封装起来。作为开发者，当我们想要实现一个自定义的同步组件时，只需要继承AQS，并重写几个关键的方法（主要涉及对共享资源状态`state`的获取和释放），而无需关心复杂的队列管理。这大大简化了并发组件的实现难度。
###### 2. AQS 的核心思想是什么？
AQS的核心思想可以概括为：**如果请求的共享资源处于空闲状态，那么就将当前请求资源的线程设置为有效的工作线程，并将资源标记为已锁定。如果请求的资源已被占用，那么就需要一套机制来让后续的线程进行等待、在适当时机被唤醒并分配资源。这套机制就是通过一个FIFO（先进先出）的线程等待队列（一个CLH锁队列的变体）来实现的**。
简单来说，AQS通过一个整型的同步状态变量（`state`）​ 和一个**FIFO线程等待队列**来解决多线程访问共享资源的问题。
###### 3. AQS 的数据结构是怎样的？
AQS的内部数据结构主要由两部分组成，这也是其实现同步的基石：
1. **同步状态（`state`）**：一个使用 `volatile`关键字修饰的 `int`类型变量。这个变量是**多线程竞争的核心**，不同的同步组件对其含义有不同的定义。
	例如：
    - 在 `ReentrantLock`中，`state`表示锁被同一个线程重入的次数。
    - 在 `Semaphore`中，`state`表示当前可用的许可证数量。
    - 在 `CountDownLatch`中，`state`表示计数器当前的值。
2. **同步队列**：一个**双向链表**结构的线程等待队列，用于存放那些未能成功获取到同步状态的线程。AQS会将每个等待线程包装成一个 `Node`节点。这个队列是CLH锁的一种变体，它通过每个节点中的 `waitStatus`字段来维护节点的状态（如 `SIGNAL`, `CANCELLED`等），从而高效地管理线程的阻塞和唤醒。
为什么是双向链表？
主要是为了高效地管理节点的前驱和后继，特别是在处理线程取消或超时等情况时，可以快速地将节点从队列中移除
###### 4. AQS 的独占模式和共享模式有什么区别？
|特性|独占模式（Exclusive）|共享模式（Shared）|
|---|---|---|
|**核心概念**​|同一时刻**只有一个线程**能获取资源，如写锁。|同一时刻**多个线程**可以同时获取资源，如读锁。|
|**代表组件**​|`ReentrantLock`|`Semaphore`, `CountDownLatch`, `ReentrantReadWriteLock`的读锁。|
|**关键方法**​|`acquire(int arg)`, `release(int arg)`|`acquireShared(int arg)`, `releaseShared(int arg)`|
|**尝试获取**​|`tryAcquire(int arg)`：成功返回true，失败返回false。|`tryAcquireShared(int arg)`：返回负数表示失败；0表示成功但无剩余资源；正数表示成功且有剩余资源。|
|**尝试释放**​|`tryRelease(int arg)`|`tryReleaseShared(int arg)`|
###### 5. AQS 中的 state 变量是什么？如何使用？
`state`变量是AQS的灵魂，它代表了同步组件的状态。AQS提供了三个**final**方法来安全地操作这个变量，这些方法都保证了内存可见性和原子性：
- `getState()`：获取当前同步状态。
- `setState(int newState)`：设置新的同步状态。
- `compareAndSetState(int expect, int update)`：通过CAS（比较并交换）​ 操作原子性地设置状态值。这是实现无锁线程安全的核心。
同步组件的实现者（即AQS的子类）需要根据自身的语义来定义如何通过操作 `state`来实现同步。例如，一个简单的互斥锁可以这样实现：
- `tryAcquire(1)`：通过CAS尝试将 `state`从0设置为1。成功则表示获取锁。
- `tryRelease(1)`：将 `state`从1设置回0，表示释放锁。
###### 6. AQS 的等待队列是如何实现的？
AQS的等待队列是一个FIFO的双向链表，其实现非常精妙。当一个线程尝试获取同步状态失败时，AQS会执行以下步骤：
1. **构造节点并入队**：将当前线程封装成一个 `Node`节点，然后通过一个**自旋（循环）CAS操作**，安全地将此节点添加到队列的尾部（`tail`）。
2. **线程阻塞**：一旦节点成功入队，如果该节点的前驱节点是头节点（`head`），它会再次尝试获取状态。如果失败，或者前驱节点状态为 `SIGNAL`（表示前驱节点释放资源后需要唤醒它），则当前线程会被 `LockSupport.park()`方法挂起（阻塞），等待被唤醒。
3. **线程唤醒与出队**：当持有锁的线程释放资源时，会唤醒队列中头节点的后继节点（如果存在）。被唤醒的线程会再次尝试获取资源。获取成功后，该节点就成为新的头节点，原头节点会被断开链接以便垃圾回收。
###### 7. AQS 如何实现公平锁和非公平锁？
基于AQS的锁可以实现公平和非公平两种策略，其区别关键在于 **新线程到来时，是否检查队列中已有等待者**：
- **非公平锁**：当线程尝试获取锁时，无论等待队列中是否有其他线程在排队，它都会**直接尝试通过CAS抢占**​ `state`。这可能导致“插队”现象，但吞吐量通常更高，因为减少了线程挂起和唤醒的开销。`ReentrantLock`默认就是非公平锁。
- **公平锁**：当线程尝试获取锁时，它会先调用 `hasQueuedPredecessors()`方法**检查等待队列中是否有比它更早的线程在排队**。如果有，则当前线程乖乖入队等待；如果没有，才会尝试获取锁。这保证了“先来后到”的公平性，但可能引入额外的检查开销。
实现上的唯一区别通常就在 `tryAcquire`方法中，公平锁多了一次检查队列是否为空的操作。
###### 8. 基于 AQS 实现的同步组件有哪些？
Java并发包（JUC）中大量同步工具都基于AQS构建，以下是几个典型的例子：

|同步组件|资源模式|功能描述|
|---|---|---|
|**ReentrantLock**​|独占|可重入的互斥锁，支持公平/非公平策略。|
|**ReentrantReadWriteLock**​|独占 + 共享|读写锁，读锁共享，写锁独占。|
|**Semaphore**​|共享|信号量，控制同时访问特定资源的线程数量。|
|**CountDownLatch**​|共享|倒计时门闩，让一个或多个线程等待一组操作完成。|
|**ThreadPoolExecutor**​|独占|Java线程池的Worker类使用AQS维护线程状态。|