###### 1. 什么是死锁？死锁产生的条件是什么？
死锁是指**两个或两个以上的线程**在执行过程中，因**争夺资源**而造成的一种互相等待的现象，若无外力干涉，这些线程都将无法推进下去。
死锁的产生必须同时满足以下四个必要条件：
1. **互斥条件**：一个资源每次只能被一个线程使用。
2. **请求与保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺条件**：线程已获得的资源，在未使用完之前，不能被其他线程强行剥夺。
4. **循环等待条件**：多个线程之间形成一种首尾相接的循环等待资源关系。
###### 2. 如何避免死锁？
避免死锁的核心在于**破坏上述四个必要条件中的至少一个**。以下是一些实践证明有效的方法：
1. **固定锁的顺序**：确保所有线程以**一致的顺序**获取锁。例如，有锁A和锁B，规定所有需要同时获取这两个锁的线程必须先获取A，再获取B。这能有效破坏“循环等待”条件。
2. **使用尝试性机制**：利用`ReentrantLock`的`tryLock()`方法，指定一个超时时间。如果在规定时间内无法获取所有需要的锁，则释放已持有的锁，进行回退并重试或执行其他逻辑。这破坏了“请求与保持”条件。
3. **避免嵌套锁**：尽量减少在持有一个锁的情况下再去获取另一个锁。如果无法避免，务必仔细设计锁的获取顺序。
4. **使用线程池**：通过`Executors`工具类创建线程池，可以有效管理线程生命周期，减少因频繁创建销毁线程带来的开销和潜在风险，但需注意线程池参数的合理配置。
###### 3. 如何检测和定位死锁？
1. **使用JDK内置工具**：
    - **jstack**：在命令行使用`jstack <pid>`（`pid`是Java进程ID）可以生成线程转储。线程转储会**明确提示发现的死锁**，并列出相关的线程和它们持有的锁信息。
    - **JConsole/JVisualVM**：这些图形化工具可以连接到正在运行的Java进程，在“线程”选项卡中通常有死锁检测功能，可以直观地查看死锁链。
2. **编程式检测**：通过`ThreadMXBean`在代码中定期检查死锁。
```java
    import java.lang.management.ManagementFactory;
    import java.lang.management.ThreadMXBean;
    
    public class DeadlockDetector {
        public static void checkForDeadlocks() {
            ThreadMXBean bean = ManagementFactory.getThreadMXBean();
            long[] threadIds = bean.findDeadlockedThreads(); // 返回发生死锁的线程ID数组
            if (threadIds != null) {
                System.err.println("Deadlock detected!");
                // 进一步输出详细线程信息，帮助定位
                for (long threadId : threadIds) {
                    System.err.println("Thread ID in deadlock: " + threadId);
                }
                // 此处可以触发告警或恢复逻辑
            }
        }
    }
    ```
3. **使用调试器和系统工具**：在Linux环境下，可使用`gdb`等工具附加到进程，检查各线程调用栈和锁的持有情况，分析是否存在循环等待链。
###### 4. 什么是活锁？与死锁有什么区别？
活锁指的是线程**没有被阻塞**，但由于某些条件未满足，导致它们不断地**重复尝试、失败、再尝试**的过程，程序整体无法取得实质性进展。活锁是“活”的，线程仍在运行，但工作无效。
- **与死锁的区别**：死锁的线程是**阻塞等待**（Blocked/Waiting），什么都不做；活锁的线程仍在**持续运行**（Running），但无法完成任务。
- **解决方法**：引入**随机性**和**重试次数上限**。例如，在重试逻辑中增加随机的退避时间，避免多个线程完全同步地重试而导致持续冲突。
###### 5. 什么是饥饿？如何避免线程饥饿？
饥饿是指某个或某类线程**长期无法获得所需资源**（如CPU时间片、锁等），导致其任务无法执行的情况。
- **产生原因**：可能是由于线程**优先级设置不合理**，或者某个线程长时间持有锁不释放。
- **解决方法**：
    1. 使用**公平锁**（如`ReentrantLock(true)`），保证等待时间最长的线程优先获取锁。 
    2. **避免设置不合理的线程优先级**，尽量使用默认优先级。
    3. 确保**锁的持有时间尽可能短**，减少临界区代码。
下面的表格清晰对比了死锁、活锁和线程饥饿这三个易混淆的概念

| 特性        | 死锁           | 活锁                  | 饥饿                |
| --------- | ------------ | ------------------- | ----------------- |
| **线程状态**​ | **阻塞**，无限期等待 | **非阻塞**，持续活动但无效     | **可能就绪**，但长期得不到调度 |
| **资源循环**​ | 存在**循环等待**链  | 可能不存在固定的循环等待链       | 不涉及循环等待           |
| **解决关键**​ | 破坏四个必要条件之一   | 引入**随机性**和**重试上限**​ | 保证**公平性**的资源分配    |
###### 6. 如何提高并发程序的性能？
**核心优化方向**：
- **最小化共享状态**：减少需要同步的区域，是提升并发性能的根本。
- **缩小临界区**：只对必须同步的代码加锁，让锁的持有时间尽可能短。
- **选择高效数据结构**：优先使用`ConcurrentHashMap`, `CopyOnWriteArrayList`等并发容器，它们在底层做了大量优化。
- **使用线程池**：避免频繁创建销毁线程的开销。
###### 7. 什么是无锁编程？有哪些应用场景？
无锁编程是一种高级并发技术，它不使用传统的互斥锁，而是依靠**原子操作**和**CAS**来实现线程安全。
- **原理**：核心是**CAS**操作。线程尝试直接修改共享数据，如果发现数据与预期不符（说明已被其他线程修改），则重试，直到成功。
- **应用场景**：
    - **高性能计数器**：如`AtomicLong`。
    - **无锁队列**：如`ConcurrentLinkedQueue`，适用于高并发、生产者-消费者场景。
- **优点**：**性能高**，避免了锁带来的线程上下文切换和阻塞开销。
- **缺点**：**开发复杂**，容易出现**ABA问题**，且在**高竞争**下，频繁的CAS失败会导致CPU空转。
###### 8. 如何使用 JMH 进行并发性能测试？
JMH是Java官方推出的专门用于进行Java微基准测试的工具，对于并发性能测试尤其重要，因为它能有效避免JVM的JIT编译器优化等因素对测试结果的干扰。
1. **添加JMH依赖**。
2. **编写测试用例**：
```java
    import org.openjdk.jmh.annotations.*;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.locks.ReentrantLock;
    
    @BenchmarkMode(Mode.Throughput) // 测试模式：吞吐量
    @OutputTimeUnit(TimeUnit.SECONDS) // 输出时间单位
    @State(Scope.Group) // 定义测试状态的作用范围
    public class LockBenchmark {
        private final ReentrantLock lock = new ReentrantLock();
        private long counter = 0;
        private AtomicLong atomicCounter = new AtomicLong(0);
    
        @Benchmark
        @Group("lock")
        public long testWithLock() {
            lock.lock();
            try {
                counter++;
                return counter;
            } finally {
                lock.unlock();
            }
        }
    
        @Benchmark
        @Group("atomic")
        public long testAtomic() {
            return atomicCounter.incrementAndGet();
        }
    }
    ```
3. **运行与解读**：通过JMH可以科学地比较`synchronized`、`ReentrantLock`和无锁方案在真实高并发环境下的吞吐量、平均耗时等指标，从而做出正确的技术选型。