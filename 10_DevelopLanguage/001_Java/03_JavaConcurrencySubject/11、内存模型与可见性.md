###### 1. 什么是 Java 内存模型（JMM）？
一个**规范/规则**，屏蔽硬件差异，保证 Java 程序在各种平台下内存访问的一致性。规定了线程如何通过主内存和工作内存的交互来访问变量。
Java 内存模型（JMM）是一种**抽象的规范**，它并不真实存在。它的核心目标是定义在多线程环境下，线程如何通过**主内存**（Main Memory）和**工作内存**（Working Memory）的交互来访问共享变量，从而在各种硬件和操作系统平台上提供一致的内存访问效果，解决由于不同平台内存访问差异可能引发的线程安全问题。
###### 2. JMM 中的主内存和工作内存是什么？
- **主内存**：存储所有的**共享变量**（实例字段、静态字段、数组元素）。所有线程都可以访问，是共享区域。
- **工作内存**：每个线程拥有**私有**的工作内存，存储该线程使用的共享变量的**副本**。线程对变量的所有操作（读、写）都必须先在工作内存中进行，不能直接操作主内存。
**注意**：JMM 的主内存和工作内存，与 JVM 运行时数据区的 Java 堆、栈是**不同层次的概念**。粗略对比，主内存主要对应堆中的对象实例数据，工作内存则对应虚拟机栈的部分区域，但从更底层看，主内存可对应硬件物理内存，工作内存则对应高速缓存和寄存器。
###### 3. 什么是内存可见性问题？什么是指令重排序？如何解决？
**内存可见性问题**根源在于：线程操作的是主内存变量的副本。若线程A修改了副本并未及时写回主内存，或线程B未及时从主内存刷新最新值，线程B就无法“看到”线程A的修改，从而可能操作过时数据。

**指令重排序**是为了提高性能，编译器和处理器可能会对指令进行重新排序，只要在**单线程**环境下结果不变。但在多线程环境下，指令重排序可能会破坏程序的预期执行顺序，导致问题。
JMM 提供了多种机制来解决可见性和重排序问题：
- **`volatile`关键字**：保证可见性（写立即刷新，读强制从主内存获取），并禁止指令重排序（通过插入内存屏障）。
- **`synchronized`关键字**：保证原子性、可见性（解锁前强制刷新到主内存）和有序性（使得代码块在多个线程之间是串行执行的）。
- **`final`关键字**：正确构造（无 this 引用逸出）下，保证 final 字段的可见性。
- **内存屏障**：CPU 指令，用于阻止特定类型的重排序，确保屏障前后指令的执行顺序。
- **happens-before 原则**：JMM 的核心规则，帮助程序员推理多线程环境下的操作顺序和可见性。
###### 5. 什么是 happens-before 原则？
happens-before 是 JMM 中定义的两个操作之间的偏序关系，用于描述**操作之间的可见性**​。如果操作 A happens-before 操作 B，那么 A 操作的结果对 B 操作是**可见的**。
常见的 happens-before 规则包括：
- **程序次序规则**：同一线程内，书写在前面的操作 happens-before 后面的操作。
- **管程锁定规则**：对一个锁的 unlock 操作 happens-before 后面对同一个锁的 lock 操作。
- **volatile 变量规则**：对一个 volatile 变量的写操作 happens-before 后面对这个变量的读操作。
- **线程启动规则**：Thread 对象的 start() 方法调用 happens-before 此线程的每一个动作。
- **线程终止规则**：线程中的所有操作都 happens-before 对此线程的终止检测（如 join() 方法返回）。
- **传递性**：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。
###### 6. final 关键字的内存语义是什么？
正确使用 `final`关键字可以提供特殊的内存可见性保证：
- 只要在构造函数中正确构造了对象（没有发生 this 引用逸出），那么在其他线程中看到的 final 字段的值，一定是它在构造函数中被初始化后的值，而不需要额外的同步。
- 在对象引用被正确发布后，其 final 字段的读取不需要同步就能保证可见性。
- JMM 禁止将 final 字段的写操作重排序到构造函数之外。
###### 7. 什么是伪共享？如何避免？
**伪共享**是影响多线程程序性能的一个“隐形杀手”。现代 CPU 从主内存加载数据到缓存时，不是按字节加载，而是以**缓存行**（通常 64 字节）为单位。如果两个无关的变量 X 和 Y 恰好位于同一个缓存行，且被两个不同的核心（线程）频繁读写，那么一个核心修改 X 会导致整个缓存行在所有核心的缓存中失效。即使另一个核心只关心 Y，它也不得不重新从主内存加载整个缓存行，造成巨大的性能损失。
**避免伪共享的方法**：
- **字节填充**：通过增加无用的字段，使变量独占一个缓存行。
- **使用 `@Contended`注解**（JDK 8+）：JVM 会自动进行缓存行填充。
###### 8. CPU 缓存一致性协议是什么？
**缓存一致性协议**（如 MESI）是硬件层面解决伪共享背后问题的机制。它通过定义缓存行的状态（修改、独占、共享、无效）和状态转换规则，来维护多核 CPU 缓存数据的一致性。