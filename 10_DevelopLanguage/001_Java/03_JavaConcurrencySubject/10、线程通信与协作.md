###### 1. 线程间通信的方式有哪些？
线程间通信主要解决**协调执行顺序**和**安全访问共享数据**两大问题。具体实现方式及其核心对比如下：

|通信机制|核心思想|关键类/关键字|适用场景|
|---|---|---|---|
|**等待/通知 (Wait/Notify)**​|线程在条件不满足时主动等待，条件满足时由其他线程通知唤醒。|`Object.wait()`, `Object.notify()`, `Object.notifyAll()`|经典的线程协作，如生产者-消费者模型。|
|**锁与条件变量 (Lock/Condition)**​|提供比 `synchronized`更灵活的锁机制，可关联多个条件队列，实现精细化的线程唤醒。|`Lock`, `Condition`(在 `java.util.concurrent.locks`包)|需要复杂线程协作的场景，如多条件触发的任务调度。|
|**同步工具类**​|提供高层抽象，封装了复杂的同步逻辑，直接实现特定协作模式。|`CountDownLatch`, `CyclicBarrier`, `Semaphore`, `Exchanger`等|特定协作模式（如倒计时、栅栏、信号量、数据交换）。|
|**线程安全容器**​|提供内置的线程安全数据容器，将通信细节封装于容器内部。|`BlockingQueue`, `ConcurrentHashMap`, `CopyOnWriteArrayList`等|生产者-消费者、共享数据缓存等场景，简化开发。|
|**ThreadLocal**​|为每个线程创建变量的独立副本，实现数据隔离，避免共享。|`ThreadLocal`|
###### 2. wait()、notify() 和 notifyAll() 的使用方法是什么？
这是最基础的线程协作机制，使用时需遵循特定模式。
- **`wait()`**：使**当前线程释放锁**并进入等待（WAITING）状态，直到被其他线程唤醒。
- **`notify()`**：**随机唤醒一个**在该对象上等待的单个线程。
- **`notifyAll()`**：**唤醒所有**在该对象上等待的线程。
**标准使用范式**：
```java
// 等待方 (Consumer)
synchronized (lockObject) { // 1. 获取锁
    while (!condition) { // 2. 循环检查条件（防止虚假唤醒）
        try {
            lockObject.wait(); // 3. 条件不满足，释放锁并等待
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // 恢复中断状态
        }
    }
    // 4. 条件满足，执行任务
}

// 通知方 (Producer)
synchronized (lockObject) { // 1. 获取锁
    changeCondition(); // 2. 改变条件
    lockObject.notifyAll(); // 3. 通知所有等待线程
}
```
**关键点**：
- **循环检查条件**：必须使用 `while`而非 `if`来检查条件，以应对**虚假唤醒**（线程未被通知也可被唤醒）。
- **同步块**：必须在 `synchronized`同步块或同步方法内调用这些方法。
###### 3. 为什么 wait() 和 notify() 必须在同步代码块中调用？
这是一个至关重要的设计约束，主要原因如下：
1. **保证原子性检查**：`wait()`调用本身涉及两个操作：**检查条件**和**进入等待**。如果没有锁保护，在线程检查条件为假后、即将调用 `wait()`前，另一个线程可能修改了条件并调用 `notify()`，导致信号丢失。而当前线程会依然调用 `wait()`并永久等待。同步块确保了检查条件和进入等待是原子操作。
2. **强制持有锁**：`wait()`方法需要**释放锁**，而 `notify()`需要**持有锁**才能进行通知。Java 强制要求线程在调用这些方法前必须先获得对象的监视器锁（通过 `synchronized`），否则会抛出 `IllegalMonitorStateException`。这保证了锁的释放和获取行为是确定且安全的。
###### 4. notify() 和 notifyAll() 的区别是什么？
| 特性        | `notify()`                            | `notifyAll()`                              |
| --------- | ------------------------------------- | ------------------------------------------ |
| **唤醒范围**​ | 随机唤醒**一个**等待线程。                       | 唤醒**所有**等待线程。                              |
| **确定性**​  | 不确定唤醒哪个线程。                            | 所有等待线程都会被唤醒，但需竞争锁。                         |
| **性能**​   | 只唤醒一个线程，**开销较小**。                     | 唤醒所有线程，可能导致**不必要的竞争和上下文切换**，开销较大。          |
| **风险**​   | 可能错误唤醒一个不满足执行条件的线程，导致**信号丢失**或**死锁**。 | 所有线程都有机会检查条件，**安全性更高**。                    |
| **选择建议**​ | 仅在**所有等待线程条件相同**（可互换）且**性能是首要考量**时考虑。 | **默认推荐使用**。尤其在等待条件可能不同或无法确定时，可避免信号丢失和死锁风险。 |
###### 5. 如何实现生产者-消费者模式？
这是一个经典用例，展示了如何用 `wait()`/`notifyAll()`协调不同速度的线程。
**使用 `wait()/notifyAll()`的实现**：
```java
public class SimpleMessageQueue {
    private final Queue<String> queue = new LinkedList<>();
    private final int maxSize;
    private final Object lock = new Object();

    public SimpleMessageQueue(int maxSize) {
        this.maxSize = maxSize;
    }

    // 生产者方法
    public void produce(String message) throws InterruptedException {
        synchronized (lock) {
            while (queue.size() == maxSize) {
                lock.wait(); // 队列满，生产者等待
            }
            queue.offer(message);
            System.out.println("Produced: " + message);
            lock.notifyAll(); // 通知可能正在等待的消费者
        }
    }

    // 消费者方法
    public String consume() throws InterruptedException {
        synchronized (lock) {
            while (queue.isEmpty()) {
                lock.wait(); // 队列空，消费者等待
            }
            String message = queue.poll();
            System.out.println("Consumed: " + message);
            lock.notifyAll(); // 通知可能正在等待的生产者
            return message;
        }
    }
}
```
**更优方案：使用 `BlockingQueue`**
在实际开发中，应优先使用 `java.util.concurrent`包中的 `BlockingQueue`（如 `LinkedBlockingQueue`或 `ArrayBlockingQueue`），它已内部完美实现了线程同步。
```java
BlockingQueue<String> queue = new LinkedBlockingQueue<>(10);
// 生产者线程
queue.put("Message"); // 阻塞式放入
// 消费者线程
String message = queue.take(); // 阻塞式取出
```
###### 6. ThreadLocal 的作用和实现原理是什么？
`ThreadLocal`并非用于线程间通信，而是通过**数据隔离**来避免共享变量引发的线程安全问题。
- **作用**：为每个使用该变量的线程提供一个独立的变量副本，每个线程只能访问和修改自己的副本，互不干扰。典型应用场景包括数据库连接、Session管理、传递上下文（如用户ID）等。
- **实现原理**：
    1. **数据结构**：每个 `Thread`对象内部都有一个 `ThreadLocalMap`类型的变量 `threadLocals`。这个Map的**Key**是 `ThreadLocal`对象本身（弱引用），**Value**是该线程设置的副本值。
    2. **数据存取**：当调用 `threadLocal.get()`或 `threadLocal.set(value)`时，会先获取当前线程的 `Thread`对象，然后找到其内部的 `ThreadLocalMap`，再以当前 `ThreadLocal`实例为Key进行读写操作。
- **内存泄漏风险与解决**：
    - **原因**：`ThreadLocalMap`的Key是弱引用，但Value是强引用。如果 `ThreadLocal`实例被回收，但线程未终止（如线程池中的线程），会导致Key为null，但Value仍存在，无法被访问也无法被回收，造成内存泄漏。
    - **防护**：
        1. **及时清理**：使用完 `ThreadLocal`后，务必调用其 `remove()`方法清除当前线程的Value。
        2. 尽量将 `ThreadLocal`声明为 `private static`，这既便于管理，也利于GC。