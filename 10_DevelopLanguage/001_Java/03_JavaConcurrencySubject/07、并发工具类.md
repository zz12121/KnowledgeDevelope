| 工具类                    | 核心作用                                 | 关键特性                 | 典型应用场景               |
| ---------------------- | ------------------------------------ | -------------------- | -------------------- |
| **CountDownLatch**​    | 让一个或多个线程**等待**其他一组线程完成操作后再执行。        | **一次性使用**，计数器不可重置。   | 主线程等待所有服务启动完成。       |
| **CyclicBarrier**​     | 让一组线程**互相等待**，直到所有线程都到达屏障点后，再一起继续执行。 | **可循环使用**，支持屏障动作和重置。 | 多阶段任务，如分步骤计算，最后合并结果。 |
| **Semaphore**​         | 控制同时访问特定资源的**线程数量**。                 | 支持公平/非公平策略，可用于流量控制。  | 数据库连接池限流、资源池管理。      |
| **Exchanger**​         | 用于两个线程之间**交换数据**。                    | 提供同步点，线程成对交换数据。      | 遗传算法中的数据交换，双人数据校对。   |
| **Phaser**​            | 更灵活、可重用的同步屏障，支持**动态注册/注销**线程。        | 分阶段同步，阶段数可动态控制。      | 复杂的多阶段并行计算任务。        |
| **CompletableFuture**​ | 用于**异步编程**，支持链式调用和组合多个异步任务。          | 非阻塞，功能强大，可组合Future。  | 异步RPC调用，流水线式异步任务处理。  |
###### 1. CountDownLatch 的作用和使用场景是什么？
**作用**：CountDownLatch 允许一个或多个线程等待另一组线程完成操作。其内部维护一个计数器，初始值在构造时设定。每个完成任务的线程调用 `countDown()`方法使计数器减1。调用 `await()`方法的线程会阻塞，直到计数器归零，此时等待的线程得以继续执行。
**核心用法**：
- **构造方法**：`CountDownLatch latch = new CountDownLatch(int N);`// 初始化计数器为 N
- **子线程完成任务时**：调用 `latch.countDown();`// 计数器减1
- **主线程等待时**：调用 `latch.await();`// 阻塞直到计数器为0
**使用场景**：
- **主线程等待所有子线程完成任务**：例如，程序启动时需要等待所有服务初始化完成。
- **并发测试**：确保所有线程准备就绪后同时开始执行任务。
- **最大等待时间**：使用 `await(long timeout, TimeUnit unit)`方法避免无限期等待，例如设置超时5秒，超时后主线程可处理未完成情况。
###### 2. CyclicBarrier 的作用和使用场景是什么？
**作用**：CyclicBarrier 让一组线程相互等待，当所有线程都到达屏障点后，屏障才打开，所有线程再继续执行。它支持重置，可以重复使用，适用于更复杂的多阶段任务同步。
**核心用法**：
- **构造方法**：可指定参与等待的线程数 `parties`，还可选择指定一个 `Runnable barrierAction`，当所有线程到达屏障后，此操作由最后一个进入屏障的线程执行，常用于执行汇总任务。
- **线程等待**：每个线程调用 `cyclicBarrier.await()`方法通知 CyclicBarrier 已到达屏障，随即被阻塞。
**使用场景**：
- **多阶段计算**：将复杂计算任务分解为多个独立子任务，由不同线程并行计算，在特定阶段点（屏障）同步，交换数据或进行阶段汇总，然后进入下一阶段。
- **模拟"人满发车"**：如多个玩家同时开始游戏回合。
###### 3. CountDownLatch 和 CyclicBarrier 的区别是什么？

###### 4. Semaphore 的作用和使用场景是什么？
**作用**：Semaphore 通过维护一组**许可证**来限制能同时访问某特定资源的线程数量，用于做流量控制或资源池化，防止资源被过度使用导致系统崩溃。
**核心概念**：
- **许可数量**：Semaphore 在构造时指定许可证的总数，例如 `new Semaphore(10)`表示允许最多10个线程同时访问。
- **获取许可**：线程执行操作前需调用 `semaphore.acquire()`获取许可。若无可用的许可，线程将被阻塞，直到有其他线程释放许可。
- **释放许可**：线程使用完资源后，必须调用 `semaphore.release()`释放许可，以便其他等待的线程可以使用。
**使用场景**：
- **数据库连接池**：限制同时获取连接的线程数。
- **限流器**：在高并发接口中，控制每秒处理的请求数量。
###### 5. Exchanger 的作用和使用场景是什么？
###### 6. Phaser 是什么？与 CyclicBarrier 有什么区别？
Phaser 是 JDK 7 引入的、功能更强大的同步屏障，可以看作是 CyclicBarrier 的增强版。
**与 CyclicBarrier 的区别**：
- **动态调整**：Phaser 允许在运行时**动态注册**新的参与线程或**注销**已有线程，而 CyclicBarrier 的参与线程数在构造时固定。
- **多阶段**：Phaser 明确支持多阶段（Phase），每个阶段的同步点称为一个相位（Phase），阶段数可以非常大，甚至动态控制。
- **分层结构**：支持树形结构，降低大规模并发下的同步开销。
**使用场景**：适用于复杂的、可分解的多阶段并行计算任务，且任务参与方可能动态变化的场景。
###### 7. CompletableFuture 的作用是什么？如何使用？
`CompletableFuture`实现了 `Future`接口，并提供了丰富的API来支持**非阻塞式**的、**可组合**的异步编程。
**核心优势**：
- **链式调用**：可以通过 `thenApply`, `thenAccept`, `thenRun`等方法将多个异步操作串联起来，形成一个流水线。
- **组合操作**：可以通过 `thenCompose`, `thenCombine`等方法将多个独立的 `CompletableFuture`组合起来，等待它们全部完成 (`allOf`) 或任意一个完成 (`anyOf`)。
- **异常处理**：提供了 `exceptionally`, `handle`等方法来优雅地处理链式调用中可能出现的异常，避免链式调用因异常而中断。
- **手动完成**：支持通过 `complete`方法手动设置完成结果，使测试和集成更灵活。
**使用示例**：
```java
// 模拟一个异步计算任务
CompletableFuture.supplyAsync(() -> "Hello") // 第一阶段：异步生成消息
    .thenApplyAsync(result -> result + " World") // 第二阶段：对上一步结果进行转换
    .thenAcceptAsync(System.out::println) // 第三阶段：消费最终结果
    .exceptionally(throwable -> { // 异常处理：如果上述任何阶段出现异常，在此捕获
        System.out.println("Error: " + throwable.getMessage());
        return null;
    });
```
###### 8. Future 和 CompletableFuture 的区别是什么？
###### 9. 如何实现异步任务的链式调用？
###### 10. CompletableFuture 的异常处理如何实现？