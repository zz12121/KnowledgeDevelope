###### 1. 常用的 JVM 参数有哪些？
这些参数用于控制 JVM 如何分配和管理内存，是调优的基石。

| 参数                           | 作用                          | 示例与说明                                                 |
| ---------------------------- | --------------------------- | ----------------------------------------------------- |
| **-Xms**​                    | 设置 **堆内存的初始大小**​。           | `-Xms2g`(设置为 2GB)。建议与 `-Xmx`设置相同，避免运行时动态调整带来性能波动。     |
| **-Xmx**​                    | 设置 **堆内存的最大大小**​。           | `-Xmx4g`(设置为 4GB)。不应超过可用物理内存，否则会触发系统交换，严重影响性能。        |
| **-Xmn**​                    | 设置 **新生代的大小**​。             | `-Xmn1g`。官方推荐约为整个堆大小的 1/4 到 1/3。                      |
| **-Xss**​                    | 设置 **每个线程的栈大小**​。           | `-Xss1m`。设置过小可能导致 `StackOverflowError`，过大则会限制可创建的线程数。 |
| **-XX:MetaspaceSize**​       | 设置 **元空间**​ 的初始容量 (JDK 8+)。 | `-XX:MetaspaceSize=256m`。触发 Full GC 的阈值。              |
| **-XX:MaxMetaspaceSize**​    | 设置 **元空间**​ 的最大容量 (JDK 8+)。 | `-XX:MaxMetaspaceSize=512m`。默认无限制，但受系统内存约束。           |
| **-XX:MaxDirectMemorySize**​ | 设置 **直接内存**（堆外内存）的最大容量。     | `-XX:MaxDirectMemorySize=1g`。默认与 `-Xmx`相等。            |

###### 3. 如何设置新生代和老年代的比例？
- **-XX:NewRatio**：控制新生代与老年代的比例。例如 `-XX:NewRatio=3`表示老年代:新生代 = 3:1，即新生代占堆的 1/4。
- **-XX:SurvivorRatio**：控制 Eden 区与一个 Survivor 区的比例。例如 `-XX:SurvivorRatio=8`表示 Eden:S0:S1 = 8:1:1。
###### 4. 什么是 -XX:+UseCompressedOops？什么是 -XX:+UseCompressedClassPointers？
指针压缩技术这是 64 位 JVM 上减少内存占用的重要技术。
- **-XX:+UseCompressedOops**：启用**普通对象指针压缩**。在 64 位系统中，一个引用指针原本占 8 字节，开启后压缩为 4 字节，显著节省堆内存。该参数在 JDK 6 之后默认开启。
- **-XX:+UseCompressedClassPointers**：启用**类指针压缩**。压缩对象头中指向类元数据的指针。**注意**：此参数依赖于 `UseCompressedOops`，必须在 `UseCompressedOops`开启时才能生效。
###### 6. 如何开启 GC 日志？
日志是分析 GC 行为和进行调优的根本依据。

| 参数                                   | 作用                                     |
| ------------------------------------ | -------------------------------------- |
| **-Xloggc:<file>**​                  | 指定 GC 日志文件的输出路径。                       |
| **-XX:+PrintGC**​                    | 输出简单的 GC 日志。                           |
| **-XX:+PrintGCDetails**​             | 输出**详细的 GC 日志**（包括各区内存变化、耗时等），这是分析的关键。 |
| **-XX:+PrintGCDateStamps**​          | 在 GC 日志中输出**日期时间戳**，便于定位。              |
| **-XX:+PrintGCTimeStamps**​          | 在 GC 日志中输出**相对于 JVM 启动的时间戳**​。         |
| **-XX:+HeapDumpOnOutOfMemoryError**​ | 在发生 **OOM 时自动生成堆转储文件**，用于事后分析内存泄漏。     |
| **-XX:HeapDumpPath=<path>**​         | 指定堆转储文件的生成路径。                          |

| 收集器              | 启用参数                      | 关键调优参数                                                                |
| ---------------- | ------------------------- | --------------------------------------------------------------------- |
| **Serial GC**​   | `-XX:+UseSerialGC`        | 适用于客户端或微服务场景。                                                         |
| **Parallel GC**​ | `-XX:+UseParallelGC`      | `-XX:ParallelGCThreads`（GC线程数）`,`-XX:MaxGCPauseMillis`（最大暂停时间目标）。     |
| **CMS GC**​      | `-XX:+UseConcMarkSweepGC` | `-XX:CMSInitiatingOccupancyFraction`（触发回收的老年代占用率）。                    |
| **G1 GC**​       | `-XX:+UseG1GC`            | `-XX:MaxGCPauseMillis`, `-XX:InitiatingHeapOccupancyPercent`（IHOP阈值）。 |
| **Z GC**​        | `-XX:+UseZGC`             | `-XX:MaxGCPauseMillis`。                                               |
###### 7. 如何分析 GC 日志？
开启详细 GC 日志后，可以使用专业的日志分析工具（如 **GCViewer**, **gceasy.io**）来可视化分析以下关键指标：
- **GC 频率与暂停时间**：Young GC 和 Full GC 发生的次数和平均/最大暂停时间。
- **内存回收效果**：每次 GC 后，各内存区域（Eden, Survivor, Old）的空间变化。
- **分配/提升速率**：应用分配内存的速率，以及对象从年轻代提升到老年代的速率。通过分析这些指标，可以判断当前内存设置是否合理，以及是否存在内存泄漏等问题。
###### 8. 什么是安全点（Safepoint）？
**安全点**：指在代码执行过程中，**线程的状态是确定的**，并且所有对象引用关系已知的点。JVM 在进行某些操作（如 GC 的根枚举）时，需要暂停所有用户线程（STW），这个暂停必须发生在安全点。循环末尾、方法调用后、异常抛出点等通常会设置安全点。
###### 9. 什么是安全区域（Safe Region）？
指**在一段代码片段中，引用关系不会发生变化**。在这个区域内的任意地方开始 GC 都是安全的。对于处于休眠或阻塞状态的线程，它们无法主动响应 JVM 的中断请求走到安全点，这些线程就位于安全区域内，GC 时可以忽略它们。
###### 10. 如何优化JVM的内存分配？
1. **合理设置堆大小**：`-Xms`和 `-Xmx`设置为相同值，避免堆震荡。初始堆大小建议为物理内存的 1/2 到 2/3，但需为系统和其他程序留出空间。
2. **优化新生代**：根据对象存活率调整新生代占比。**短期对象多**的应用可适当增大新生代（`-Xmn`）；**长期对象多**的应用可适当减小新生代，增大老年代。
3. **调整 Survivor 区**：通过 `-XX:SurvivorRatio`调整。观察 GC 日志中对象年龄分布，避免对象过早晋升到老年代。
4. **避免大对象**：可使用 `-XX:PretenureSizeThreshold`设置对象阈值，大于此值的对象直接在老年代分配，避免在新生代来回拷贝。
###### 11. 如何优化JVM的垃圾回收性能？
1. **选择合适的 GC**：根据应用特性（低延迟或高吞吐）和硬件资源选择垃圾收集器。
2. **目标暂停时间**：对 G1 或 ZGC，使用 `-XX:MaxGCPauseMillis`设置合理的停顿时间目标。设置过小会导致 GC 频率增高，反而降低吞吐量。
3. **GC 线程数**：通过 `-XX:ParallelGCThreads`设置并行 GC 的线程数，通常不应超过 CPU 核心数。
4. **降低 Full GC**：优化代码避免内存泄漏、合理设置堆大小和老年代 GC 触发阈值，是减少耗时严重的 Full GC 的关键。
###### 12. 如何监控JVM的运行状态？
- **命令行工具**：使用 `jps`查看 Java 进程，`jstat`查看内存和 GC 实时统计信息，`jstack`查看线程栈，`jmap`查看堆内存详情或生成堆转储。
- **图形化工具**：**JConsole**​ 和 **VisualVM**​ 是 JDK 自带的图形化监控工具，可以直观查看堆内存使用、线程、类加载等信息。
- **APM 工具**：生产环境可考虑使用 **Prometheus**​ + **Grafana**​ 等专业应用性能监控系统进行全方位监控和告警。
###### 13. 如何解决JVM内存泄漏问题？如何处理JVM的OOM问题？
1. **定位问题**：在启动参数中添加 `-XX:+HeapDumpOnOutOfMemoryError`和 `-XX:HeapDumpPath`，以便在 OOM 时自动生成堆转储文件。
2. **分析堆转储**：使用 **Eclipse Memory Analyzer Tool**​ 等工具分析转储文件，查找占用内存最大的对象和其 GC Roots 引用链，从而定位泄漏点。
3. **代码修复**：检查集合类使用、监听器或回调函数注册、单例模式等常见泄漏场景，确保无用对象能被正常回收。
###### 15. 如何处理JVM的Full GC问题？
频繁的 Full GC 通常由以下原因导致，需结合 GC 日志和堆转储分析：
- **老年代空间不足**：对象提升过快，可能是年轻代过小或 `-XX:MaxTenuringThreshold`设置过小。
- **内存泄漏**：对象无法被回收，老年代逐渐被填满。
- **显式调用 System.gc()**：可通过 `-XX:+DisableExplicitGC`禁用，但需确保第三方库不会依赖此调用。
- **元空间不足**：适当调大 `-XX:MaxMetaspaceSize`。