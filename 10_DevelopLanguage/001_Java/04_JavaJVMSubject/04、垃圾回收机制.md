###### 1. 什么是垃圾回收？
**垃圾回收**是一种自动内存管理机制，其核心目标是识别并释放程序中不再使用的对象所占用的内存，从而防止内存泄漏和内存溢出等问题，确保应用的稳定运行。
###### 2. 如何判断对象是否可以被回收？什么是引用计数法？什么是可达性分析算法？
- **引用计数法**：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1。任何时刻计数器为0的对象就是不可能再被使用的。但其**无法解决对象之间循环引用**的问题。
- **可达性分析算法**：这是Java主要采用的方法。它通过一系列称为 “GC Roots”​ 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，所走过的路径称为“引用链”。如果某个对象到GC Roots之间没有任何引用链相连，则证明此对象是不可能再被使用的，可以被回收
###### 5. 什么是 GC Roots？哪些对象可以作为 GC Roots？
根对象。
**GC Roots**包括以下几种类型的对象：
- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI（即通常所说的Native方法）引用的对象。
- 所有被同步锁（synchronized关键字）持有的对象。
###### 7. 什么是强引用、软引用、弱引用、虚引用？
|引用类型|被GC回收的时机|生存强度|应用场景|
|---|---|---|---|
|**强引用**​ (Strong Reference)|**永不回收**（只要强引用存在，即使抛出OOM）|最强|普通对象赋值，如 `Object obj = new Object();`|
|**软引用**​ (SoftReference)|在**内存不足，即将发生OOM之前**会被回收|次强|适用于对内存敏感的高速缓存|
|**弱引用**​ (WeakReference)|在**下一次GC发生时**，无论内存是否充足都会被回收|较弱|生命周期较短的对象，如 `WeakHashMap`的键|
|**虚引用**​ (PhantomReference)|无法通过它获取对象实例，其存在意义在于能在对象被回收时收到**系统通知**​|最弱|用于在对象被销毁后执行一些清理工作，通常与 `ReferenceQueue`联合使用|
###### 8. finalize() 方法的作用是什么？
`finalize()`方法是对象逃脱死亡命运的最后一次机会。当垃圾回收器发现没有引用链指向一个对象（即不可达）时，会先进行第一次标记，并判断是否有必要执行 `finalize()`方法（只有当对象未覆盖此方法或已被调用过，才会被视为“无需执行”）。如果被判定为有必要执行，该对象会被放入一个低优先级的队列，由JVM自动建立的Finalizer线程去执行其 `finalize()`方法。在这个方法中，对象可以通过重新与引用链上的任一对象建立关联（例如将自身赋值给某个类变量）来“自救”。成功自救后，在第二次标记时它会被移出“即将回收”的集合。需要注意的是，`finalize()`方法**只会被系统自动调用一次**，且运行代价高昂，不确定性大，**通常不推荐使用**。
###### 9. 什么是垃圾回收算法？
| 算法                        | 原理                                                                     | 优点                            | 缺点                              | 适用场景                         |
| ------------------------- | ---------------------------------------------------------------------- | ----------------------------- | ------------------------------- | ---------------------------- |
| **标记-清除**​ (Mark-Sweep)   | 1. **标记**：从GC Roots开始，标记所有存活对象。  <br>2. **清除**：遍历整个内存，回收未被标记的对象所占用的空间。 | 实现简单                          | 1. **产生内存碎片**  <br>2. **效率不高**​ | 老年代（如CMS收集器的并发回收阶段）          |
| **标记-复制**​ (Copying)      | 将可用内存分为大小相等的两块，每次只使用一块。当一块用完了，就将存活的对象**复制**到另一块上，然后清理已用的那块。            | 1. **无内存碎片**  <br>2. **效率高**​ | **浪费一半内存空间**​                   | 对象存活率低的新生代（如Eden区和Survivor区） |
| **标记-整理**​ (Mark-Compact) | 1. **标记**：同标记-清除。  <br>2. **整理**：让所有存活的对象都向内存的一端移动，然后直接清理掉边界以外的内存。     | **无内存碎片**​                    | 移动对象成本高，需要更新引用地址，**效率较低**​      | 对象存活率高的老年代                   |
| **分代收集**​ (Generational)  | 根据对象存活周期的不同，将Java堆划分为**新生代**和**老年代**，然后根据各自的特点采用不同的收集算法。               | 结合各算法优点，是**现代商用虚拟机的主流算法**​    | 实现相对复杂                          | Java堆内存管理                    |

###### 13. 分代收集理论是什么？
**分代收集理论**是当前主流垃圾收集器的基础。它建立在两个假说之上：1）绝大多数对象都是朝生夕死的（弱分代假说）；2）熬过越多次垃圾收集的对象就越难以消亡（强分代假说）。因此，Java堆被划分为新生代和老年代。
- **新生代 (Young Generation)**：存放新创建的对象。又分为一个**Eden**区和两个**Survivor**区（通常称为From和To）。新生代发生的GC称为 **Minor GC**，非常频繁，速度较快。
- **老年代 (Old Generation)**：存放经过多次Minor GC后仍然存活的对象。老年代发生的GC称为 **Major GC**，通常伴随着至少一次Minor GC。**Full GC**​ 则指清理整个堆空间（包括新生代和老年代以及方法区/元空间），速度慢，应尽量避免。
在垃圾回收过程中，为了确保对象引用关系不再变化，JVM需要暂停所有用户线程，这种现象称为 **Stop-The-World (STW)**。所有的垃圾收集器都无法完全避免STW，但优化的目标是尽可能缩短暂停时间。
###### 16. 有哪些垃圾收集器？
| 收集器                    | 目标区域 | 核心特点                               | 优点                         | 缺点                   | 适用场景                       |
| ---------------------- | ---- | ---------------------------------- | -------------------------- | -------------------- | -------------------------- |
| **Serial**​            | 新生代  | 单线程、复制算法、STW                       | 简单高效（单核CPU）、内存开销小          | 停顿时间长、多核CPU利用率低      | Client模式、单核CPU、小内存应用       |
| **ParNew**​            | 新生代  | Serial的多线程版、复制算法、STW               | 多核下停顿时间短、可与CMS配合           | 单核性能可能不如Serial、仍有STW | 多核Server端、与CMS搭配           |
| **Parallel Scavenge**​ | 新生代  | 多线程、吞吐量优先、支持自适应策略                  | 高吞吐量、自适应调节                 | 停顿时间目标不保证、交互体验一般     | 后台运算、批处理任务                 |
| **Serial Old**​        | 老年代  | Serial的老年代版、标记-整理算法、STW            | 实现简单、内存开销小                 | 停顿时间长、单线程效率低         | Client模式、CMS后备方案           |
| **Parallel Old**​      | 老年代  | Parallel Scavenge的老年代版、标记-整理算法、多线程 | 与Parallel Scavenge组成高吞吐量组合 | 停顿时间较长               | 与Parallel Scavenge搭配、注重吞吐量 |
| **CMS**​               | 老年代  | 并发收集、低停顿目标、标记-清除算法                 | 低停顿时间、用户体验好                | 产生内存碎片、对CPU敏感、有浮动垃圾  | B/S系统、重视响应速度               |
| **G1**​                | 整个堆  | 分区模型、可预测停顿、整体标记-整理、局部复制            | 停顿时间可控、高吞吐量、无内存碎片          | 内存占用稍高、小内存应用表现一般     | 大内存服务端、兼顾吞吐量和低延迟           |
- **Serial / ParNew / Parallel Scavenge (新生代，复制算法)**
    1. **暂停应用线程**​ (STW)。
    2. **标记**出Eden区和Survivor区（From Space）中存活的对象。
    3. 将存活对象**复制**到另一个Survivor区（To Space）。
    4. **清理**Eden区和已用的Survivor区。
    5. **恢复应用线程**。
- **Serial Old / Parallel Old (老年代，标记-整理算法)**
    1. **暂停应用线程**​ (STW)。
    2. **标记**出所有存活的对象。
    3. 将存活对象**整理**（向内存一端移动）。
    4. **清理**边界以外的内存。
    5. **恢复应用线程**。
- **CMS (老年代，标记-清除算法)**
    1. **初始标记**​ (STW)：标记GC Roots直接关联的对象，速度很快。
    2. **并发标记**：从GC Roots开始遍历对象图，与用户线程并发执行，耗时较长。
    3. **重新标记**​ (STW)：修正并发标记期间因用户程序运行而产生变动的标记记录。
    4. **并发清除**：清理垃圾对象，与用户线程并发执行。
###### 25. G1 的工作原理是什么？
**G1收集器**的工作流程可概括为：
1. **初始标记**：标记GC Roots能直接关联到的对象，需STW，但耗时短。
2. **并发标记**：从GC Roots开始进行可达性分析，找出存活对象，耗时较长，但可与用户线程并发执行。
3. **最终标记**：修正并发标记期间因用户程序运行而导致标记产生变动的记录，需STW。
4. **筛选回收**：首先对各个Region的回收价值和成本进行排序，根据用户期望的停顿时间来制定回收计划。然后将决定回收的Region中存活的对象**复制**到空的Region中，再清理整个旧的Region。这个过程需要STW。