###### 1. ArrayList 和 LinkedList 的区别是什么？
这两个类都实现了`List`接口，但底层数据结构的不同导致了性能和适用场景的显著差异。

| 特性           | ArrayList                    | LinkedList                     |
| ------------ | ---------------------------- | ------------------------------ |
| **底层数据结构**​  | 动态数组                         | 双向链表                           |
| **随机访问性能**​  | **极快 (O(1))**。基于索引直接定位，类似数组。 | **慢 (O(n))**。需要从链表头或尾开始遍历查找。   |
| **插入/删除性能**​ | **较差**。需移动后续元素（尾部添加快，中间插入慢）。 | **极快 (O(1))**。只需修改相邻节点的指针。     |
| **内存占用**​    | 较小。仅存储实际数据，内存连续。             | 较大。每个节点需存储数据和前后节点的引用。          |
| **额外功能**​    | 基础列表操作。                      | 实现了`Deque`接口，可轻松作为栈、队列或双端队列使用。 |

**小结**：**ArrayList 更适合随机访问密集（查询多）的场景，而 LinkedList 更适合频繁进行插入和删除操作的场景**​。
###### 2. ArrayList 和 Vector 的区别是什么？
尽管两者底层都是数组实现，但在线程安全性和性能上存在关键区别。

| 特性         | ArrayList         | Vector                                               |
| ---------- | ----------------- | ---------------------------------------------------- |
| **线程安全性**​ | **非线程安全**。性能更高。   | **线程安全**。其公共方法大多使用`synchronized`关键字修饰，但同步开销大，性能相对较低。 |
| **扩容策略**​  | 增长为原来的 **1.5倍**​。 | 默认增长为原来的 **2倍**（可通过构造参数设置扩容增量）。                      |
| **出现版本**​  | JDK 1.2。          | JDK 1.0。                                             |

**小结**：在现代Java开发中，由于Vector的同步开销较大，在**非线程安全**的场景下**ArrayList性能更优**。即便需要线程安全，也通常有更好的选择。
###### 3. ArrayList 的扩容机制是怎样的？ArrayList 的初始容量是多少？
ArrayList的核心优势在于其能够动态扩容，这背后有一套精巧的机制。
- **初始容量**：当使用无参构造函数 `new ArrayList()`时，底层数组初始化为一个**空数组**，并非直接创建容量为10的数组。真正的初始化在第一次添加元素时发生，容量会被设置为 **10**​。
- **触发扩容**：每当调用`add`方法时，会检查当前数组是否已满。如果已满，则会触发扩容。
- **扩容过程**：扩容的核心方法是 `grow()`。新容量的计算规则是：`新容量 = 旧容量 + (旧容量 >> 1)`，即大约增长为旧的 **1.5倍**​。如果计算后的新容量仍不足以容纳新元素，则直接使用所需的最小容量。新容量确定后，会调用 `Arrays.copyOf()`方法将原数组的数据复制到一个新大小的数组中，这是扩容过程中最耗时的操作。
**最佳实践**：如果能够预估数据量的大小，建议使用 `ArrayList(int initialCapacity)`构造函数指定初始容量，或者使用 `ensureCapacity(int minCapacity)`方法提前扩容，这样可以避免或减少后续添加元素时的多次扩容和数据复制，提升性能。
###### 4. 如何实现数组和 List 之间的转换？
- **数组 转 List**：
    - 使用 `Arrays.asList(T... a)`方法。但需要注意，返回的List并非 `java.util.ArrayList`，而是一个固定大小的视图，不支持添加(`add`)或删除(`remove`)操作，但可以修改元素。
    - 如果需要可变的List，可以这样创建：`new ArrayList<>(Arrays.asList(array))`。
- **List 转 数组**：
    - 使用 `List`的 `toArray()`方法。无参重载返回的是 `Object[]`类型。
    - 使用 `toArray(T[] a)`可以指定返回数组的类型，更常用。例如：`list.toArray(new String[0])`或 `list.toArray(new String[list.size()])`。
###### 5. ArrayList 和 LinkedList 的使用场景分别是什么？
- **优先使用 ArrayList**：在绝大多数情况下，由于ArrayList基于数组实现，具有出色的局部性原理，CPU缓存命中率高，因此**遍历和随机访问的效率极高**。它是目前**最常用、最通用**的List实现。
- **考虑使用 LinkedList**：
    - 当需要频繁在**列表的中部**进行插入和删除操作时。
    - 当需要将List当作**栈、队列或双端队列**使用时（因为它实现了`Deque`接口）。
###### 6. ArrayList 的线程安全问题如何解决？说说 CopyOnWriteArrayList 的原理和应用场景？
标准的ArrayList和LinkedList都是**非线程安全**的。在多线程环境下，如果多个线程同时修改一个ArrayList，可能会导致数据不一致或其他未定义行为。
解决方案主要有以下几种：
1. **使用 `Collections.synchronizedList(List<T> list)`**：
    - 该方法会返回一个同步包装器类，它使用同步块来保证方法级别的线程安全。
    - 性能有损耗，因为每个方法调用都需要获取锁。
2. **使用 `java.util.concurrent.CopyOnWriteArrayList`**：
    - **原理**：这是JUC包下提供的一个线程安全的List。其核心思想是 **"写时复制"​ 。每当需要修改列表（如add, set）时，它不会直接操作原数组，而是先将原数组完整地复制一份到一个新数组，然后在新数组上进行修改，修改完成后再将底层数组的引用指向新数组。读操作（如get）则完全无锁，直接在当前数组快照上进行。
    - **优点**：**适用于读多写少**的并发场景。因为读操作非常快，且不需要加锁，多个线程可以并发读而不会阻塞。
    - **缺点**：
        - **内存开销大**：每次写操作都会复制整个底层数组。
        - **数据最终一致性**：读操作可能无法立即读到最新写入的数据，因为它读取的是写操作开始前的数组快照。
###### 7. LinkedList 可以作为栈和队列使用吗？如何使用？
是的，**LinkedList 完全可以作为栈和队列使用**，这是因为它不仅实现了`List`接口，还实现了`Deque`（双端队列）接口。`Deque`接口提供了丰富的方法来模拟栈和队列的行为。
- **作为栈（LIFO，后进先出）**：
    - 入栈（压栈）：`push(e)`或 `addFirst(e)`
    - 出栈（弹栈）：`pop()`或 `removeFirst()`
    - 查看栈顶：`peek()`或 `peekFirst()`
- **作为队列（FIFO，先进先出）**：
    - 入队（队尾）：`add(e)`或 `offer(e)`
    - 出队（队首）：`remove()`或 `poll()`
    - 查看队首：`element()`或 `peek()`
由于LinkedList在两端（头尾）进行插入和删除操作的效率极高（O(1)），因此它非常适合用来实现栈和队列。
###### 8. subList 方法返回的是什么？使用时需要注意什么？
`List`的 `subList(int fromIndex, int toIndex)`方法返回的是原列表的一个**视图**（View），而非一个新的独立List对象。
这意味着：
- 对子列表的非结构性修改（如`set`方法）会反映到原列表上。
- 对原列表的结构性修改（如直接调用`add`, `remove`）会导致后续对子列表的任何操作（包括简单的遍历）抛出 `ConcurrentModificationException`异常。
**最佳实践**：如果你需要一份与原列表无关的副本，应该这样创建：`new ArrayList<>(originalList.subList(from, to))`。