###### 1. Collections 工具类的常用方法有哪些？
`java.util.Collections`是一个纯粹的工具类，无法实例化，其所有方法都是静态的。它主要提供以下几类操作：

|功能类别|核心方法|作用描述|
|---|---|---|
|**排序与洗牌**​|`sort(List<T> list)`, `sort(list, Comparator)`|对列表排序（自然序或定制序）|
||`reverse(List<?> list)`|反转列表中元素的顺序|
||`shuffle(List<?> list)`|随机打乱列表元素顺序（常用于测试或游戏）|
|**查找与极值**​|`binarySearch(List, key)`|在**已排序**的列表中使用二分法查找，效率高（O(log n)）|
||`max(Collection)`, `min(Collection)`|返回集合中的最大/最小元素（基于自然顺序或比较器）|
||`frequency(Collection, Object)`|统计指定元素在集合中出现的次数|
|**修改与替换**​|`swap(List, int i, int j)`|交换列表中指定位置的元素|
||`replaceAll(List<T> list, T oldVal, T newVal)`|将列表中所有出现的某一指定值替换为另一值|
||`fill(List<? super T> list, T obj)`|使用指定元素填充列表的所有位置（**注意：会覆盖原有元素**）|
|**线程安全包装**​|`synchronizedList/Set/Map(...)`|返回一个线程安全的集合包装器。**注意：迭代时仍需手动同步**​|
|**不可变包装**​|`unmodifiableList/Set/Map(...)`|返回一个只读的集合视图。任何修改操作都会抛出 `UnsupportedOperationException`|
|**特殊集合创建**​|`emptyList()/emptySet()/emptyMap()`|返回一个不可变的空集合实例，避免返回`null`，推荐作为空结果返回|
||`singleton(T o)`, `singletonList(T o)`, `singletonMap(K, V)`|返回一个包含且仅包含一个指定元素的不可变集合，避免创建集合的开销|
|**批量添加**​|`addAll(Collection<? super T> c, T... elements)`|将所有指定元素添加到指定 collection 中，比多次调用`add`更方便|

**使用示例：**
```java
// 排序与查找
List<Integer> numbers = new ArrayList<>(Arrays.asList(3, 1, 4, 1, 5));
Collections.sort(numbers); // 列表变为 [1, 1, 3, 4, 5]
int index = Collections.binarySearch(numbers, 4); // 返回 3
int count = Collections.frequency(numbers, 1); // 返回 2

// 创建不可变空集合和单元素集合（安全返回的好习惯）
public List<String> getData() {
    // ... 如果没数据，返回空集合而非null，避免调用方空指针
    return Collections.emptyList();
}
public Set<String> getDefaultConfig() {
    return Collections.singleton("default_value");
}
```
###### 2. 如何实现集合的浅拷贝和深拷贝？
- **浅拷贝**：只复制对象本身和其内部基本数据类型的值，对于引用类型字段，则只复制引用地址，而不复制引用的对象本身。因此，**原对象和拷贝对象中的引用字段将指向同一个子对象**​。
```java
    // 浅拷贝的几种实现方式
    List<String> original = new ArrayList<>(Arrays.asList("A", "B"));
    List<String> shallowCopy1 = new ArrayList<>(original); // 使用构造函数
    List<String> shallowCopy2 = (List<String>) ((ArrayList<String>) original).clone(); // 使用clone方法
    List<String> shallowCopy3 = original.stream().collect(Collectors.toList()); // 使用Stream API
    ```
修改`original`中的字符串（字符串是不可变对象，此处指替换为新的字符串）不会影响`shallowCopy`，但如果列表里存的是自定义对象，修改某个对象的属性，则所有拷贝中的这个对象都会变化。
- **深拷贝**：不仅复制对象本身，还会递归地复制其所有子对象。生成一个完全独立的副本，与原对象完全脱离关系。
 ```java
    // 深拷贝的实现方式（以List为例，元素类Person需实现Serializable接口）
    import java.io.*;
    
    public static <T extends Serializable> List<T> deepCopy(List<T> src) throws IOException, ClassNotFoundException {
        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
        ObjectOutputStream out = new ObjectOutputStream(byteOut);
        out.writeObject(src);
        ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());
        ObjectInputStream in = new ObjectInputStream(byteIn);
        @SuppressWarnings("unchecked")
        List<T> dest = (List<T>) in.readObject();
        return dest;
    }
    // 使用第三方库，如Apache Commons Lang
    // List<Person> deepCopy = SerializationUtils.clone(original);
    ```
**如何选择**：如果集合元素是不可变对象（如`String`, `Integer`），浅拷贝即可。如果元素是可变对象，且你希望副本的修改不影响原集合，则必须使用深拷贝。
###### 3. 如何实现集合的去重？
| 方法                 | 描述                                                                                                                | 是否保持顺序                               |
| ------------------ | ----------------------------------------------------------------------------------------------------------------- | ------------------------------------ |
| **利用 `Set`**​      | `Set<String> set = new HashSet<>(listWithDuplicates);`最常用、直接。`HashSet`不保证顺序，如需保持插入顺序，使用`LinkedHashSet`。           | `HashSet`: 否  <br>`LinkedHashSet`: 是 |
| **使用 Stream API**​ | `List<String> uniqueList = list.stream().distinct().collect(Collectors.toList());`代码简洁，是函数式编程风格，默认保持遇到顺序（通常是原顺序）。 | 是                                    |
| **循环判断**​          | 使用循环和`Collections.frequency`或`contains`方法判断，性能较差，不推荐大规模数据使用。                                                      | 是                                    |
###### 4. 如何实现两个集合的交集、并集、差集？
虽然`Collections`工具类没有直接提供这些运算的方法，但利用`Set`的特性可以轻松实现。以下示例均使用 `Set`，但思路也可用于其他集合类型。
```java
Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));

// 并集 (Union)
Set<Integer> union = new HashSet<>(set1);
union.addAll(set2); // union 包含 [1, 2, 3, 4, 5, 6]

// 交集 (Intersection)
Set<Integer> intersection = new HashSet<>(set1);
intersection.retainAll(set2); // intersection 包含 [3, 4]

// 差集 (Difference, 在set1中但不在set2中)
Set<Integer> difference = new HashSet<>(set1);
difference.removeAll(set2); // difference 包含 [1, 2]
```
对于`List`等，也可使用`retainAll`和`removeAll`，但需要注意重复元素和处理效率。
###### 5. Arrays.asList() 方法有什么注意事项？
这个方法是将数组转换为List的便捷方式，但有一些重要的限制：
1. **固定大小**：返回的列表是基于原数组的**视图**，是一个固定大小的列表。你不能对该列表进行**添加(`add`)或删除(`remove`)​ 操作，否则会抛出 `UnsupportedOperationException`。
2. **反映修改**：对返回列表的修改（如`set`方法）会**直接反映到原数组**上，因为它们共享存储。
3. **基本类型数组问题**：如果传入一个基本数据类型（如`int[]`）的数组，`Arrays.asList()`会将其视为单个元素，返回`List<int[]>`，而不是期望的`List<Integer>`。应使用包装类数组。
**正确使用示例：**
```java
String[] strArray = {"Hello", "World"};
List<String> list = Arrays.asList(strArray); // ok
// list.add("Java"); // 错误！不支持添加操作
list.set(0, "Hi"); // 正确，修改元素，同时strArray[0]也会变成"Hi"

// 对于基本类型数组，应使用如下方式
int[] intArray = {1, 2, 3};
List<Integer> realList = Arrays.stream(intArray).boxed().collect(Collectors.toList());
```
###### 6. 如何将集合转换为数组？
- **集合 → 数组**：使用 `toArray()`方法。
```java
    List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
    Object[] array1 = list.toArray(); // 返回 Object[] 类型，不常用
    
    String[] array2 = list.toArray(new String[0]); // 推荐方式，类型安全
    // 或者指定大小，避免分配新数组
    String[] array3 = list.toArray(new String[list.size()]);
    ```
- **数组 → 集合**：除了`Arrays.asList`，在Java 8+中更灵活的方式是使用Stream。
```java
    String[] array = {"A", "B", "C"};
    List<String> list1 = Arrays.asList(array); // 得到固定大小的列表
    List<String> list2 = new ArrayList<>(Arrays.asList(array)); // 得到一个可变的ArrayList
    List<String> list3 = Arrays.stream(array).collect(Collectors.toList()); // 使用Stream
    ```
###### 7. Stream API 对集合操作有什么优势？
Java 8 引入的 Stream API 为集合操作带来了革命性的变化，其核心优势包括：
- **声明式编程**：代码更简洁、易读。你只需说明"要做什么"（如`filter`, `map`, `collect`），而不是"如何做"（写循环和if条件）。
- **无缝并行**：只需将`stream()`改为`parallelStream()`，就能（在数据量大且操作耗时时）尝试利用多核优势，简化了并发编程的复杂性。
- **链式操作**：可以将多个中间操作（如`filter`, `map`, `sorted`）和一个终端操作（如`collect`, `forEach`）连接起来，形成流畅的管道（Pipeline），逻辑清晰。
- **优化潜力**：Stream API 在内部可能进行延迟执行、短路等优化，性能可能优于传统的循环。
**示例：找出一个列表中所有偶数，去重后转换为平方，并收集到新列表。
```java
// 传统方式
List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 4, 5);
Set<Integer> evenNumbers = new HashSet<>();
for (Integer num : numbers) {
    if (num % 2 == 0) {
        evenNumbers.add(num);
    }
}
List<Integer> squares = new ArrayList<>();
for (Integer even : evenNumbers) {
    squares.add(even * even);
}

// 使用Stream API
List<Integer> result = numbers.stream()
        .filter(n -> n % 2 == 0)
        .distinct()
        .map(n -> n * n)
        .collect(Collectors.toList());
```
###### 8. 如何遍历集合？各种方式的优缺点是什么？
|方式|优点|缺点|适用场景|
|---|---|---|---|
|**for循环（带索引）**​|效率高，可通过索引直接访问元素|不适用于所有`Collection`（如`Set`），只能用于`List`|需要知道元素索引时|
|**增强for循环**​|语法简洁，不易出错，适用于所有`Iterable`对象|遍历过程中不能直接修改集合结构（增删元素）|**大多数情况下首选**，简单遍历|
|**Iterator迭代器**​|安全地在遍历时**移除**当前元素（使用`iterator.remove()`）|语法相对增强for循环稍显复杂|**需要在遍历中删除元素**时|
|**forEach + Lambda**​|代码简洁，函数式风格|同增强for循环，不能修改结构|Java 8+，简单遍历，代码可读性高|
|**Stream API**​|支持链式操作、过滤、映射等复杂数据处理，可并行|对于简单遍历，开销稍大|需要进行复杂**数据加工、过滤、转换**时|

**示例：**
```java
List<String> list = Arrays.asList("A", "B", "C");

// 1. 增强for循环 (推荐)
for (String item : list) {
    System.out.println(item);
}

// 2. Iterator迭代器 (需删除元素时用)
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String item = iterator.next();
    if ("B".equals(item)) {
        iterator.remove(); // 安全删除
    }
}

// 3. forEach + Lambda (Java 8+)
list.forEach(item -> System.out.println(item));
// 或使用方法引用
list.forEach(System.out::println);
```