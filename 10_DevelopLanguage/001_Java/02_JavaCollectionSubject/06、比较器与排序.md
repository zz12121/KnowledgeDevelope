###### 1. Comparable 和 Comparator 接口的区别？
`Comparable`和 `Comparator`是 Java 中用于定义对象排序规则的两种接口，它们的设计目的和使用场景有本质区别。下面的表格清晰地展示了它们的核心差异：

|特性|Comparable|Comparator|
|---|---|---|
|**包名**​|`java.lang`|`java.util`|
|**核心方法**​|`compareTo(T o)`|`compare(T o1, T o2)`|
|**排序概念**​|**自然排序**​ (Natural Ordering)|**定制排序**​ (Custom Ordering)|
|**实现方式**​|在要排序的**类内部实现**接口|在要排序的**类外部创建**一个独立的比较器类|
|**排序逻辑**​|与类本身绑定，**只有一种**默认排序方式|与类解耦，可以为同一个类创建**多种**排序规则|
|**对类的影响**​|需要**修改类的源代码**​|**无需修改原类**，符合开闭原则|

**核心理解**：您可以将 `Comparable`理解为对象**与生俱来**的一种比较能力（如 `String`、`Integer`等类自身就实现了该接口）。而 `Comparator`则像是外部配备的一个**定制化比较工具**，可以根据不同场景的需要，为同一个对象提供多种不同的排序标准
###### 2. 如何对集合进行排序？
在实际开发中，对集合进行排序主要依赖于 `Collections.sort()`和 `List.sort()`方法，它们都支持通过 `Comparable`（自然排序）和 `Comparator`（定制排序）两种方式工作。
###### 3. 如何对自定义对象进行排序？
**1. 实现 Comparable 接口（自然排序）**
当您希望某个类的对象具备一种默认的、最常用的排序方式时，可以让该类实现 `Comparable`接口。例如，希望 `Person`对象默认按年龄排序：
```java
public class Person implements Comparable<Person> {
    private String name;
    private int age;

    // 构造方法、getter和setter省略

    @Override
    public int compareTo(Person other) {
        // 按年龄升序排列
        return Integer.compare(this.age, other.age);
    }
}

// 使用：直接调用sort即可，默认按年龄排序
List<Person> people = new ArrayList<>();
// ... 添加Person对象
Collections.sort(people); // 或 people.sort(null);
```
**2. 使用 Comparator 比较器（定制排序）**
当您无法修改类的源代码（例如第三方库的类），或者需要为同一个类提供多种排序规则时，`Comparator`是理想选择。您可以在排序时传入一个 `Comparator`实例。
```java
// 按姓名排序
public class NameComparator implements Comparator<Person> {
    @Override
    public int compare(Person p1, Person p2) {
        return p1.getName().compareTo(p2.getName());
    }
}

// 使用
List<Person> people = new ArrayList<>();
// ... 添加Person对象
Collections.sort(people, new NameComparator());

// 更简洁的方式：使用Lambda表达式（Java 8+）
Collections.sort(people, (p1, p2) -> p1.getName().compareTo(p2.getName()));
// 或者使用方法引用
Collections.sort(people, Comparator.comparing(Person::getName));

// 支持多重排序：先按年龄，年龄相同再按姓名
Collections.sort(people, Comparator
    .comparingInt(Person::getAge)
    .thenComparing(Person::getName));
```
**最佳实践建议**：
- 实现 `Comparable`接口时，强烈建议保证 `compareTo`方法与 `equals`方法的结果一致，即当 `x.compareTo(y) == 0`时，应有 `x.equals(y)`为 `true`。这对于使用 `SortedSet`和 `SortedMap`至关重要。
- 使用 `Comparator`时，可以利用 Java 8 提供的静态方法（如 `Comparator.comparing`、`Comparator.thenComparing`）来流畅地构建复杂的比较器链，代码更简洁。
###### 4. Collections.sort() 和 Arrays.sort() 的实现原理？
**1. `Arrays.sort()`**
- **用于对象数组**：当排序对象数组时，它使用了一种改进的排序算法——**TimSort**​。
- **TimSort 简介**：这是一种混合排序算法，由 Tim Peters 为 Python 设计，结合了**归并排序**​ 和**插入排序**​ 的优点。它善于处理真实世界中部分有序的数据集，能提供稳定的、高效的排序性能。
- **用于基本数据类型数组**：当排序基本数据类型（如 `int[]`, `double[]`）的数组时，它使用**双基准快速排序**。该算法是经典快速排序的高效变体，通常比传统单基准快排更快。
**2. `Collections.sort()`**
- 该方法底层实际上是先将 `List`转换为数组，然后调用 `Arrays.sort()`方法进行排序，排序完成后再将结果更新回原来的 `List`。因此，**`Collections.sort()`的底层核心也是 TimSort 算法**​。
**TimSort 核心步骤简析**：
1. **判断数据量**：如果数组元素少于某个阈值（如 32），则使用高效的**二分插入排序**。
2. 识别并扩展 **"run"**：遍历数组，寻找连续的、单调递增或严格递减的序列（称为一个 "run"）。对于短于最小长度（minrun）的 run，使用二分插入排序进行扩展，使其达到 minrun 长度，以保证后续合并的平衡性。
3. **合并 run**：将识别出的所有 run 放入一个栈中，并按照特定规则（保持栈内 run 的长度满足一定约束）合并相邻的 run，直到所有 run 合并成一个有序序列。
这种策略使得 TimSort 在最佳情况下（数组已基本有序）时间复杂度接近 O(n)，平均和最坏情况下为 O(n log n)，并且是**稳定排序**（相等元素的相对位置不变）。