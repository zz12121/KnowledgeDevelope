###### 1. Queue 接口的常用方法有哪些？
Java的`Queue`接口定义了队列的基本行为，其方法通常以成对的形式出现，分别对应不同的异常处理策略。

|操作类型|方法|功能描述|特殊情况处理|
|---|---|---|---|
|**添加元素**​|`add(e)`|插入元素到队列尾部，成功返回`true`|**队列已满时抛出 `IllegalStateException`**|
||`offer(e)`|插入元素到队列尾部，成功返回`true`|**队列已满时返回 `false`**|
|**移除元素**​|`remove()`|**移除并返回**队列头部的元素|**队列为空时抛出 `NoSuchElementException`**|
||`poll()`|**移除并返回**队列头部的元素|**队列为空时返回 `null`**|
|**检查元素**​|`element()`|**获取但不移除**队列头部的元素|**队列为空时抛出 `NoSuchElementException`**|
||`peek()`|**获取但不移除**队列头部的元素|**队列为空时返回 `null`**|

**最佳实践建议**：在不确定操作是否会失败时（例如，在容量受限的队列中插入元素），优先使用返回特殊值（如`offer(e)`, `poll()`, `peek()`）的方法，以避免不必要的异常处理，使代码更简洁。
###### 2. PriorityQueue 的实现原理是什么？
`PriorityQueue`是一个基于**优先级堆（通常是最小堆）的无界队列，元素出队的顺序由优先级决定，而非插入顺序。
- **底层结构**：基于一个动态数组（`Object[] queue`）来模拟一棵**完全二叉树**。这种结构可以利用数组下标快速定位父子节点：对于下标为`i`的节点，其父节点为`(i-1)/2`，左孩子为`2*i+1`，右孩子为`2*i+2`。
- **排序规则**：元素优先级可通过两种方式确定：
    1. **自然排序**：元素类实现`Comparable`接口。
    2. **定制排序**：在构造`PriorityQueue`时传入一个`Comparator`比较器。
- **核心操作（以最小堆为例）**：
    - **插入（`offer(e)`）**：新元素被放在数组末尾，然后执行**上浮（siftUp）操作，即不断与父节点比较，如果优先级更高（值更小），则与父节点交换，直到满足堆的性质。时间复杂度为O(log n)。
    - **取出队首（`poll()`）**：移除堆顶（数组第一个元素）后，将数组末尾元素移至堆顶，然后执行**下沉（siftDown）操作，即不断与优先级较高的那个子节点比较并交换，直到恢复堆的结构**。时间复杂度也为O(log n)。
`PriorityQueue`适用于需要按优先级处理任务的场景，如任务调度、求Top K问题等。需要注意的是，`PriorityQueue`的迭代遍历（`iterator()`）不保证按优先级顺序输出，只有通过`poll()`或`remove()`方法依次取出才能得到有序序列。
###### 3. ArrayDeque 和 LinkedList 作为队列有什么区别？
当被用作队列时，`ArrayDeque`和`LinkedList`都实现了`Deque`接口，但底层实现和性能特性有显著差异。

| 特性          | ArrayDeque                       | LinkedList                       |
| ----------- | -------------------------------- | -------------------------------- |
| **底层数据结构**​ | **动态扩容的数组**​                     | **双向链表**​                        |
| **性能特点**​   | 在大多数情况下作为栈或队列性能更优；内存连续，**缓存友好**。 | 每次插入/删除需要创建节点对象，内存开销相对较大。        |
| **内存占用**​   | 更紧凑，**通常更节省内存**。                 | 每个元素需要额外空间存储前后节点的引用。             |
| **功能特性**​   | **不允许插入`null`元素**。               | **允许插入`null`元素**。                |
|             | 随机访问效率低（O(n)）。                   | 实现了`List`接口，支持按索引随机访问（效率低，O(n)）。 |

**选择指南**：在**绝大多数单线程环境**下需要队列或栈功能时，**应优先选择`ArrayDeque`**，因为它通常能提供更优的性能和更低的内存占用。只有在需要同时使用`List`的按索引访问功能，或需要存储`null`值时，才考虑使用`LinkedList`。
###### 4. BlockingQueue 有哪些实现类？各有什么特点？
`BlockingQueue`是`java.util.concurrent`包中定义的接口，扩展了`Queue`，提供了**线程安全的阻塞操作**，是实现生产者-消费者模型的利器。

| 实现类                        | 核心特点                                                       | 适用场景                                             |
| -------------------------- | ---------------------------------------------------------- | ------------------------------------------------ |
| **ArrayBlockingQueue**​    | **有界**队列，基于数组。内部使用**单锁或分离锁（生产/消费）**，性能相对保守。                | 需要明确边界防止资源耗尽，对吞吐量要求不是极致的场景。                      |
| **LinkedBlockingQueue**​   | 默认是**无界**的（可指定容量），基于链表。通常采用**两把锁**，生产者和消费者操作分离，在高并发下吞吐量较好。 | 大多数生产者-消费者场景，特别是任务量波动大或通信数据量大的情况。                |
| **PriorityBlockingQueue**​ | **无界**的优先级阻塞队列。是`PriorityQueue`的线程安全版本，`take`操作会在队列为空时阻塞。  | 需要按优先级处理任务的并发场景。                                 |
| **SynchronousQueue**​      | **不存储元素**的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作，反之亦然。直接传递，**吞吐量很高**。 | 任务交接场景，如`Executors.newCachedThreadPool()`中的工作队列。 |
| **DelayQueue**​            | **无界**队列，元素必须实现`Delayed`接口。只有在元素指定的**延迟时间到达后**，才能从队列中取出。   | 定时任务调度、缓存过期失效、超时处理等。                             |
###### 5. ArrayBlockingQueue 和 LinkedBlockingQueue 的区别？
|特性|ArrayBlockingQueue|LinkedBlockingQueue|
|---|---|---|
|**底层存储**​|**数组**​|**链表**​|
|**队列边界**​|**有界**（构造时必须指定容量）|默认**无界**（`Integer.MAX_VALUE`），也可指定为有界|
|**锁机制**​|**单锁**（或可选的分离锁）|**两把锁**（`putLock`和`takeLock`）|
|**并发性能**​|生产者和消费者会竞争同一把锁|生产者和消费者通常可并行操作，**高并发下吞吐量可能更高**​|
|**内存预分配**​|初始化时分配固定大小的数组|动态创建节点，**每次插入都有额外内存开销**|
###### 6. DelayQueue 的应用场景是什么？
`DelayQueue`是一个非常有特色的阻塞队列，它封装了一个`PriorityQueue`，要求所有元素都必须实现`Delayed`接口，该接口定义了`long getDelay(TimeUnit unit)`方法。队列根据延迟时间排序，延迟时间最短（即最早到期）的元素排在队首。
其典型应用场景包括：
- **定时任务调度**：将需要延迟执行的任务（如`TimerTask`）放入队列，工作线程在任务的延迟时间到达后取出并执行。
- **缓存系统**：将缓存项及其过期时间放入`DelayQueue`，一个后台线程不断检查并移除过期的缓存项。
- **会话管理**：管理具有超时时间的用户会话，超时后自动清理。
- **限流与熔断**：在微服务架构中，可用于实现熔断器在超时后自动尝试恢复。
###### 7. ConcurrentLinkedQueue 和 LinkedBlockingQueue 的区别？

|特性|ConcurrentLinkedQueue|LinkedBlockingQueue|
|---|---|---|
|**类型**​|**无界**的非阻塞队列|可指定为**有界**或**无界**的**阻塞**队列|
|**锁与阻塞**​|基于**CAS无锁算法**，`poll()`和`offer()`等操作不会阻塞线程|使用**锁机制**，`put()`和`take()`方法在条件不满足时会阻塞线程|
|**适用场景**​|**高并发、高性能，且生产消费速度大致匹配**的场景|**典型的生产者-消费者模型**，需要阻塞来协调生产消费速度|
|**功能特性**​|不提供`size()`方法的强一致性保证（因为无锁，计数成本高）|提供阻塞API，能有效协调生产消费节奏，避免CPU空转|