###### 1. 说说 Java 中的并发集合有哪些？
Java的并发集合主要位于 `java.util.concurrent`包中，它们的设计目标是在保证线程安全的前提下，通过更精细的锁机制或无锁算法，最大限度地提升并发性能，其核心实现理念包括锁分离、无锁算法（如CAS）以及写时复制等。
下面的表格列出了主要的并发集合及其核心特点：

|集合类型|实现类|核心特点|典型应用场景|
|---|---|---|---|
|**并发Map**​|`ConcurrentHashMap`|高并发键值对存储，JDK 1.8后采用`synchronized`+ `CAS`+ **红黑树**优化|缓存、共享配置、计数器|
|**并发Queue**​|`ArrayBlockingQueue`|**有界**的基于数组的阻塞队列，内部使用可重入锁和条件变量|生产者-消费者模型（任务大小相对固定）|
||`LinkedBlockingQueue`|基于链表的**可选有界**阻塞队列，采用**两把锁**，吞吐量通常较高|生产者-消费者模型（通用）|
||`ConcurrentLinkedQueue`|基于链表的**无界非阻塞**队列，采用**CAS**实现|高并发、非阻塞的任务调度|
||`SynchronousQueue`|**不存储元素**，每个插入操作必须等待对应的移除操作|直接的任务传递（线程池）|
|**并发List**​|`CopyOnWriteArrayList`|**写时复制**，读操作完全无锁，**弱一致性**迭代器|**读多写少**的极致场景（监听器列表、黑白名单）|
|**并发Set**​|`CopyOnWriteArraySet`|内部基于`CopyOnWriteArrayList`实现|读多写少的集合场景|
||`ConcurrentSkipListSet`|基于跳表实现的有序并发Set|需要有序且线程安全的集合|
###### 2. CopyOnWriteArrayList 的原理和应用场景？
`CopyOnWriteArrayList`的实现策略是 **“写时复制”​。
- **核心原理**：所有写操作（如 `add`, `set`, `remove`）都会获取一把**可重入锁**，接着将底层数组完整复制一份，然后在**新数组**上进行修改。修改完成后，再将原数组的引用指向新数组。由于用于读操作的数组引用被 `volatile`关键字修饰，这个更新对所有读线程是立即可见的。
- **读操作**：所有的读操作（如 `get`）**完全无锁**，直接访问当前数组。因此，在存在写操作的情况下，读操作可能读取到的是旧数据，其迭代器也具有**弱一致性**。
- **优缺点与场景**：
    - **优点**：在**读操作远多于写操作**的场景下，读性能极高。
    - **缺点**：**内存占用大**（写操作会复制整个数组）；**数据实时性弱**，无法保证读到最新数据。
    - **适用场景**：适用于**读多写极少**且对数据实时性要求不高的场景，例如**事件监听器列表**、系统配置项或黑白名单的存储。
###### 3. ConcurrentHashMap 的原理？
`ConcurrentHashMap`是线程安全HashMap的高性能实现，其在JDK 1.7和1.8中有重大演进。
- **JDK 1.7：分段锁时代**
    采用**分段锁**机制。容器内包含一个 `Segment`数组，每个 `Segment`类似于一个小的 `HashMap`，并继承自 `ReentrantLock`。当线程修改数据时，只需锁住对应的 `Segment`，其他 `Segment`仍可被并发访问。这降低了锁的粒度，提升了并发度。
- **JDK 1.8及以后：`synchronized`+ CAS + 红黑树**
    放弃了 `Segment`，转而采用更细粒度的锁策略。
    - **锁粒度细化**：直接对数组中的每个桶（桶的首个节点）进行加锁（使用 `synchronized`关键字）。
    - **CAS无锁化**：在插入元素等操作中，大量使用**CAS操作**进行无锁化尝试，进一步减少线程阻塞。
    - **结构优化**：当链表长度超过阈值（默认8）且数组容量达到一定值（默认64）时，链表会转换为**红黑树**，以防止在极端哈希冲突下性能退化。查询时间复杂度从O(n)提升到O(log n)。
###### 4. 如何选择合适的并发集合？
选择合适的并发集合取决于具体的应用场景和需求。您可以参考以下指南：

| 需求场景             | 推荐容器                                          | 理由               |
| ---------------- | --------------------------------------------- | ---------------- |
| **高频键值存取**​      | `ConcurrentHashMap`                           | 高并发、低延迟，全能选手。    |
| **有序的键值存取**​     | `ConcurrentSkipListMap`                       | 线程安全且按键有序。       |
| **生产者-消费者模式**​   | `ArrayBlockingQueue`/ `LinkedBlockingQueue`   | 天然的阻塞特性，完美适配。    |
| **直接任务传递（高吞吐）**​ | `SynchronousQueue`                            | 不存储元素，直接传递，吞吐量高。 |
| **极高的读频率，极少写**​  | `CopyOnWriteArrayList`/ `CopyOnWriteArraySet` | 读操作无锁，性能极佳。      |
| **高性能非阻塞队列**​    | `ConcurrentLinkedQueue`                       | CAS实现，避免锁开销。     |

**重要原则**：优先使用JUC并发容器，而不是用 `Collections.synchronizedXXX()`来包装普通的非线程安全集合。
###### 5. 为什么不推荐使用 Vector 和 Hashtable？
`Vector`和 `Hashtable`是Java早期的线程安全集合类，它们通过在几乎所有方法上添加 `synchronized`关键字来实现线程安全。这种方式虽然保证了线程安全，但是一种**粗粒度的锁策略**，导致每次只允许一个线程访问集合，严重限制了并发性能。在高并发场景下，这种同步开销巨大，性能远低于JUC包中的并发集合（如 `ConcurrentHashMap`）。
###### 6. Collections.synchronizedXXX 方法的原理是什么？
`Collections.synchronizedList(List<T> list)`等方法是一种**装饰器模式**的应用。它们会返回一个包装类，这个包装类内部持有一个原始的集合对象（如 `ArrayList`），并且在其所有方法上使用 **`synchronized`关键字**进行同步，通常是在**方法级别**或使用一个**公共的互斥锁对象**进行同步块包装。
这种实现确实能保证线程安全，但其本质是一种**粗粒度锁**，性能上通常不如专门设计的JUC并发集合。它适用于并发访问量不高的场景，或者需要将现有非线程安全集合快速转换为线程安全版本的情况。