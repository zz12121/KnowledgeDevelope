###### 1. Redis 的过期键删除策略有哪些?
Redis采用**惰性删除**和**定期删除**相结合的过期键清理策略，两者协同工作，在合理使用CPU时间和避免内存浪费之间取得平衡。

|策略|触发机制|优点|缺点|在Redis中的地位|
|---|---|---|---|---|
|**定时删除**​|设置键过期时间时创建定时器，到期立即删除|内存友好，及时释放空间|CPU不友好，大量定时器影响性能|**未采用**|
|**惰性删除**​|访问键时检查并删除过期键|CPU友好，只在必要时触发|内存不友好，可能导致内存泄漏|**核心策略之一**|
|**定期删除**​|周期性随机扫描并删除过期键|平衡CPU和内存使用|难以确定执行时长和频率|**核心策略之一**|
**Redis的选择**：Redis服务器实际使用的是**惰性删除**和**定期删除**这两种策略的配合。通过配合使用这两种删除策略，服务器可以很好地合理使用CPU时间和避免浪费内存空间之间取得平衡。
###### 2. 什么是惰性删除?
惰性删除是一种**被动清理**策略。其核心原理是：只有在客户端**访问某个键**时，Redis才会顺带检查这个键是否过期。如果过期，则删除它，并给客户端返回空值；如果未过期，则正常返回键值。
**源码实现**：
惰性删除的核心逻辑由 `db.c`文件中的 `expireIfNeeded`函数实现。所有读写数据库的Redis命令（如 `GET`, `HGET`, `SET`）在执行前都会调用此函数对输入的键进行检查。
```c
// 简化后的核心逻辑
int expireIfNeeded(redisDb *db, robj *key) {
    if (!keyIsExpired(db,key)) return 0; // 键未过期，直接返回0
    // ... (从库相关逻辑处理)
    
    // 键已过期，执行删除
    server.stat_expiredkeys++; // 过期键计数器+1
    // 根据 `lazyfree-lazy-expire` 配置决定同步还是异步删除
    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key);
}
```
**优缺点分析**：
- **优点**：对CPU时间最友好，因为删除操作只会在访问时进行，不会创建额外的性能开销。
- **缺点**：对内存最不友好。如果一个键已经过期，但永远不再被访问，那么它将一直占用内存，相当于一种内存泄漏。
###### 3. 什么是定期删除?
定期删除是一种**主动清理**策略。Redis会**周期性**地执行一个任务，随机地从一部分数据库中检查一部分键，并删除其中已过期的键。
**源码实现**：
定期删除的核心逻辑由 `expire.c`文件中的 `activeExpireCycle`函数实现。该函数由Redis的周期性任务函数 `serverCron`调用。
其工作流程可以简化为以下步骤：
1. **遍历数据库**：默认每次检查最多16个数据库（由 `REDIS_DBCRON_DBS_PER_CALL`定义）。
2. **随机抽样**：从每个数据库的过期字典（`expires`）中**随机**抽取20个键（默认值，由 `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP`定义）。
3. 删除所有抽样中已过期的键。
4. **自适应调整**：如果在一轮抽样中，发现过期键的比例**超过25%**，则重复步骤2和3，直到过期键比例低于25%或执行时间达到上限。
**执行时间控制**：
为了防止定期删除占用过多CPU，该过程有严格的时间限制。
- **正常模式**（`ACTIVE_EXPIRE_CYCLE_SLOW`）：默认每次执行时间不超过 `25ms`（由 `ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC`等参数计算）。
- **快模式**（`ACTIVE_EXPIRE_CYCLE_FAST`）：执行时间更短，用于快速清理。
**配置调整**：
- 可以通过修改 `redis.conf`中的 `hz`参数来调整每秒执行定期删除的频率（默认10，即每秒10次）。
###### 4. Redis 的内存淘汰策略有哪些?
当Redis使用的内存达到配置的最大值 `maxmemory`时，会根据设定的淘汰策略删除键以释放空间。
以下是Redis支持的策略：

|策略|应用范围|机制|适用场景|
|---|---|---|---|
|`noeviction`|所有键|**默认策略**。新写入命令会报错，读、删除命令正常。|保证数据不丢失，需确保内存充足。|
|`allkeys-lru`|所有键|淘汰**最近最久未使用**的键。|热点数据分布较为平均，无法预测访问模式的场景。|
|`volatile-lru`|带过期时间的键|从设置了过期时间的键中淘汰**最近最久未使用**的键。|需要淘汰数据，但希望保留部分持久键。|
|`allkeys-random`|所有键|**随机**淘汰任意键。|数据访问概率相等，无热点。|
|`volatile-random`|带过期时间的键|从设置了过期时间的键中**随机**淘汰。|同`volatile-lru`，但不需要LRU的精度。|
|`volatile-ttl`|带过期时间的键|淘汰**剩余存活时间最短**的键。|希望通过过期时间层级来管理数据。|
|`allkeys-lfu`|所有键|淘汰**最不经常使用**的键（根据访问频率）。|存在明确的热点数据，希望长期保留高频访问数据。|
|`volatile-lfu`|带过期时间的键|从设置了过期时间的键中淘汰**最不经常使用**的键。|需要淘汰数据，但希望保留部分持久键，且存在热点。|
**配置方法**：
在 `redis.conf`文件中设置：
```
maxmemory 2gb
maxmemory-policy allkeys-lru
```
或运行时动态配置：
```
CONFIG SET maxmemory-policy volatile-lfu
```
###### 5. LRU 和 LFU 算法的区别是什么?
LRU和LFU是两种常用的缓存淘汰算法，Redis在实现时都采用了**近似算法**以节省内存。

|特征|LRU（最近最少使用）|LFU（最不经常使用）|
|---|---|---|
|**核心思想**​|淘汰**最久没有被访问**的键|淘汰**访问频率最低**的键|
|**关注点**​|访问的**时间距离**（何时访问）|访问的**频率次数**（访问多少次）|
|**Redis实现**​|每个键记录最近一次访问的时间戳（精度受限）|每个键记录一个访问计数器，会随时间衰减|
|**适用场景**​|最近的访问行为更能预测未来需求（如新闻首页）|存在长期稳定热点数据的场景（如商品热门榜单）|
**举例**：
- 一个键可能在1小时前被频繁访问，但最近5分钟没有被访问（LRU可能会保留）。
- 一个键在最近1分钟内被偶然访问了10次，而另一个键在过去一天内被规律性地访问了100次（LFU会更倾向于淘汰前者）。
###### 6. Redis 如何设置过期时间?
Redis提供了多种命令为键设置过期时间（Time To Live, TTL）。

|命令|语法|说明|示例|
|---|---|---|---|
|`EXPIRE`|`EXPIRE key seconds`|为键设置过期时间，单位**秒**。|`EXPIRE user:123 3600`（1小时后过期）|
|`PEXPIRE`|`PEXPIRE key milliseconds`|为键设置过期时间，单位**毫秒**。|`PEXPIRE session:abc 1500`（1.5秒后过期）|
|`EXPIREAT`|`EXPIREAT key timestamp`|设置键在指定的**UNIX时间戳**（秒级）过期。|`EXPIREAT job:xyz 1893456000`|
|`PEXPIREAT`|`PEXPIREAT key timestamp`|设置键在指定的**UNIX时间戳**（毫秒级）过期。|`PEXPIREAT lock:data 1893456000000`|
|`SETEX`|`SETEX key seconds value`|**设置字符串键值并同时指定过期时间（秒）**，原子操作。|`SETEX cache:item 60 "some_data"`|
**查看和删除过期时间**：
- `TTL key`：查看键的剩余生存时间（秒），返回-2表示键不存在，-1表示键存在但没有设置过期时间。
- `PTTL key`：查看键的剩余生存时间（毫秒）。
- `PERSIST key`：移除键的过期时间，使其成为永久键。
###### 7. Redis 内存满了会怎样?
当Redis使用的内存达到 `maxmemory`限制时，其行为完全由配置的 `maxmemory-policy`决定。
1. **触发内存淘汰**：当客户端执行一个可能导致内存增加的命令（如 `SET`, `LPUSH`）时，Redis会检查内存使用情况。如果超过 `maxmemory`，就会**触发内存淘汰流程**。
2. **根据策略淘汰数据**：Redis会按照配置的策略（如 `allkeys-lru`）执行删除键的操作，直到释放出足够的内存来执行新命令。
3. **策略执行结果**：
    - 如果淘汰策略成功删除了足够的键，新命令正常执行。
    - 如果策略是 `noeviction`，或者在某些策略下没有键可以淘汰（如 `volatile-lru`但没有任何键设置过期时间），Redis会向执行写操作的客户端返回一个 **`OOM command not allowed when used memory > 'maxmemory'.`（内存溢出）错误**。
**重要提示**：内存淘汰是**被动触发**的，只有在尝试写入新数据时才会发生。因此，即使内存使用率达到100%，已有的数据也不会被自动清除，直到有新的写入命令到来。
###### 8. 如何查看 Redis 的内存使用情况?
Redis提供了丰富的命令来监控内存状态。
**核心命令**：
1. **`INFO memory`**：这是最全面的命令，会返回大量内存相关指标。
    - `used_memory`：Redis实际分配的内存总量（字节）。
    - `used_memory_human`：以人类可读格式（如`1.23M`）显示的内存总量。
    - `used_memory_rss`：Redis进程从操作系统角度占用的内存（常驻集大小）。
    - `used_memory_peak`：Redis内存使用的峰值。
    - `maxmemory`：配置的内存最大限制。
    - `mem_fragmentation_ratio`：内存碎片比率（`used_memory_rss / used_memory`），大于1表示有碎片。
2. **`redis-cli --stat`**：可以实时查看内存使用等统计信息的变化。
3. **`CONFIG GET maxmemory`**：查看当前设置的最大内存限制。
4. **`CONFIG GET maxmemory-policy`**：查看当前设置的内存淘汰策略。