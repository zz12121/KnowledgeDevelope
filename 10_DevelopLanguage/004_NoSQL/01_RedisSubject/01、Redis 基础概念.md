###### 1. 你觉得 Redis 是什么?
Redis是一个**开源的内存数据结构存储系统**，核心价值在于提供高性能的键值存储与多种数据结构操作能力。从架构视角看，它超越了简单缓存，可作为数据库、缓存、消息中间件使用。
**核心定位与设计哲学**：
- **内存优先架构**：数据主要存储在内存中，读写操作直接操作内存数据结构，这是高性能的根本。
- **数据持久化支持**：通过RDB快照和AOF日志两种方式将内存数据持久化到磁盘，保证数据安全。
- **键值存储模型**：键是字符串，值支持多种数据结构（字符串、哈希、列表等），操作语义由值的数据类型决定。
**源码视角**：在Redis源码中，所有数据存储在全局的`redisDb`结构中，其核心是哈希表，用于存储键到值的映射。值的底层通过`redisObject`结构体表示，其`type`字段标识具体数据类型（如`REDIS_STRING`、`REDIS_LIST`），`ptr`指针指向存储该数据类型的实际数据结构（如SDS、字典、跳跃表等）。
###### 2. Redis 有哪些主要特点?

|特性|核心描述|技术价值|
|---|---|---|
|**高性能**​|内存操作，读写速度可达10万+/秒|支撑高并发场景|
|**数据结构丰富**​|支持字符串、哈希、列表、集合、有序集合等|直接映射业务模型，减少开发复杂度|
|**持久化**​|提供RDB（快照）和AOF（日志）两种方式|数据可靠性保障|
|**高可用**​|支持主从复制、哨兵模式（Sentinel）、集群模式（Cluster）|满足生产环境高可用需求|
|**原子性**​|所有操作是原子性的，支持事务（MULTI/EXEC）|简化并发编程模型|
|**功能扩展**​|支持发布/订阅、Lua脚本、键过期等特性|适用更多业务场景|
**源码角度（持久化举例）**：RDB持久化通过`rdbSave`函数实现，它遍历数据库，将每个键值对按特定格式序列化到磁盘。AOF持久化则在`propagate`函数中，将写命令追加到AOF缓冲区，根据`appendfsync`配置（always/everysec/no）决定刷盘策略。
###### 3. Redis 和 Memcached 有什么区别?

|维度|Redis|Memcached|
|---|---|---|
|**数据类型**​|支持字符串、哈希、列表、集合、有序集合等复杂类型|仅支持简单的字符串键值对|
|**持久化**​|支持RDB和AOF两种持久化机制|不提供持久化，数据纯在内存|
|**架构模型**​|单线程（6.0前）处理命令，避免上下文切换|多线程模型，可利用多核|
|**内存管理**​|提供多种淘汰策略，支持内存优化数据结构|使用LRU算法，内存管理相对简单|
|**功能特性**​|支持发布订阅、事务、Lua脚本等高级功能|功能聚焦于缓存，相对简单|
|**数据大小**​|值最大支持512MB|单个值通常限制在1MB|
**选择建议**：需要复杂数据结构、持久化或高级功能（如发布订阅）选Redis；纯缓存场景，值较小且无需持久化可考虑Memcached。
###### 4. Redis 支持哪些数据类型?

|数据类型|底层实现（源码关键）|常用命令示例|典型应用场景|
|---|---|---|---|
|**String**​|简单动态字符串（SDS）|`SET/GET/INCR`|缓存、计数器、分布式锁|
|**Hash**​|字典（哈希表）|`HSET/HGET/HGETALL`|存储对象（如用户信息）|
|**List**​|快速链表（quicklist）|`LPUSH/RPOP/LRANGE`|消息队列、最新列表|
|**Set**​|字典（哈希表）或整数集合|`SADD/SMEMBERS/SINTER`|标签、好友关系、去重|
|**Sorted Set**​|跳跃表（skiplist）和字典|`ZADD/ZRANGE/ZREVRANK`|排行榜、延迟队列|
|**BitMap**​|String类型的位操作|`SETBIT/GETBIT/BITCOUNT`|用户签到、活跃统计|
|**HyperLogLog**​|稀疏矩阵编码|`PFADD/PFCOUNT`|大数据量去重统计|
**源码角度（Sorted Set实现）**：有序集合同时使用跳跃表和字典。跳跃表支持范围查询（`ZRANGE`），字典支持按成员快速查找分数（`ZSCORE`）。这种双重结构以空间换时间，确保各操作高效。
###### 5. Redis 为什么这么快?
**核心原因分析**：
1. **内存存储**：数据存储在内存，直接操作内存数据结构，避免磁盘I/O瓶颈。
2. **单线程模型（6.0前）**：处理命令的核心模块是单线程，避免了多线程的上下文切换和锁竞争开销。虽然单线程，但通过**I/O多路复用**（epoll/kqueue）处理大量并发连接。
3. **高效数据结构**：如SDS、字典、跳跃表等均经过优化，时间复杂度低。
4. **优化网络I/O**：I/O多路复用技术使单个线程能高效处理多个网络连接请求。
**源码角度（事件循环）**：Redis启动后进入`aeMain`函数的事件循环（`ae.c`）。它通过`aeApiPoll`（封装epoll等）监听所有套接字的事件（读/写）。当客户端命令到达，文件事件处理器将命令读入缓冲区，解析后调用对应命令函数（如`setCommand`）执行，最后将结果写回客户端。整个过程在单线程内顺序执行，高效且无锁。
###### 6. Redis 的应用场景有哪些?

|场景|实现方式|技术要点|
|---|---|---|
|**缓存**​|将数据库查询结果、热点数据存入Redis|设置过期时间，避免缓存穿透/击穿/雪崩|
|**会话存储**​|将用户Session集中存储到Redis|实现分布式Session管理|
|**消息队列**​|使用List的LPUSH/BRPOP或Streams|实现简单的生产消费模型|
|**排行榜**​|使用Sorted Set，分数作为排名依据|`ZADD`更新分数，`ZREVRANGE`获取TopN|
|**分布式锁**​|使用SET命令的NX/PX选项|保证原子性：`SET lock_key unique_value NX PX 30000`|
|**实时统计**​|使用HyperLogLog、BitMap|统计UV、PV，存储用户签到|
###### 7. Redis 是单线程还是多线程?
**经典版本（6.0前）**：**网络I/O和命令处理是单线程**。这里的"单线程"主要指其核心的**命令处理逻辑**（包括读取命令、解析、执行、返回结果）由一个主线程顺序执行。
**多线程任务**：Redis并非所有任务都是单线程。持久化（RDB快照生成、AOF重写）、异步删除（`UNLINK`命令）、集群同步等操作会由**后台线程或子进程**执行，以避免阻塞主线程。
**源码体现**：在`src/networking.c`中，`readQueryFromClient`（读命令）和`addReply`（写回复）等函数都在主线程上下文中被调用。而像`rdbSaveBackground`（后台RDB保存）则会`fork`子进程来执行。
###### 8. Redis 6.0 为什么引入多线程?
**引入多线程的背景**：随着网络硬件性能提升（万兆网卡），在某些场景下，**网络I/O的处理开销可能成为瓶颈**，尤其是在需要高吞吐量的大容量缓存场景中。单线程模型下，主线程需要独自完成读取请求、解析请求、执行命令、发送回复这一整套流程，网络I/O（特别是发送大量数据）可能成为制约因素。
**Redis 6.0多线程模型**：
- **线程角色**：多线程主要用于处理**网络I/O**，即解析请求和发送响应，而**命令的执行本身仍然是单线程的**，这保证了命令操作的原子性和顺序性，无需引入复杂锁机制。
- **工作模式**：主线程负责接收连接、读命令仍由主线程做，然后将待执行的命令放入队列。多个I/O线程并行从队列中获取命令结果，并负责通过网络发送给客户端。
- **配置启用**：默认关闭，需在配置文件中设置`io-threads-do-reads yes`并指定`io-threads`数量（建议为CPU核心数的3/4左右）。
**设计目标**：通过将耗时的网络数据发送任务卸载到I/O线程，减轻主线程负担，从而**提升整体吞吐量**，尤其是在需要返回大量数据的场景（如`LRANGE`、`HGETALL`等大结果集操作）下效果显著。对于延迟敏感的点对点GET/SET操作，提升可能不明显。