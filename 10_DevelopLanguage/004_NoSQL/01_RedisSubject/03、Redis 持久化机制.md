###### 1. Redis 有哪些持久化方式?
Redis 提供了三种主要的持久化策略，每种策略都有其特定的应用场景和实现机制：

|**持久化方式**​|**核心机制**​|**数据安全等级**​|**性能影响**​|**适用版本**​|
|---|---|---|---|---|
|**RDB（快照持久化）**​|定时生成内存数据的时间点快照|中（可能丢失最后一次快照后的数据）|低|所有版本|
|**AOF（追加日志）**​|记录每个写操作命令的日志文件|高（最多丢失1秒数据）|中|Redis 2.0+|
|**混合持久化**​|RDB快照 + 增量AOF日志组合|高（兼顾恢复速度和数据安全）|中低|Redis 4.0+|
**设计哲学**：Redis的持久化设计体现了在**数据安全**与**性能**之间的权衡。RDB优先考虑性能，AOF优先考虑数据安全，混合模式试图找到平衡点。
###### 2. RDB 持久化的原理是什么?
RDB持久化的核心是基于**内存快照**的持久化机制，其实现涉及操作系统和Redis内部的精密协作。
**触发机制与执行流程**：
- **手动触发**：通过`SAVE`（阻塞）或`BGSAVE`（非阻塞）命令
- **自动触发**：根据配置规则（如`save 900 1`表示900秒内至少1个key变化）
- **其他触发**：执行`SHUTDOWN`或`FLUSHALL`命令时
**BGSAVE的核心源码机制**：
```c
// Redis源码中rdb.c的关键函数
int rdbSaveBackground(char *filename) {
    pid_t childpid;
    
    if ((childpid = fork()) == 0) {
        // 子进程：执行实际RDB文件生成
        int retval = rdbSave(filename);
        // 完成后退出子进程
        exit((retval == C_OK) ? 0 : 1);
    } else {
        // 父进程：记录fork时间等信息，继续处理请求
        server.stat_fork_time = ustime()-start;
        return C_OK;
    }
}
```
**写时复制（Copy-on-Write）技术**：
当父进程fork出子进程后，父子进程共享相同的物理内存页。只有当父进程修改某些内存页时，操作系统才会为子进程创建该页的副本。这极大地减少了内存开销和复制时间。
**RDB文件结构**：
RDB文件采用二进制格式，包含以下部分：
- **文件头**：REDIS魔数和版本信息
- **数据库数据**：键值对及其过期时间等信息
- **文件尾**：结束标记和校验和
###### 3. AOF 持久化的原理是什么?
AOF持久化通过**记录写操作命令**来保证数据持久性，其设计更加精细化。
**AOF工作流程**：
1. **命令传播**：客户端写命令被执行后，命令被追加到`aof_buf`缓冲区
2. **文件同步**：根据`appendfsync`配置，将缓冲区内容同步到磁盘
3. **文件重写**：定期对AOF文件进行重写，消除冗余命令
**AOF文件格式示例**：
```
*3
$3
SET
$5
mykey
$7
myvalue
```
这种格式是Redis协议格式，便于解析和重放。
**AOF重写机制**：
重写并非分析旧AOF文件，而是**遍历当前数据库状态**，生成最小命令集：
```c
// 重写过程中的关键函数（aof.c）
int rewriteAppendOnlyFile(char *filename) {
    // 遍历所有数据库
    for (j = 0; j < server.dbnum; j++) {
        // 遍历数据库中的所有键
        while((de = dictNext(di)) != NULL) {
            // 为每个键生成相应的SET命令
            // 写入新的AOF文件
        }
    }
}
```
重写期间的新写命令会同时写入**AOF重写缓冲区**，确保数据一致性。
###### 4. RDB 和 AOF 的优缺点对比?

|**特性维度**​|**RDB**​|**AOF**​|
|---|---|---|
|**数据安全**​|可能丢失最后一次快照后的所有数据|最多丢失1秒数据（everysec策略）|
|**恢复速度**​|快（直接加载二进制数据）|慢（需要逐条重放命令）|
|**磁盘占用**​|小（二进制压缩格式）|大（文本格式，需重写优化）|
|**性能影响**​|写入时fork子进程有短暂阻塞|持续写入，fsync策略影响性能|
|**可读性**​|差（二进制格式，不可读）|好（文本格式，可人工修改）|
|**版本兼容**​|不同版本兼容性可能有问题|向前兼容性较好|
**运维复杂度对比**：
- **RDB**：备份简单，文件易迁移，但故障时数据恢复点固定
- **AOF**：文件可能损坏需修复，但`redis-check-aof`工具可修复
###### 5. 如何选择 RDB 和 AOF?
**选择策略应基于业务需求和技术约束**：

|**业务场景**​|**推荐策略**​|**理由**​|**配置示例**​|
|---|---|---|---|
|**缓存系统**​|仅RDB|数据可重建，追求最高性能|`save 900 1``save 300 10`|
|**会话存储**​|RDB+AOF|平衡性能与数据安全|`appendonly yes``appendfsync everysec`|
|**金融交易**​|仅AOF（always）|数据绝对不能丢失|`appendfsync always`|
|**大数据量**​|RDB为主|快速启动和备份|适当延长RDB间隔|
|**混合场景**​|混合持久化|兼顾恢复速度和数据安全|`aof-use-rdb-preamble yes`|
**容量规划建议**：
- 如果数据量很大且对启动速度有要求，优先考虑RDB
- 如果写操作非常频繁，AOF文件可能增长很快，需要监控磁盘空间
- 生产环境推荐至少开启一种持久化方式，避免数据完全丢失
###### 6. 什么是 AOF 重写?
AOF重写是解决AOF文件膨胀问题的核心机制，其本质是**基于当前数据状态生成最小命令集**。
**触发条件**：
- **自动触发**：`auto-aof-rewrite-percentage 100`（增长100%）和`auto-aof-rewrite-min-size 64mb`（最小64MB）
- **手动触发**：执行`BGREWRITEAOF`命令
**重写过程的源码级细节**：
1. **主进程fork子进程**执行实际重写工作
2. **子进程遍历数据库**生成新AOF文件：
```c
// 遍历数据库中的所有键
for (j = 0; j < server.dbnum; j++) {
    redisDb *db = server.db+j;
    dict *d = db->dict;
    if (dictSize(d) == 0) continue;
    
    di = dictGetIterator(d);
    while((de = dictNext(di)) != NULL) {
        sds keystr = dictGetKey(de);
        robj key, *o = dictGetVal(de);
        
        // 为每个键值对生成相应的写命令
        // 跳过过期键
        if (o->type == OBJ_STRING) {
            // 生成SET命令
        } else if (o->type == OBJ_LIST) {
            // 生成RPUSH命令
        }
        // ... 处理其他数据类型
    }
}
```
1. **主进程同时将新写命令写入AOF缓冲区和AOF重写缓冲区**
2. **子进程完成重写后，主进程将重写缓冲区内容追加到新AOF文件**
3. **原子性地用新文件替换旧文件**
**重写的优化效果**：
多条重复操作命令会被合并为一条最新状态命令，极大减少文件大小。例如，连续执行`SET count 1`、`INCR count`、`INCR count`后，重写后只需保留`SET count 3`。
###### 7. Redis 的混合持久化是什么?
混合持久化是Redis 4.0引入的创新方案，结合了RDB的快速恢复和AOF的数据安全优势。
**实现原理**：
1. **AOF文件结构变化**：传统的纯命令AOF文件变为`[RDB格式数据][AOF格式命令]`
2. **持久化流程**：先做RDB快照写入文件头，后续增量命令以AOF格式追加
**启用配置**：
```properties
# redis.conf
appendonly yes
aof-use-rdb-preamble yes
```
**混合持久化AOF文件结构**：
```
REDIS0009...     [RDB格式的全量数据]
*3               [AOF格式的增量命令]
$3
SET
$5
key1
$7
value1
*3
$3
SET
$5
key2
$7
value2
```
**优势分析**：
- **快速恢复**：直接加载RDB部分大幅提升恢复速度
- **数据安全**：AOF部分保证近乎实时的数据安全
- **兼容性**：Redis 4.0+自动支持，对客户端透明
###### 8. RDB 持久化会阻塞主进程吗?
RDB持久化是否阻塞主进程取决于具体执行方式：
**SAVE命令**：**完全阻塞**
- 执行期间Redis不响应任何请求
- 适用于停机维护或数据备份场景
- 源码中直接调用`rdbSave`函数，无fork操作
**BGSAVE命令**：**部分阻塞**
- **fork阶段短暂阻塞**：fork子进程时，主进程阻塞，耗时与内存量正相关
- **持久化阶段不阻塞**：子进程执行实际持久化，主进程正常服务
- **copy-on-write内存开销**：父进程修改数据时会产生内存页复制
**阻塞优化策略**：
1. **控制实例内存大小**：单实例不超过20GB，减少fork时间
2. **使用高性能存储**：SSD硬盘减少持久化时间
3. **合理配置持久化策略**：避免在高峰时段触发自动持久化
4. **监控fork耗时**：通过`info stats`查看`latest_fork_usec`指标
###### 9. AOF 的三种同步策略是什么?
AOF的同步策略通过`appendfsync`配置项控制，直接影响数据安全性和性能：

|**策略**​|**机制**​|**数据安全性**​|**性能**​|**适用场景**​|
|---|---|---|---|---|
|**always**​|每个写命令都调用`fsync`同步到磁盘|最高（故障时最多丢失一个命令）|最低（频繁磁盘IO）|金融、交易等对数据一致性要求极高的场景|
|**everysec**​|后台线程每秒执行一次`fsync`|较高（最多丢失1秒数据）|较高（平衡点）|大多数生产环境的默认选择|
|**no**​|不主动执行`fsync`，由操作系统决定|较低（依赖系统刷新，可能丢失较多数据）|最高（无额外磁盘IO）|可容忍数据丢失的缓存场景|
**源码中的同步实现**：
```c
// aof.c中的同步处理
void flushAppendOnlyFile(int force) {
    if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
        fsync(server.aof_fd);  // 每次写入后同步
    } else if (server.aof_fsync == AOF_FSYNC_EVERYSEC) {
        // 每秒同步，有后台线程处理
        aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL);
    }
    // no策略：不执行主动同步
}
```
**生产环境建议**：`appendfsync everysec`在性能和数据安全间提供了最佳平衡，是大多数场景的推荐配置。
###### 10. Redis 持久化数据丢失的场景有哪些?
**RDB数据丢失场景**：
- **两次快照间故障**：最后一次快照后到故障期间的所有数据修改丢失
- **自动持久化配置不合理**：`save`间隔过长导致潜在数据丢失窗口大
- **停机未触发持久化**：`SHUTDOWN`命令未正确执行且无持久化配置
**AOF数据丢失场景**：
- **everysec策略的1秒窗口**：每秒同步间隔内的数据可能丢失
- **操作系统缓存未刷新**：AOF数据在OS缓存未刷盘时断电丢失
- **AOF文件损坏**：故障时AOF文件写入不完整或损坏
**混合持久化数据丢失场景**：
- **RDB快照后AOF部分未刷新**：故障时丢失快照点后的增量数据
- **重写过程中的故障**：重写失败或中断可能导致数据不一致
**数据安全最佳实践**：
- **多机房备份**：定期将RDB/AOF文件备份到异地
- **监控持久化状态**：通过`info persistence`监控持久化相关指标
- **故障演练**：定期测试数据恢复流程，确保备份有效性
- **主从复制**：结合主从架构提供数据冗余