###### 1. Redis 的主从复制原理是什么?
Redis主从复制是一种**异步的数据同步机制**，其核心目标是实现数据冗余、故障恢复和读写分离。整个过程可以清晰地划分为三个阶段：**连接建立、数据同步和命令传播**​ 。
**第一阶段：连接建立**
1. **保存主节点信息**：从节点（Slave）通过配置（`replicaof <masterip> <masterport>`）或命令设置主节点（Master）的地址和端口，并存入本地服务器状态。
2. **建立Socket连接**：从节点内部定时任务检测到新的主节点信息后，会创建一个**专用文件事件处理器**，向主节点发起Socket连接。连接成功后，从节点便成为主节点的一个客户端。
3. **发送PING命令**：从节点向主节点发送PING命令，主要目的是检查Socket连接是否可用以及主节点当前是否能够处理请求。根据PING结果（PONG、超时、其他响应），从节点会决定是继续流程还是重连。
4. **身份验证**：如果主节点设置了密码（`requirepass`），从节点需要发送`AUTH`命令进行验证。密码由从节点通过`masterauth`配置指定。
**第二阶段：数据同步（PSYNC命令）**
连接建立后，从节点会执行数据同步。Redis 2.8之后使用`PSYNC`命令，支持**全量复制**和**部分复制**。
- **全量复制**：通常发生在从节点首次连接主节点，或从节点记录的复制偏移量已不在主节点的复制积压缓冲区中时。其流程如下：
    1. 从节点发送`PSYNC ? -1`命令请求全量同步。
    2. 主节点收到命令后，执行`BGSAVE`，在后台fork一个子进程生成RDB快照文件。
    3. 主节点将生成的RDB文件发送给从节点。从节点先清空自身旧数据，然后加载RDB文件，将自身数据状态更新到主节点执行`BGSAVE`时的状态。
    4. 在主节点生成和传输RDB期间，新的写命令会被缓存在内存的**复制客户端缓冲区**（`client-output-buffer`）中。
    5. RDB加载完成后，主节点将缓冲区中积累的写命令发送给从节点，从节点执行这些命令，最终达到与主节点完全一致的状态。
- **部分复制**：用于处理网络中断等原因导致连接断开后重连的场景，旨在提高效率。其实现依赖于三个核心概念：
    1. **复制偏移量（Replication Offset）**：主从节点各自维护一个偏移量。主节点每次向从节点传播N字节数据，自己的偏移量就增加N；从节点接收后，偏移量也增加N。通过对比偏移量可以判断数据是否一致。
    2. **复制积压缓冲区（Replication Backlog）**：主节点维护的一个固定大小的**环形队列**（默认1MB）。在命令传播阶段，主节点不仅将写命令发送给从节点，还会写入这个缓冲区。当从节点重连后，会将自己的偏移量发送给主节点。如果该偏移量之后的数据仍然存在于积压缓冲区中，主节点就会将这部分数据（缺失的数据）发送给从节点，完成同步。
    3. **服务器运行ID（Run ID）**：每个Redis节点启动时都会生成一个唯一ID。从节点会保存主节点的Run ID。重连时，从节点会发送之前保存的Run ID。如果ID匹配，且偏移量有效，则尝试部分复制；否则，需要进行全量复制。
**第三阶段：命令传播**
数据同步完成后，进入命令传播阶段。主节点每执行一个写命令，会**异步地**将该命令广播给所有从节点。从节点执行相同的命令，从而保持数据的最终一致性。
###### 2. 说一说Redis分布式场景下数据同步?
在Redis的分布式架构（如主从复制、哨兵模式、集群模式）中，数据同步的核心机制是**基于主从复制的异步同步**。这意味着主节点在处理写命令后，会立即返回结果给客户端，而后才将命令异步地发送给从节点。
这种设计带来了**最终一致性**模型。在主从节点网络延迟、从节点负载过高或网络分区等情况下，从节点的数据可能会暂时落后于主节点，导致应用程序可能读到旧数据。
为了在一定程度上保证数据一致性，Redis提供了`WAIT`命令。`WAIT <numreplicas> <timeout>`命令会**阻塞**当前客户端，直到当前写命令传播给至少指定数量的从节点，或直到超时。例如，`WAIT 1 1000`会等待至少1个从节点确认复制，最多等待1秒。但这是一种**弱一致性**保证，并不能完全等同于强一致性。
###### 3. Redis 哨兵模式的工作原理?
Redis哨兵（Sentinel）是一个**高可用性解决方案**，它通过监控主从节点，并在主节点故障时实现**自动故障转移**来提升系统可用性。
哨兵模式的工作原理主要包括**监控、故障判定（主观下线和客观下线）和故障转移**。
1. **监控**：每个Sentinel节点会以每秒一次的频率向所有被监控的主节点、从节点以及其他Sentinel节点发送PING命令，以此检查实例是否在线。
2. **主观下线**：如果一个实例（包括主节点、从节点、其他Sentinel）在配置的毫秒数（`down-after-milliseconds`）内未有效回复PING命令（可能是超时或返回错误），那么发起检测的Sentinel节点就会将该实例标记为**主观下线**。主观下线意味着单个Sentinel认为该实例可能故障了。
3. **客观下线**：当某个Sentinel节点将主节点标记为主观下线后，它会通过**Sentinel之间的内部通信频道**询问其他Sentinel节点是否也认为该主节点已下线。如果达到法定数量（Quorum，在Sentinel配置中设定）的Sentinel节点都报告主节点主观下线，那么该Sentinel节点就会将主节点标记为**客观下线**。客观下线意味着整个Sentinel集群达成共识，认为主节点确实故障了，随即开始故障转移流程。
4. **Sentinel领导者选举**：主节点被判定为客观下线后，多个Sentinel节点会通过**Raft算法**进行选举，选出一个**领导者**来负责执行故障转移操作。
5. **故障转移**：Sentinel领导者会根据一定规则（如优先级、复制偏移量等）从已下线主节点的从节点中选出一个最优者，向其发送`SLAVEOF NO ONE`命令，将其提升为新的主节点。然后，向其他所有从节点发送`SLAVEOF`命令，让它们复制新的主节点。最后，更新配置，告知客户端新的主节点地址。
###### 4. Redis 集群模式的工作原理?
Redis Cluster是一种**去中心化的分片集群**方案，旨在通过数据分片和分布式存储来应对海量数据和高并发场景，同时保证高可用性。
其核心工作原理包括：
- **数据分片**：Redis Cluster将整个数据集划分为16384个**哈希槽**。每个键通过CRC16算法计算后再对16384取模，确定其属于哪个槽。集群中的每个主节点负责处理一部分哈希槽。
- **节点互联（Gossip协议）**：所有集群节点通过**Gossip协议**彼此互联。每个节点都维护着完整的集群元数据，包括集群的状态、各个节点负责的哈希槽范围等。这使得客户端可以连接至任何一个节点来访问数据。
- **请求路由**：
    - 当客户端向某个节点发送一个命令时，该节点会计算命令key所属的哈希槽。
    - 如果该槽由当前节点负责，则直接执行命令。
    - 如果不由当前节点负责，节点会返回一个**MOVED重定向错误**，并告知客户端正确的节点地址。智能的客户端（如JedisCluster）会缓存槽与节点的映射关系，后续直接连接正确的节点。
- **高可用性**：Redis Cluster本身集成了主从复制功能。每个负责槽的主节点都有一个或多个从节点。当某个主节点故障时，其下属的从节点会自动触发选举，晋升为新的主节点，继续提供服务，从而实现故障自动转移。
###### 5. Redis 集群的数据分片方式?
Redis Cluster采用**虚拟哈希槽分区**，而非一致性哈希。
- **哈希槽数量**：固定的16384个（0~16383）。
- **分片算法**：`HASH_SLOT = CRC16(key) % 16384`。
- **槽位分配**：集群管理员可以手动将16384个槽分配给不同的主节点。在节点数量相对稳定时，通常采用**平均分配**的原则。例如，一个3主节点的集群，每个节点可能分别负责0-5460、5461-10922、10923-16383号槽。
- **优势**：
    - **解耦数据与节点**：数据只与哈希槽相关，而与具体节点无关。这使得**节点扩容或缩容时，仅需要将部分槽位进行迁移，而无需重新计算所有数据的哈希值**，大大简化了数据迁移过程。
    - **易于管理**：可以精确控制每个节点负责的槽位数量，从而管理节点的负载。
###### 6. 什么是哈希槽 (Hash Slot)?
哈希槽是Redis Cluster进行数据分片和路由的基本单位。可以将整个16384槽的集合视为一个**逻辑上的完整数据库**，物理上则由多个Redis节点共同分担。
**关键特性**：
- 每个键都唯一属于一个槽。
- 节点的变更（增删）不会影响键到槽的计算规则，只会引起槽在节点间的重新分布。
- 槽的迁移过程是原子的，集群无需下线。
###### 7. Redis 集群如何进行故障转移?
Redis Cluster的故障转移是**自动进行的**，无需人工干预，其流程与哨兵模式类似但内置于集群功能中。
1. **故障检测**：集群中的每个节点都会定期与其他节点发送PING消息。如果一个主节点在指定时间内未响应，它就会被集群中的其他主节点标记为**疑似下线**。集群节点间通过Gossip协议传播这一状态。
2. **故障确认**：当某个主节点发现另一个主节点下线后，它会将这一信息广播给集群。如果集群中大多数负责处理槽的主节点都确认该节点下线，则将其标记为**已下线**，并开始故障转移。
3. **从节点选举**：当主节点被标记为已下线后，其下属的一个从节点会被选举为新的主节点。选举过程基于**配置纪元**，总共有N个从节点参与投票，每个从节点都会请求其他主节点给自己投票，第一个获得N/2+1票的从节点当选。
4. **槽转移与更新**：选举出的新主节点会接管原主节点负责的所有哈希槽，并更新集群的元数据。其他节点会通过Gossip协议学习到这一变更。
###### 8. Redis 主从复制的延迟问题如何解决?
主从复制延迟是异步复制机制下的固有问题。解决方案需从多角度考虑：
1. **优化网络与硬件**：确保主从节点间的网络低延迟、高带宽。使用高性能磁盘，避免I/O成为瓶颈。
2. **监控与告警**：监控主从节点的`master_repl_offset`和`slave_repl_offset`，及时发现延迟并处理。
3. **调整Redis配置**：
    - **增大复制积压缓冲区**：通过`repl-backlog-size`参数（如设置为`512mb`或更大），使得从节点在短暂断开重连后更有可能进行部分同步，而不是耗时的全量同步。
    - **调整`repl-disable-tcp-nodelay`**：设置为`no`（默认），主节点会尽快发送数据，减少延迟，但可能增加小包数量。
4. **使用`WAIT`命令**：在需要强一致性读的场景，可在写操作后使用`WAIT`命令，确保数据已同步到指定数量的从节点。但这会牺牲部分性能和可用性。
5. **架构设计**：
    - 在业务层做兼容，容忍短暂延迟。
    - 对于关键业务，直接读主节点（但这会增加主节点压力）。
###### 9. Redis 哨兵模式的脑裂问题是什么?
脑裂是指在网络分区（Network Partition）发生时，集群中被隔离的部分节点各自认为主节点已下线，并可能选举产生了**多个主节点**，导致数据不一致的现象。
**产生原因**：假设一个包含一主一从和三个Sentinel的集群。网络分区将主节点和一个Sentinel隔离在A区，从节点和另外两个Sentinel隔离在B区。
1. B区的Sentinel无法与A区的主节点通信，达到法定人数后，将主节点判定为客观下线并执行故障转移，将B区的从节点提升为新的主节点。
2. 此时，客户端可能继续向A区的旧主节点写入数据，而向B区的新主节点写入其他数据。
3. 当网络恢复后，旧主节点会作为从节点尝试重新连接新主节点。在连接同步前，Redis会清空旧主节点的数据，然后全量同步新主节点的数据。这导致**在A区旧主节点上写入的数据会永久丢失**。
**解决方案**：
- **`min-replicas-to-write`**：此配置项规定，主节点必须至少有指定数量的从节点连接且延迟时间在`min-replicas-max-lag`秒以内，主节点才接受写操作。例如：
```
    min-replicas-to-write 1
    min-replicas-max-lag 10
```
这意味着如果主节点连一个延迟在10秒内的从节点都没有，它会拒绝写请求。这在网络分区时可以有效减少数据不一致的窗口。
- **合理部署**：将Sentinel部署在多个可用区，并合理配置Quorum值，降低因网络抖动误判的概率。
###### 10. Redis 集群的扩容和缩容如何操作?
Redis Cluster的扩容和缩容核心是**哈希槽的重新分配**，可以使用`redis-cli --cluster`命令集工具化完成。
**扩容流程**：
- **准备新节点**：启动新的Redis实例，配置为集群模式。
- **加入集群**：使用`redis-cli --cluster add-node <new_node_ip:port> <existing_node_ip:port>`将新节点加入集群。此时新节点是空的，不负责任何槽。
- **迁移数据（槽重分配）**：使用`redis-cli --cluster reshard <existing_node_ip:port>`命令。工具会交互式询问要迁移的槽数量（如从16384个中迁移1000个）和接收这些槽的目标节点（新节点）。然后，工具会自动规划从哪些现有节点迁移槽到新节点，并执行迁移。迁移过程是**原子性**的，对客户端的影响很小。当客户端访问正在迁移的键时，可能会收到一个**ASK重定向**，引导其连接到正确的节点。
**缩容流程**：
- **迁移数据**：使用`redis-cli --cluster reshard`将被移除节点上负责的所有槽迁移到集群的其他节点上。
- **移除节点**：当节点不再负责任何槽后，使用`redis-cli --cluster del-node <existing_node_ip:port> <node_id>`将其从集群中移除。
###### 11. Redis 集群支持事务吗?
Redis Cluster**支持事务，但有严格限制**。
- **限制**：所有在`MULTI`/`EXEC`事务块中的命令的key，必须**落在同一个节点的同一个哈希槽**中。这是因为事务需要原子性执行，而集群的数据是分布在多个节点上的，跨节点无法保证原子性。
- **实现方式**：通常通过**哈希标签**来保证一组相关的key被分配到同一个槽。哈希标签是指用`{}`括起来的部分，计算槽位时只对`{}`内的内容进行哈希。例如，`user:{1000}:name`和`user:{1000}:email`的标签部分都是`1000`，因此会被分配到同一个槽，可以在一个事务中执行。
- **与单机Redis事务的区别**：在集群模式下，不支持需要跨多个key且这些key不在同一节点的复杂事务。
###### 12. Redis 的读写分离如何实现?
Redis的读写分离主要通过**主从复制架构**来实现，写操作发往主节点，读操作分发到一个或多个从节点，以此提升系统的读吞吐量。
**实现方式**：
1. **客户端直连**：在应用程序代码中，配置两个不同的连接池。一个**写连接池**指向主节点，一个**读连接池**指向一个或多个从节点。在DAO层或服务层根据操作类型（读/写）选择数据源。这种方式简单，但需要客户端自己维护节点状态。
2. **使用代理中间件**：使用像**Twemproxy**、**Codis**或**Redis官方的Redis Cluster Proxy**等中间件。客户端直接连接代理，由代理根据配置的路由规则（如写请求发往主节点，读请求轮询发往从节点）将命令转发到后端的Redis节点。这种方式对客户端透明，但引入了额外的网络跳转和潜在的性能瓶颈。
3. **Spring Data Redis等框架支持**：在Java生态中，Spring Data Redis可以配置`Lettuce`或`Jedis`连接库来支持读写分离。通过配置主节点和从节点地址，框架可以自动地将写操作路由到主节点，并将读操作负载均衡到从节点。
**注意事项**：
- **数据一致性**：由于主从复制是异步的，从节点的数据可能稍旧于主节点。应用程序必须能够容忍这种**读写延迟**，适用于对一致性要求不高的场景。
- **从节点扩展性**：可以通过增加从节点数量来线性扩展读性能。
- **连接池配置**：需要为从节点设置合理的连接池大小和负载均衡策略（如轮询、随机）。