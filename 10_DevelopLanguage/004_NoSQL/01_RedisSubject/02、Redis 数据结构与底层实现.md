###### 1. Redis 的 String 类型底层是如何实现的?
Redis的String类型通过**redisObject对象系统**进行封装，根据存储内容动态选择最优编码方式，包含三种底层实现：
**int编码**：当字符串值可表示为64位有符号整数时，Redis直接将整数值存储在redisObject的ptr指针位置（刚好8字节），不再需要额外的SDS结构。这种编码在存储数值型数据时完全避免了额外内存开销。
**embstr编码**：针对短字符串（≤44字节）的优化编码，将redisObject和SDS结构在内存中连续分配。这种编码方式只需一次内存分配操作，且内存局部性更好，但因为是只读的，任何修改操作都会导致其转换为raw编码。
**raw编码**：长字符串（>44字节）的标准编码方式，redisObject和SDS结构分开存储。这种编码支持动态修改，是处理大字符串的基础编码。
**编码转换机制**在实践中很重要：当对int编码的值执行APPEND等非数值命令时，会转换为raw编码；embstr编码被修改时会转换为raw编码。44字节的阈值是根据内存分配器jemalloc的64字节最小分配单元计算得出：64 - 16(redisObject) - 3(sdshdr8) - 1(\0) = 44字节。
###### 2. Redis 的 List 类型底层实现原理?
Redis的List类型经历了显著的结构演进，当前核心实现是**quicklist**，它平衡了内存效率和操作性能。
**quicklist架构**：作为双向链表结构，每个节点都是ziplist或listpack（Redis 7.0+）。这种设计将大列表分割为多个小块，有效控制了连锁更新的影响范围。
**历史演进**体现了持续优化：
- **linkedlist**（3.2前）：标准双向链表，每个节点独立分配内存，支持高效的双端操作，但内存开销大且容易产生碎片。
- **ziplist**（3.2前）：紧凑型结构，所有元素连续存储，内存效率高但修改成本高，可能触发连锁更新。
- **quicklist**（3.2+）：结合linkedlist和ziplist的优点，通过`list-max-ziplist-size`参数控制每个节点的ziplist大小。
**listpack**（7.0+）作为ziplist的替代，核心改进是每个entry只记录自身长度，彻底解决了连锁更新问题。其结构包含total-bytes、num-elements、entries和结束标志。
###### 3. Redis 的 Hash 类型底层实现原理?
Redis Hash类型根据数据特征在**ziplist和hashtable**两种编码间动态选择。
**ziplist编码**适用于小型Hash，所有键值对在压缩列表中连续存储，键和值相邻排列。这种编码内存紧凑但查询效率为O(N)，适用于元素数量少且键值长度小的场景。
**hashtable编码**使用字典结构实现，支持O(1)时间复杂度的查询操作。字典包含两个哈希表，用于渐进式rehash，每个桶存储dictEntry链表解决哈希冲突。
**编码转换条件**由以下参数控制：
- Hash对象保存的所有键值对的键和值的字符串长度都小于64字节
- 哈希对象保存的键值对数量小于512个
  当不满足任一条件时，ziplist会转换为hashtable，此过程不可逆。
###### 4. Redis 的 Set 类型底层实现原理?
Set类型根据元素内容和数量在**intset和hashtable**两种编码间选择。
**intset编码**适用于纯整数集合，结构包含编码方式、长度和整数数组，元素有序存储支持二分查找。当元素均为整数且数量较小时，intset能提供极高的内存密度和查询效率。
**hashtable编码**是Set的通用实现，字典的键存储Set元素，值设为NULL。这种编码支持O(1)时间复杂度的添加、删除和查找操作，但内存开销相对较大。
**编码转换**在以下情况发生：
- 添加非整数元素导致intset转换为hashtable
- 元素数量超过`set-max-intset-entries`阈值（默认512）时转换
###### 5. Redis 的 Sorted Set (ZSet) 底层实现原理?
Sorted Set通过**ziplist和skiplist+dict**两种结构实现，支持高效的范围查询和单键操作。
**ziplist编码**将元素和分值相邻存储，按分值排序。这种编码内存效率高，但查询和修改性能随数据量增长而下降，适用于小规模数据。
**skiplist+dict组合编码**是核心实现：
- **跳跃表**支持O(logN)复杂度的范围查询和排序操作，每个节点包含前进指针、层数和分值。
- **字典**提供O(1)复杂度的单元素查询，键为元素，值为分值。
这种双重结构确保了在不同操作场景下都能保持高性能，虽然会增加内存开销，但提供了最佳的操作效率平衡。
###### 6. 什么是 SDS (Simple Dynamic String)?
SDS是Redis设计的**二进制安全动态字符串**，解决了C字符串的多个固有缺陷。
**核心结构特性**包括多种长度的header（sdshdr8/16/32/64）和柔性字节数组。这种设计使SDS能根据字符串长度自动选择最合适的header类型，优化内存使用。
**相比C字符串的优势**显著：
- **O(1)时间复杂度获取长度**：通过len字段直接获取
- **杜绝缓冲区溢出**：API在修改前自动检查空间并进行必要扩容
- **减少内存重分配**：通过空间预分配和惰性空间释放策略优化
- **二进制安全**：可存储任意二进制数据，不受'\0'字符限制
- **兼容C字符串函数**：自动在末尾添加'\0'，支持部分C库函数
**空间预分配策略**优化了追加操作：SDS长度小于1MB时，预分配双倍空间；大于等于1MB时，每次多分配1MB。惰性空间释放则在字符串缩短时保留多余空间，供未来增长使用。
###### 7. 什么是跳跃表 (Skip List)?
跳跃表是**有序数据结构**，通过维护多级索引实现高效查询，Redis将其作为Sorted Set的底层实现之一。
**层级结构**包含多个层级，每个层级都是有序链表，底层包含所有元素。节点层级根据概率分布随机生成，高层级节点数量较少但跨度大。
**操作复杂度**表现优异：查询、插入和删除操作平均时间复杂度均为O(logN)，最坏情况下为O(N)。与平衡树相比，跳跃表实现更简单且顺序性操作更高效。
在Redis中的具体实现中，跳跃表节点包含后退指针（用于逆序遍历）、分值和成员对象。这种设计既支持高效的点查询，也优化了范围查询性能。
###### 8. Redis 的压缩列表 (ziplist) 是什么?
ziplist是**内存紧凑型顺序结构**，为小规模数据提供高内存密度存储。
**整体结构**包含zlbytes（总字节数）、zltail（尾节点偏移量）、zllen（节点数量）、entries（节点列表）和zlend（结束标志）。这种布局使ziplist能够在不使用指针的情况下支持快速的双向遍历。
**entry结构**设计精巧，包含prevlen（前驱节点长度）、encoding（编码类型）和entry-data（实际数据）。prevlen采用变长编码，当前驱节点长度小于254时用1字节，否则用5字节存储。
**连锁更新问题**是ziplist的主要缺点：插入或删除节点可能导致后续多个节点需要重新分配空间，最坏情况下时间复杂度为O(N²)。这限制了ziplist只适用于元素数量较少的情况。
###### 9. Redis 的快速列表 (quicklist) 是什么?
quicklist是**ziplist的双向链表**，平衡了内存效率和操作性能，作为List类型的底层实现。
**节点结构**包含前驱指针、后继指针和指向ziplist的指针，以及ziplist的大小、元素计数等元数据。这种设计将一个大列表分割为多个小ziplist，限制了连锁更新的影响范围。
**控制参数**影响quicklist的表现：
- `list-max-ziplist-size`控制每个ziplist节点的最大容量
- `list-compress-depth`指定两端不压缩的节点数，优化两端操作性能
这种结构既保持了ziplist的内存效率，又通过链表结构支持高效的元素插入和删除，在实际应用中提供了最佳的综合性能。
###### 10. Redis 的字典 (dict) 是如何实现的?
Redis字典采用**哈希表实现**，通过链地址法解决冲突，支持渐进式rehash确保高性能。
**核心结构**包含两个哈希表（ht[0]和ht[1])，用于在rehash过程中平滑迁移数据。哈希表包含桶数组、大小、掩码和已用节点数等字段。
**渐进式rehash**是字典的关键特性：当负载因子超过阈值时，Redis会开始rehash过程，但不会一次性迁移所有数据，而是分多次、渐进式地完成。在rehash期间，查找操作会同时检查两个哈希表，新插入的数据则直接进入新表。
这种设计避免了单次rehash导致的性能抖动，保证了Redis在高负载条件下的稳定响应，是Redis能够提供稳定高性能的重要基础。
###### 11. Redis 的整数集合 (intset) 是什么?
intset是**纯整数集合的高效存储结构**，当Set类型的元素均为整数时使用。
**编码升级机制**是intset的核心特性：当添加的整数超出当前编码范围时，intset会自动升级到更宽的编码（从16位→32位→64位）。这种升级是不可逆的，升级后所有元素都会转换为新的编码格式。
**查找操作**使用二分查找算法，时间复杂度为O(logN)。intset的元素保持有序存储，这既优化了查询性能，也方便进行集合运算。
对于整数集合，intset能提供极高的内存密度和查询效率，但当包含非整数元素或元素数量过大时，会转换为标准的hashtable实现。
###### 12. Redis 对象的类型和编码是什么关系?
Redis的**类型(type)和编码(encoding)是解耦的**，这种设计提供了极大的灵活性和优化空间。
**类型定义数据接口**，包括string、list、hash、set和zset五种基本类型，决定了Redis对外提供的操作接口。
**编码决定内部实现**，每种类型可以根据数据特征动态选择最适合的编码方式。例如，string类型有int、embstr和raw三种编码；list类型主要使用quicklist编码；hash类型根据条件选择ziplist或hashtable编码。
这种解耦设计使Redis能够根据实际数据特征自动选择最优存储策略，无需用户干预。通过`OBJECT ENCODING`命令可以查看任意键的当前编码方式，了解其内部存储结构。