###### 1. MySQL 有哪些日志？
MySQL的日志系统是其高可靠性和可维护性的基石，主要分为以下几类：

|日志类型|所属层级|核心作用|对Java开发者的意义|
|---|---|---|---|
|**Redo Log（重做日志）**​|InnoDB存储引擎层|保证事务的**持久性（Durability）**，崩溃恢复|确保事务提交后数据不丢失，是事务ACID的基石|
|**Undo Log（回滚日志）**​|InnoDB存储引擎层|保证事务的**原子性（Atomicity）**，实现MVCC|支持事务回滚和读写并发（MVCC）|
|**Binlog（二进制日志）**​|MySQL Server层|**主从复制**、**数据恢复**​|实现数据同步、异构数据源订阅（如Canal）|
|**Error Log（错误日志）**​|MySQL Server层|记录启动、运行、停止过程中的错误信息|问题排查和系统监控的第一手资料|
|**Slow Query Log（慢查询日志）**​|MySQL Server层|记录执行时间超过阈值的SQL语句|**SQL性能调优**的关键依据|
|**General Query Log（通用查询日志）**​|MySQL Server层|记录所有客户端连接和执行的语句|审计和安全分析，但对性能影响较大|
此外，还有**中继日志（Relay Log）**（用于主从复制中的从库）和**DDL日志**（记录数据定义语句的元数据变更）。
###### 2. 什么是 Redo Log（重做日志）？
**Redo Log**是InnoDB存储引擎特有的**物理日志**，用于保证事务的持久性。其核心设计是 **WAL（Write-Ahead Logging，预写式日志）技术，即**先写日志，再写数据页。
- **工作原理**：
    1. 当执行DML操作（如UPDATE）时，InnoDB首先将数据页从磁盘加载到**Buffer Pool**（内存缓冲池）中修改，产生"脏页"。
    2. 同时，将"在某个数据页的某个偏移量做了什么修改"这类**物理信息**记录到**Redo Log Buffer**（内存缓冲区）。
    3. 事务提交时，根据`innodb_flush_log_at_trx_commit`策略，将Redo Log Buffer的内容刷新到磁盘上的**Redo Log文件**（通常为`ib_logfile0`、`ib_logfile1`）。
    4. 后台线程会择机将Buffer Pool中的脏页刷新到磁盘数据文件。
- **源码/机制角度**：
    - **循环写入**：Redo Log文件是固定大小的，采用循环写入的方式。有`write pos`指向当前记录位置，`checkpoint`指向待擦除的位置。当`write pos`追上`checkpoint`时，需要先推动`checkpoint`（即刷脏页）才能继续写入。
    - **Crash-Safe**：如果数据库在脏页刷盘前崩溃，重启后InnoDB可以通过重放Redo Log，将已提交事务的修改"重做"到数据页上，从而保证数据不丢失。
###### 3. 什么是 Undo Log（回滚日志）？
**Undo Log**是InnoDB存储引擎特有的**逻辑日志**，主要承担两个核心职责：
1. **保证事务原子性**：记录数据修改前的状态。当事务回滚（ROLLBACK）或执行失败时，利用Undo Log中的反向逻辑（例如，INSERT对应DELETE，UPDATE记录旧值）将数据恢复到事务前的状态。
2. **实现MVCC（多版本并发控制）**：这是实现**可重复读（RR）和**读已提交（RC）**​ 隔离级别的关键。当某行数据被其他事务锁定时，Undo Log可以构建该行数据的历史版本，供当前事务进行**快照读，从而实现非阻塞读，提高并发性。
- **源码/机制角度**：
    - Undo Log存储在**回滚段（Rollback Segment）中。每行记录除了用户定义的字段，还有隐藏字段`DB_TRX_ID`（最近修改它的事务ID）和`DB_ROLL_PTR`（指向该行上一个历史版本在Undo Log中的地址），从而形成一个**版本链。
    - 事务提交后，Undo Log不会立即删除，因为可能还有其他快照读需要它。由后台**Purge线程**负责清理不再需要的Undo Log版本。
###### 4. 什么是 Binlog（二进制日志）？
**Binlog**是MySQL Server层维护的**逻辑日志**，记录所有引起或可能引起数据库改变的**逻辑SQL语句**（如INSERT、UPDATE、DELETE、DDL），但不包括SELECT和SHOW这类不修改数据的查询。
- **核心作用**：
    1. **主从复制（Replication）**：这是其最主要的功能。主库将Binlog发送给从库，从库重放这些逻辑事件，从而保持数据最终一致性。
    2. **数据恢复（Point-in-Time Recovery）**：结合全量备份和Binlog，可以将数据库恢复到某个特定时间点。
###### 5. Redo Log 和 Binlog 的区别？

|特性维度|**Redo Log**​|**Binlog**​|
|---|---|---|
|**所属层级**​|**InnoDB存储引擎层**，是引擎特有的|**MySQL Server层**，所有存储引擎都可使用|
|**日志性质**​|**物理日志**，记录"在某个数据页上做了什么修改"|**逻辑日志**，记录SQL语句的原始逻辑（如"给id=1的余额+100"）|
|**写入方式**​|**循环写入**，空间固定，会覆盖旧日志|**追加写入**，文件达到一定大小会切换，旧文件归档保存|
|**功能职责**​|保证事务的**持久性**，**崩溃恢复（Crash-Safe）**​|**主从复制**、**数据归档**、**时间点恢复**​|
|**事务支持**​|与InnoDB事务紧密绑定|本身不感知存储引擎事务，通过Server层事件记录|
###### 6. 什么是两阶段提交（Two-Phase Commit）？
**两阶段提交**是保证Redo Log和Binlog在分布式事务（这里可理解为需要同时写两个日志）下逻辑一致性的核心机制。它将一个事务的提交过程分为两个阶段：
1. **Prepare阶段**：
    - InnoDB将事务的Redo Log写入磁盘，并将事务状态标记为**PREPARE**。
    - 此时，事务的修改已经持久化，但尚未真正提交。
2. **Commit阶段**：
    - MySQL Server将事务的Binlog写入磁盘。
    - Binlog写入成功后，InnoDB将事务的Redo Log状态标记为**COMMIT**，事务才算真正提交完成。
###### 7. 为什么需要两阶段提交？
两阶段提交是为了解决"先写Redo Log后写Binlog"或反之可能引起的数据不一致问题**。假设没有两阶段提交，考虑以下崩溃场景：
- **场景1：先写Redo Log，写完后崩溃，Binlog未写入**
    - **恢复后果**：重启后，InnoDB根据Redo Log重做事务，主库有该数据。但Binlog丢失，从库无法同步这个事务，导致**主从不一致**。
    - **两阶段提交解决**：在Prepare阶段后崩溃，重启后，发现Redo Log是Prepare状态但Binlog不完整，则会**回滚**该事务。主从库均无此数据，保持一致。
- **场景2：先写Binlog，写完后崩溃，Redo Log未写入**
    - **恢复后果**：重启后，InnoDB发现Redo Log不完整，认为事务未提交，主库无此数据。但Binlog已存在，从库会执行这个事务，导致**主从不一致**。
    - **两阶段提交解决**：在Commit阶段前崩溃，重启后，虽然Binlog完整，但发现对应的事务的Redo Log不是Commit状态。此时，会去检查Binlog是否存在该事务的XID事件。如果存在，则**重做（提交）事务（因为Binlog代表主库已决定提交）；否则回滚。
核心思想**：两阶段提交以**Binlog的写入成功**作为事务最终提交的依据，通过Redo Log的Prepare状态来桥接，确保了这两个日志的逻辑一致性。
###### 8. 什么是 Error Log（错误日志）？
错误日志记录了MySQL服务器从启动、运行到关闭的整个生命周期中遇到的**错误、警告和提示信息**。它是DBA和开发者进行故障排查的**首要入口**。
- **记录内容**：服务器启动/关闭过程信息、运行过程中的错误信息（如无法加载表）、事件调度器运行信息等。
- **配置与查看**：默认位于数据目录下，名为`host_name.err`。可通过`log_error`参数配置路径。
###### 9. 什么是 Slow Query Log（慢查询日志）？
慢查询日志用于记录执行时间超过指定阈值（`long_query_time`，默认10秒）的SQL语句。它是**数据库性能调优的利器**。
- **核心价值**：帮助开发者找出执行效率低下的SQL，以便进行优化，如添加索引、重写SQL等。
- **高级配置**：
    - `log_queries_not_using_indexes`：是否记录未使用索引的查询。
    - `min_examined_row_limit`：查询扫描行数少于该值则不记录。
- **分析工具**：推荐使用`mysqldumpslow`或更强大的`pt-query-digest`等工具对慢查询日志进行分析。
###### 10. 什么是 General Query Log（通用查询日志）？
通用查询日志记录了**所有连接到MySQL的客户端执行的所有语句**，无论语句是否正确执行。由于其记录量非常庞大，会带来显著的I/O压力，**通常仅在需要审计或跟踪特定问题时临时开启**，生产环境不建议长期开启。
- **与慢查询日志的区别**：慢查询日志只记录"慢"的语句，而通用查询日志记录"所有"语句。
###### 11. Binlog 的三种格式（Statement、Row、Mixed）是什么？
Binlog的格式决定了它记录变更的具体方式，各有优劣：

|格式|原理|优点|缺点|适用场景|
|---|---|---|---|---|
|**Statement (SBR)**​|记录**原始的SQL语句**​|日志文件小，节省I/O|可能引发**主从不一致**（如使用`CURRENT_USER()`、`RAND()`等非确定性函数）|旧版本兼容，逻辑简单且确定的SQL|
|**Row (RBR)**​|记录**每一行数据修改前后的镜像**​|非常安全，**绝对精准**，是默认格式|日志体积大（如批量更新百万行）|要求数据绝对一致的场景（如金融业务）|
|**Mixed (MBR)**​|**混合模式**。MySQL根据执行的SQL语句自动选择使用Statement还是Row格式|在安全性和性能间取得平衡|仍存在少量不确定性风险|通用场景，兼顾性能与安全|