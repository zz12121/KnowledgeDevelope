###### 1. MySQL 有哪些常见的存储引擎？
|存储引擎|主要特点|典型应用场景|
|---|---|---|
|**InnoDB**​|**支持事务**（ACID）、**行级锁**、**外键约束**、MVCC（多版本并发控制）、崩溃恢复能力强|在线交易处理（OLTP）、金融系统、电子商务等高并发、高可靠性业务|
|**MyISAM**​|**不支持事务和外键**，**表级锁**，读取速度快，支持全文索引，存储空间较小|读多写少的场景，如内容管理系统（CMS）、数据仓库、日志系统|
|**Memory**​|数据完全存储在**内存**中，速度极快，服务重启后**数据丢失**​|会话管理、缓存、临时数据存储等非持久化需求|
|**Archive**​|**高压缩比**存储，只支持插入和查询操作，不支持索引和事务|存储大量历史归档数据，如日志、审计记录|
|**NDB**​|**分布式集群**存储引擎，支持高可用性和水平扩展|电信、金融等高可用性、高性能的分布式应用|

**总结**：自MySQL 5.5版本起，**InnoDB已成为默认的存储引擎**。对于新项目，除非有非常特殊的理由，否则应优先选择InnoDB。
###### 2. InnoDB 和 MyISAM 的区别？
|特性维度|**InnoDB**​|**MyISAM**​|
|---|---|---|
|**事务支持**​|**支持**​ (ACID)。确保关键操作的数据一致性|**不支持**。意外宕机后数据一致性难以保证|
|**锁机制**​|**行级锁**。大幅提高多用户并发操作的性能|**表级锁**。写操作会阻塞整个表的读/写，并发性能差|
|**外键约束**​|**支持**。保证数据的参照完整性|**不支持**。需要应用层自己维护关联逻辑|
|**存储结构**​|**聚簇索引**。数据文件本身是按主键聚集的B+树索引，数据即索引|**非聚簇索引**。数据（.MYD）和索引（.MYI）分开存储|
|**COUNT(*)查询**​|不保存行数，带WHERE条件时会实时扫描统计，效率较低|保存总行数，`COUNT(*)`直接返回，极快|
|**崩溃恢复**​|通过**事务日志（Redo Log）**​ 和 **Double Write Buffer**​ 等技术提供强大的崩溃恢复能力|崩溃后表易损坏，恢复能力较弱，需使用`CHECK TABLE`和`REPAIR TABLE`命令|

**从Java开发者视角的深度剖析**：
- **并发控制与MVCC**：InnoDB通过**多版本并发控制（MVCC）实现高并发。简单说，当一行数据被更新时，InnoDB不会立即覆盖旧数据，而是创建该行数据的一个新版本（存储在Undo Log中）。这样，其他正在执行的事务仍然可以读取到数据修改前的旧版本，从而避免读写冲突，实现非锁定一致性读。这是其高并发能力的基石。
- **关键特性源码角度**：
    - **插入缓冲（Change Buffer）**：对于非唯一辅助索引的插入或更新操作，如果目标页不在缓冲池中，InnoDB会将这些操作缓存在Change Buffer中，从而避免昂贵的随机I/O。当页被读到缓冲池时，再合并操作。这在Java应用中进行大批量插入时能显著提升性能。
    - **双写缓冲（Doublewrite Buffer）**：为确保数据页写入的可靠性，InnoDB在写入数据文件前，会先将脏页写到双写缓冲区域。如果发生部分页写入（如系统崩溃），可以从这里恢复页的副本。这保证了数据的耐久性（Durability）。
###### 3. 如何选择合适的存储引擎？
|业务场景特征|**推荐引擎**​|**理由**​|
|---|---|---|
|**需要事务支持**（如银行转账、订单支付）|**InnoDB**​|唯一内置支持事务和外键的常用引擎，确保数据一致性|
|**高并发读写，写操作频繁**（如用户中心、商品库存）|**InnoDB**​|行级锁极大减少锁等待，MVCC提升并发吞吐量|
|**读多写少，且数据修改简单**（如新闻文章、日志记录）|**MyISAM**​|在只读或少量写入场景下，查询速度可能更快|
|**需要临时存储会话/缓存数据**（如用户登录状态）|**Memory**​|数据存于内存，访问速度极快|
|**存储大量历史归档数据，很少查询**（如操作日志）|**Archive**​|极高的压缩比，节省存储空间|

**给Java开发者的建议**：
在现代Java应用开发中（如使用Spring Boot框架），**绝大多数情况应首选InnoDB**。其对事务和并发安全的支持，与Java EE/JDBC规范强调的数据一致性理念完全契合。仅在遇到明确的性能瓶颈且确信MyISAM的特性（如全文索引）能带来巨大收益，且可以接受其缺点时，才考虑使用其他引擎。
###### 4. InnoDB 的架构是怎样的？
InnoDB的架构设计其核心可分为**内存结构**和**磁盘结构**两大部分。
1. **内存结构（In-Memory Structures）**
    - **缓冲池（Buffer Pool）**：这是InnoDB的**核心组件**，是主内存中的一个区域，用于缓存数据和索引页。当读取数据时，会先将页从磁盘加载到缓冲池；修改数据时，则修改缓冲池中的页（称为脏页），再由特定机制刷回磁盘。从Java应用视角看，合理设置`innodb_buffer_pool_size`（通常为系统内存的50%-80%）是至关重要的性能调优手段。
    - **日志缓冲区（Log Buffer）**：保存要写入磁盘上的重做日志（Redo Log）的数据。定期刷新此缓冲区可以减少磁盘I/O操作。
    - **变更缓冲区（Change Buffer）**：前述的特殊结构，用于缓存非唯一辅助索引的变更。
2. **磁盘结构（On-Disk Structures）**
    - **表空间（Tablespaces）**：InnoDB所有数据的存储容器，后文会详述。
    - **重做日志（Redo Log）**：用于崩溃恢复的**物理日志**。它记录了数据页的物理修改。事务提交时，先写Redo Log（**Write-Ahead Logging, WAL策略**），再在适当时候将脏页刷盘。如果数据库崩溃，重启后可通过Redo Log重做已提交但未落盘的事务，保证持久性。
    - **撤销日志（Undo Log）**：用于事务回滚和MVCC的**逻辑日志**。它记录旧版本的数据。当执行ROLLBACK或需要构建数据的历史版本时，会使用Undo Log。
###### 5. 什么是表空间（Tablespace）？
表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都被存放在表空间中。
- **概念**：你可以将表空间理解为一个**虚拟的文件系统**，InnoDB用它来管理数据和索引的存储。
- **类型**：
    1. **系统表空间（The System Tablespace）**：默认包含InnoDB数据字典、双写缓冲、撤销日志等元数据信息。在MySQL 5.6之前，所有表的数据和索引也默认存储在此（`ibdata1`文件）。
    2. **独立表空间（File-Per-Table Tablespaces）**：**MySQL 5.6.6之后默认启用**。启用后，每个InnoDB表会有自己独立的`.ibd`表空间文件，存储该表的数据和索引。**推荐使用独立表空间**，因为它便于管理（如单独备份、回收空间）、传输表，且可以避免系统表空间无限增长的问题。
    3. **通用表空间（General Tablespaces）**：允许将多个表存放到一个共享的表空间文件中，可以更灵活地管理存储。
    4. **撤销表空间（Undo Tablespaces）**：用于存储撤销日志。
    5. **临时表空间（Temporary Tablespaces）**：用于存储用户创建的临时表和磁盘内部临时表。