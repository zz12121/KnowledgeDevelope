###### 1. 什么是主从复制？
**主从复制**是一种数据复制技术，它允许将一个数据库服务器（主库，Master）的数据实时同步到一个或多个其他数据库服务器（从库，Slave）。其核心目标是提升系统的**高可用性、可扩展性和数据安全性**。
- **高可用性 (High Availability)**：当主库发生故障时，可以快速切换到从库继续提供服务，减少停机时间。
- **可扩展性 (Scalability)**：实现**读写分离**。主库通常只负责处理写操作（及少量核心读操作），而将大量的读请求负载分发到多个从库上，从而显著提升整个系统的读并发处理能力。这非常符合读多写少型应用（如电商平台、内容网站）的架构需求。
- **数据安全与备份**：可以在从库上执行备份操作，而不会影响主库的性能。同时，从库也充当了一份实时热备数据。
###### 2. MySQL 主从复制的原理是什么？
MySQL主从复制本质上是将一个数据库服务器（主库）的二进制日志（binlog）中的数据变更同步到另一个数据库服务器（从库），并在从库上重新执行（重放）这些变更。这个过程依赖于**三个核心线程和两种日志**。
**核心组件与流程：**
1. **二进制日志 (Binary Log, binlog)**：这是复制的基石。主库将所有对数据产生变更的DDL（数据定义语言）和DML（数据操纵语言）操作按照特定格式（Statement, Row, Mixed）记录到binlog中。从源码角度看，`MYSQL_BIN_LOG`类是管理binlog的核心，事务提交时，日志会先被写入binlog cache，再刷到磁盘文件。
2. **主库的 Binlog Dump 线程**：当从库连接主库时，主库会为每个连接的从库创建一个`Binlog Dump`线程。这个线程负责读取主库的binlog中的事件，并将其发送给从库的I/O线程。在读取binlog时，该线程会对binlog文件加锁，读取完成后释放锁。
3. **从库的 I/O 线程**：从库执行 `START SLAVE`后，会启动I/O线程。它连接到主库，接收`Binlog Dump`线程发送过来的binlog事件，并将其写入到本地的**中继日志 (Relay Log)**​ 中。
4. **中继日志 (Relay Log)**：位于从库上，作为主库binlog的缓冲区，其格式与binlog完全相同。它的引入实现了**异步复制**，使得拉取日志和应用日志解耦，I/O线程和SQL线程可以独立工作。
5. **从库的 SQL 线程**：从库的SQL线程负责读取Relay Log中的事件，解析成具体的SQL语句或在Row格式下直接应用数据变更，并在从库上执行，最终保证主从数据一致性。
**复制的基本过程**可以概括为：
- 从库I/O线程连接主库，请求指定位置点之后的binlog内容。
- 主库Dump线程发送binlog事件。
- 从库I/O线程接收事件，写入Relay Log，并记录已接收到的binlog位置到`master.info`文件。
- 从库SQL线程读取Relay Log，重放事件，并记录已重放的位置到`relay-log.info`文件。
###### 3. 主从复制有哪些模式？
主从复制可以根据**数据一致性保证的强度**和**binlog的记录格式**进行划分。
**1. 按数据同步保证强度划分 (详见第4点)**
- 异步复制 (Asynchronous Replication)
- 半同步复制 (Semisynchronous Replication)
- 全同步复制 (全同步复制)
**2. 按binlog记录格式划分**
- **基于语句的复制 (SBR)**：记录原始SQL语句。优点是日志量小，节省I/O。缺点是可能因上下文（如`CURRENT_TIME()`、存储过程）导致主从数据不一致。
- **基于行的复制 (RBR)**：记录每一行数据是如何被修改的。优点是数据同步更安全、准确。缺点是日志量可能非常大（如`UPDATE`语句影响大量行时）。
- **混合模式复制 (MBR)**：由MySQL自动选择使用SBR还是RBR。通常以SBR为主，在可能引起不一致时切换到RBR，是推荐的模式。
**3. 按数据流架构划分**
- **一主一从/一主多从**：最基本、最常见的架构。
- **级联复制**：部分从库不再直接连接主库，而是连接另一个从库，减轻主库的Dump线程压力。
- **双主/多主复制**：两个或多个主库互为主从，适用于多活架构，但需谨慎处理数据冲突。
###### 4. 什么是异步复制、半同步复制、全同步复制？
这是三种不同数据一致性级别的复制模式，其核心区别在于主库在何时向客户端返回事务成功的响应。

|模式|工作原理|优点|缺点|适用场景|
|---|---|---|---|---|
|**异步复制**​|主库提交事务后，立即返回客户端成功，**不关心**从库是否收到或处理binlog。|**性能最好**，延迟最低。|**数据安全性最差**，主库崩溃可能导致已提交的事务丢失。|对数据一致性要求不高的场景，追求极致性能。|
|**半同步复制**​|主库提交事务后，**等待至少一个从库**确认已收到并写入Relay Log后，才返回客户端成功。|在性能和数据安全间取得平衡，保证了数据至少有一个副本。|有一定延迟，延迟至少为一个TCP/IP往返时间。|对数据一致性有一般要求的常见业务场景。|
|**全同步复制**​|主库提交事务后，**等待所有从库**都成功执行完该事务后，才返回客户端成功。|**数据一致性最高**。|**性能最差**，延迟很高，严重影响系统吞吐量。|对数据强一致性有极端要求的金融、交易核心场景，较少使用。|
**半同步复制的增强**：在MySQL 5.7中，引入了**无损半同步复制**，将等待从库确认的时机调整到**主库存储引擎提交之前**，进一步保证了数据的可靠性，即使主库宕机，从库也一定拥有了这份数据。
###### 5. 主从复制的延迟问题如何解决？
主从延迟（`Seconds_Behind_Master`> 0）是常见问题，原因和解决方案是多方面的。
**产生原因**：
- **硬件资源瓶颈**：从库的CPU、内存、特别是磁盘I/O性能不如主库。
- **大事务**：主库上一个耗时很长的大事务，从库的SQL线程也需要同样长的时间来回放。
- **长事务**：长时间未提交的事务，会阻塞Relay Log的清理和应用。
- **单线程应用**（传统模式）：在MySQL 5.6之前，从库的SQL线程是单线程，容易跟不上主库的并发写入。
**解决方案**：
1. **优化硬件和配置**：确保从库硬件（尤其是SSD磁盘）不弱于主库。调整`sync_binlog`、`innodb_flush_log_at_trx_commit`等参数，在性能和数据安全间权衡。
2. **启用多线程复制 (MTS)**：这是**最核心的优化手段**。
    - MySQL 5.6：支持按库并行（`DATABASE`模式），如果多个库同时写入，有效。
    - MySQL 5.7+：支持**基于逻辑时钟的并行复制（`LOGICAL_CLOCK`）**。同一组内的事务没有冲突，可以并行执行，极大提升了复制效率。通过设置 `slave_parallel_workers > 0`和 `slave_parallel_type = 'LOGICAL_CLOCK'`来开启。
3. **避免大事务**：将大批量的DML操作拆分为小批次执行。例如，避免一次更新100万条数据，而是分批次每次更新1万条。
4. **使用更优的binlog格式**：采用`ROW`格式，在某些场景下比`STATEMENT`更高效且安全。可以设置 `binlog_row_image=MINIMAL`来减少日志量。
5. **网络优化**：确保主从库之间的网络低延迟、高带宽。同机房部署是理想选择。
6. **监控与告警**：使用`SHOW SLAVE STATUS`命令监控`Seconds_Behind_Master`。部署类似`pt-heartbeat`的工具，它可以更精确地测量真实延迟。
###### 6. 如何保证主从数据的一致性？
除了解决延迟，还需主动确保数据一致。
1. **使用GTID复制**：GTID（全局事务标识符）为每个事务分配一个全局唯一的ID。在切换主从时，GTID可以自动定位同步点，避免了传统基于`binlog`文件名和位置（`Position`）复制可能的人为错误，极大地简化了故障转移和数据一致性保障。
2. **定期数据校验**：使用Percona Toolkit中的 **`pt-table-checksum`**​ 工具定期校验主从数据是否一致。它会主库上执行校验查询，并对比主从库的结果。
3. **不一致数据修复**：当`pt-table-checksum`发现不一致时，使用 **`pt-table-sync`**​ 工具来修复从库上的数据，使其与主库一致。
4. **架构与流程保障**：
    - 确保从库设置为**只读**（`read_only=ON`），避免人为误操作在从库写入导致不一致。
    - 使用中间件进行读写分离，避免应用层误操作。
###### 7. 什么是读写分离？如何实现？
**读写分离**是建立在主从复制基础上的一种架构模式，其核心是**将应用程序的写操作定向到主库，将读操作定向到从库**，从而分摊主库压力，提升系统整体并发处理能力。
**实现方式主要有三种**：
1. **应用层代码封装（最常见）**：在Java应用代码中，使用抽象数据源（如Spring的`AbstractRoutingDataSource`）或框架注解来动态选择数据源。
    - **优点**：灵活，可控性强。
    - **缺点**：侵入业务代码，需要开发者维护数据源路由逻辑。
    - **实现示例**：结合Spring的`@Transactional`注解。在写方法上使用`@Transactional`，默认走主库。在读方法上使用`@Transactional(readOnly = true)`，通过AOP切面将其路由到从库。
2. **中间件代理**：在应用和数据库之间部署一个独立的代理中间件，如ShardingSphere-Proxy、MyCat、MySQL Router等。应用程序连接代理，由代理自动解析SQL并路由。
    - **优点**：对应用透明，解耦性好，支持高级功能（如分库分表）。
    - **缺点**：引入新的运维组件，增加了架构复杂性。
3. **数据库驱动层支持**：使用MySQL官方提供的支持复制协议的JDBC驱动（Connector/J），在连接字符串中配置主从地址，驱动会根据SQL是否只读自动路由。
    - **示例连接串**：`jdbc:mysql:replication://master-host:3306,slave-host:3306/database?allowMasterDownConnections=true`。
    - **优点**：实现简单，无需修改代码或引入中间件。
    - **缺点**：功能相对简单，不够灵活。
###### 8. 读写分离可能遇到的问题有哪些？
- **数据延迟带来的不一致**：这是**最核心的问题**。用户刚在主库写入数据，立即查询时请求被路由到尚未同步完成的从库，导致“看不到”刚写入的数据。
    - **解决方案**：
        - **强制走主**：对于需要读取刚写入数据的业务，在查询时通过注解或Hint强制指定从主库读取。
        - **半同步复制**：降低数据延迟窗口。
        - **业务妥协**：允许非核心业务存在短暂不一致。
- **事务内的路由**：如果一个事务中同时包含读和写操作，所有查询都必须走主库，否则会读到旧数据。
- **从库负载不均衡**：多个从库间可能存在负载不均。
    - **解决方案**：使用加权轮询、随机等负载均衡策略。
- **从库故障**：某个从库宕机可能导致读服务不可用。
    - **解决方案**：中间件需要具备从库健康检查和服务自动摘除/恢复的能力。
###### 9. 什么是 MySQL 的高可用方案（如 MHA、MGR）？
主从复制是基础，但要实现自动化故障转移（Failover），需要高可用方案。
1. **MHA (Master High Availability)**
    - **原理**：由Node节点（部署在每个MySQL服务器上）和Manager节点（管理节点）组成。Manager会定期探测Master状态，当检测到Master故障时，会自动将一个数据最先进的Slave提升为新的Master，并让其他Slave指向新Master。
    - **优点**：故障转移速度快（通常30秒内），成熟稳定，对现有拓扑入侵小。
    - **缺点**：需要自行配置VIP或配合中间件进行切换，且需要开启GTID和半同步复制来保证数据一致性。架构相对复杂，运维有一定成本。
2. **MGR (MySQL Group Replication) - 官方推荐**
    - **原理**：基于Paxos协议的分布式状态机复制。由多个节点共同组成一个复制组，一个事务的提交，必须经过**组内大多数节点（N/2+1）**​ 的决议并通过才能提交。它本质上是**多主同步复制**，任何一个节点都是可读可写的，数据强一致性由协议保证。
    - **核心机制**：使用了**组通信（Group Communication）**​ 和**冲突检测**机制。任何节点的写操作都会在组内协商，如果多个节点同时修改同一行数据，MGR会自动检测到冲突并只让一个事务成功提交。
    - **优点**：原生高可用，数据强一致，自动故障检测与切换，支持多主写入。
    - **缺点**：对网络要求极高，写性能受节点数量影响（需要多数节点确认），可能有写入冲突。
**选择建议**：
- 传统的主从架构，追求稳定和可控，可选择**MHA**。
- 追求数据库层面的原生高可用、强一致性和自动化运维，并且是MySQL 5.7及以上版本，强烈推荐使用**MGR**。