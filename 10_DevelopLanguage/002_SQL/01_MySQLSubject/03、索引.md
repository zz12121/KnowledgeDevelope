###### 1. 什么是索引？索引的作用是什么？
索引是一种**帮助MySQL高效获取数据的数据结构**，类似于书籍的目录。它通过将数据表中的特定列值进行排序和组织，建立快速查找路径，从而避免全表扫描。
- **核心作用**：
    - **提高查询速度**：避免全表扫描，将查询时间复杂度从O(n)降到O(log n)。
    - **保证数据唯一性**：通过唯一索引确保字段值的唯一性。
    - **加速表连接**：提高JOIN操作的性能。
    - **优化排序分组**：对ORDER BY和GROUP BY操作进行优化。
- **需要付出的代价**：
    - **占用存储空间**：每个索引都需要额外的磁盘空间。
    - **降低写操作性能**：INSERT、UPDATE、DELETE操作需要维护索引结构，增加开销。
###### 2. MySQL 有哪些索引类型？
MySQL支持多种索引类型，适应不同的业务场景需求：

|索引类型|特点|适用场景|
|---|---|---|
|**主键索引（PRIMARY KEY）**​|唯一且非空，每表只有一个，InnoDB中即聚簇索引|主键字段，确保唯一标识|
|**唯一索引（UNIQUE）**​|保证字段值唯一，允许一个NULL值|邮箱、身份证号等需要唯一性的字段|
|**普通索引（INDEX）**​|最基本的索引，无任何约束|提高查询频率高的字段查询速度|
|**组合索引（复合索引）**​|在多个列上创建的索引，遵循最左前缀原则|多条件联合查询|
|**全文索引（FULLTEXT）**​|用于全文搜索，支持自然语言分析|文本内容的模糊搜索（如文章内容）|
|**空间索引（SPATIAL）**​|用于地理空间数据类型|GIS系统，地理位置查询|
###### 3. B+树索引的原理是什么？
B+树是MySQL InnoDB存储引擎默认使用的索引数据结构，它是一种平衡多路查找树，专为磁盘等外存设备设计。
- **核心结构特点**：
    - **所有数据存储在叶子节点**：非叶子节点只存储索引键（key）和指向子节点的指针，不存储实际数据。
    - **叶子节点形成有序链表**：所有叶子节点通过指针连接成双向链表，支持高效的范围查询和顺序遍历。
    - **树高度平衡**：从根节点到每个叶子节点的路径长度相同，查询性能稳定。
- **查找过程**（以查询`id=25`为例）：
    1. 从根节点开始，在节点内使用二分查找定位到`25`所在的区间。
    2. 根据指针找到对应的内部节点。
    3. 重复上述过程，直到找到包含`id=25`的叶子节点。
    4. 在叶子节点中读取完整的数据行（聚簇索引）或主键值（二级索引）。
###### 4. 为什么 InnoDB 选择 B+树而不是 B树或哈希表？
这是基于不同数据结构的特性和数据库应用场景的深度考量：

|数据结构|优点|缺点|
|---|---|---|
|**B+树**​|**支持高效范围查询**（叶子节点链表）、**更高的扇出率**（节点存储更多key，树更矮胖）、**查询性能稳定**（任何查询都要到叶子节点）|实现相对复杂|
|**B树**​|所有节点都存储数据，某些点查询可能更快|**范围查询效率低**（无链表指针）、**节点存储数据导致扇出率低**（树更高）|
|**哈希表**​|**等值查询极快**O(1)|**不支持范围查询和排序**、**需要处理哈希冲突**、**内存需求大**​|

**结论**：B+树在**范围查询、排序操作、磁盘I/O优化**方面的综合优势，使其更适合作为磁盘数据库的索引结构。InnoDB也提供了**自适应哈希索引**，针对频繁访问的索引页在内存中自动建立哈希索引，作为B+树的补充。
###### 5. 什么是聚簇索引和非聚簇索引？
这是根据**数据存储方式**进行的核心划分：
- **聚簇索引（Clustered Index）**：
    - **特点**：**索引键的逻辑顺序与数据行的物理存储顺序一致**。表数据文件本身就是按B+树组织的主索引。InnoDB中，主键索引就是聚簇索引。
    - **优点**：基于主键的查询非常快，数据访问通常只需一次B+树查找。
    - **限制**：每张表只能有一个聚簇索引。
- **非聚簇索引（Non-Clustered Index / Secondary Index）**：
    - **特点**：**索引的逻辑顺序与数据的物理存储顺序无关**。索引树的叶子节点不包含完整数据行，而是存储**索引列的值和对应数据行的主键值**。
    - **查询过程**：需要**回表（Bookmark Lookup）**，即先通过非聚簇索引找到主键，再通过主键到聚簇索引中查找完整数据行，共需要两次B+树查找。
###### 6. 主键索引和普通索引的区别？

|特性|**主键索引**​|**普通索引**​|
|---|---|---|
|**唯一性**​|**唯一且非空**​|允许重复值和空值|
|**数量限制**​|每表**只能有一个**​|可以有**多个**​|
|**在InnoDB中的实质**​|**聚簇索引**，决定数据物理存储顺序|**非聚簇索引（二级索引）**，叶子节点存储主键值|
|**是否可为NULL**​|**不允许**​|允许|
###### 7. 什么是覆盖索引？
覆盖索引是一种**性能优化技术**，指一个索引包含了查询需要的所有字段，使得MySQL**无需回表**即可完成查询。

- **示例**：
 ```sql
    -- 假设有联合索引 (name, age)
    CREATE INDEX idx_name_age ON users(name, age);
    
    -- 覆盖索引查询：要查询的字段name和age都在索引中
    SELECT name, age FROM users WHERE name = 'Alice';
```
- **优势**：避免二次查询，显著提升性能，尤其对于IO密集型的应用。
###### 8. 什么是联合索引？最左前缀原则是什么？
- **联合索引**：指在**多个列上联合创建**的一个索引。
- **最左前缀原则**：联合索引的**使用必须从最左边的列开始**，且不能跳过中间的列。索引会先按第一列排序，第一列相同再按第二列排序，以此类推。

|查询条件|是否使用索引 `(a, b, c)`|原因分析|
|---|---|---|
|`WHERE a = 1`|**是**​|从最左列a开始匹配|
|`WHERE a = 1 AND b = 2`|**是**​|连续使用a和b列|
|`WHERE b = 2`|**否**​|未从最左列a开始|
|`WHERE a = 1 AND c = 3`|**部分使用**（仅使用a列）|跳过了b列，c列无法利用索引排序|
###### 9. 索引失效的常见场景有哪些？
即使建立了索引，不当的SQL写法也会导致优化器无法使用索引：
1. **对索引列使用函数或表达式**：`WHERE YEAR(create_time) = 2023`。
2. **隐式类型转换**：字符串索引列查询时未加引号，如`WHERE code = 100`（code是varchar类型）。
3. **模糊查询以`%`开头**：`WHERE name LIKE '%abc'`（`abc%`会使用索引）。
4. **使用`OR`连接非索引列条件**：如果`OR`一侧的字段无索引，则整个查询可能全表扫描。
5. **违反最左前缀原则**：联合索引未从最左列开始使用。
6. **对索引列进行运算**：`WHERE id + 1 = 5`。
###### 10. 如何创建和删除索引？
```sql
-- 创建普通索引
CREATE INDEX idx_email ON users(email);

-- 创建唯一索引
CREATE UNIQUE INDEX uni_mobile ON users(mobile);

-- 创建联合索引
CREATE INDEX idx_name_age ON users(name, age);

-- 删除索引
DROP INDEX idx_email ON users;

-- 查看表索引
SHOW INDEX FROM users;
```
###### 11. 什么情况下不适合建立索引？
建立索引需要权衡，以下情况需谨慎：
- **数据量极小的表**：全表扫描可能更快。
- **写操作非常频繁，读操作较少的表**：维护索引的代价可能超过其带来的查询收益。
- **重复度极高（低选择性）的列**：例如“性别”列，索引几乎无法有效过滤数据。
- **很少被用于查询条件的列**。
###### 12. 索引下推（Index Condition Pushdown）是什么？
索引下推是MySQL 5.6引入的一项重要优化。**其核心思想是将WHERE子句中的过滤条件尽可能地“下推”到存储引擎层去处理，减少回表次数和向上层返回的数据量**。
- **工作原理（以联合索引`(name, age)`为例）**：
    - **没有ICP**：存储引擎根据`name`索引条件定位数据，**无论`age`是多少，都会先回表**读取完整行，再由Server层判断`age > 20`。
    - **启用ICP后**：存储引擎根据`name`定位后，**会同时用`age > 20`条件在索引内部进行过滤**，只将满足`name`和`age`两个条件的数据的主键值用于回表查询。