###### 1. 什么是事务？
事务是**数据库管理系统中的一个逻辑工作单元**，它包含一系列的操作（如SQL语句），这些操作要么全部成功执行，要么全部失败回滚。事务是保证数据一致性和完整性的关键机制，特别是在并发操作和系统故障的场景下。
从Java开发者的视角看，你可以将事务理解为**一个不可分割的业务操作边界**。例如，银行转账操作包含扣款和加款两个步骤，必须作为一个整体来执行。
###### 2. 事务的 ACID 特性是什么？
ACID是事务的四个核心特性，也是衡量事务可靠性的标准：

|特性|描述|实际业务场景示例（银行转账）|
|---|---|---|
|**原子性（Atomicity）**​|事务是一个不可分割的单位，操作要么全部成功，要么全部失败回滚|扣款和加款必须同时成功或同时失败|
|**一致性（Consistency）**​|事务执行前后，数据库必须从一种一致状态变换到另一种一致状态|转账前后总金额不变（A-100 + B+100）|
|**隔离性（Isolation）**​|并发事务之间相互隔离，不应互相干扰|同时发生的多个转账操作不能相互影响|
|**持久性（Durability）**​|事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失|转账成功后的余额变化必须永久保存|
###### 3. MySQL 如何实现原子性（Atomicity）？
MySQL通过**undo log（回滚日志）来实现原子性。
- **核心机制**：当事务对数据库进行修改时，InnoDB会生成对应的undo log。如果事务执行失败或调用rollback，InnoDB会利用undo log中的信息将数据回滚到修改前的状态。
- **源码角度**：undo log属于逻辑日志，记录的是SQL执行相关的信息。例如：
    - 对于INSERT操作，undo log会记录主键信息，回滚时执行DELETE
    - 对于DELETE操作，undo log会记录完整数据行，回滚时执行INSERT
    - 对于UPDATE操作，undo log会记录修改前的数据，回滚时执行反向UPDATE
- **Java应用中的体现**：当你在Java代码中调用`connection.rollback()`时，JDBC驱动会通知MySQL执行回滚，MySQL则根据undo log进行数据恢复。
###### 4. MySQL 如何实现一致性（Consistency）？
一致性是ACID的最终目标，它由原子性、隔离性、持久性共同保证，同时也需要应用层的业务逻辑配合。
- **数据库层面**：通过约束（主键、外键、唯一约束、数据类型检查等）来保证数据的一致性。例如，外键约束确保不会引用不存在的记录。
- **业务层面**：在Java代码中，你需要确保业务规则被正确实现。例如，转账前检查余额是否充足，如果不足则抛出异常触发回滚。
###### 5. MySQL 如何实现隔离性（Isolation）？
MySQL主要通过**锁机制**和**多版本并发控制（MVCC）来实现隔离性。
- **锁机制**：
    - **共享锁（S锁）**：允许事务读取数据，其他事务可以加共享锁但不能加排他锁。
    - **排他锁（X锁）**：允许事务更新数据，其他事务不能加任何锁。
    - **行锁 vs 表锁**：InnoDB支持更细粒度的行级锁，大幅提高了并发性能。
- **MVCC（多版本并发控制）**：
    - **核心思想**：为每个事务创建一个数据快照（Read View），使读写操作不互相阻塞。
    - **实现细节**：InnoDB为每行数据维护隐藏的系统字段：
        - `DB_TRX_ID`：最近修改该行数据的事务ID
        - `DB_ROLL_PTR`：指向undo log中旧版本数据的指针
    - **工作流程**：当执行查询时，MySQL会根据当前事务的ID和行的`DB_TRX_ID`来判断哪个版本的数据对该事务可见，从而避免读取到未提交或已提交但不应可见的数据。
###### 6. MySQL 如何实现持久性（Durability）？
MySQL通过**redo log（重做日志）来实现持久性。
- **背景问题**：InnoDB使用Buffer Pool缓存数据页，修改操作先发生在内存中，再异步刷到磁盘。如果MySQL在刷盘前宕机，内存中的数据会丢失。
- **解决方案**：采用**WAL（Write-Ahead Logging）策略，即先写日志，再写数据页。具体过程如下：
    1. 事务修改数据页时，先在内存中修改（Buffer Pool）
    2. 将修改内容记录到redo log buffer中
    3. 事务提交时，将redo log buffer刷盘（`fsync`系统调用）
    4. 后台线程将脏页刷到磁盘数据文件
- **性能优势**：redo log是顺序写入，而数据页是随机写入，因此先写redo log能大幅提升IO性能。即使系统崩溃，重启后也可以通过redo log重做已提交但未落盘的事务。
###### 7. 什么是脏读、不可重复读、幻读？

|问题|描述|示例|
|---|---|---|
|**脏读（Dirty Read）**​|事务A读取了事务B**未提交**的数据，如果B回滚，A读到的就是无效数据|A看到B正在修改的库存值（100→50），但B最终回滚，A看到的是错误数据|
|**不可重复读（Non-repeatable Read）**​|事务A多次读取同一数据，期间事务B**提交了修改**，导致A两次读取结果不一致|A第一次查询余额为100，B转账后余额变为80，A再次查询得到80|
|**幻读（Phantom Read）**​|事务A多次查询一组数据，期间事务B**提交了新增/删除**，导致A两次查询的结果集不同|A第一次统计用户数为100，B新增用户后，A再次统计得到101|

###### 8. MySQL 的事务隔离级别有哪些？
SQL标准定义了四种隔离级别，用于平衡一致性和并发性能：

|隔离级别|脏读|不可重复读|幻读|性能|适用场景|
|---|---|---|---|---|---|
|**读未提交（Read Uncommitted）**​|❌ 可能|❌ 可能|❌ 可能|最高|日志记录、统计分析等对一致性要求极低的场景|
|**读已提交（Read Committed）**​|✅ 避免|❌ 可能|❌ 可能|较高|大多数业务场景（Oracle默认级别）|
|**可重复读（Repeatable Read）**​|✅ 避免|✅ 避免|⚠️ 部分避免|中等|**MySQL默认级别**，需要保证读写一致性的场景|
|**串行化（Serializable）**​|✅ 避免|✅ 避免|✅ 避免|最低|金融交易等对一致性要求极高的场景|
###### 9. 如何查看和设置事务隔离级别？
```sql
-- 查看当前会话隔离级别
SELECT @@transaction_isolation;

-- 查看全局隔离级别  
SELECT @@global.transaction_isolation;

-- 设置当前会话隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 设置全局隔离级别
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

在Java应用中，通常通过Spring框架的`@Transactional`注解来设置：
```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void transferMoney(String from, String to, BigDecimal amount) {
    // 转账业务逻辑
}
```
###### 10. 可重复读（RR）如何解决幻读问题？
MySQL的InnoDB在可重复读隔离级别下，通过**Next-Key Lock**机制来防止幻读。
- **Next-Key Lock组成**：行锁（Record Lock） + 间隙锁（Gap Lock）
    - **行锁**：锁定索引项本身
    - **间隙锁**：锁定索引项之间的范围，防止其他事务在范围内插入新记录
- **实际示例**：
  ```sql
    -- 事务A执行范围查询
    SELECT * FROM users WHERE age BETWEEN 20 AND 30 FOR UPDATE;
    
    -- InnoDB不仅会锁定age=20到30的现有记录（行锁）
    -- 还会锁定(20, 30]这个区间，防止其他事务插入age在此范围内的新用户（间隙锁）
    ```
- **MVCC的作用**：对于快照读（普通SELECT），RR级别通过MVCC保证在事务内始终读取事务开始时的数据快照，从而避免幻读。但对于当前读（SELECT ... FOR UPDATE），则需要Next-Key Lock来防止幻读。
###### 11. 什么是当前读和快照读？
这是InnoDB中两种不同的数据读取方式：

|读取方式|机制|示例|一致性保证|
|---|---|---|---|
|**快照读（Snapshot Read）**​|读取数据的历史版本（通过Read View+undo log）|`SELECT * FROM table WHERE ...`|基于事务开始时的数据快照|
|**当前读（Current Read）**​|读取数据的最新提交版本，并加锁|`SELECT ... FOR UPDATE`  <br>`UPDATE ...`  <br>`DELETE ...`|读取最新数据并防止并发修改|

- **快照读实现原理**：当事务执行普通SELECT时，InnoDB会查找满足以下条件的行版本：
    - 行的`DB_TRX_ID`小于当前事务ID 
    - 行的`DB_TRX_ID`对应的事务已提交
    - 通过`DB_ROLL_PTR`在undo log中构建历史版本链
- **当前读实现原理**：当事务执行UPDATE或加锁SELECT时，InnoDB会：
    1. 读取数据的最新提交版本
    2. 申请相应的锁（共享锁或排他锁）
    3. 确保在事务提交前，其他事务不能修改被锁定的数据