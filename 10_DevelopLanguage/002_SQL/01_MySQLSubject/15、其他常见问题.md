###### 1. VARCHAR 和 CHAR 的区别？
下面是从资深Java开发者角度，结合MySQL底层原理，对这些核心概念的详细对比分析。

|特性对比|CHAR|VARCHAR|
|---|---|---|
|**存储方式**​|固定长度，不足部分用空格填充|可变长度，只存储实际字符+长度前缀|
|**存储空间**​|固定，定义多长就占多长|可变，实际数据长度+1或2字节长度前缀|
|**性能**​|读写更快，固定长度便于寻址|读写稍慢，需要计算偏移量|
|**尾部空格**​|检索时自动去除|保留尾部空格（MySQL 5.0+）|
|**适用场景**​|长度固定的数据（MD5哈希、邮编等）|长度变化大的数据（姓名、地址等）|
**存储机制深度解析**：
- **CHAR**：在`storage/innobase/include/dict0mem.h`中，InnoDB会将CHAR字段填充到定义长度，便于直接通过偏移量定位数据
- **VARCHAR**：需要额外的1-2字节存储实际长度（≤255用1字节，>255用2字节），数据存储更加紧凑
###### 2. DATETIME 和 TIMESTAMP 的区别？

|特性对比|DATETIME|TIMESTAMP|
|---|---|---|
|**时间范围**​|1000-01-01 到 9999-12-31|1970-01-01 到 2038-01-19 (2038年问题)|
|**存储空间**​|8字节（5.6.4前）/5字节+小数秒（5.6.4+）|4字节+小数秒|
|**时区处理**​|无时区转换，存储什么返回什么|自动转换为UTC存储，返回时转换为当前时区|
|**NULL处理**​|允许NULL，存储NULL值|允许NULL，但插入NULL会存储当前时间|
|**自动更新**​|不支持|支持DEFAULT CURRENT_TIMESTAMP和ON UPDATE|
**时区处理源码角度**：TIMESTAMP在存储时调用`my_timestamp_to_utc()`转换为UTC时间，读取时通过`my_timestamp_from_utc()`转换回当前时区。
###### 3. TEXT 和 BLOB 的区别？

|特性对比|TEXT|BLOB|
|---|---|---|
|**存储内容**​|字符文本数据，有字符集|二进制数据，无字符集|
|**排序规则**​|按字符集排序规则比较|按字节数值二进制比较|
|**大小写敏感**​|不敏感（依赖字符集）|敏感|
|**字符集转换**​|插入/查询自动转换字符集|无转换，原始字节存储|
|**适用场景**​|长文本、文章内容、描述等|图片、视频、加密数据、序列化对象等|
**存储引擎实现**：在InnoDB中，当TEXT/BLOB值过大时，前768字节存储在主记录中，剩余部分存储在溢出页中。
###### 4. NULL 和空字符串的区别？

|特性对比|NULL|空字符串''|
|---|---|---|
|**语义含义**​|未知/缺失/不适用|已知的空值/零长度字符串|
|**存储空间**​|NULL位图标记，基本不占空间|占用存储空间（长度信息）|
|**查询比较**​|`IS NULL`/`IS NOT NULL`|`= ''`/`!= ''`|
|**聚合函数**​|`COUNT(col)`忽略NULL值|计入空字符串|
|**索引行为**​|唯一索引允许多个NULL|唯一索引只允许一个''|
|**运算结果**​|任何与NULL的运算结果为NULL|可参与字符串运算|
**索引设计建议**：如果字段可能为空，建议设置默认值为''而非允许NULL，因为`NOT NULL DEFAULT ''`的查询优化效果更好。
###### 5. DELETE、TRUNCATE、DROP 的区别？

|操作|类型|可回滚|重置自增|触发器|性能|
|---|---|---|---|---|---|
|**DELETE**​|DML|✓ 可回滚|✗ 不重置|✓ 触发|慢（逐行）|
|**TRUNCATE**​|DDL|✗ 不可回滚|✓ 重置|✗ 不触发|快（直接释放数据页）|
|**DROP**​|DDL|✗ 不可回滚|- 表删除|✗ 不触发|最快|
**TRUNCATE实现原理**：在InnoDB中，TRUNCATE实际上是通过先执行DROP TABLE再CREATE TABLE来实现的快速清空，这也是为什么它不能回滚的原因。
###### 6. UNION 和 UNION ALL 的区别？
**核心区别**：UNION会去除重复行并进行排序，而UNION ALL直接合并所有结果。
**性能影响**：
- **UNION**：需要创建临时表进行去重排序，性能开销大
- **UNION ALL**：直接返回合并结果，性能更高
**使用建议**：除非确实需要去重，否则优先使用UNION ALL，特别是在大数据量时性能差异显著。
###### 7. HAVING 和 WHERE 的区别？

|层面|WHERE|HAVING|
|---|---|---|
|**执行顺序**​|GROUP BY之前过滤|GROUP BY之后过滤|
|**可使用字段**​|普通表字段|分组后字段或聚合函数|
|**聚合函数**​|不可直接使用|可直接使用|
|**性能影响**​|先过滤减少处理数据量|后过滤，数据量可能较大|
**优化建议**：尽可能在WHERE阶段进行过滤，减少GROUP BY处理的数据量，最后用HAVING对分组结果进行筛选。
###### 8. EXISTS 和 IN 的区别？

|特性|EXISTS|IN|
|---|---|---|
|**执行逻辑**​|半连接，找到即停止|子查询结果物化后比较|
|**NULL处理**​|不受子查询NULL影响|NULL IN (子查询)可能返回UNKNOWN|
|**性能特点**​|外表驱动，适合外表小|适合子查询结果集小的情况|
|**索引利用**​|通常能利用子表索引|依赖子查询优化|
**优化器策略**：现代MySQL优化器会对IN进行半连接转换优化，但EXISTS的逻辑更符合"存在性检查"的业务语义。
###### 9. 如何查看表的结构和索引信息？
**常用命令**：
```sql
-- 查看表结构
DESC table_name;
DESCRIBE table_name;
SHOW COLUMNS FROM table_name;

-- 查看建表语句（包含索引）
SHOW CREATE TABLE table_name;

-- 查看索引信息
SHOW INDEX FROM table_name;
ANALYZE TABLE table_name;  -- 更新索引统计信息

-- 查看表状态信息
SHOW TABLE STATUS LIKE 'table_name';
```
**Information Schema查询**：

```sql
-- 查看列信息
SELECT * FROM information_schema.COLUMNS 
WHERE TABLE_SCHEMA = 'your_db' AND TABLE_NAME = 'your_table';

-- 查看索引统计
SELECT * FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_db' AND TABLE_NAME = 'your_table';
```
###### 10. 如何查看 MySQL 的版本和配置信息？
**版本信息查看：**
- **命令行方式**：`mysql --version`或 `mysql -V`直接显示客户端版本
- **SQL查询方式**：
```sql
SELECT VERSION();  -- 简洁版本信息[3,5](@ref)
SHOW VARIABLES LIKE '%version%';  -- 详细版本相关变量[2,3](@ref)
```
- **管理工具方式**：`mysqladmin -u root -p version`显示服务器运行状态和版本
**配置信息查看：**
- **关键配置查询**：
```sql
SHOW VARIABLES LIKE 'datadir%';  -- 数据目录位置[2](@ref)
SHOW VARIABLES LIKE 'innodb_buffer_pool_size%';  -- 缓冲池大小
SHOW GLOBAL STATUS LIKE 'Threads_connected';  -- 当前连接数[4](@ref)
```
- **配置文件位置**：`mysql --help | grep "Default options"`显示配置文件加载顺序
- **性能监控**：`SHOW ENGINE INNODB STATUS\G`显示InnoDB引擎详细状态信息
**源码角度**：`SHOW VARIABLES`命令实际查询的是MySQL内部的全局系统变量表，这些变量在服务器启动时初始化，存储在内存的全局结构中。
###### 11. 什么是存储过程和触发器？
**存储过程**是预编译的SQL语句集合，保存在数据库中，通过名称调用执行。
**触发器**是一种特殊的存储过程，在特定数据库事件（INSERT/UPDATE/DELETE）发生时自动执行。

|特性|存储过程|触发器|
|---|---|---|
|**调用方式**​|显式调用 `CALL proc_name()`|自动触发，无法直接调用|
|**参数支持**​|支持输入、输出参数|通过NEW/OLD访问行数据|
|**返回结果**​|可以返回结果集|不返回结果|
|**事务控制**​|支持完整事务控制|与触发语句同一事务|
|**适用场景**​|复杂业务逻辑、批量处理|数据审计、完整性约束|
**触发器示例与源码机制：**
```sql
DELIMITER //
CREATE TRIGGER before_salary_update 
BEFORE UPDATE ON employees FOR EACH ROW
BEGIN
    IF NEW.salary < OLD.salary THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Salary cannot decrease';
    END IF;
END//
```
**源码角度**：触发器定义存储在`mysql.triggers`系统表中，当DML操作执行时，查询优化器会检查是否存在相关触发器并将其逻辑注入执行计划。
###### 12. 什么是视图？视图的优缺点？
**视图**是虚拟表，其内容由查询定义，不存储实际数据，在查询时动态生成。
**优点：**
- **安全性**：隐藏敏感数据，限制用户只能访问特定列
- **简化复杂性**：封装复杂查询逻辑，简化应用代码
- **数据抽象**：底层表结构变化时，视图接口可保持不变
**缺点：**
- **性能开销**：复杂视图查询可能转换为复杂连接，影响性能
- **更新限制**：不是所有视图都支持更新操作
**可更新视图条件：**
- 必须包含基表的所有非空列
- 不能使用聚合函数、DISTINCT、GROUP BY等
- 来自单一基表或使用可更新的连接
###### 13. MySQL 8.0 有哪些新特性？
**1. 窗口函数**
支持OVER()子句，实现复杂分析查询，如排名、累计汇总等。
**2. 通用表表达式**
```sql
WITH department_stats AS (
    SELECT department_id, AVG(salary) avg_sal
    FROM employees GROUP BY department_id
)
SELECT * FROM department_stats WHERE avg_sal > 5000;
```
**3. 原子DDL操作**
数据定义语句完全原子化，避免部分成功导致的元数据不一致。
**4. 增强的JSON支持**
```sql
SELECT json_extract(data, '$.user.name') FROM documents;
```
**5. 不可见索引**
`ALTER TABLE t ADD INDEX idx_name (name) INVISIBLE;`可临时禁用索引测试性能影响。
**源码角度**：窗口函数在`sql/window_functions.cc`中实现，使用基于排序的流式处理，避免中间结果物化，提升内存使用效率。
###### 14. 什么是 CTE（公用表表达式）？
CTE是临时命名结果集，在单个语句执行范围内有效，支持递归查询。
**非递归CTE：**
```sql
WITH regional_sales AS (
    SELECT region, SUM(amount) total_sales
    FROM orders GROUP BY region
)
SELECT region, total_sales FROM regional_sales 
WHERE total_sales > 100000;
```
**递归CTE（组织结构查询）：**
```sql
WITH RECURSIVE employee_tree AS (
    -- 锚点查询
    SELECT employee_id, name, manager_id, 1 level
    FROM employees WHERE manager_id IS NULL
    UNION ALL
    -- 递归成员
    SELECT e.employee_id, e.name, e.manager_id, et.level + 1
    FROM employees e JOIN employee_tree et 
    ON e.manager_id = et.employee_id
)
SELECT * FROM employee_tree;
```
**源码角度**：CTE在`sql/sql_cte.cc`中实现，递归CTE使用临时表存储中间结果，通过迭代计算直到满足终止条件。
###### 15. 什么是窗口函数？
窗口函数对一组相关行（窗口）进行计算，同时保留原始行细节。
**核心语法：**
```sql
SELECT 
    employee_name,
    department,
    salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank,
    AVG(salary) OVER (PARTITION BY department) as dept_avg_salary
FROM employees;
```
**常用窗口函数：**
- **排名函数**：ROW_NUMBER(), RANK(), DENSE_RANK()
- **分布函数**：PERCENT_RANK(), CUME_DIST()
- **偏移函数**：LAG(), LEAD(), FIRST_VALUE(), LAST_VALUE()
- **聚合函数**：SUM(), AVG() 配合OVER()
**性能优化**：窗口函数通过`filesort`操作实现分区排序，合理使用索引可显著提升性能。
###### 16. 如何进行全文检索？
MySQL支持基于倒排索引的全文检索功能。
**创建全文索引：**
```sql
ALTER TABLE articles ADD FULLTEXT(title, content);
```
**全文检索查询：**
```sql
-- 自然语言模式
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('database optimization');

-- 布尔模式（高级查询）
SELECT * FROM articles 
WHERE MATCH(title, content) 
AGAINST('+MySQL -Oracle' IN BOOLEAN MODE);
```
**InnoDB全文索引源码机制**：在`storage/innobase/fts`目录下，FTS索引维护倒排列表，将文档分解为词元并建立映射关系。查询时通过倒排索引快速定位包含关键词的文档。
**优化技巧**：
- 设置合适的`ft_min_word_len`参数控制最小词长
- 使用查询扩展提高召回率
- 对于大规模应用，考虑专用搜索引擎（如Elasticsearch）
###### 17. MySQL 如何处理表情符号（emoji）？
表情符号处理核心在于字符集和排序规则的支持。
**UTF8与UTF8MB4：**
- **utf8**：最多3字节，支持基本多语言平面（BMP）字符
- **utf8mb4**：4字节编码，完全支持Unicode，包括表情符号
**配置步骤：**
1. **修改字符集**：
```sql
ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;
ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```
2. **连接配置**：确保应用程序连接字符串指定UTF-8编码
3. **验证支持**：
```sql
SELECT * FROM test_emoji WHERE content LIKE '%😊%';
```
**Java应用配置：**
```java
// JDBC连接字符串
String url = "jdbc:mysql://localhost:3306/db?useUnicode=true&characterEncoding=UTF-8";
```
**源码角度**：在`strings/ctype-utf8mb4.c`中实现UTF8MB4编码处理，表情符号被识别为4字节序列，存储引擎在索引和比较操作中正确处理这些字符。