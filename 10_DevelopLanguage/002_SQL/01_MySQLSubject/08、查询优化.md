###### 1. 如何分析 SQL 查询性能？
分析SQL查询性能是一个系统性的过程，核心在于**定位瓶颈**。
**（1）监控与发现慢查询**
- **慢查询日志 (Slow Query Log)**：这是最直接的方法。通过设置`long_query_time`阈值（如1秒），MySQL会自动记录所有执行时间超过该阈值的SQL语句、执行时间、锁定时间等信息。这是发现性能问题的第一步。
- **性能模式 (Performance Schema)**：MySQL 5.7及以上版本提供的更强大的性能监控工具，可以记录详细的SQL执行统计信息，包括阶段等待、锁信息等，比慢查询日志更细致。
**（2）使用EXPLAIN进行执行计划分析**
找到慢SQL后，下一步就是使用`EXPLAIN`分析其执行计划，这是性能分析的核心。下文会详细展开。
**（3）实际执行分析**
`EXPLAIN`只是预测，`EXPLAIN ANALYZE`会**实际执行**SQL，并输出预估和实际执行的对比数据，如实际返回行数、实际执行时间等，对于验证优化效果非常有用。
**（4）数据库状态诊断**
在SQL执行期间，监控数据库服务器的CPU、内存、I/O使用率。如果一条SQL导致CPU或I/O长时间飙高，很可能涉及大量数据扫描、排序或临时表操作。
从源码角度看，MySQL的查询执行引擎（如`sql/sql_executor.cc`中的`Query_result_send`、`Query_result_union`等类）负责执行查询计划。性能瓶颈往往出现在存储引擎（如InnoDB）的磁盘访问（`ha_innobase::index_read`等函数）、排序（`filesort`）或连接操作（`JOIN::exec`）等环节。
###### 2. EXPLAIN 命令的作用是什么？如何使用？
**作用**：`EXPLAIN`命令用于**获取MySQL优化器为指定SQL语句生成的执行计划**。它不会真正执行SQL语句，而是展示MySQL打算如何执行这条语句，例如使用哪个索引、表的连接顺序和连接方式等。这是理解查询行为和性能瓶颈的关键。
```sql
EXPLAIN SELECT * FROM your_table WHERE your_condition;
```
对于`INSERT`、`UPDATE`、`DELETE`，可以使用`EXPLAIN FORMAT=TRADITIONAL`或更高版本中的`EXPLAIN FOR CONNECTION`。
**高级用法**：
- `EXPLAIN FORMAT=JSON`：提供比传统表格格式更详细的JSON格式信息，包括成本估算。
- `EXPLAIN ANALYZE`：在MySQL 8.0+中可用，会实际执行SQL并输出详细的执行时间信息，是分析性能的利器。
###### 3. EXPLAIN 输出结果中各字段的含义？
EXPLAIN输出结果中的每个字段都描述了执行计划的一个重要方面：
id：查询的序列号。相同id按顺序执行；不同id，id值越大优先级越高，越先执行。
select_type：查询类型，如SIMPLE（简单查询，无子查询或UNION）、PRIMARY（最外层查询）、SUBQUERY（子查询）、DERIVED（派生表，FROM子句中的子查询）等。
table：正在访问的表名。
partitions：匹配的分区。
type：连接类型或访问类型。这是判断查询效率的关键指标，从好到坏依次为：
system> const：通过主键或唯一索引一次就找到，如WHERE id = 1。
eq_ref：唯一索引扫描，常用于主键或唯一索引关联。
ref：非唯一索引扫描。
range：索引范围扫描。
index：全索引扫描（比ALL好，因为只扫描索引树）。
ALL：全表扫描，需要优化。
possible_keys：查询可能使用的索引。
key：查询实际使用的索引。为NULL表示未使用索引。
key_len：使用的索引长度。可判断索引是否被充分利用。
ref：显示索引的哪一列被使用。
rows：MySQL预估需要扫描的行数。这是一个重要的估值。
filtered：表示存储引擎返回的数据在Server层过滤后，剩余数据占rows的百分比。
Extra：额外信息，非常重要，常见值有：
Using index：覆盖索引，数据直接从索引获取，无需回表。
Using where：在Server层进行了过滤。
Using temporary：使用了临时表，常见于GROUP BY、ORDER BY。
Using filesort：使用了文件排序，而非索引排序。
Using join buffer：使用了连接缓存。
###### 4. 什么是查询优化器？
查询优化器是数据库系统的核心组件，其职责是**为一条SQL语句生成一个它认为最高效的执行计划**。
**源码角度**：在MySQL中，优化器入口大致在`sql/sql_optimizer.cc`。其工作流程包括：
1. **逻辑优化**：基于关系代数规则进行优化，例如条件化简、子查询优化（`SELECT_LEX::optimize`）。
2. **物理优化**：主要为**基于成本的优化（CBO）**。优化器会考虑各种可能的执行路径（如使用哪个索引、何种连接顺序），并利用`handler::read_time`等接口向存储引擎询问I/O成本，利用`records_in_range`询问索引筛选度，最终选择一个它计算出的成本最低的计划。
优化器的决策依赖于表的统计信息（如`TABLE::stat_records`），因此过时的统计信息可能导致优化器生成次优计划。
###### 5. 常见的 SQL 优化技巧有哪些？
- **合理使用索引**：
    - 为`WHERE`、`JOIN`、`ORDER BY`、`GROUP BY`的列建立索引。
    - 使用覆盖索引减少回表。
    - 注意索引失效场景，如对索引列使用函数、类型转换、左模糊匹配（`LIKE '%abc'`）等。
- **优化SQL语句**：
    - 避免`SELECT *`，只取需要的列。
    - 用`UNION ALL`替代`UNION`，除非需要去重。
    - 用`EXISTS`替代`IN`，尤其在子查询结果集较大时。
    - 避免在`WHERE`子句中对字段进行表达式操作或函数转换。
- **优化数据访问**：
    - 分页查询优化大偏移量问题（参见第11点）。
    - 避免全表扫描（参见第7点）。
- **设计层面优化**：
    - 选择合适的数据类型，如用`INT`而非`VARCHAR`存储数字，用`varchar(n)`替代`char(n)`。
    - 遵循数据库范式，但有时可适当反范式以减少`JOIN`。
    - 读写分离、分库分表。
###### 6. 什么是慢查询？如何定位和优化慢查询？
- **定义**：执行时间超过指定阈值（`long_query_time`）的查询。
- **定位**：
    1. **开启慢查询日志**：在MySQL配置文件（如`my.cnf`）中设置`slow_query_log=1`和`long_query_time`。
    2. **分析日志**：使用`mysqldumpslow`或`pt-query-digest`等工具分析慢查询日志。
- **优化**：定位到慢SQL后，采用上述第5点的优化技巧进行分析和优化。
###### 7. 如何避免全表扫描？
全表扫描（`type`为`ALL`）通常性能较差，应尽量避免。
- **在`WHERE`和`JOIN`涉及的列上创建有效的索引**。
- **避免索引失效**：防止对索引列使用函数、计算、类型转换、`OR`条件（可尝试用`UNION`替代）等。
- **使用索引提示（Index Hint）**：如果优化器选择了错误的索引，可以使用`FORCE INDEX`强制使用某个索引。
- **更新统计信息**：使用`ANALYZE TABLE`更新表统计信息，帮助优化器做出正确选择。
- **小表扫描是正常的**：如果表非常小，全表扫描可能比索引扫描更快，这是合理的。
###### 8. 什么是子查询？如何优化子查询？
- **定义**：嵌套在另一个查询（外部查询）内部的查询。
- **优化策略**：
    - **将子查询转化为连接（JOIN）**：这是最常见的优化手段，连接查询通常效率更高。
    - **使用`EXISTS`或`NOT EXISTS`替代`IN`或`NOT IN`**：特别是当子查询结果集很大时。
    - **避免在子查询中使用`SELECT *`**。
    - **将派生表（FROM中的子查询）物化**：或先将其结果存入临时表。
从源码看，子查询优化在`sql/sql_optimizer.cc`中处理，如`SELECT_LEX::resolve_subquery`和`Item_subselect::select_transformer`函数，会尝试将子查询转化为半连接（semi-join）或物化等更高效的执行方式。
###### 9. JOIN 的类型有哪些？如何优化 JOIN 查询？
- **类型**：`INNER JOIN`、`LEFT/RIGHT OUTER JOIN`、`CROSS JOIN`。
- **优化策略**：
    - **确保`ON`或`USING`子句中的列上有索引**。对于`INNER JOIN`，放在`WHERE`条件的列也应考虑索引。
    - **尽量减少JOIN的表数量**，过多（如超过12个）可考虑使用临时表拆分。
    - **以小表驱动大表**。优化器通常会尝试这样做，但有时连接顺序不理想，可使用`STRAIGHT_JOIN`强制顺序（谨慎使用）。
    - 合理选择`JOIN`算法：MySQL主要使用**Nested-Loop Join (NLJ)**、**Block Nested-Loop Join (BNL)**​ 和 **Hash Join**（MySQL 8.0.18+）。`EXPLAIN`格式的`Extra`字段有时会提示算法。
###### 10. 什么是索引合并（Index Merge）？
###### 11. LIMIT 分页如何优化？
###### 12. COUNT( * ) 和 COUNT(1) 和 COUNT(字段) 的区别？
###### 13. 如何优化大数据量的查询？