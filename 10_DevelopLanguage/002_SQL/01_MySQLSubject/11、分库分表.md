###### 1. 什么是分库分表？为什么需要分库分表？
**分库分表**是一种数据库架构优化技术，其核心目标是通过将单个大型数据库或数据表，按照特定规则拆分成多个小型数据库或数据表，并将它们分布到不同的物理服务器或存储介质上，以提升系统的整体性能、存储容量和并发处理能力。
- **分库**：将一个完整的数据库实例拆分成多个独立的数据库实例，每个实例可以部署在不同的服务器上。
- **分表**：将一张数据量巨大的表拆分成多张结构相同的小表，这些小表可以位于同一个数据库实例，也可以分布在不同的数据库实例中。
**为什么需要分库分表？**
随着业务规模的爆炸式增长，单机数据库会面临显著的瓶颈：

| 瓶颈类型        | 具体表现                                                                                                        |
| ----------- | ----------------------------------------------------------------------------------------------------------- |
| **性能瓶颈**​   | - **查询性能下降**：单表数据量过大（如超千万行）导致查询效率急剧降低。  <br>- **写入压力大**：高并发写入导致大量锁冲突，性能下降。  <br>- **连接数限制**：数据库可支撑的并发连接数有限。 |
| **存储瓶颈**​   | - **磁盘容量**：单机存储容量无法满足TB/PB级别的数据增长。  <br>- **IO瓶颈**：单服务器IO处理能力有限。                                            |
| **可维护性瓶颈**​ | - **备份与恢复困难**：大数据库备份耗时极长，故障恢复时间窗口不可接受。  <br>- **单点故障风险**：所有业务依赖单一数据库，一旦宕机，整个系统不可用。                          |
**实施前提**：在考虑分库分表前，应优先尝试**读写分离、优化索引、引入缓存、归档历史数据、升级硬件**等方案。只有当这些手段无法解决问题时，才应考虑分库分表，因为它会显著增加系统复杂度和运维成本。
###### 2. 垂直分库和水平分库的区别？

|维度|垂直分库 (Vertical Sharding)|水平分库 (Horizontal Sharding)|
|---|---|---|
|**拆分依据**​|**业务维度**。按业务模块将不同的表拆分到不同的数据库。|**数据分布维度**。将同一张表的数据按规则（如ID取模、范围）分散到多个数据库。|
|**库/表结构**​|不同库中的**表结构不同**，各自服务于独立的业务单元。|不同库中的**表结构完全相同**，每个库存储全量数据的一个子集。|
|**主要目标**​|**解耦业务，降低单库压力**。将不同业务的访问压力分散到不同数据库实例。|**解决单表数据量过大问题**，提升存储和并发处理能力。|
|**优点**​|- 业务清晰，拆分规则明确  <br>- 易于数据维护和扩展|- 不存在单库大数据量和高并发的性能瓶颈  <br>- 扩展性好，可通过增加分片解决容量问题|
|**缺点**​|- 跨库Join操作困难  <br>- 事务处理复杂（分布式事务）  <br>- 若某个业务表数据量依然巨大，仍存在性能瓶颈|- 拆分规则设计复杂  <br>- 跨库查询、排序、分页困难  <br>- 数据扩容和迁移难度大|
**举例**：一个电商系统，垂直分库后可拆分为用户库、商品库、订单库、支付库等。而水平分库则是将订单库中的`orders`表，按订单ID的哈希值分散到4个不同的数据库实例中。
###### 3. 垂直分表和水平分表的区别？

|维度|垂直分表 (Vertical Splitting)|水平分表 (Horizontal Splitting)|
|---|---|---|
|**拆分依据**​|**字段/列维度**。将一张宽表中的列，按使用频率或长度拆分成多张表。|**数据行维度**。将一张大表的行数据按规则拆分到多张结构相同的表中。|
|**表结构**​|拆分后的**表结构不同**，通常是一张主表和若干张扩展表。|拆分后的**表结构完全相同**。|
|**主要目标**​|**解决单表字段过多导致的IO效率问题**，实现冷热数据分离。|**解决单表数据行过多导致的性能问题**。|
|**优点**​|- 行数据变小，单数据块可存放更多数据，减少IO次数  <br>- 利于缓存优化和冷热数据分离|- 单表数据量可控，有助于性能提升  <br>- 应用层改造较少，只需增加路由规则|
|**缺点**​|- 需要管理冗余列（通常是主键）  <br>- 查询时需关联表或在应用中拼接|- 跨分片查询复杂  <br>- 分片事务一致性难保证|
**举例**：垂直分表是将`user`表拆分为`user_basic`（ID, 用户名, 手机号）和`user_profile`（用户ID, 生日, 个人简介）。水平分表则是将`orders`表按订单创建时间拆分为`orders_2024`、`orders_2025`等。
###### 4. 分库分表的策略有哪些？
水平拆分的策略选择至关重要，直接影响到数据分布的均匀性和系统的可扩展性。

|策略|原理|优点|缺点|适用场景|
|---|---|---|---|---|
|**范围分片**​|按分片键的连续区间（如时间、ID范围）分配数据。|- 扩容简单，只需追加新库/表  <br>- 利于范围查询|**容易产生热点数据**，最新数据所在分片压力大。|有明显时间特征或顺序性的数据，如订单、日志。|
|**哈希取模分片**​|对分片键的哈希值进行取模运算，根据余数确定分片位置。|**数据分布均匀**，不易出现热点。|**扩容极其困难**。分片数量变化会导致数据重新分布，迁移量大。|需要随机读写、无顺序要求的场景。|
|**一致性哈希分片**​|将分片节点和数据都映射到一个哈希环上，数据顺时针找到第一个节点。节点增减只影响相邻数据。|**扩容/缩容时数据迁移量小**，只影响相邻节点。|实现相对复杂，需要虚拟节点来保证数据均匀性。|**推荐在分布式架构中使用**，对扩展性要求高的场景。|
|**地理位置分片**​|根据用户所在地理区域分配数据。|可就近部署，降低访问延迟，符合数据合规要求。|数据分布可能不均衡。|用户地域性强的业务，如本地生活、出行服务。|
###### 5. 什么是分片键？如何选择分片键？
**分片键**是决定数据行被分布到哪个分片（库或表）的**一个或多个字段**。例如，订单表中的`order_id`或用户表中的`user_id`都可以作为分片键。
**选择分片键的核心原则**是保证数据**均匀分布**并满足**高频查询**的需求。
1. **数据分布均匀性**：分片键的取值应尽可能分散，避免数据倾斜导致单个分片成为热点。例如，`user_id`通常比`gender`更适合做分片键。
2. **支持高频查询**：分片键应包含在大多数查询的条件中。这样，查询可以被直接路由到单个分片，避免全分片扫描。例如，以`buyer_id`分片的订单表，能高效支持“查询某买家的所有订单”。
3. **避免跨分片查询**：尽量选择能避免或减少跨分片操作（JOIN、排序、分页）的字段。
4. **业务相关性**：结合业务逻辑。例如，电商订单系统可同时按`buyer_id`和`seller_id`进行数据冗余，分别支持买家和卖家的查询。
###### 6. 分库分表后如何进行分页查询？
分页查询是分库分表后最具挑战性的问题之一，尤其是基于非分片键的查询。主要有以下几种方案：

|方案|实现方式|优点|缺点|适用场景|
|---|---|---|---|---|
|**全局视野法**​|从所有分片中查询满足条件的数据，在内存中汇总、排序，再计算分页结果。|结果准确。|**性能极差**，偏移量越大性能越差，严重消耗应用和数据库资源。|数据量小、分片少、非核心业务的离线查询。|
|**业务折衷法**​|- **禁止跳页**：只提供“下一页”功能，记录上一页最后一条记录的位置。  <br>- **允许数据微小误差**：使用近似计算。|实现相对简单，性能较好。|功能受限，用户体验有折衷。|对一致性要求不高的Feed流、时间线场景。|
|**二次查询法**​|一种优化算法，先在各分片扩大范围查询，再在内存中精准定位。|比全局视野法性能稍好。|逻辑复杂，理解维护成本高。|较少使用。|
|**中间件支持**​|使用ShardingSphere等中间件，在代理层自动处理分页聚合。|对应用透明。|增加了系统复杂度，中间件本身可能成为瓶颈。|需要简化应用层开发的场景。|
|**异构索引表**​|**最推荐的方案**。将数据同步到Elasticsearch、TiDB等专为检索设计的系统中，在这些系统上执行分页查询。|性能优秀，支持复杂查询。|技术架构更复杂，需维护数据同步链路和一致性。|**大型互联网公司常用方案**，适用于复杂查询和高并发场景。|
###### 7. 分库分表后如何处理跨库 JOIN？
跨库JOIN同样非常棘手，应尽量避免。
1. **全局表/广播表**：将数据量小、更新少、所有分片都需要关联的字典表（如省市信息），在每个分片都冗余存储一份。
2. **字段冗余**：将关联表的部分常用字段冗余到主表中，避免JOIN。如在订单表中冗余商品名称。
3. **应用层JOIN**：先查询主表数据，再根据结果中的关联ID，去查询其他分片或表，最后在应用内存中进行数据拼接。这会发起多次查询，效率较低。
4. **数据异构同步**：与分页查询的解决方案类似，将关联数据同步到同一个检索系统（如ES）中，在系统内完成JOIN。
5. **表分组**：将关联紧密的表（如订单表和订单明细表）使用相同的分片键和分片策略进行分片，确保关联数据落在同一个分片内，从而可以在单库内进行JOIN。
###### 8. 分库分表后如何生成全局唯一 ID？
单机数据库的自增ID在分布式环境下会重复，必须使用分布式ID生成方案。

|方案|原理|优点|缺点|
|---|---|---|---|
|**UUID**​|生成128位的全局唯一字符串。|实现简单，本地生成无网络开销。|无序，导致索引效率低下；字符串长，存储空间大。|
|**数据库序列号表**​|使用一张独立的表专门生成有序递增的ID。|ID有序，利于索引。|有单点故障风险，性能有瓶颈。|
|**雪花算法**​|**推荐方案**。生成64位Long型数字，包含时间戳、工作机器ID、序列号。|**性能极高**，本地生成，ID趋势递增。|对系统时钟有依赖，需解决时钟回拨问题。|
|**中间件生成**​|如ShardingSphere内置的分布式ID生成器。|对应用透明，集成方便。|依赖中间件。|
**最佳实践**：在Java应用中，可结合`@Component`注解自定义ID生成器组件，使用雪花算法生成ID，确保全局唯一和高性能。
###### 9. 常见的分库分表中间件有哪些？
使用中间件可以大幅降低应用层处理分库分表的复杂度。可分为两类：
- **Client层模式**：以Jar包形式嵌入到应用中，如ShardingSphere-JDBC。
- **Proxy层模式**：作为独立代理服务部署，应用像连接普通数据库一样连接它，如ShardingSphere-Proxy、MyCat。

|中间件|模式|特点|
|---|---|---|
|**ShardingSphere**​|支持Client（Sharding-JDBC）和Proxy（Sharding-Proxy）两种模式。|**当前主流首选**。功能全面（分库分表、读写分离、分布式事务等），社区活跃，文档完善。|
|**MyCat**​|Proxy层。|基于Cobar开发，功能完善，社区曾非常活跃。但近年来发展和更新放缓。|
|**TDDL**​|Client层。|阿里开源，但功能相对简单，且依赖自身的配置系统，社区版资料较少。|
**选择建议**：对于Java技术栈，**ShardingSphere-JDBC**因其轻量级、高性能和对程序的无侵入性，是大多数场景下的首选。如果希望语言无关或希望对应用完全透明，则可考虑ShardingSphere-Proxy。