```
疯狂创客圈^
```
# 牛逼的职业发展之路

40 岁老架构尼恩用一张图揭秘: Java 工程师的高端职业发展路径，走向食物链顶端的之路

链接：https://www.processon.com/view/link/618a2b62e0b34d73f7eb3cd


```
疯狂创客圈
```
# 史上最全：价值 10 W 的架构师知识图谱

此图梳理于尼恩的多个 3 高生产项目：多个亿级人民币的大型 SAAS 平台和智慧城市项目

链接：https://www.processon.com/view/link/60fb9421637689719d


```
疯狂创客圈
```
# 牛逼的架构师哲学

40 岁老架构师尼恩对自己的 20 年的开发、架构经验总结

链接：https://www.processon.com/view/link/616f801963768961e9d9aec


```
疯狂创客圈
```
# 牛逼的 3 高架构知识宇宙

尼恩 3 高架构知识宇宙，帮助大家穿透 3 高架构，走向技术自由，远离中年危机

链接：https://www.processon.com/view/link/635097d2e0b34d40be778ab


```
疯狂创客圈
```
# 尼恩 Java 高并发三部曲（卷 1 加强版）

老版本：《Java 高并发核心编程卷 1 ：NIO、Netty、Redis、ZooKeeper》（已经过时，不建
议购买）

###### 新版本：《Java 高并发核心编程卷 1 加强版 ：NIO、Netty、Redis、ZooKeeper》

 由浅入深地剖析了高并发 IO 的底层原理。

 图文并茂的介绍了 TCP、HTTP、WebSocket 协议的核心原理。

 细致深入地揭秘了 Reactor 高性能模式。

 全面介绍了 Netty 框架，并完成单体 IM、分布式 IM 的实战设计。

 详尽地介绍了 ZooKeeper、Redis 的使用，以帮助提升高并发、可扩展能力

详情：https://www.cnblogs.com/crazymakercircle/p/16868827.html


```
疯狂创客圈
```
# 尼恩 Java 高并发三部曲（卷 2 加强版）

老版本：《Java 高并发核心编程卷 2 ：多线程、锁、JMM、JUC、高并发设计模式》
（已经过时，不建议购买）

###### 新版本：《Java 高并发核心编程卷 2 加强版 ：多线程、锁、JMM、JUC、高并发设计模式》

 由浅入深地剖析了 Java 多线程、线程池的底层原理。

 总结了 IO 密集型、CPU 密集型线程池的线程数预估算法。

 图文并茂的介绍了 Java 内置锁、JUC 显式锁的核心原理。

 细致深入地揭秘了 JMM 内存模型。

 全面介绍了 JUC 框架的设计模式与核心原理，并完成其高核心组件的实战介绍。

 详尽地介绍了高并发设计模式的使用，以帮助提升高并发、可扩展能力

详情参阅：https://www.cnblogs.com/crazymakercircle/p/16868827.html


```
疯狂创客圈
```
# 尼恩 Java 高并发三部曲（卷 3 加强版）

老版本：《SpringCloud Nginx 高并发核心编程》（已经过时，不建议购买）

###### 新版本：《Java 高并发核心编程卷 3 加强版 ：亿级用户 Web 应用架构与实战》

 在当今的面试场景中， 3 高知识是大家面试必备的核心知识，本书基于亿级用户 3 高 Web 应用

```
的架构分析理论，为大家对 3 高架构系统做一个系统化和清晰化的介绍。
```
 从 Java 静态代理、动态代理模式入手，抽丝剥茧地解读了 Spring Cloud 全家桶中 RPC 核心原

```
理和执行过程，这是高级Java工程师面试必备的基础知识。
```
 从 Reactor 反应器模式入手，抽丝剥茧地解读了 Nginx 核心思想和各配置项的底层知识和原理，

```
这是高级Java工程师、架构师面试必备的基础知识。
```
 从观察者模式入手，抽丝剥茧地解读了 RxJava、Hystrix 的核心思想和使用方法，这也是高级

```
Java工程师、架构师面试必备的基础知识。
```
详情：https://www.cnblogs.com/crazymakercircle/p/16868827.html


```
疯狂创客圈
```
# 尼恩 Java 面试宝典

35 个专题（卷王专供+ 史上最全 + 2023 面试必备）
详情：https://www.cnblogs.com/crazymakercircle/p/13917138.html


### 高性能核心组件穿透的意义

要想成为高手，就要穿透式、起底式、绞杀式的掌握顶级组件、王者组件。

**唯有如此，才能成为技术王者。**

从中吸取思想和精华，为大家自己的业务 CRUD 所有。

接下来，和尼恩一起，开始穿透之旅吧：

```
高性能核心组件之 1 ：
```
穿透“ **IO 之王 Netty** ” 架构和源码

```
穿透高性能核心组件之 2 ：
```
“ **队列之王 Disruptor** ” 架构和源码（Disruptor 红宝书）

```
穿透高性能核心组件之 3 ：
```
穿透“ **缓存之王 Caffeine** ” 架构和源码（Caffeine 红宝书）

```
穿透高性能核心组件之 4 ：
```
穿透“ **链路之王 Skywalking** ” 架构和源码

此文，带大家穿透高性能核心组件之 2 ：

**队列之王 Disruptor” 架构和源码（Disruptor 红宝书）**

所以，此文又名为:

**Disruptor 红宝书**

```
文章会不断升级，最新版本，请关注尼恩的朋友圈。
```
### disruptor 红宝书目的：

作为 Java 领域 **最高性能的队列** ，没有之一，大家不光要懂，而是需要 **深入骨髓的搞懂** 。

所以，给大家奉上了本书，并且配备了视频进行详细介绍，目的：

帮助，大家穿透一个绝对核心高性能 Java 高性能的队列的架构和原理，让 **面试题五体投地、顶礼膜
拜** 。

### 本书目录

```
高性能核心组件穿透的意义
```

disruptor 红宝书目的：
本书目录
**队列之王 Disruptor 简介**
Java 内置队列的问题
Disruptor 的使用场景
**1 前置知识：伪共享原理与实操**
CPU 的结构
缓存行 cache line
什么是伪共享（False Sharing）问题？
伪共享问题（False Sharing）的本质
伪共享问题的解决方案
一个缓冲行填充的例子
伪共享 False Sharing 在 java 8 中解决方案
伪共享性能比对实操：结论，差 6 倍
存在伪共享场景下的耗时计算
消除伪共享场景下的耗时计算
使用 unsafe 访问变量的耗时计算
性能总结
JDK 源码中如何解决伪共享问题
LongAdder 以及 Striped 64 如何解决伪共享问题
Cell 元素如何消除伪共享
对于伪共享，我们在实际开发中该怎么做？
3 Disruptor 框架是如何解决伪共享问题的？
Sequence 的结构和源码
**2 ：Disruptor 的使用实战**
定义一个 Event 和工厂
定义事件处理器（消费者）
定义事件源 (生产者)
组装起来
事件转换器
通过 Java 8 Lambda 使用 Disruptor
构造 Disruptor 对象的几个要点
Disruptor 如何实现高性能？
Disruptor 和 BlockingQueue 比较:
原理：Disruptor 的内部 Ring Buffer 环形队列
RingBuffer 是什么
Disruptor 使用环形队列的优势：
关闭 Disruptor
**3 ：Disruptor 的使用场景分析**
Disruptor 使用细分场景
单生产者多消费者并行场景
ProducerType 的类型
单生产者多消费者并行场景的参考代码
多生产者单消费者场景
ProducerType 的类型
多生产者场景的要点
多生产者场景的参考代码
单生产者多消费者竞争场景
disruptor 如何设置多个竞争消费者？
演示代码如下:
多个消费者串行消费场景
多个消费者串行消费场景案例
执行结果
菱形方式执行场景
场景特点
菱形方式执行场景案例
链式并行执行场景
场景特点


场景案例
多组消费者相互隔离场景
场景特点
场景案例
多组消费者航道执行模式
场景特点
场景案例
六边形执行顺序
场景特点
参考代码
执行结果
**4 ：架构师视角，深入 Disruptor 源码分析**
核心概念
Ring Buffer
Sequence
Sequencer
Sequence Barrier
Wait Strategy
Event
EventProcessor
EventHandler
Producer
RingBuffer
Disruptor
Disruptor 的无锁架构
**如何管理消费者和生产者之间的依赖关系呢？**
如何管理消费者与消费者之间的依赖关系呢？
依赖关系管理的例子
**如何避免未消费事件的写入覆盖呢？**
Disruptor 的总体模块架构
核心类 Sequence
核心类 Sequencer
Sequencer 的实现类
SingleProducerSequencer
MultiProducerSequencer
核心类消费者仓库和消费者信息
消费者仓库 ConsumerRepository
消费者的信息 ConsumerInfo
消费者的信息实现类
WorkerPoolInfo 多线程消费者信息
消费者处理器
BatchEventProcessor 单线程批处理事件
事件消费者组 EventHandlerGroup
SequenceBarrier 协调屏障
disrutor 管理两种依赖关系
消除锁和 CAS 操作
SequenceBarrier 的几个方法
SequenceBarrier 进行依赖消费
ProcessingSequenceBarrier
RingBuffer 预分配内存
Disruptor 的等待策略
uml 图
SleepingWaitStrategy
源码
YieldingWaitStrategy
源码
BusySpinW 4 aitStrategy
Disruptor 的缓存行填充


```
队列 有界性 锁 数据结构
```
```
ArrayBlockingQueue bounded 加锁 arraylist
```
```
LinkedBlockingQueue optionally-bounded 加锁 linkedlist
```
```
ConcurrentLinkedQueue unbounded 无锁 linkedlist
```
```
LinkedTransferQueue unbounded 无锁 linkedlist
```
```
PriorityBlockingQueue unbounded 加锁 heap
```
```
DelayQueue unbounded 加锁 heap
```
```
RingBuffer 的缓存行填充
Sequence是如何消除伪共享的
参考文献
```
## 队列之王 Disruptor 简介

Disruptor 是英国外汇交易公司 LMAX 开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题
（在性能测试中发现竟然与 I/O 操作处于同样的数量级）。

基于 Disruptor 开发的系统单线程能支撑每秒 600 万订单， 2010 年在 QCon 演讲后，获得了业界关注。

2011 年，企业应用软件专家 Martin Fowler 专门撰写长文介绍 Disruptor。

2011 年，Disruptor 还获得了 Oracle 官方的 **Duke 大奖** 。

目前，包括 Apache Storm、Camel、Log 4 j 2 在内的很多知名项目都应用了 Disruptor 以获取高性能。

要深入了解 disruptor ，咱们从 Java 的内置队列开始介绍起。

### Java 内置队列的问题

介绍 Disruptor 之前，我们先来看一看常用的线程安全的内置队列有什么问题。

Java 的内置队列如下表所示。

队列的底层一般分成三种：数组、链表和堆。

其中，堆一般情况下是为了实现带有优先级特性的队列，

```
暂时不做介绍，后面讲netty 定时任务的时候，再介绍。
```
从数组和链表两种数据结构来看，两类结构如下：

```
基于数组线程安全的队列，比较典型的是ArrayBlockingQueue，它主要通过加锁的方式来保证线
程安全；
基于链表的线程安全队列分成LinkedBlockingQueue和ConcurrentLinkedQueue两大类，前者也
通过锁的方式来实现线程安全，而后者通过原子变量compare and swap（以下简称“CAS”）这种
无锁方式 来实现的。
```

和 ConcurrentLinkedQueue 一样，上面表格中的 LinkedTransferQueue 都是通过原子变量 compare
and swap（以下简称“CAS”）这种不加锁的方式来实现的

但是，对 volatile 类型的变量进行 CAS 操作，存在伪共享问题，

### Disruptor 的使用场景

Disruptor 它可以用来作为高性能的有界内存队列，适用于两大场景：

```
生产者消费者场景
发布订阅 场景
```
生产者消费者场景。Disruptor 的最常用的场景就是“生产者-消费者”场景，对场景的就是“一个生产者、
多个消费者”的场景，并且要求顺序处理。

```
备注，这里和JCTool 的 MPSC 队列，刚好相反， MPSC 使用于多生产者，单消费者场景
```
发布订阅场景：Disruptor 也可以认为是观察者模式的一种实现，实现发布订阅模式。

当前业界开源组件使用 Disruptor 的包括 Log 4 j 2、Apache Storm 等，

## 1 前置知识：伪共享原理与实操

在介绍无锁框架 disruptor 之前，作为前置的知识，首先给大家介绍伪共享原理&性能对比实战。

### CPU 的结构

下图是计算的基本结构。

L 1、L 2、L 3 分别表示一级缓存、二级缓存、三级缓存，越靠近 CPU 的缓存，速度越快，容量也越小。

```
L1缓存很小但很快，并且紧靠着在使用它的CPU内核；
L2大一些，也慢一些，并且仍然只能被一个单独的CPU核使用；
L3更大、更慢，并且被单个插槽上的所有CPU核共享；
最后是主存，由全部插槽上的所有CPU核共享。
```

级别越小的缓存，越接近 CPU，意味着速度越快且容量越少。

L 1 是最接近 CPU 的，它容量最小 **（比如 256 个字节）** ，速度最快，

每个核上都有一个 L 1 Cache (准确地说每个核上有两个 L 1 Cache，一个存数据 L 1 d Cache，一个存指令
L 1 i Cache)；

L 2 Cache 更大一些 **（比如 256 K 个字节）** ，速度要慢一些，一般情况下每个核上都有一个独立的 L
Cache；

二级缓存就是一级缓存的存储器：

```
一级缓存制造成本很高因此它的容量有限，二级缓存的作用就是存储那些CPU处理时需要用到、
一级缓存又无法存储的数据。
```
L 3 Cache 是三级缓存中最大的一级，例如 **（比如 12 MB 个字节）** ，同时也是最慢的一级，在同一个 CPU
插槽之间的核共享一个 L 3 Cache。

三级缓存和内存可以看作是二级缓存的存储器，它们的容量递增，但 **单位制造成本却递减** 。

**L 3 Cache 和 L 1，L 2 Cache 有着本质的区别。**

L 1 和 L 2 Cache 都是每个 CPU core 独立拥有一个，而 L 3 Cache 是几个 Cores 共享的，可以认为是一个更
小但是更快的内存。

### 缓存行 cache line

为了提高 IO 效率，CPU 每次从内存读取数据，并不是只读取我们需要计算的数据，而是一批一批去读取
的，这一批数据，也叫 Cache Line（缓存行）。

也可以理解为 **批量读取，提升性能** 。为啥要一批、一批的读取呢？ **这也满足空间的局部性原理（具体
请参见葵花宝典）。**

从读取的角度来说，缓存，是由缓存行 Cache Line 组成的。

所以使用缓存时，并不是一个一个字节使用，而是一行缓存行、一行缓存行这样使用；


换句话说，CPU 存取缓存都是按照一行，为最小单位操作的。并不是按照字节为单位，进行操作的。

一般而言，读取一行数据时，是将我们需要的数据周围的连续数据一次性全部读取到缓存中。这段连续
的数据就称为一个 **缓存行** 。

一般一行缓存行有 64 字节。intel 处理器的缓存行是 64 字节。目前主流的 CPU Cache 的 Cache Line 大小
都是 64 Bytes。

假设我们有一个 512 Bytes 的一级缓存，那么按照 64 Bytes 的缓存单位大小来算，这个一级缓存所能存
放的缓存个数就是 512/64 = 8 个。

所以，Cache Line 可以简单的理解为 CPU Cache 中的最小缓存单位。

这些 CPU Cache 的写回和加载，都不是以一个变量作为单位。这些都是以整个 Cache Line 作为单位。

如果一个常量和变量放在一行，那么变量的更新，也会影响常量的使用：


CPU 在加载数据时，整个缓存行过期了，加载常量的时候，自然也会把这个数据从内存加载到高速缓
存。

### 什么是伪共享（False Sharing）问题？

```
提前说明： 翻译 有瑕疵， 伪共享（False Sharing）， 应该翻译为 “错共享”， 才更准确
```
CPU 的缓存系统是以缓存行 (cache line) 为单位存储的，一般的大小为 64 bytes。

在多线程程序的执行过程中，存在着一种情况，多个需要频繁修改的变量存在同一个缓存行当中。

```
假设：有两个线程分别访问并修改X和Y这两个变量，X和Y恰好在同一个缓存行上，这两个线程分
别在不同的CPU上执行。
```
```
那么每个CPU分别更新好X和Y时将缓存行刷入内存时，发现有别的修改了各自缓存行内的数据，
这时缓存行会失效，从L3中重新获取。
```
```
这样的话，程序执行效率明显下降。
```
为了减少这种情况的发生，其实就是避免 X 和 Y 在同一个缓存行中，

```
如何操作呢？可以主动添加一些无关变量将缓存行填充满，
```
比如在 X 对象中添加一些变量，让它有 64 Byte 那么大，正好占满一个缓存行。


两个线程（Thread 1 和 Thread 2）同时修改一个同一个缓存行上的数据 X Y:

如果线程 1 打算更改 a 的值，而线程 2 准备更改 b 的值：

由 x 值被更新了，所以 x 值需要在线程 1 和线程 2 之间传递（从线程 1 到线程 2 ），

```
x、y的变更，都会引起 cache line 整块 64 bytes 被刷新，因为cpu核之间以cache line的形式交
换数据(cache lines的大小一般为64bytes)。
```
在并发执行的场景下，每个线程在不同的核中被处理。

```
假设 x,y是两个频繁修改的变量，x,y，还位于同一个缓存行.
```
如果，CPU 1 修改了变量 x 时，L 3 中的缓存行数据就失效了，也就是 CPU 2 中的缓存行数据也失效了，
CPU 2 需要的 y 需要重新从内存加载。

如果，CPU 2 修改了变量 y 时，L 3 中的缓存行数据就失效了，也就是 CPU 1 中的缓存行数据也失效了，
CPU 1 需要的 x 需要重新从内存加载。

```
Thread1：x=3;
```
```
Thread2：y=2;
```

```
x,y在两个cpu上进行修改，本来应该是互不影响的，但是由于缓存行在一起，导致了相互受到了
影响。
```
### 伪共享问题（False Sharing）的本质

出现伪共享问题（False Sharing）的原因：

```
一个缓存行可以存储多个变量（存满当前缓存行的字节数）； 64 个字节可以放 8 个long， 16 个int
而CPU对缓存的修改又是以缓存行为最小单位的； 不是以long 、byte这样的数据类型为单位的
在多线程情况下，如果需要修改“共享同一个缓存行的其中一个变量”，该行中其他变量的状态 就
会失效，甚至进行一致性保护
```
所以，伪共享问题（False Sharing）的本质是：

**对缓存行中的单个变量进行修改了，导致整个缓存行其他不相关的数据也就失效了，需要从主存重新加
载**

**如果其中有 volatile 修饰的变量，需要保证线程可见性的变量，还需要进入缓存与数据一致性的保障
流程，如 mesi 协议的数据一致性保障用了其他变量的 Core 的缓存一致性。**

缓存一致性是根据缓存行为单元来进行同步的，假如 y 是 volatile 类型的，假如 a 修改了 x，而其他的线
程用到 y，虽然用到的不是同一个数据，但是他们（数据 X 和数据 Y）在同一个缓存行中，其他的线程的
缓存需要保障数据一致性而进行数据同步，当然，同步也需要时间。

一个 CPU 核心在加载一个缓存行时要执行上百条指令。如果一个核心要等待另外一个核心来重新加载缓
存行，那么他就必须等在那里，称之为 stall (停止运转)。

### 伪共享问题的解决方案

减少伪共享也就意味着减少了 stall 的发生，其中一个手段就是通过填充 (Padding) 数据的形式，来保
证本应有可能位于同一个缓存行的两个变量，在被多线程访问时必定位于不同的缓存行。

简单的说，就是以 **空间换时间** ： 使用占位字节，将变量的所在的缓冲行塞满。

disruptor 无锁框架就是这么干的。

### 一个缓冲行填充的例子

下面是一个填充了的缓存行的，尝试 p 1, p 2, p 3, p 4, p 5, p 6 为 AtomicLong 的 value 的缓存行占位，将
AtomicLong 的 value 变量的所在的缓冲行塞满，

代码如下:

```
package com.crazymakercircle.demo.cas;
```
```
import java.util.concurrent.atomic.AtomicLong;
```

例子的部分结果如下：

### 伪共享 False Sharing 在 java 8 中解决方案

JAVA 8 中添加了一个@Contended 的注解，添加这个的注解，将会在自动进行缓存行填充。

```
public class PaddedAtomicLong extends AtomicLong {
private static final long serialVersionUID = - 3415778863941386253L;
```
```
/**
* Padded 6 long (48 bytes)
*/
public volatile long p1, p2, p3, p4, p5, p6 = 7L;
```
```
/**
* Constructors from {@link AtomicLong}
*/
public PaddedAtomicLong() {
super();
}
```
```
public PaddedAtomicLong(long initialValue) {
super(initialValue);
}
```
```
/**
* To prevent GC optimizations for cleaning unused padded references
*/
public long sumPaddingToPreventOptimization() {
return p1 + p2 + p3 + p4 + p5 + p6;
}
```
```
}
```
```
printable = com.crazymakercircle.basic.demo.cas.busi.PaddedAtomicLong object
internals:
OFFSET SIZE TYPE DESCRIPTION VALUE
 0 4 (object header) 01 00 00 00
( 00000001 00000000 00000000 00000000 ) ( 1 )
 4 4 (object header) 00 00 00 00
( 00000000 00000000 00000000 00000000 ) ( 0 )
 8 4 (object header) 50 08 01 f
( 01010000 00001000 00000001 11111000 ) (- 134150064 )
12 4 (alignment/padding gap)
16 8 long AtomicLong.value  
24 8 long PaddedAtomicLong.p1 0
32 8 long PaddedAtomicLong.p2 0
40 8 long PaddedAtomicLong.p3 0
48 8 long PaddedAtomicLong.p4 0
56 8 long PaddedAtomicLong.p5 0
64 8 long PaddedAtomicLong.p6 7
```
```
Instance size: 72 bytes
Space losses: 4 bytes internal + 0 bytes external = 4 bytes total
```

下面有一个@Contended 的例子：

以上代码使得 padVar 和 notPadVar 都在不同的 cache line 中。@Contended 使得 notPadVar 字段远离了
对象头部分。

```
package com.crazymakercircle.basic.demo.cas.busi;
import sun.misc.Contended;
public class ContendedDemo
{
//有填充的演示成员
@Contended
public volatile long padVar;
```
```
//没有填充的演示成员
public volatile long notPadVar;
```
```
}
```

执行时，必须加上虚拟机参数-XX:-RestrictContended，@Contended 注释才会生效。

很多文章把这个漏掉了，那样的话实际上就没有起作用。

新的结果；

```
printable = com.crazymakercircle.basic.demo.cas.busi.ContendedDemo object
internals:
OFFSET SIZE TYPE DESCRIPTION VALUE
 0 4 (object header) 01 00 00 00 ( 00000001 00000000
00000000 00000000 ) ( 1 )
 4 4 (object header) 00 00 00 00 ( 00000000 00000000
00000000 00000000 ) ( 0 )
 8 4 (object header) 50 08 01 f8 ( 01010000 00001000
00000001 11111000 ) (- 134150064 )
12 4 (alignment/padding gap)
16 8 long ContendedDemo.padVar  0
24 8 long ContendedDemo.notPadVar 0
Instance size: 32 bytes
Space losses: 4 bytes internal + 0 bytes external = 4 bytes total
```
```
printable = com.crazymakercircle.basic.demo.cas.busi.ContendedDemo object
internals:
OFFSET SIZE TYPE DESCRIPTION VALUE
 0 4 (object header) 01 00 00 00 ( 00000001 00000000
00000000 00000000 ) ( 1 )
 4 4 (object header) 00 00 00 00 ( 00000000 00000000
00000000 00000000 ) ( 0 )
 8 4 (object header) 50 08 01 f8 ( 01010000 00001000
00000001 11111000 ) (- 134150064 )
12 4 (alignment/padding gap)
16 8 long ContendedDemo.notPadVar 0
24 128 (alignment/padding gap)
 152 8 long ContendedDemo.padVar  0
 160 128 (loss due to the next object alignment)
Instance size: 288 bytes
Space losses: 132 bytes internal + 128 bytes external = 260 bytes total
```

在 Java 8 中，使用@Contended 注解的对象或字段的前后各增加 128 字节大小的 padding，使用 2 倍于大
多数硬件缓存行的大小来避免相邻扇区预取导致的伪共享冲突。我们目前的缓存行大小一般为 64 Byte，
这里 Contended 注解为我们前后加上了 128 字节绰绰有余。

```
注意：如果想要@Contended注解起作用，需要在启动时添加JVM参数-XX:-RestrictContended
参数后 @sun.misc.Contended 注解才有。
```
可见至少在 JDK 1.8 以上环境下，只有@Contended 注解才能解决伪共享问题，但是消耗也很大，占用
了宝贵的缓存，用的时候要谨慎。

另外：

```
@Contended 注释还可以添加在类上，每一个成员，都会加上。
```
### 伪共享性能比对实操：结论，差 6 倍

三个实操：

```
首先存在伪共享场景下的 耗时计算
其次是消除伪共享场景下的 耗时计算
再次是使用unsafe访问变量时的耗时计算
```
##### 存在伪共享场景下的耗时计算

entity 类

并行的执行数据修改， **这里抽取成为了一个通用的方法**


测试用例

执行的时间

##### 消除伪共享场景下的耗时计算


entity 类

测试用例

消除伪共享场景下的耗时计算 （550 ms）


##### 使用 unsafe 访问变量的耗时计算

entity

使用 unsafe 访问变量的耗时计算:

**54 ms**


##### 性能总结

**消除伪共享场景，比存在伪共享场景的性能，性能提升 6 倍左右**

```
实验数据，从 3000ms 提升 到 500ms
```
**使用 unsafe 取消内存可见性，比消除伪共享场景，性能提升 10 倍左右**

```
实验数据，从 500ms 提升 到 50ms
```
通过实验的对比，可见 Java 的性能，是可以大大优化的，尤其在高性能组件

```
以上实操的 详细介绍 ，请参见 《100wqps 日志平台实操》
```
### JDK 源码中如何解决伪共享问题

在 LongAdder 在 java 8 中的实现已经采用了@Contended。

##### LongAdder 以及 Striped 64 如何解决伪共享问题

LongAdder 是大家常用的高并发累加器

通过分而治之的思想，实现超高并发累加。

LongAdder 的结构如下：


Striped 64 是在 java 8 中添加用来支持累加器的并发组件，它可以在并发环境下使用来做某种计数，

Striped 64 的设计思路是在竞争激烈的时候尽量分散竞争，

Striped 64 维护了一个 base Count 和一个 Cell 数组，计数线程会首先试图更新 base 变量，如果成功则退
出计数，否则会认为当前竞争是很激烈的，那么就会通过 Cell 数组来分散计数，

Striped 64 根据线程来计算哈希，然后将不同的线程分散到不同的 Cell 数组的 index 上，然后这个线程的
计数内容就会保存在该 Cell 的位置上面，

基于这种设计，最后的总计数需要结合 base 以及散落在 Cell 数组中的计数内容。

这种设计思路类似于 java 7 的 ConcurrentHashMap 实现，也就是所谓的分段锁算法，
ConcurrentHashMap 会将记录根据 key 的 hashCode 来分散到不同的 segment 上，

线程想要操作某个记录，只需要锁住这个记录对应着的 segment 就可以了，而其他 segment 并不会被锁
住，其他线程任然可以去操作其他的 segment，

这样就显著提高了并发度，

虽然如此，java 8 中的 ConcurrentHashMap 实现已经抛弃了 java 7 中分段锁的设计，而采用更为轻量级
的 CAS 来协调并发，效率更佳。

##### Cell 元素如何消除伪共享

Striped 64 中的 Cell 元素，是如何消除伪共享的呢？


可以打印一下 cell 的内存结构

当然，别忘记加上 vm 选项：-XX:-RestrictContended


### 对于伪共享，我们在实际开发中该怎么做？

通过上面大篇幅的介绍，我们已经知道伪共享的对程序的影响。

那么，在实际的生产开发过程中，我们一定要通过缓存行填充去解决掉潜在的伪共享问题吗？

其实并不一定。

首先就是多次强调的，伪共享是很隐蔽的，我们暂时无法从系统层面上通过工具来探测伪共享事件。

其次，不同类型的计算机具有不同的微架构（如 32 位系统和 64 位系统的 java 对象所占自己数就不一
样），如果设计到跨平台的设计，那就更难以把握了，一个确切的填充方案只适用于一个特定的操作系
统。

还有，缓存的资源是有限的，如果填充会浪费珍贵的 cache 资源，并不适合大范围应用。

### 3 Disruptor 框架是如何解决伪共享问题的？

在 Disruptor 中有一个重要的类 Sequence，该类包装了一个 volatile 修饰的 long 类型数据 value，

##### Sequence 的结构和源码

无论是 Disruptor 中的基于数组实现的缓冲区 RingBuffer，还是生产者，消费者，都有各自独立的
Sequence，

Sequence 的用途是啥呢？


```
在RingBuffer缓冲区中，Sequence标示着写入进度，例如每次生产者要写入数据进缓冲区时，都
要调用RingBuffer.next（）来获得下一个可使用的相对位置。
对于生产者和消费者来说，Sequence标示着它们的事件序号。
```
Sequence 的结构图如下

来看看 Sequence 类的源码：


## 2 ：Disruptor 的使用实战

我们从一个简单的例子开始学习 Disruptor：

生产者传递一个 long 类型的值给消费者，而消费者消费这个数据的方式仅仅是把它打印出来。

##### 定义一个 Event 和工厂

首先定义一个 Event 来包含需要传递的数据：

```
class LhsPadding {
protected long p1, p2, p3, p4, p5, p6, p7;
}
```
```
class Value extends LhsPadding {
protected volatile long value;
}
```
```
class RhsPadding extends Value {
protected long p9, p10, p11, p12, p13, p14, p15;
}
```
```
public class Sequence extends RhsPadding {
static final long INITIAL_VALUE = -1L;
private static final Unsafe UNSAFE;
private static final long VALUE_OFFSET;
static {
UNSAFE = Util.getUnsafe();
try {
VALUE_OFFSET =
UNSAFE.objectFieldOffset(Value.class.getDeclaredField("value"));
} catch(final Exception e) {
throw new RuntimeException(e);
}
}
```
```
public Sequence() {
this(INITIAL_VALUE);
}
```
```
public Sequence(final long initialValue) {
UNSAFE.putOrderedLong(this, VALUE_OFFSET, initialValue);
}
```
```
}
```

由于需要让 Disruptor 为我们创建事件，我们同时还声明了一个 EventFactory 来创建 Event 对象。

##### 定义事件处理器（消费者）

我们还需要一个事件消费者，也就是一个事件处理器。

这个例子中，事件处理器的工作，就是简单地把事件中存储的数据打印到终端：

disruptor 会回调此处理器的方法

##### 定义事件源 (生产者)

事件都会有一个生成事件的源，类似于生产者的角色，

如何产生事件，然后发出事件呢？

通过从环形队列中获取序号，通过序号获取对应的事件对象，将数据填充到事件对象，再通过序
号将事件对象发布出去。

一段生产者的代码如下：

```
public class LongEvent {
private long value;
public long getValue() {
return value;
}
```
```
public void setValue(long value) {
this.value = value;
}
}
```
```
public class LongEventFactory implements EventFactory {
@Override
public Object newInstance() {
return new LongEvent();
}
}
```
```
/**
* 类似于消费者
* disruptor会回调此处理器的方法
*/
static class LongEventHandler implements EventHandler<LongEvent> {
@Override
public void onEvent(LongEvent longEvent, long l, boolean b) throws
Exception {
System.out.println(longEvent.getValue());
}
}
```
```
// 事件生产者：业务代码
// 通过从 环形队列中 获取 序号， 通过序号获取 对应的 事件对象， 将数据填充到 事件对象，再
通过 序号将 事件对象 发布出去。
```

很明显的是：

当用一个简单队列来发布事件的时候会牵涉更多的细节，这是因为事件对象还需要预先创建。

发布事件最少需要三步：

step 1：获取下一个事件槽。

如果我们使用 RingBuffer.next () 获取一个事件槽，那么一定要发布对应的事件。

step 2: 通过序号获取对应的事件对象，将数据填充到事件对象，

step 3: 再通过序号将事件对象发布出去。

发布事件的时候要使用 try/finnally 保证事件一定会被发布

如果不能发布事件，那么就会引起 Disruptor 状态的混乱。

尤其是在多个事件生产者的情况下会导致事件消费者失速，从而不得不重启应用才能会恢复。

Disruptor 3.0 提供了 lambda 式的 API。

这样可以把一些复杂的操作放在 Ring Buffer，所以在 Disruptor 3.0 以后的版本最好使用 Event Publisher
或者 Event Translator (事件转换器) 来发布事件。

```
static class LongEventProducer {
private final RingBuffer<LongEvent> ringBuffer;
```
```
public LongEventProducer(RingBuffer<LongEvent> ringBuffer) {
this.ringBuffer = ringBuffer;
}
```
```
/**
* onData用来发布事件，每调用一次就发布一次事件事件
* 它的参数会通过事件传递给消费者
*
* @param data
*/
public void onData(long data) {
```
```
// step1：通过从 环形队列中 获取 序号
//可以把ringBuffer看做一个事件队列，那么next就是得到下面一个事件槽
long sequence = ringBuffer.next();
```
```
try {
```
```
//step2: 通过序号获取 对应的 事件对象， 将数据填充到 事件对象，
//用上面的索引，取出一个空的事件用于填充
LongEvent event = ringBuffer.get(sequence);// for the sequence
event.setValue(data);
} finally {
```
```
//step3: 再通过 序号将 事件对象 发布出去。
//发布事件
ringBuffer.publish(sequence);
}
}
}
```

##### 组装起来

最后一步就是把所有的代码组合起来完成一个完整的事件处理系统。

##### 事件转换器

Disruptor 3.0 以后 , 提供了事件转换器，帮助填充 LongEvent 的业务数据

下面是一个例子

```
@org.junit.Test
public void testSimpleDisruptor() throws InterruptedException {
// 消费者线程池
Executor executor = Executors.newCachedThreadPool();
// 事件工厂
LongEventFactory eventFactory = new LongEventFactory();
// 环形队列大小， 2 的指数
int bufferSize = 1024 ;
```
```
// 构造 分裂者 （事件分发者）
Disruptor<LongEvent> disruptor = new Disruptor<LongEvent>(eventFactory,
bufferSize, executor);
```
```
// 连接 消费者 处理器
disruptor.handleEventsWith(new LongEventHandler());
// 开启 分裂者（事件分发）
disruptor.start();
```
```
// 获取环形队列，用于生产 事件
RingBuffer<LongEvent> ringBuffer = disruptor.getRingBuffer();
```
```
LongEventProducer producer = new LongEventProducer(ringBuffer);
```
```
for (long i = 0 ; true; i++) {
//发布事件
producer.onData(i);
Thread.sleep( 1000 );
}
}
```
```
static class LongEventProducerWithTranslator {
//一个translator可以看做一个事件初始化器，publicEvent方法会调用它
//填充Event
private static final EventTranslatorOneArg<LongEvent, Long> TRANSLATOR =
new EventTranslatorOneArg<LongEvent, Long>() {
public void translateTo(LongEvent event, long sequence, Long
data) {
event.setValue(data);
}
};
```
```
private final RingBuffer<LongEvent> ringBuffer;
```
```
public LongEventProducerWithTranslator(RingBuffer<LongEvent> ringBuffer)
{
```

使用事件转换器的好处，省了从环形队列获取序号，然后拿到事件填充数据，再发布序号中的第二
步骤

给事件填充数据的动作，在 EventTranslatorOneArg 完成

Disruptor 提供了不同的接口去产生一个 Translator 对象：

```
EventTranslator,
EventTranslatorOneArg,
EventTranslatorTwoArg,
```
很明显，Translator 中方法的参数是通过 RingBuffer 来传递的。

使用事件转换器转换器的进行事件的生产与消费代码，大致如下：

上面写法的另一个好处是，Translator 可以分离出来并且更加容易单元测试。

```
this.ringBuffer = ringBuffer;
}
```
```
public void onData(Long data) {
ringBuffer.publishEvent(TRANSLATOR, data);
}
}
```
```
@org.junit.Test
public void testSimpleDisruptorWithTranslator() throws InterruptedException
{
// 消费者线程池
Executor executor = Executors.newCachedThreadPool();
// 事件工厂
LongEventFactory eventFactory = new LongEventFactory();
// 环形队列大小， 2 的指数
int bufferSize = 1024;
```
```
// 构造 分裂者 （事件分发者）
Disruptor<LongEvent> disruptor = new Disruptor<LongEvent>(eventFactory,
bufferSize, executor);
```
```
// 连接 消费者 处理器
disruptor.handleEventsWith(new LongEventHandler());
// 开启 分裂者（事件分发）
disruptor.start();
```
```
// 获取环形队列，用于生产 事件
RingBuffer<LongEvent> ringBuffer = disruptor.getRingBuffer();
```
```
LongEventProducerWithTranslator producer = new
LongEventProducerWithTranslator(ringBuffer);
```
```
for (long i = 0; true; i++) {
//发布事件
producer.onData(i);
Thread.sleep(1000);
}
}
```

##### 通过 Java 8 Lambda 使用 Disruptor

Disruptor 在自己的接口里面添加了对于 Java 8 Lambda 的支持。

大部分 Disruptor 中的接口都符合 Functional Interface 的要求（也就是在接口中仅仅有一个方法）。

所以在 Disruptor 中，可以广泛使用 Lambda 来代替自定义类。

由于在 Java 8 中方法引用也是一个 lambda，因此还可以把上面的代码改成下面的代码：

```
@org.junit.Test
public void testSimpleDisruptorWithLambda() throws InterruptedException {
// 消费者线程池
Executor executor = Executors.newCachedThreadPool();
// 环形队列大小， 2 的指数
int bufferSize = 1024 ;
```
```
// 构造 分裂者 （事件分发者）
Disruptor<LongEvent> disruptor = new Disruptor<LongEvent>
(LongEvent::new, bufferSize, executor);
```
```
// 连接 消费者 处理器
// 可以使用lambda来注册一个EventHandler
disruptor.handleEventsWith((event, sequence, endOfBatch) ->
System.out.println("Event: " + event.getValue()));
// 开启 分裂者（事件分发）
disruptor.start();
```
```
// 获取环形队列，用于生产 事件
RingBuffer<LongEvent> ringBuffer = disruptor.getRingBuffer();
```
```
LongEventProducerWithTranslator producer = new
LongEventProducerWithTranslator(ringBuffer);
```
```
for (long i = 0 ; true; i++) {
//发布事件
producer.onData(i);
Thread.sleep( 1000 );
}
}
```
```
public static void handleEvent(LongEvent event, long sequence, boolean
endOfBatch)
{
System.out.println(event.getValue());
}
```
```
@org.junit.Test
public void testSimpleDisruptorWithMethodRef() throws InterruptedException {
// 消费者线程池
Executor executor = Executors.newCachedThreadPool();
// 环形队列大小， 2 的指数
int bufferSize = 1024 ;
```

### 构造 Disruptor 对象的几个要点

在构造 Disruptor 对象，有几个核心的要点：
1 ：事件工厂 (Event Factory) 定义了如何实例化事件 (Event)，Disruptor 通过 EventFactory 在
RingBuffer 中预创建 Event 的实例。
2 ：ringBuffer 这个数组的大小，一般根据业务指定成 2 的指数倍。
3 ：消费者线程池，事件的处理是在构造的线程池里来进行处理的。
4 ：指定等待策略，Disruptor 定义了 com. lmax. disruptor. WaitStrategy 接口用于抽象 **Consumer 如
何等待 Event 事件** 。

Disruptor 提供了多个 WaitStrategy 的实现，每种策略都具有不同性能和优缺点，根据实际运行环境的
CPU 的硬件特点选择恰当的策略，并配合特定的 JVM 的配置参数，能够实现不同的性能提升。

```
BlockingWaitStrategy 是最低效的策略，但其对 CPU的消耗最小 并且在各种不同部署环境中能提
供更加一致的性能表现；
SleepingWaitStrategy 的性能表现跟 BlockingWaitStrategy 差不多，对 CPU 的消耗也类似，但其
对生产者线程的影响最小，适合用于异步日志类似的场景；
YieldingWaitStrategy 的性能是最好的，适合用于低延迟的系统。在要求极高性能且 事件处理线数
小于 CPU 逻辑核心数的场景中 ，推荐使用此策略；。
```
### Disruptor 如何实现高性能？

使用 Disruptor，主要用于对性能要求高、延迟低的场景，它通过“榨干”机器的性能来换取处理的高性
能。

```
// 构造 分裂者 （事件分发者）
Disruptor<LongEvent> disruptor = new Disruptor<LongEvent>
(LongEvent::new, bufferSize, executor);
```
```
// 连接 消费者 处理器
// 可以使用lambda来注册一个EventHandler
disruptor.handleEventsWith(LongEventDemo::handleEvent);
// 开启 分裂者（事件分发）
disruptor.start();
```
```
// 获取环形队列，用于生产 事件
RingBuffer<LongEvent> ringBuffer = disruptor.getRingBuffer();
```
```
LongEventProducerWithTranslator producer = new
LongEventProducerWithTranslator(ringBuffer);
```
```
for (long i = 0 ; true; i++) {
//发布事件
producer.onData(i);
Thread.sleep( 1000 );
}
}
}
```

Disruptor 实现高性能主要体现了去掉了锁，采用 CAS 算法，同时内部通过环形队列实现有界队列。

```
环形数据结构
数组元素不会被回收，避免频繁的GC，所以，为了避免垃圾回收，采用数组而非链表。
同时，数组对处理器的缓存机制更加友好。
元素位置定位
数组长度2^n，通过位运算，加快定位的速度。
下标采取递增的形式。不用担心index溢出的问题。
index是long类型，即使 100 万QPS的处理速度，也需要 30 万年才能用完。
无锁设计
采用CAS无锁方式，保证线程的安全性
每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位
置写入或者读取数据。整个过程通过原子变量CAS，保证操作的线程安全。
```
```
属性填充：
通过添加额外的无用信息，避免伪共享问题
```
##### Disruptor 和 BlockingQueue 比较:

```
BlockingQueue: FIFO队列.生产者Producer向队列中发布publish一个事件时,消费者Consumer
能够获取到通知.如果队列中没有消费的事件,消费者就会被阻塞,直到生产者发布新的事件
Disruptor可以比BlockingQueue做到更多:
Disruptor队列中同一个事件可以有多个消费者,消费者之间既可以并行处理,也可以形成依赖
图相互依赖,按照先后次序进行处理
Disruptor可以预分配用于存储事件内容的内存空间
Disruptor使用极度优化和无锁的设计实现极高性能的目标
```
如果你的项目有对性能要求高，对延迟要求低的需求，并且需要一个无锁的有界队列，来实现生产者/
消费者模式，那么 Disruptor 是你的不二选择。

### 原理：Disruptor 的内部 Ring Buffer 环形队列

##### RingBuffer 是什么

RingBuffer 是一个环 (首尾相连的环)，用做在不同上下文 (线程) 间传递数据的 buffer。

RingBuffer 拥有一个序号，这个序号指向数组中下一个可用元素。


##### Disruptor 使用环形队列的优势：

Disruptor 框架就是一个使用 CAS 操作的内存队列，与普通的队列不同，

Disruptor 框架使用的是一个基于数组实现的环形队列，无论是生产者向缓冲区里提交任务，还是消费
者从缓冲区里获取任务执行，都使用 CAS 操作。

使用环形队列的优势：

第一，简化了多线程同步的复杂度。

学数据结构的时候，实现队列都要两个指针 head 和 tail 来分别指向队列的头和尾，对于一般的队列是这
样，

想象下，如果有多个生产者同时往缓冲区队列中提交任务，某一生产者提交新任务后，tail 指针都要做
修改的，那么多个生产者提交任务，头指针不会做修改，但会对 tail 指针产生冲突，

例如某一生产者 P 1 要做写入操作，在获得 tail 指针指向的对象值 V 后，执行 compareAndSet（）方法
前，tail 指针被另一生产者 P 2 修改了，这时生产者 P 1 执行 compareAndSet（）方法，发现 tail 指针指向
的值 V 和期望值 E 不同，导致冲突。

同样，如果多个消费者不断从缓冲区中获取任务，不会修改尾指针，但会造成队列头指针 head 的冲突
问题（因为队列的 FIFO 特点，出列会从头指针出开始）。

环形队列的一个特点就是只有一个指针，只通过一个指针来实现出列和入列操作。

如果使用两个指针 head 和 tail 来管理这个队列，有可能会出现“伪共享”问题（伪共享问题在下面我会详
细说），

因为创建队列时，head 和 tail 指针变量常常在同一个缓存行中，多线程修改同一缓存行中的变量就容易
出现伪共享问题。

第二，由于使用的是环形队列，那么队列创建时大小就被固定了，

Disruptor 框架中的环形队列本来也就是基于数组实现的，使用数组的话，减少了系统对内存空间管理
的压力，

因为数组不像链表，Java 会定期回收链表中一些不再引用的对象，而数组不会出现空间的新分配和回收
问题。

### 关闭 Disruptor

```
disruptor.shutdown() : 关闭 Disruptor. 方法会阻塞,直至所有的事件都得到处理
executor.shutdown() : 关闭 Disruptor 使用的线程池. 如果线程池需要关闭,必须进行手动关闭
,Disruptor 在 shutdown 时不会自动关闭使用的线程池
```

## 3 ：Disruptor 的使用场景分析

Disruptor 它可以用来作为高性能的有界内存队列，适用于两大场景：

```
生产者消费者场景
发布订阅 场景
```
生产者消费者场景。Disruptor 的最常用的场景就是“生产者-消费者”场景，对场景的就是“一个生产者、
多个消费者”的场景，并且要求顺序处理。

```
备注，这里和JCTool 的 MPSC 队列，刚好相反， MPSC 使用于多生产者，单消费者场景
```
发布订阅场景：Disruptor 也可以认为是观察者模式的一种实现，实现发布订阅模式。

当前业界开源组件使用 Disruptor 的包括 Log 4 j 2、Apache Storm 等，

### Disruptor 使用细分场景

Disruptor 是一个优秀的并发框架，可以使用在多个生产者单消费者场景

```
单生产者多消费者场景
多生产者单消费者场景
单生产者多消费者场景
多个消费者串行消费场景
菱形方式执行场景
链式并行执行场景
多组消费者相互隔离场景
多组消费者航道执行模式
```
### 单生产者多消费者并行场景

在并发系统中提高性能最好的方式之一就是单一写者原则，对 Disruptor 也是适用的。

如果在生产者单消费者需求中仅仅有一个事件生产者，那么可以设置为单一生产者模式来提高系统的性
能。


##### ProducerType 的类型

ProducerType 定义了生产者的类型，两类

在这种场景下，ProducerType 的类型的 SINGLE

##### 单生产者多消费者并行场景的参考代码

参考的代码如下：


执行结果：

```
以上用例的具体减少，请参见 尼恩《100wqps 日志平台实操，视频》
```
### 多生产者单消费者场景

该场景较为简单，就是多个生产者，单个消费者


其实， **消费者也可以是多个**

##### ProducerType 的类型

ProducerType 定义了生产者的类型，两类

在这种场景下，ProducerType 的类型的 MULTI

##### 多生产者场景的要点

在代码编写维度，多生产者单消费者场景的要点如下：

```
创建Disruptor 的时候，将ProducerType.SINGLE改为ProducerType.MULTI，
编写多线程生产者的相关代码即可。
```
##### 多生产者场景的参考代码

参考的代码如下：


运行的结果如下

```
以上用例的具体减少，请参见 尼恩《100wqps 日志平台实操，视频》
```

### 单生产者多消费者竞争场景

该场景中，生产者为一个，消费者为多个，多个消费者之间，存在着竞争关系，

也就是说，对于同一个事件 event ，多个消费者不重复消费

##### disruptor 如何设置多个竞争消费者？

首先，得了解一下，disruptor 框架的两个设置消费者的方法

大概有两点：

```
消费者需要 实现 WorkHandler 接口，而不是 EventHandler 接口
使用 handleEventsWithWorkerPool 设置 disruptor的 消费者，而不是 handleEventsWith 方法
```
在 disruptor 框架调用 start 方法之前，有两个方法设置消费者：

```
disruptor.handleEventsWith(EventHandler ... handlers)，将多个EventHandler的实现类传入方
法，封装成一个EventHandlerGroup，实现多消费者消费。
disruptor.handleEventsWithWorkerPool(WorkHandler ... handlers)，将多个WorkHandler的实
现类传入方法，封装成一个EventHandlerGroup实现多消费者消费。
```
那么，以上的 Disruptor 类的 handleEventsWith，handleEventsWithWorkerPool 方法的联系及区别是
什么呢？
**相同的在于：**

```
两者共同点都是，将多个消费者封装到一起，供框架消费事件。
```
**第一个不同点在于：**

对于某一条事件 event，

handleEventsWith 方法返回的 EventHandlerGroup，Group 中的每个消费者都会对 event 进行消费，
各个消费者之间不存在竞争。

handleEventsWithWorkerPool 方法返回的 EventHandlerGroup，Group 的消费者对于同一条事件
event 不重复消费；也就是，如果 c 0 消费了事件 m，则 c 1 不再消费事件 m。


**另外一个不同：**

在设置消费者的时候，Disruptor 类的 handleEventsWith，handleEventsWithWorkerPool 方法所传入
的形参不同。对于独立消费的消费者，应当实现 EventHandler 接口。对于不重复消费的消费者，应当
实现 WorkHandler 接口。

因此，根据消费者集合是否独立消费事件，可以对不同的接口进行实现。也可以对两种接口同时实现，
具体消费流程由 disruptor 的方法调用决定。

##### 演示代码如下:

执行结果

以上用例的具体减少，请参见尼恩《100 wqps 日志平台实操，视频》


### 多个消费者串行消费场景

在多个消费者串行消费场景中，多个消费者，可以按照次序，消费消息。

比如：一个用户注册的 Event，需要有一个 Handler 来存储信息，一个 Hanlder 来发邮件等等。

##### 多个消费者串行消费场景案例

##### 执行结果


### 菱形方式执行场景

##### 场景特点

先并发，后串行

##### 菱形方式执行场景案例


执行结果

### 链式并行执行场景

##### 场景特点

多组消费者形成并行链，特点是：

```
链内 串行
链间 并行
```

##### 场景案例

执行结果


### 多组消费者相互隔离场景

##### 场景特点

多组消费者相互隔离，特点是：

```
组内 相互竞争
组间 相互隔离
```
##### 场景案例


执行结果

### 多组消费者航道执行模式

##### 场景特点

多组消费者形成并行链，特点是：

```
组内 相互竞争
组之间串行依次执行
```

##### 场景案例

组之间串行依次执行, 组内有多个实例竞争执行

执行效果


### 六边形执行顺序

这是一种比较复杂的场景

##### 场景特点

单边内部是有序的

边和边之间是并行的

##### 参考代码

```
@org.junit.Test
public void testHexagonConsumerDisruptorWithMethodRef() throws
InterruptedException {
// 消费者线程池
Executor executor = Executors.newCachedThreadPool();
// 环形队列大小， 2 的指数
int bufferSize = 1024;
// 构造 分裂者 （事件分发者）
Disruptor<LongEvent> disruptor = new Disruptor<LongEvent>
(LongEvent::new, bufferSize,
executor,
ProducerType.SINGLE, //多个生产者
new YieldingWaitStrategy());
```
```
EventHandler consumer1 = new LongEventHandlerWithName("consumer 1");
EventHandler consumer2 = new LongEventHandlerWithName("consumer 2");
EventHandler consumer3 = new LongEventHandlerWithName("consumer 3");
EventHandler consumer4 = new LongEventHandlerWithName("consumer 4");
EventHandler consumer5 = new LongEventHandlerWithName("consumer 5");
// 连接 消费者 处理器
// 可以使用lambda来注册一个EventHandler
```
```
disruptor.handleEventsWith(consumer1,consumer2);
disruptor.after(consumer1).handleEventsWith(consumer3);
disruptor.after(consumer2).handleEventsWith(consumer4);
disruptor.after(consumer3,consumer4).handleEventsWith(consumer5);
// 开启 分裂者（事件分发）
```

##### 执行结果

## 4 ：架构师视角，深入 Disruptor 源码分析

Disruptor 其实是“生产者-消费者”模型一种典型的应用场合，它的功能其实就是一种有界队列。

### 核心概念

##### Ring Buffer

如其名，环形的缓冲区。

```
disruptor.start();
// 获取环形队列，用于生产 事件
RingBuffer<LongEvent> ringBuffer = disruptor.getRingBuffer();
//1生产者，并发生产数据
LongEventProducerWithTranslator producer = new
LongEventProducerWithTranslator(ringBuffer);
Thread thread = new Thread() {
@Override
public void run() {
for (long i = 0; true; i++) {
producer.onData(i);
ThreadUtil.sleepSeconds(1);
}
}
};
thread.start();
ThreadUtil.sleepSeconds(5);
}
```

曾经 RingBuffer 是 Disruptor 中的最主要的对象，但从 3.0 版本开始，其职责被简化为仅仅负责对通过
Disruptor 进行交换的数据（事件）进行存储和更新。

在一些更高级的应用场景中，Ring Buffer 可以由用户的自定义实现来完全替代。

##### Sequence

通过顺序递增的序号来编号管理通过其进行交换的数据（事件），对数据 (事件) 的处理过程总是沿着序
号逐个递增处理。

Sequence 采用缓存行填充的方式对 long 类型的一层包装，用以代表事件的序号。

一个 Sequence 用于跟踪标识某个特定的事件处理者 ( RingBuffer/Consumer ) 的处理进度。

虽然一个 AtomicLong 也可以用于标识进度，但定义 Sequence 来负责该问题还有另一个目的，那就是
防止不同的 Sequence 之间的 CPU 缓存伪共享 (Flase Sharing) 问题。

另外，Sequence 通过 unsafe 的 cas 方法从而避免了锁的开销。

##### Sequencer

Sequencer 是 Disruptor 的真正核心。

生产者与缓存 RingBuffer 之间的桥梁、

此接口有两个实现类 SingleProducerSequencer、MultiProducerSequencer ，它们定义在生产者和
消费者之间快速、正确地传递数据的并发算法。

##### Sequence Barrier

消费者与消费者直接的隔离屏障。

消费者之间，并不是通过 RingBuffer 进行加锁互斥隔离，而是通过 Sequence Barrier 来管理依赖次
序关系，从而能减少 RingBuffer 上的并发冲突；

```
在一定程度上， Sequence Barrier 类似与 aqs 同步队列
```
Sequence Barrier 用于保持对 RingBuffer 的 main published Sequence 和 Consumer 依赖的其它
Consumer 的 Sequence 的引用。

Sequence Barrier 还定义了: Consumer 是否还有可处理的事件的逻辑。

##### Wait Strategy

定义 Consumer 如何进行等待下一个事件的策略。 （注：Disruptor 定义了多种不同的策略，针对不
同的场景，提供了不一样的性能表现）

##### Event

在 Disruptor 的语义中，生产者和消费者之间进行交换的数据被称为事件 (Event)。

它不是一个被 Disruptor 定义的特定类型，而是由 Disruptor 的使用者定义并指定。

##### EventProcessor

事件处理器，是消费者线程池 Executor 的调度单元，

EventProcessor 是对事件业务处理 EventHandler 与异常处理 ExceptionHandler 等的一层封装；

EventProcessor 持有特定消费者 (Consumer) 的 Sequence，并提供事件循环 (Event Loop)，用于调用
业务事件处理实现 EventHandler


##### EventHandler

Disruptor 定义的事件处理接口，由用户实现，用于处理事件，是 Consumer 的真正实现。

##### Producer

```
即生产者，只是泛指调用 Disruptor 发布事件的用户代码，Disruptor 没有定义特定接口或类型
```
##### RingBuffer

基于数组的缓存实现，也是创建 sequencer 与定义 WaitStrategy 的入口；

##### Disruptor

Disruptor 的使用入口。

持有 RingBuffer、消费者线程池 Executor、消费者仓库 ConsumerRepository 等引用。

### Disruptor 的无锁架构

并发领域的一个典型场景是生产者消费者模型，生产者消费者模型的经典方式，是使用 queue 作为生产
者线程与消费者线程之间共享数据的方法，但是，经典方式对于 queue 的读写避免不了读写锁的竞争。

通过序号屏障对依赖关系的管理，RingBuffer 实现了事件缓存的无锁架构。

Disruptor 使用环形缓冲区 RingBuffer 作为共享数据的媒介。

生产者通过 Sequencer 控制 RingBuffer，以及唤醒等待事件的消费者，

消费者通过 SequenceBarrier 监听 RingBuffer 的可消费事件。

考虑一个场景，一个生产者 A 与三个消费者 B、C、D, 同时 D 的事件处理需要 B 与 C 先完成。

则该模型结构如下：


Disruptor 中，生产者与 Sequencer 有关系，由生产者通过 Sequencer 控制 RingBuffer 的写入。

RingBuffer 是 Disruptor 高性能的一个亮点。RingBuffer 就是一个大数组，事件以循环覆盖的方式写
入。

与常规 RingBuffer 拥有 2 个首尾指针的方式不同，Disruptor 的 RingBuffer 只有一个指针 (或称序号)，指
向数组下一个可写入的位置，该序号在 Disruptor 源码中就是 **Sequencer 中的 cursor** ，

##### 如何管理消费者和生产者之间的依赖关系呢？

还是通过 SequenceBarrier 进行依赖管理，

消费者的 processer，通过 SequenceBarrier 获取生产者的生产序号

##### 如何管理消费者与消费者之间的依赖关系呢？

每个消费者拥有各自独立的事件序号 Sequence，消费者之间不通过 Sequence 在共享竞态，或者说依赖
管理。

消费者与消费者之间的依赖关系是，通过 SequenceBarrier 进行依赖管理。

##### 依赖关系管理的例子

在上面的例子中：

SequenceBarrier 1 监听 RingBuffer 的序号 cursor，消费者 B 与 C 通过 SequenceBarrier 1 等待可消费事
件。

SequenceBarrier 2 除了监听 RingBuffer 的序号 cursor，同时也监听 B 与 C 的序号 Sequence，从而将最
小的序号返回给消费者 D，由此实现了 D 依赖 B 与 C 的逻辑。

##### 如何避免未消费事件的写入覆盖呢？

为了避免未消费事件的写入覆盖，生产者的 Sequencer 需要监听所有消费者的消息处理进度，也就是
gatingSequences。

### Disruptor 的总体模块架构

结合执行流程进行梳理


### 核心类 Sequence

用来表达 event 序例号的对象，但这里为什么不直接用 long 呢 ？

为了高并发下的可见性，肯定不能直接用 long 的，至少也是 volatile long。

但 Disruptor 觉得 volatile long 还是不够用，所以创造了 Sequence 类。

Sequence 的内部实现主要是 volatile long，

除此以外还支持以下特性：

```
CAS 更新
order writes (Store/Store barrier，改动不保证立即可见) vs volatile writes (Store/Load
barrier，改动保证立即可见)
在 volatile 字段 附近添加 padding 解决伪共享问题
```
简单理解就是高并发下优化的 long 类型。

比如在对 EventProcessor. sequence 的更新中都是用的 order writes，不保证立即可见，但速度快很
多。

在这个场景里，造成的结果是显示的消费进度可能比实际上慢，导致生产者有可能在可以生产的情况下
没有去生产。

但生产者看的是多个消费者中最慢的那个消费进度，所以影响可能没有那么大。

### 核心类 Sequencer

Sequencer 是生产者与缓存 RingBuffer 之间的桥梁、是 Disruptor 的真正核心。

Sequencer 负责在生产者和消费者之间快速、正确地传递数据的序号。

生产者发布 event 的时候首先需要预定一个 sequence，Sequencer 就是计算和发布 sequence 的。

```
volatile long value;
```

##### Sequencer 的实现类

Sequencer 接口有两个重要实现类 SingleProducerSequencer、MultiProducerSequencer ，

##### SingleProducerSequencer

生产者发布事件的步骤：

```
通过 Sequencer.next(n) 来预定下面 n 个可以写入的位置序号
根据序号获取事件，然后修改事件数据，然后发布 event。
```
因为 RingBuffer 是环形的，一个 size 为 1024 的 RingBuffer ，当拿到的序号 Sequence 为 1024 时，
相当于又要去写 0 位置，

问题来了，假如之前的 0 位置的数据，还没被消费呢？

**此时，不能直接写，如果写的话，老数据就会被覆盖了。**

如何解决数据覆盖的问题呢？

答案就是使用：Sequencer 。 Sequencer 在内部维护了一个 gatingSequences 数组：

gatingSequences 数据里边，记录的是消费者的 Sequence ，

每个消费者会维护一个自己的 Sequence 对象，来记录自己已经消费到的序例位置。

每添加一个消费者，都会把消费者的 Sequence 引用添加到 gatingSequences 中。

通过访问 gatingSequences，Sequencer 可以得知消费的最慢的消费者消费到了哪个位置。

```
volatile Sequence[] gatingSequences = new Sequence[0];
```

在 next (n) 方法里，如果计算出的下一个 event 的 Sequence 值减去 bufferSize

得出来的 wrapPoint > min (gatingSequences)，说明即将写入的位置上，之前的 event 还有消费者没
有消费，这时 SingleProducerSequencer 会等待并自旋。

举个例子，gatingSequences=[7, 8, 9, 10, 3, 4, 5, 6, 11]， RingBuffer size 16 的情况下，如果算出来
的 nextSequence 是 20 ，wrapPoint 是 20-16=4，这时 gatingSequences 里最小的是 3 。

说明下一个打算写入的位置是 wrapPoint 4，但最慢的消费者才消费到 3 ，你不能去覆盖之前 4 上的数
据，这时只能等待，等消费者把之前的 4 消费掉。

为什么 wrapPoint = nextSequence - bufferSize，而不是 bufferSize 的 n 倍呢，因为消费者只能落后
生产者一圈，不然就已经存在数据覆盖了。

等到 SingleProducerSequencer 自旋到下一个位置所有人都消费过的时候，它就可以从 next 方法中返
回，生产者拿着 sequence 就可以继续去发布。

##### MultiProducerSequencer

MultiProducerSequencer 是在多个生产者的场合使用的，多个生产者的情况下存在竞争，导致它的实
现更加复杂。

```
8 个消费者的例子，
gatingSequences=[7, 8, 9, 10, 3, 4, 5, 6, 11]
最慢的消费完了 3 ，此时可以写seq 19的数据，但不能写seq 20。
```
```
long nextValue = this.nextValue;long nextSequence = nextValue + n;
long wrapPoint = nextSequence - bufferSize;
```
```
while (wrapPoint > (minSequence = Util.getMinimumSequence(gatingSequences,
nextValue))) {
LockSupport.parkNanos(1L);
}
```

数据结构上多出来的主要就是这个 availableBuffer，用来记录 RingBuffer 上哪些位置有数据可以读。

还是从 Sequencer.next (n) 说起，计算下一个数据位 Sequence 的逻辑是一样的，包括消费者落后导致
Sequencer 自旋等待的逻辑。不同的是因为有多个 publisher 同时访问 Sequencer.next (n) 方法，所以
在确定最终位置的时候用了一个 CAS 操作，如果失败了就自旋再来一次。

另一个不同的地方是 publish (final long sequence) 方法，SingleProducer 的版本很简单，就是移动了
一下 cursor。

MultiProducer 的版本则是

setAvailable 做了什么事呢，它去设置 availableBuffer 的状态位了。给定一个 sequence，先计算出对
应的数组下标 index，然后计算出在那个 index 上要写的数据 availabilityFlag，最后执行

```
int[] availableBuffer;
int indexMask;
int indexShift;
public MultiProducerSequencer(int bufferSize, final WaitStrategy waitStrategy){
```
```
super(bufferSize, waitStrategy);
availableBuffer = new int[bufferSize];
indexMask = bufferSize - 1;
indexShift = Util.log2(bufferSize);
initialiseAvailableBuffer();
}
```
```
cursor.compareAndSet(current, next)
```
```
public void publish(long sequence){
```
```
cursor.set(sequence);
waitStrategy.signalAllWhenBlocking();
```
```
}
```
```
public void publish(final long sequence){
```
```
setAvailable(sequence);
waitStrategy.signalAllWhenBlocking();
```
```
}
```
```
availableBuffer[index]=availabilityFlag
```

根据 calculateAvailabilityFlag (sequence) 方法计算出来的 availabilityFlag 实际上是该 sequence 环绕
RingBuffer 的圈数。

availableBuffer 主要用于判断一个 sequence 下的数据是否可用

作为比较，来看一下 SingleProducer 的方法

在单个生产者的场景下，publishEvent 的时候才会推进 cursor，所以只要 sequence<=cursor，就说
明数据是可消费的。

多个生产者的场景下，在 next (n) 方法中，就已经通过 cursor.compareAndSet (current, next) 移动
cursor 了，此时 event 还没有 publish，所以 cursor 所在的位置不能保证 event 一定可用。

在 publish 方法中是去 setAvailable (sequence) 了，所以 availableBuffer 是数据是否可用的标志。那
为什么值要写成圈数呢，应该是避免把上一轮的数据当成这一轮的数据，错误判断 sequence 是否可
用。

另一个值得一提的是 getHighestPublishedSequence 方法，这个是消费者用来查询最高可用 event 数
据的位置。

```
availableBuffer=[6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]例子：前 4 个已经走到
第 6 圈。
```
```
public boolean isAvailable(long sequence){
int index = calculateIndex(sequence);
int flag = calculateAvailabilityFlag(sequence);
long bufferAddress = (index * SCALE) + BASE;
return UNSAFE.getIntVolatile(availableBuffer, bufferAddress) == flag;
```
```
}
```
```
public boolean isAvailable(long sequence){
return sequence <= cursor.get();
}
```
```
public long getHighestPublishedSequence(long lowerBound, long availableSequence)
{
for (long sequence = lowerBound; sequence <= availableSequence; sequence++)
{
if (!isAvailable(sequence))
{
return sequence - 1;
}
}
return availableSequence;
}
```

range，依次查询 availableBuffer，直到发现不可用的 Sequence，那么该 Sequence 之前的都是可用
的。或全部都是可用的。

单生产者的版本:

说完了生产者，下面来看看消费者

### 核心类消费者仓库和消费者信息

##### 消费者仓库 ConsumerRepository

Disruptor 中，通过 ConsumerRepository 来管理所有消费者，主要维护了以下结构：

```
EventHandler 到 消费者处理器 信息的映射，用于信息查询
```
```
Sequence 到消费者信息的映射
```
ConsumerInfo 和 Sequence 是一对多关系

一个 ConsumerInfo 消费者可能有多个 Sequence

但是一个 Sequence 只从属一个消费者。

```
public long getHighestPublishedSequence(long lowerBound, long
availableSequence)
{
return availableSequence;
}
```

核心代码如下：

##### 消费者的信息 ConsumerInfo

ConsumerRepository 用于维护 Disruptor 的所有消费者的信息，管理的集合类里主要有 ConsumerInfo
接口，


##### 消费者的信息实现类

ConsumerInfo 维护了消费者信息的抽象，目前主要有两个实现类：

```
EventProcessorInfo 单事件处理器消费者信息
WorkerPoolInfo 线程池消费者信息对象/工作者池信息。
```
EventProcessorInfo ： 一个单线程的消费者 (只有一个 EventProcessor)，代理 EventHandler，管理处
理事件以外的其他事情 (如：拉取事件，等待事件...)

WorkerPoolInfo 表示： WorkPool 整体是一个消费者，是一个多线程的消费者，每个生产者 publish
的事件只会被 WorkerPool 里的某一个 WorkProcessor 消费


##### WorkerPoolInfo 多线程消费者信息

WorkerPoolInfo 包含了一个 WorkerPool 类型的成员

WorkerPool 和处理器没有任何继承关系，是一个独立的类

协作者模式下，所有的消费者共用一个 workSequence，通过 CAS 写 workSequence

多线程消费者信息, 包含了多个工作处理器，多个工作处理器，放在下面的数组中

由 WorkerPool 的 start 方法启动 WorkProcessor 工作处理器

```
// WorkProcessors are created to wrap each of the provided WorkHandlersprivate
final WorkProcessor<?>[] workProcessors;
```

### 消费者处理器

Disruptor 的消费者依赖 EventProcessor 事件处理器。

```
handler和processer都可以翻译为“处理器”，但是process侧重于 处理执行，实际执行，
processer与cpu有关系，一个processer事件处理器关联一个执行线程
```
```
而handle侧重于 业务处理器，表示用户逻辑的处理， process表示 handler 的执行过程
```
```
handle和process 的关系，类似于 程序 与进程的关系
```
消费者处理器类型比较多， uml 图如下：

主要的消费者处理器类型，两种：

```
BatchEventProcessor 单线程批处理消费者，同一批次添加的消费者，会消费每一个event
WorkProcessor 消费者池，同一批次添加的消费者，每个event只会被其中一个processer 消费。
```
WorkProcessor 通过 WorkerPool 进行管理


##### BatchEventProcessor 单线程批处理事件

在使用 BatchEventProcessor 时，通过 Disruptor #handleEventsWith方法可以获取一个
EventHandlerGroup，再通过 EventHandlerGroup 的 and 和 then 方法可以构建一个复杂的消费者链。

##### 事件消费者组 EventHandlerGroup

EventHandlerGroup 表示一组事件消费者，内部持有了 Disruptor 类实例 disruptor，其大部分功能都是
通过调用 disruptor 实现，其实可以算作是 Disruptor 这个辅助类的一部分。

EventHandlerGroup. java

设置批处理程序以使用环形缓冲区中的事件。这些处理程序仅在此组中的每个{@link EventProcessor}
处理完事件后处理事件。
该方法通常用作链的一部分。例如，如果处理程序 A 必须在处理程序 B dw. handleEventsWith（A）之
前处理事件。那么（B）
@param 处理将处理事件的批处理程序。
@return {@link EventHandlerGroup}，可用于在创建的事件处理器上设置事件处理器障碍。

设置批处理程序以处理来自环形缓冲区的事件。

这些处理程序仅在此组中的每个{@link EventProcessor}处理完事件后处理事件。

该方法通常用作链的一部分。例如，如果 A 必须在 Bdw. after（A）. handleEventsWith（B）之前处理
事件
@param 处理将处理事件的批处理程序。
@return {@link EventHandlerGroup}，可用于在创建的事件处理器上设置事件处理器障碍。

```
// 由EventHandlerGroup调用时，barrierSequences是EventHandlerGroup实例的序列，
//也就是上一个事件处理者组的序列，作为当前事件处理的门控，防止后边的消费链超前
// 如果第一次调用handleEventsWith，则barrierSequences为空
EventHandlerGroup<T createEventProcessors(final Sequence[] barrierSequences,
final EventHandler<? super T[]
eventHandlers) {
checkNotStarted();
```

可以看到，使用 BatchEventProcessor 构建消费者链时的逻辑都在 createEventProcessors 方法中。

```
// 对应此事件处理器组的序列组
final Sequence[] processorSequences = new
Sequence[eventHandlers.length];
final SequenceBarrier barrier = ringBuffer.newBarrier(barrierSequences);
```
```
for (int i = 0 , eventHandlersLength = eventHandlers.length; i <
eventHandlersLength; i++) {
final EventHandler<? super T eventHandler = eventHandlers[i];
```
```
final BatchEventProcessor<T batchEventProcessor =
new BatchEventProcessor<(ringBuffer, barrier, eventHandler);
```
```
if (exceptionHandler != null) {
batchEventProcessor.setExceptionHandler(exceptionHandler);
}
```
```
consumerRepository.add(batchEventProcessor, eventHandler, barrier);
processorSequences[i] = batchEventProcessor.getSequence();
}
// 每次添加完事件处理器后，更新门控序列，以便后续调用链的添加
// 所谓门控，是指后续消费链的消费，不能超过前边
updateGatingSequencesForNextInChain(barrierSequences,
processorSequences);
```
```
return new EventHandlerGroup<(this, consumerRepository,
processorSequences);
}
```
```
// 为消费链下一组消费者，更新门控序列
// barrierSequences是上一组事件处理器组的序列（如果本次是第一次，则为空数组），本组不能超过上
组序列值
// processorSequences是本次要设置的事件处理器组的序列
private void updateGatingSequencesForNextInChain(final Sequence[]
barrierSequences, final Sequence[] processorSequences)
{
if (processorSequences.length  0 )
{
// 将本组序列添加到Sequencer中的gatingSequences中
ringBuffer.addGatingSequences(processorSequences);
// 将上组序列从Sequencer中的gatingSequences中，gatingSequences一直保存消
费链末端消费者的序列组
for (final Sequence barrierSequence : barrierSequences)
{
ringBuffer.removeGatingSequence(barrierSequence);
}
// 取消标记上一组消费者为消费链末端
```
```
consumerRepository.unMarkEventProcessorsAsEndOfChain(barrierSequences);
}
}
```

ConsumerRepository 类主要保存消费者的各种关系，如通过 EventHandler 引用获取
EventProcessorInfo 信息，通过 Sequence 获取 ConsumerInfo 信息等。

因为要使用引用做 key，所以数据结构使用 IdentityHashMap。

IdentityHashMap 和 HashMap 最大的不同，就是使用==而不是 equals 比较 key。

这个 createEventProcessors 方法接收两个参数，barrierSequences 表示当前消费者组的屏障序列数
组，如果当前消费者组是第一组，则取一个空的序列数组；否则，barrierSequences 就是上一组消费者
组的序列数组。

createEventProcessors 方法的另一个参数 eventHandlers，这个参数是代表事件消费逻辑的
EventHandler 数组。
Disruptor 为每个 EventHandler 实现类都创建了一个对应的 BatchEventProcessor。

在构建 BatchEventProcessor 时需要以下传入三个构造参数：dataProvider 是数据存储结构如
RingBuffer；sequenceBarrier 用于跟踪生产者游标，协调数据处理；

eventHandler 是用户实现的事件处理器，也就是实际的消费者。

注意，Disruptor 并非为每个 BatchEventProcessor 都创建一个新的 SequenceBarrier，而是每个消费
者组共用一个 SequenceBarrier。
BatchEventProcessor 定义，请参见源码仓库。

至于为什么要叫做 BatchEventProcessor，可以看看在 run () 方法里每次 waitFor 获取的
availableSequence 是当前能够使用的最大值，然后再循环处理这些数据。

这样当消费者有瞬时抖动，导致暂时落后生产者时，可在下一次循环中，批量处理所有落后的事件。

可以看出：

BatchEventProcessor 可以处理超时，可以处理中断，可以通过用户实现的异常处理类处理异常，同
时，发生异常之后再次启动，不会漏消费，也不会重复消费。

### SequenceBarrier 协调屏障

SequenceBarrier：一个协调屏障，

SequenceBarrier 用来跟踪发布者 (publisher) 的游标 (cursor) 和事件处理者 (EventProcessor) 的序列号
(sequence)。


##### disrutor 管理两种依赖关系

disrutor 需要管理两种依赖关系：

```
生产者与消费者之间的依赖关系
以及消费者与消费者之间的依赖关系
```
消费者与消费者之间的依赖关系 ,使用的是 sequenceBarrier 的 dependentSequence 来管理

消费者对生产者之间的依赖关系 ,使用的是 sequenceBarrier 的 seqquencer 来管理

生产者对最慢+末端消费者直接的依赖关系，使用门禁序号 gatingSequence 来管理

##### 消除锁和 CAS 操作

```
Disruptor 中,通过联合使用 SequenceBarrier 和 Sequence, 协调和管理消费者和生产者之间的处
理关系,避免了锁和 CAS 操作
Disruptor中的各个消费者和生产者持有自己的序号Sequence,
```
```
序号Sequence需要满足以下条件:
条件一: 消费者的序号 Sequence 的数值必须小于生产者的序号 Sequence 的数值
```

```
条件二: 消费者的序号 Sequence 的数值必须小于依赖关系中前置的消费者的序号 Sequence
的数值
条件三: 生产者的序号 Sequence 的数值不能大于消费者正在消费的序号 Sequence 的数值,防
止生产者速度过快,将还没有来得及消费的事件消息覆盖
条件一 和 条件二 在 SequenceBarrier 中的 waitFor() 方法中实现:
条件三是针对生产者建立的SequenceBarrier,逻辑判定发生在生产者从RingBuffer获取下一个可用
的entry时,RingBuffer会将获取下一个可用的entry委托给Sequencer处理:
```
##### SequenceBarrier 的几个方法

long waitFor (long sequence) throws AlertException, InterruptedException, TimeoutException;

等待给定的序列号可用，用来消费。

long getCursor ();

获取当前能读取到的游标 (cursor) 值。

boolean isAlerted ();

barrier 当前的状态是否是警报 (alert) 状态。

void alert ();

提醒 EventProcessor，一个状态发生了变化，直到清除之前，一直处于这种状态下。

void clearAlert ();

清除当前的警报状态。

void checkAlert () throws AlertException;

检查是否提出了警报，如果提出了，就抛出异常。

##### SequenceBarrier 进行依赖消费

```
1. 不同的BatchEventProcessor之间通过SequenceBarrier进行依赖消费。
```

```
原理如下图所示：
```
```
假设我们有三个消费者BatchEventProcessor1，BatchEventProcessor2，
BatchEventProcessor3.
1 需要先于 2 和 3 消费，那么构建BatchEventProcessor和SequenceBarrier时，
我们需要让BatchEventProcessor2和BatchEventProcessor3的SequenceBarrier的
dependentSequence中加入SequenceBarrier1的sequence。
其实这里 2 和 3 共用一个SequenceBarrier就行。
```
##### ProcessingSequenceBarrier

接下来看下它的实现类 - ProcessingSequenceBarrier

SequenceBarrier 只有一个重要的实现类，就是 ProcessingSequenceBarrier。

ProcessingSequenceBarrier 有以下几个重要的属性：

```
生产者Sequencer，
消费定位cursorSequence，
等待策略waitStrategy ,
还有一组依赖sequence：dependentSequence
```

（上图是从它的构造器中截取的一部分）

可以看出如果 dependentSequence 的长度是 0 ，就将 cursorSequence 指向它，即两者有着相同的引
用。

否则，通过 FixedSequenceGroup 来创建它，即与 cursorSequence 之间，两者独立存在。

然后重点看下如下几个实现方法：


### RingBuffer 预分配内存

RingBuffer 使用数组 Object[] entries 来存储元素:

```
初始化 RingBuffer 时,会将所有数组元素 entries 的指定为特定的事件 Event 参数,此时 Event 中的
detail 属性为 null
生产者向 RingBuffer 写入消息时 ,RingBuffer 不是直接将数组元素 entries 指向 Event 对象,而是先
获取 Event 对象,更改 Event 对象中的 detail 属性
消费者在消费时,也是从 RingBuffer 中读取 Event, 读取 Event 对象中的 detail 属性
由此可见,在生产和消费过程中 ,RingBuffer 中的数组元素 entries 没有发生任何变化,没有产生临时
对象,数组中的元素一直存活,直到 RingBuffer 消亡
```
通过以上方式, 可以最小化 **JVM** 中的垃圾回收 **GC** 的频率, 提升性能

### Disruptor 的等待策略

##### uml 图

Disruptor 默认的等待策略是 BlockingWaitStrategy。

这个策略的内部适用一个锁和条件变量来控制线程的执行和等待（Java 基本的同步方法）。

```
private void fill(EventFactory<E> eventFactory) {
for (int i = 0; i < bufferSize; i++) {
// 使用工厂方法初始化数组中的entries元素
entries[BUFFER_PAD + i] = eventFactory.newInstance();
}
}
```

BlockingWaitStrategy 是最慢的等待策略，但也是 CPU 使用率最低和最稳定的选项。然而，可以根据不
同的部署环境调整选项以提高性能。

##### SleepingWaitStrategy

和 BlockingWaitStrategy 一样，SpleepingWaitStrategy 的 CPU 使用率也比较低。

它的方式是循环等待并且在循环中间调用 LockSupport.parkNanos (1) 来睡眠，（在 Linux 系统上面睡眠
时间 60μs）.

然而，它的优点在于生产线程只需要计数，而不执行任何指令。并且没有条件变量的消耗。

但是，事件对象从生产者到消费者传递的延迟变大了。

SleepingWaitStrategy 最好用在不需要低延迟，而且事件发布对于生产者的影响比较小的情况下。比如
异步日志功能。

###### 源码

```
/*
* Copyright 2011 LMAX Ltd.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
package com.lmax.disruptor;
```
```
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
```
```
import com.lmax.disruptor.util.ThreadHints;
```
```
/**
* Blocking strategy that uses a lock and condition variable for {@link
EventProcessor}s waiting on a barrier.
* <p>
* This strategy can be used when throughput and low-latency are not as
important as CPU resource.
*/
public final class BlockingWaitStrategy implements WaitStrategy
{
private final Lock lock = new ReentrantLock();
private final Condition processorNotifyCondition = lock.newCondition();
```
```
/**
```

*
* @param sequence to be waited on. 消费者想要消费的下一个序号
* @param cursorSequence 当前 ringbuffer 最大的生产者序号？
* @param dependentSequence on which to wait.
* @param barrier the processor is waiting on.
* @return
* @throws AlertException
* @throws InterruptedException
*/
@Override
public long waitFor (long sequence, Sequence cursorSequence, Sequence
dependentSequence, SequenceBarrier barrier)
throws AlertException, InterruptedException
{
long availableSequence;
// cursorSequence: 生产者的序号
// 第一重条件判断：如果消费者消费速度，大于生产者生产速度（即消费者要消费的下一个数据
已经大于生产者生产的数据时），
// 那么消费者等待一下
if (cursorSequence.get () < sequence)
{
lock.lock ();
try
{
while (cursorSequence.get () < sequence)
{
barrier.checkAlert ();
processorNotifyCondition.await ();
}
}
finally
{
lock.unlock ();
}
}
// 第一重条件判断：自旋等待
// 即当前消费者线程要消费的下一个 sequence，大于其前面执行链路（若有依赖关系）的任何一
个消费者最小 sequence（dependentSequence.get ()），
// 那么这个消费者要自旋等待，
// 直到前面执行链路（若有依赖关系）的任何一个消费者最小
sequence（dependentSequence.get ()）已经大于等于当前消费者的 sequence 时，
// 说明前面执行链路的消费者已经消费完了
while ((availableSequence = dependentSequence.get ()) < sequence)
{
barrier.checkAlert ();
ThreadHints.onSpinWait ();
}

return availableSequence;
}

/**
* 如果生产者新生产一个元素，那么唤醒所有消费者
*/
@Override
public void signalAllWhenBlocking ()
{
lock.lock ();


##### YieldingWaitStrategy

YieldingWaitStrategy 是可以被用在低延迟系统中的两个策略之一，这种策略在减低系统延迟的同时也
会增加 CPU 运算量。

YieldingWaitStrategy 策略会循环等待 sequence 增加到合适的值。

循环中调用 Thread.yield () 允许其他准备好的线程执行。

如果需要高性能而且事件消费者线程比逻辑内核少的时候，推荐使用 YieldingWaitStrategy 策略。

例如：在开启超线程的时候。

###### 源码

```
try
{
processorNotifyCondition.signalAll();
}
finally
{
lock.unlock();
}
}
```
```
@Override
public String toString()
{
return "BlockingWaitStrategy{" +
"processorNotifyCondition=" + processorNotifyCondition +
'}';
}
}
```
```
/*
* Copyright 2011 LMAX Ltd.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
package com.lmax.disruptor;
```
```
/**
```

##### BusySpinW 4 aitStrategy

```
* Yielding strategy that uses a Thread.yield() for {@link
com.lmax.disruptor.EventProcessor}s waiting on a barrier
* after an initially spinning.
* <p>
* This strategy will use 100% CPU, but will more readily give up the CPU than a
busy spin strategy if other threads
* require CPU resource.
*/
public final class YieldingWaitStrategy implements WaitStrategy
{
private static final int SPIN_TRIES = 100;
```
```
@Override
public long waitFor(
final long sequence, Sequence cursor, final Sequence
dependentSequence, final SequenceBarrier barrier)
throws AlertException, InterruptedException
{
long availableSequence;
int counter = SPIN_TRIES;
// 如果消费者需要消费的下一个序号超过了生产者已生产数据的最大序号，
// 那么消费者需要等待，否则返回生产者已生产数据的最大序号给消费者消费即可
while ((availableSequence = dependentSequence.get()) < sequence)
{
counter = applyWaitMethod(barrier, counter);
}
```
```
return availableSequence;
}
```
```
@Override
public void signalAllWhenBlocking()
{
}
```
```
private int applyWaitMethod(final SequenceBarrier barrier, int counter)
throws AlertException
{
barrier.checkAlert();
```
```
if (0 == counter)
{
Thread.yield();
}
else
{
--counter;
}
```
```
return counter;
}
}
```

BusySpinWaitStrategy 是性能最高的等待策略，同时也是对部署环境要求最高的策略。

这个性能最好用在事件处理线程比物理内核数目还要小的时候。例如：在禁用超线程技术的时候。

### Disruptor 的缓存行填充

##### RingBuffer 的缓存行填充

Disruptor RingBuffer（环形缓冲区）定义了 RingBufferFields 类，里面有 indexMask 和其他几个变量存
放 RingBuffer 的内部状态信息。


对此，Disruptor 利用了缓存行填充，在 RingBufferFields 里面定义的变量的前后，分别定义了 7 个 long
类型的变量：

```
前面 7 个来自继承的 RingBufferPad 类
后面 7 个直接定义在 RingBuffer 类
```
这 14 个变量无任何实际用途。我们既不读他们，也不写他们。而 RingBufferFields 里面定义的这些变量
都是 **final** ，第一次写入后就不会再修改。

所以，一旦它被加载到 CPU Cache 后，只要被频繁读取访问，就不会再被换出 Cache。这意味着，对于
该值的读取速度，会一直是 CPU Cache 的访问速度，而非内存的访问速度。

##### Sequence 是如何消除伪共享的

从 Sequence 的父类 Value 可以看到，真正使用到的变量是 Value 类的 value，它的前后空间都由 8 个 long
型的变量填补了，对于一个大小为 64 字节的缓存行，它刚好被填补满（一个 long 型变量 value， 8 个字节
加上前/后个 7 long 型变量填补，7*8=56，56+8=64 字节）。

这样做每次把变量 value 读进高速缓存中时，都能把缓存行填充满，保证每次处理数据时都不会与其他
变量发生冲突。

当然，对于大小为 64 个字节的缓存行来说，如果缓存行大小大于 64 个字节，那么还是会出现伪共享问
题，但是毕竟 **非 64 个字节的 Cache Line** 并不是当前的主流。

### 参考文献

https://blog.51cto.com/u_11440114/5184594

https://blog.csdn.net/hxg117/article/details/78064632

[http://openjdk.java.net/projects/jdk8/features](http://openjdk.java.net/projects/jdk8/features)
[http://beautynbits.blogspot.co.uk/2012/11/the-end-for-false-sharing-in-java.html](http://beautynbits.blogspot.co.uk/2012/11/the-end-for-false-sharing-in-java.html)
[http://openjdk.java.net/jeps/142](http://openjdk.java.net/jeps/142)
[http://mechanical-sympathy.blogspot.co.uk/2011/08/false-sharing-java-7.html](http://mechanical-sympathy.blogspot.co.uk/2011/08/false-sharing-java-7.html)
[http://stackoverflow.com/questions/19892322/when-will-jvm-use-intrinsics](http://stackoverflow.com/questions/19892322/when-will-jvm-use-intrinsics)
https://blogs.oracle.com/dave/entry/java_contented_annotation_to_help


https://www.jianshu.com/p/b38ffa33d64d

https://blog.csdn.net/MrYushiwen/article/details/123171635

https://blog.csdn.net/everyok/article/details/88889057


```
疯狂创客圈^
```
# 硬核推荐：尼恩 Java 硬核架构班

## 又名疯狂创客圈社群 VIP

## 详情：https://www.cnblogs.com/crazymakercircle/p/9904544.html


疯狂创客圈^


```
疯狂创客圈^
```
#### 架构班（社群 VIP）的起源：^

最初的视频，主要是给读者加餐。很多的读者，需要一些高质量的实操、理论视频，所以，我就围绕书，和
底层，做了几个实操、理论视频，然后效果还不错，后面就做成迭代模式了。

#### 架构班（社群 VIP）的功能：^

提供高质量实操项目整刀真枪的架构指导、快速提升大家的:
 开发水平
 设计水平
 架构水平
弥补业务中 CRUD 开发短板，帮助大家尽早脱离具备 3 高能力，掌握：
 高性能
 高并发
 高可用
作为一个高质量的架构师成长、人脉社群，把所有的卷王聚焦起来，一起卷：
 卷高并发实操
 卷底层原理
 卷架构理论、架构哲学
 最终成为顶级架构师，实现人生理想，走向人生巅峰

#### 架构班（社群 VIP）的目的：^

 高质量的实操，大大提升简历的含金量，吸引力，增强面试的召唤率
 为大家提供九阳真经、葵花宝典，快速提升水平
 进大厂、拿高薪
 一路陪伴，提供助学视频和指导，辅导大家成为架构师
 自学为主，和其他卷王一起，卷高并发实操，卷底层原理、卷大厂面试题，争取狠卷 3 月成高手，狠卷
3 年成为顶级架构师


```
疯狂创客圈^
```
#### N 个超高并发实操项目：简历压轴、个顶个精彩


```
疯狂创客圈^
```
###### 【样章】第 17 章：横扫全网 Rocketmq 视频第 2 部曲: 工业级 rocketmq 高可用（HA）

###### 底层原理和实操

工业级 rocketmq 高可用底层原理，包含：消息消费、同步消息、异步消息、单向消息等不同消息的底层原理
和源码实现；消息队列非常底层的主从复制、高可用、同步刷盘、异步刷盘等底层原理。
工业级 rocketmq 高可用底层原理和搭建实操，包含：高可用集群的搭建。
解决以下难题：
1 、技术难题：RocketMQ 如何最大限度的保证消息不丢失的呢？RocketMQ 消息如何做到高可靠投递？
2 、技术难题：基于消息的分布式事务，核心原理不理解
3 、选型难题： kafka or rocketmq ，该娶谁？
下图链接：https://www.processon.com/view/6178e8ae0e3e7416bde9da19


```
疯狂创客圈^
```
#### 成功案例：^2 年翻^3 倍，^35 岁卷王成功转型为架构师^

详情：http://topcoder.cloud/forum.php?mod=forumdisplay&fid=43&page=1


疯狂创客圈^


疯狂创客圈^


疯狂创客圈^


```
疯狂创客圈^
```
#### 简历优化后的成功涨薪案例（VIP 含免费简历优化）


疯狂创客圈^


疯狂创客圈^


疯狂创客圈^


疯狂创客圈^


疯狂创客圈^


```
疯狂创客圈^
```
# 修改简历找尼恩（资深简历优化专家）

 如果面试表达不好，尼恩会提供简历优化指导

 如果项目没有亮点，尼恩会提供项目亮点指导

 如果面试表达不好，尼恩会提供面试表达指导

作为 40 岁老架构师，尼恩长期承担技术面试官的角色：

 从业以来，“阅历”无数，对简历有着点石成金、改头换面、脱胎换骨的指导能力。

 尼恩指导过刚刚就业的小白，也指导过 P 8 级的老专家，都指导他们上岸。

如何联系尼恩。尼恩微信，请参考下面的地址：

语雀：https://www.yuque.com/crazymakercircle/gkkw8s/khigna
码云：https://gitee.com/crazymaker/SimpleCrayIM/blob/master/疯狂创客圈总目录.md


