#### 文章一：vivo 全球商城亿级订单中心架构设计与实践

```
截止 2021 ，vivo在全球已覆盖 4 亿 多用户，服务 60 多个国家和地区，
```
```
vivo 在菲律宾、马来、印度等国家的市场份额名列前三，在国内出货量始终保持领先地位，并通过vivo
X70系列的推出，成功跻身 2021 年第三季度4000+以上高端手机市场份额的Top3。
```
#### 一、背景

```
从 2017 年开始，随着用户量级的快速增长，vivo 官方商城 v1.0 的单体架构逐渐暴露出弊端：
```
```
模块愈发臃肿
开发效率低下
性能出现瓶颈
系统维护困难。
```
```
从 2017 年开始启动的 v2.0 架构升级和全面的解耦，基于业务模块进行垂直的系统物理拆分，
拆分出来业务线各司其职，提供服务化的能力，共同支撑主站业务。
```
```
订单模块是电商系统的交易核心，不断累积的数据即将达到单表存储瓶颈，
```
```
系统难以支撑新品发布和大促活动期间的流量，服务化改造势在必行。
```
```
本文将介绍 vivo 商城订单系统建设的过程中遇到的问题和解决方案，分享架构设计经验。
```
#### 二、系统架构

```
将订单模块从商城拆分出来，独立为订单系统，使用独立的数据库，
```
```
为商城相关系统提供订单、支付、物流、售后等标准化服务。
```
```
系统架构如下图所示：
```
page:1/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


#### 三、技术挑战

```
1 、数据量和高并发问题
```
```
首先面对的挑战来自存储系统：
```
###### 1 、数据量问题

```
随着历史订单不断累积，MySQL中订单表数据量已达千万级。
```
```
我们知道InnoDB存储引擎的存储结构是B+树，查找时间复杂度是O(log n)，
因此当数据总量n变大时，检索速度必然会变慢，
```
```
不论如何加索引或者优化都无法解决，只能想办法减小单表数据量。
```
```
数据量大的解决方案有：
```
```
数据归档
分表
```
###### 2 、高并发问题

page:2/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
商城业务处于高速发展期，下单量屡创新高，业务复杂度也在提升，
```
```
应用程序对MySQL的访问量越来越高，但是， 单机MySQL的处理能力是有限的，
```
```
当压力过大时，所有请求的访问速度都会下降，甚至有可能使数据库宕机。
```
```
并发量高的解决方案有：
```
```
使用缓存
读写分离
分库
```
```
下面对这些方案进行简单描述：
```
**1 ）数据归档**

```
订单数据具备时间属性，存在热尾效应，大部分情况下检索的都是最近的订单，而订单表里却存储了大
量使用频率较低的老数据。
```
```
那么就可以将新老数据分开存储，将历史订单移入另一张表中，
然后，对代码中的查询模块做一些相应改动，便能有效解决数据量大的问题。
```
```
2 ）使用缓存
```
```
使用Redis作为MySQL的前置缓存，可以挡住大部分的查询请求，并降低响应时延。
缓存对商品系统这类与用户关系不大的系统效果特别好，
```
```
但订单系统有一个特点，每个用户的订单数据都不一样，
所以，对订单系统而言，缓存命中率不算高，效果不是太好。
```
page:3/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


**3 ）读写分离**

```
主库负责执行数据更新请求，然后将数据变更实时同步到所有从库，用多个从库来分担查询请求。
```
```
问题是：
```
```
但订单数据的更新操作较多，下单高峰时主库的压力依然没有得到解决。
且存在主从同步延迟，正常情况下延迟非常小，不超过1ms，但也会导致在某一个时刻的主从数据
不一致。
```
```
那就需要对所有受影响的业务场景进行兼容处理，可能会做一些妥协，
比如下单成功后先跳转到一个下单成功页，用户手动点击查看订单后才能看到这笔订单。
```
page:4/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


**4 ）分库**

```
分库又包含垂直分库和水平分库：
```
```
水平分库： 把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上；
垂直分库： 按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，
它的核心理念是专库专用。
```
**5 ）分表**

```
分表又包含垂直分表和水平分表：
```
```
水平分表： 在同一个数据库内，把一个表的数据按一定规则拆到多个表中；
垂直分表： 将一个表按照字段分成多表，每个表存储其中一部分字段。
```
```
我们综合考虑了改造成本、效果和对现有业务的影响，决定直接使用最后一招： 分库分表。
```
###### 2 、分库分表技术选型

```
分库分表的技术选型主要从这几个方向考虑：
```
```
客户端sdk开源方案
```
page:5/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
中间件proxy开源方案
公司中间件团队提供的自研框架
自己动手造轮子
```
```
参考之前项目经验，并与公司中间件团队沟通后，采用了开源的 Sharding-JDBC 方案。
```
```
Sharding-JDBC 方案 已更名为Sharding-Sphere。其官方的地址是：
```
```
Github：https://github.com/sharding-sphere/
文档：官方文档比较粗糙，但是网上资料、源码解析、demo比较丰富
社区：活跃
特点：jar包方式提供，属于client端分片，支持xa事务
```
**1 ）分库分表策略**

```
结合业务特性，选取用户标识作为分片键，
通过计算用户标识的哈希值再取模，来得到用户订单数据的库表编号。
```
```
假设共有n个库，每个库有m张表，
```
```
则库表编号的计算方式为：
```
page:6/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
库序号：Hash(userId) / m % n
表序号：Hash(userId) % m
```
```
路由过程如下图所示：
```
**2 ）分库分表的局限性和应对方案**

```
分库分表解决了数据量和并发问题，但它会 极大限制数据库的查询能力 ，
```
```
有一些之前很简单的关联查询，在分库分表之后可能就没法实现了，
```
```
那就需要单独对这些Sharding-JDBC不支持的SQL进行改写。
```
```
除此之外，还遇到了这些挑战：
```
```
①全局唯一ID设计
```
page:7/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
分库分表后，数据库自增主键不再全局唯一，不能作为订单号来使用，
```
```
但很多内部系统间的交互接口只有订单号，没有用户标识这个分片键，如何用订单号来找到对应的库表
呢？
```
```
原来，我们在生成订单号时，就将库表编号隐含在其中了。
```
```
这样就能在没有用户标识的场景下，从订单号中获取库表编号。
```
```
②历史订单号没有隐含库表信息
```
```
用一张表单独存储历史订单号和用户标识的映射关系，随着时间推移，这些订单逐渐不在系统间交互，
就慢慢不再被用到。
```
```
③管理后台需要根据各种筛选条件，分页查询所有满足条件的订单
```
```
将订单数据冗余存储在搜索引擎Elasticsearch中，仅用于后台查询。
```
###### 3 、怎么做 MySQL 到 ES 的数据同步

```
上面说到为了便于管理后台的查询，我们将订单数据冗余存储在Elasticsearch中，
```
```
那么，如何在MySQL的订单数据变更后，同步到ES中呢？
```
```
这里要考虑的是数据同步的时效性和一致性、对业务代码侵入小、不影响服务本身的性能等。
```
```
1 ）MQ方案
```
```
ES更新服务作为消费者，接收订单变更MQ消息后对ES进行更新
```
**2 ）Binlog方案**
page:8/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
ES更新服务借助canal等开源项目，把自己伪装成MySQL的从节点，接收Binlog并解析得到实时的数据
变更信息，然后根据这个变更信息去更新ES。
```
```
其中BinLog方案比较通用，但实现起来也较为复杂，我们最终选用的是MQ方案。
```
```
因为ES数据只在管理后台使用，对数据可靠性和同步实时性的要求不是特别高。
```
```
考虑到宕机和消息丢失等极端情况，在后台增加了按某些条件手动同步ES数据的功能来进行补偿。
```
###### 4 、如何安全地更换数据库

```
如何将数据从原来的单实例数据库，迁移到新的数据库集群，也是一大技术挑战。
```
```
不但要确保数据的正确性，还要保证每执行一个步骤后，一旦出现问题，能快速地回滚到上一个步骤。
```
```
我们考虑了停机迁移和不停机迁移的两种方案：
```
**1 ）不停机迁移方案：**

```
把旧库的数据复制到新库中，上线一个同步程序，使用 Binlog等方案实时同步旧库数据到新库；
上线双写订单新旧库服务，只读写旧库；
开启双写，同时停止同步程序，开启对比补偿程序，确保新库数据和旧库一致；
逐步将读请求切到新库上；
读写都切换到新库上，对比补偿程序确保旧库数据和新库一致；
下线旧库，下线订单双写功能，下线同步程序和对比补偿程序。
```
page:9/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


**2 ）停机迁移方案：**

```
上线新订单系统，执行迁移程序将两个月之前的订单同步到新库，并对数据进行稽核；
将商城V1应用停机，确保旧库数据不再变化；
执行迁移程序，将第一步未迁移的订单同步到新库并进行稽核；
上线商城V2应用，开始测试验证，如果失败则回退到商城V1应用（新订单系统有双写旧库的开
关）。
```
page:10/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
考虑到不停机方案的改造成本较高，而夜间停机方案的业务损失并不大，最终选用的是停机迁移方案。
```
###### 5 、分布式事务问题

```
电商的交易流程中，分布式事务是一个经典问题，比如：
用户支付成功后，需要通知发货系统给用户发货；
用户确认收货后，需要通知积分系统给用户发放购物奖励的积分。
```
```
我们是如何保证微服务架构下数据的一致性呢？
```
```
不同业务场景对数据一致性的要求不同，业界的主流方案中，用于解决强一致性的有两阶段提交
(2PC)、三阶段提交(3PC)，解决最终一致性的有TCC、本地消息、事务消息和最大努力通知等。
我们正在使用的本地消息表方案：
```
```
在本地事务中将要执行的异步操作记录在消息表中，如果执行失败，可以通过定时任务来补偿。
```
```
下图以订单完成后通知积分系统赠送积分为例。
```
page:11/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


###### 6 、系统安全和稳定性

```
1 ）网络隔离
```
```
只有极少数第三方接口可通过外网访问，且都会验证签名，内部系统交互使用内网域名和RPC接口。
```
```
2 ）并发锁
```
```
任何订单更新操作之前，会通过数据库行级锁加以限制，防止出现并发更新。
```
```
3 ）幂等性
所有接口均具备幂等性，不用担心对方网络超时重试所造成的影响。
```
```
4 ）熔断
使用Hystrix组件，对外部系统的实时调用添加熔断保护，防止某个系统故障的影响扩大到整个分布式
系统中。
```
```
5 ）监控和告警
```
```
通过配置日志平台的错误日志报警、调用链的服务分析告警，再加上公司各中间件和基础组件的监控告
警功能，让我们能够能够第一时间发现系统异常。
```
###### 7 、踩过的坑

**1 ）消息的有序性问题**
page:12/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
采用MQ消费的方式同步数据库的订单相关数据到ES中，遇到的写入数据不是订单最新数据问题。
```
```
下图左边是原方案：
```
```
在消费订单数据同步的MQ时，如果线程A在先执行，查出数据，
这时候订单数据被更新了，线程B开始执行同步操作，查出订单数据后先于线程A一步写入ES中，
```
```
线程A执行写入时就会将线程B写入的数据覆盖，导致ES中的订单数据不是最新的。
```
```
下图右边是解决方案：
```
```
解决方案是在查询订单数据时加行锁，整个业务执行在事务中，执行完成后再执行下一个线程。
```
**2 ）sharding-jdbc 分组后排序分页查询出所有数据问题**

```
示例：
```
```
执行时Sharding-jdbc里group by 和 order by 字段和顺序不一致时将 10 置为Integer.MAX_VALUE, 导致
分页查询失效。
```
```
select a from temp group by a,b order by a desc limit 1,10。
```
page:13/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
正确的写法应该是
```
```
io.shardingsphere.core.routing.router.sharding.ParsingSQLRouter#processLimit
```
```
private void processLimit(final List<Object> parameters, final SelectStatement
selectStatement, final boolean isSingleRouting) {
boolean isNeedFetchAll = (!selectStatement.getGroupByItems().isEmpty() ||
!selectStatement.getAggregationSelectItems().isEmpty()) &&
!selectStatement.isSameGroupByAndOrderByItems();
selectStatement.getLimit().processParameters(parameters, isNeedFetchAll,
databaseType, isSingleRouting);
}
```
```
io.shardingsphere.core.parsing.parser.context.limit.Limit#processParameters
```
```
/**
* Fill parameters for rewrite limit.
*
* @param parameters parameters
* @param isFetchAll is fetch all data or not
* @param databaseType database type
* @param isSingleRouting is single routing or not
*/
public void processParameters(final List<Object> parameters, final boolean
isFetchAll, final DatabaseType databaseType, final boolean isSingleRouting) {
fill(parameters);
rewrite(parameters, isFetchAll, databaseType, isSingleRouting);
}
```
```
private void rewrite(final List<Object> parameters, final boolean isFetchAll,
final DatabaseType databaseType, final boolean isSingleRouting) {
int rewriteOffset = 0;
int rewriteRowCount;
if (isFetchAll) {
rewriteRowCount = Integer.MAX_VALUE;
} else if (isNeedRewriteRowCount(databaseType) && !isSingleRouting) {
rewriteRowCount = null == rowCount? -1 : getOffsetValue() +
rowCount.getValue();
} else {
rewriteRowCount = rowCount.getValue();
}
if (null != offset && offset.getIndex() > -1 && !isSingleRouting) {
parameters.set(offset.getIndex(), rewriteOffset);
}
if (null != rowCount && rowCount.getIndex() > -1) {
parameters.set(rowCount.getIndex(), rewriteRowCount);
}
}
```
page:14/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
两个sql，可以对比一下
```
```
这里 使用的版本是sharing-jdbc的3.1.1。
```
**3 ）ES分页查询如果排序字段存在重复的值，**

```
最好加一个唯一的字段作为第二排序条件，避免分页查询时漏掉数据、查出重复数据，
```
```
比如用的是订单创建时间作为唯一排序条件，同一时间如果存在很多数据，就会导致查询的订单存在遗
漏或重复，
```
```
这里，需要增加一个唯一值作为第二排序条件、或者直接使用唯一值作为排序条件。
```
#### 四、成果

```
一次性上线成功，稳定运行了一年多；
核心服务性能提升十倍以上；
系统解耦，迭代效率大幅提升；
能够支撑商城至少五年的高速发展。
```
#### 五、结语

```
我们在系统设计时并没有一味追求前沿技术和思想，面对问题时也不是直接采用主流电商的解决方案，
而是根据业务实际状况来选取最合适的办法。
个人觉得，一个好的系统不是在一开始就被大牛设计出来的，一定是随着业务的发展和演进逐渐被迭代
出来的，持续预判业务发展方向，提前制定架构演进方案，
```
```
简单来说就是：走到业务的前面去！
```
```
作者丨官网商城开发团队
```
```
来源丨vivo互联网技术（ID：vivoVMIC）
```
```
select a from temp group by a desc ，b limit 1,10 ；
```
```
select a from temp group by a desc ，b limit 1,10 ； #优化的sql， 去掉了 oderby
```
```
select a from temp group by a,b order by a desc limit 1,10 #原始的sql
```
page:15/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


## 文章 2 ： vivo 全球商城：优惠券系统架构设

## 计与实践

###### 一、业务背景

```
优惠券是电商常见的营销手段，具有灵活的特点，既可以作为促销活动的载体，也是重要的引流入口。
优惠券系统是vivo商城营销模块中一个重要组成部分，早在 15 年vivo商城还是单体应用时，优惠券就是
其中核心模块之一。随着商城的发展及用户量的提升，优惠券做了服务拆分，成立了独立的优惠券系
统，提供通用的优惠券服务。目前，优惠券系统覆盖了优惠券的 4 个核心要点：创、发、用、计。
“创” 指优惠券的创建，包含各种券规则和使用门槛的配置。
“发” 指优惠券的发放，优惠券系统提供了多种发放优惠券的方式，满足针对不同人群的主动发放和
被动发放。
“用” 指优惠券的使用，包括正向购买商品及反向退款后的优惠券回退。
“计” 指优惠券的统计，包括优惠券的发放数量、使用数量、使用商品等数据汇总。
```
```
vivo商城优惠券系统除了提供常见的优惠券促销玩法外，还以优惠券的形式作为其他一些活动或资产的
载体，比如手机类商品的保值换新、内购福利、与外部广告商合作发放优惠券等。
以下为vivo商城优惠券部分场景的展示：
```
page:16/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


###### 二、系统架构及变迁

```
优惠券最早和商城耦合在一个系统中。
```
```
随着vivo商城的不断发展，营销活动力度加大，优惠券使用场景增多，优惠券系统逐渐开始“力不从
心”，暴露了很多问题：
海量优惠券的发放，达到优惠券单库、单表存储瓶颈。
与商城系统的高耦合，直接影响了商城整站接口性能。
优惠券的迭代更新受限于商城的版本安排。
针对多品类优惠券，技术层面没有沉淀通用优惠券能力。
```
```
为了解决以上问题， 19 年优惠券系统进行了系统独立，提供通用的优惠券服务，独立后的系统架构如
下：
```
page:17/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
优惠券系统独立迁移方案
如何将优惠券从商城系统迁移出来，并兼容已对接的业务方和历史数据，也是一大技术挑战。系统迁移
有两种方案：停机迁移和不停机迁移。
```
```
我们采用的是不停机迁移方案：
```
```
迁移前，运营停止与优惠券相关的后台操作，避免产生优惠券静态数据。
```
```
静态数据：优惠券后台生成的数据，与用户无关。
```
```
动态数据：与用户有关的优惠券数据，含用户领取的券、券和订单的关系数据等。
配置当前数据库开关为单写，即优惠券数据写入商城库（旧库）。
优惠券系统上线，通过脚本迁移静态数据。迁完后，验证静态数据迁移准确性。
配置当前数据库开关为双写，即线上数据同时写入商城库和优惠券新库。此时服务提供的数据源依
旧是商城库。
迁移动态数据。迁完后，验证动态数据迁移准确性。
切换数据源，服务提供的数据源切换到新库。验证服务是否正确，出现问题时，切换回商城数据
源。
关闭双写，优惠券系统迁移完成。
```
```
迁移后优惠券系统请求拓扑图如下：
```
page:18/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


###### 三、系统设计

**3.1 优惠券分库分表**

```
随着优惠券发放量越来越大，单表已经达到瓶颈。为了支撑业务的发展，综合考虑，对用户优惠券数据
进行分库分表。
```
```
关键字：技术选型、分库分表因子
```
```
分库分表有成熟的开源方案，这里不做过多介绍。
```
```
参考之前项目经验，采用了公司中间件团队提供的自研框架。
```
```
原理是引入自研的MyBatis的插件，根据自定义的路由策略计算不同的库表后缀，定位至相应的库表。
用户优惠券与用户id关联，并且用户id是贯穿整个系统的重要字段，因此使用用户id作为分库分表的路
由因子。这样可以保证同一个用户路由至相同的库表，既有利于数据的聚合，也方便用户数据的查询。
```
```
假设共分N个库M个表，分库分表的路由策略为：
库后缀databaseSuffix = hash(userId) / M %N
```
```
表后缀tableSuffix = hash(userId) % M
```
page:19/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


**3.2 优惠券发放方式设计**

```
为满足各种不同场景的发券需求，优惠券系统提供三种发券方式：
```
```
统一领券接口 、
```
```
后台定向发券 、
```
```
券码兑换发放 。
```
```
3.2.1 统一领券接口
```
```
保证领券校验的准确性
领券时，需要严格校验优惠券的各种属性是否满足：比如领取对象、各种限制条件等。
```
```
其中，比较关键的是库存和领取数量的校验。因为在高并发的情况下，需保证数量校验的准确性，不然
很容易造成用户超领。
```
```
存在这样的场景：A用户连续发起两次领取券C的请求，券C限制每个用户领取一张。
```
```
第一次请求通过了领券数量的校验，在用户优惠券未落库的情况下，如果不做限制，第二次请求也会通
过领券数量的校验。这样A用户会成功领取两张券C，造成超领。
```
```
为了解决这个问题，优惠券采用的是分布式锁方案，分布式锁的实现依赖于Redis。
在校验用户领券数量前先尝试获取分布式锁，优惠券发放成功后释放锁，保证用户领取同一张券时不会
出现超领。上面这种场景，用户第一次请求成功获取分布式锁后，直至第一次请求成功释放已获取的分
布式锁或超时释放，不然用户第二次请求会获取分布式锁失败，这样保证A用户只会成功领取一张。
```
```
库存扣减
```
```
领券要进行库存扣减，常见库存扣减方案有两种：
```
```
方案一： 数据库扣减。
```
page:20/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
扣减库存时，直接更新数据库中库存字段。
```
```
该方案的 优点 是简单便捷，查验库存时直接查库即可获取到实时库存。且有数据库事务保证，不
用考虑数据丢失和不一致的问题。
```
```
缺点 也很明显，主要有两点：
```
```
1 ）库存是数据库中的单个字段，在更新库存时，所有的请求需要等待行锁。一旦并发量大了，就
会有很多请求阻塞在这里，导致请求超时，进而系统雪崩。
```
```
2 ）频繁请求数据库，比较耗时，且会大量占用数据库连接资源。
方案二： 基于redis实现库存扣减操作。
```
```
将库存放到缓存中，利用redis的incrby特性来扣减库存。
```
```
该方案的 优点 是突破数据库的瓶颈，速度快，性能高。
```
```
缺点 是系统流程会比较复杂，而且需要考虑缓存丢失或宕机数据恢复的问题，容易造成库存数据
不一致。
```
```
从优惠券系统当前及可预见未来的流量峰值、系统维护性、实用性上综合考虑，优惠券系统采用了方案
一的改进方案。改进方案是将单库存字段分散成多库存字段，分散数据库的行锁，减少并发量大的情况
数据库的行锁瓶颈。
```
```
库存数更新后，会将库存平均分配成M份，初始化更新到库存记录表中。用户领券，随机选取库存记录
表中已分配的某一库存字段（共M个）进行更新，更新成功即为库存扣减成功。同时，定时任务会定期
同步已领取的库存数。相比方案一，该方案突破了数据库单行锁的瓶颈限制，且实现简单，不用考虑数
据丢失和不一致的问题。
一键领取多张券
```
```
在对接的业务方的领券场景中，存在用户一键领取多张券的情形。因此统一领券接口需要支持用户一键
领券，除了领取同一券模板的多张，也支持领取不同券模板的多张。一般来说，一键领取多张券指领取
不同券模板的多张。在实现过程中，需要注意以下几点：
1 ）如何保证性能
```
page:21/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
领取多张券，如果每张券分别进行校验、库存扣减、入库，那么接口性能的瓶颈卡在券的数量上，数量
越多，性能直线下降。那么在券数量多的情况下，怎么保证高性能呢？主要采取两个措施：
```
```
a. 批量操作 。
```
```
从发券流程来看，瓶颈在于券的入库。领券是实时的（异步的话，不能实时将券发到用户账户
下，影响到用户的体验还有券的转化率），券越多，入库时与数据库的IO次数越多，性能越差。
批量入库可以保证与数据库的IO的次数只有一次，不受券的数量影响。如上所述，用户优惠券数
据做了分库分表，同一用户的优惠券资产保存在同一库表中，因此同一用户可实现批量入库。
```
```
b. 限制单次领券数量 。
```
```
设置阀值，超出数量后，直接返回，保证系统在安全范围内。
2 ）保证高并发情况下，用户不会超领
```
```
假如用户在商城发起请求，一键领取A/B/C/D四张券，同时活动系统给用户发放券A，这两个领券请求
是同时的。其中，券A限制了每个用户只能领取一张。按照前述采用分布式锁保证校验的准确性，两次
请求的分布式锁的key分别为：
```
```
用户id+A_id+B_id+C_id+D_id
```
```
用户id+A_id
```
```
这种情况下，两次请求的分布式锁并没有发挥作用，因为锁key是不同，数量校验依旧存在错误的可能
性。为避免批量领券过程中用户超领现象的发生，在批量领券过程中，对分布锁的获取进行了改造。上
例一键领取A/B/C/D四张券，需要批量获取 4 个分布式锁，锁key为：
用户id+A_id
```
```
用户id+B_id
```
```
用户id+C_id
```
```
用户id+D_id
获取其中任何一个锁失败，即表明此时该用户正在领取其中某一张券，需要自旋等待（在超时时间
内）。获取所有的分布式锁成功，才可以进行下一步。
```
```
接口幂等性
统一领券接口需保证幂等性（幂等性：用户对于同一操作发起的一次请求或者多次请求的结果是一致
的）。在网络超时、异常情况下，领券结果没有及时返回，业务方会进行领券重试。如果接口不保证幂
等性，会造成超发。幂等性的实现有多种方案，优惠券系统利用数据库的唯一索引来保证幂等。
```
```
领券最早是不支持幂等性的，表设计没有考虑幂等性。
```
```
那么 第一个需要考虑的问题：在哪个表来添加唯一索引呢？
无非两种方案：现有的表或者新建表。
```
```
采用现有的表，不需要增加表的关联。但如上所述，因为做了分库分表，大量的表需要添加唯一字
段，并且需要兼容历史数据，需要保证历史数据新增字段的唯一性。
采用新建表这种方式，不需要兼容历史数据，但缺陷也很明显，增加了一层表的关联，对性能和现
有逻辑都有很大影响。综合考虑，我们选取了在现有表添加唯一字段这种方式，这样更利于保证性
能和后续的维护性。
第二个考虑的问题：怎么兼容历史数据和业务方？ 历史数据增加了唯一字段，需要填入唯一值，不然无
法添加唯一索引。我们采用脚本刷数据的方式，构造唯一值并刷新到每一行历史数据中。优惠券已对接
的业务方没有传入唯一编码，针对这种情况，优惠券侧生成唯一编码作为替代，保证兼容性。
```
```
3.2.2 定向发券
```
page:22/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
定向发券用于运营在后台针对特定人群进行发券。定向发券可以弥补用户主动领券，人群覆盖不精准、
覆盖面不广的问题。通过定向发券，可以精准覆盖特定人群，提高下单转化率。在大促期间，大范围人
群的定向发券还可以承载活动push和降价促销双重任务。
```
```
定向发券主要在于人群的圈选和发券流程的设计，整体流程如下：
```
```
定向发券不同于用户主动领券，定向发券的量通常会很大（亿级）。为了支撑大批量的定向发券，定向
发券做了一些优化：
```
```
1 ）去除事务 。事务逻辑过重，对于定向发券来说没必要。发券失败，记录失败的券，保证失败可以重
试。
2 ）轻量化校验 。定向发券限制了券类型，通过限制配置的方式规避需严格校验属性的配置。不同于用
户主动领券校验逻辑的冗长，定向发券的校验非常轻量，大大提升发券性能。
```
```
3 ）批量插入 。批量券插入减少数据库IO次数，消除数据库瓶颈，提升发券速度。定向发券是针对不同
的用户，用户优惠券做了分库分表，为了实现批量插入，需要在内存中先计算出不同用户对应的库表后
缀，数据归集后再批量插入，最多插入M次，M为库表总个数。
```
```
4 ）核心参数可动态配置 。比如单次发券数量，单次读库数量，发给消息中心的消息体包含的用户数量
等，可以控制定向发券的峰值速度和平均速度。
```
```
3.2.3 券码兑换
```
```
站外营销券的发放方式与其他券不同，通过券码进行兑换。券码由后台导出，通过短信或者活动的方式
发放到用户，用户根据券码兑换后获取相应的券。券码的组成有一定的规则，在规则的基础上要保证安
全性，这种安全性主要是券码校验的准确性，防止已兑换券码的再次兑换和无效券码的恶意兑换。
```
**3.3 精细化营销能力设计**

page:23/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
通过标签组合配置的方式，优惠券提供精细化营销的能力，以实现优惠券的千人千面。标签可分为准实
时和实时，值得注意的是，一些实时的标签的处理需要前提条件，比如地区属性需要用户授权。
```
```
优惠券的精准触达：
```
**3.4 券和商品之间的关系**

```
优惠券的使用需要和商品关联，可关联所有商品，也可以关联部分商品。为了灵活性地满足运营对于券
关联商品的配置，优惠券系统有两种关联方式：
a. 黑名单。
```
```
可用商品 = 全部商品 - 黑名单商品。
```
```
黑名单适用于券的可使用商品范围比较广这种情况，全部商品排除掉黑名单商品就是券的可使用
范围。
```
```
b. 白名单。
```
```
可用商品 = 白名单商品。
白名单适用于券的可使用商品范围比较小这种情况，直接配置券的可使用商品。
```
```
除此以外，还有超级黑名单的配置，黑名单和白名单只对单个券有效，超级黑名单对所有券有效。当前
优惠券系统提供商品级的关联，后续优惠券会支持商品分类维度的关联，分类维度 + 商品维度可以更灵
活地关联优惠券和商品。
```
**3.5 高性能保证**

```
优惠券对接系统多，存在高流量场景，优惠券对外提供接口需保证高性能和高稳定性。
```
```
多级缓存
```
```
为了提升查询速度，减轻数据库的压力，同时为了应对瞬时高流量带来热点key的场景（比如发布会直
播结束切换流量至特定商品商详页、热点活动商品商详页都会给优惠券系统带来瞬时高流量），优惠券
采用了多级缓存的方式。
```
page:24/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
数据库读写分离
```
```
优惠券除了上述所说的分库分表外，在此基础上还做了读写分离操作。主库负责执行数据更新请求，然
后将数据变更实时同步到所有从库，用从库来分担查询请求，解决数据库写入影响查询的问题。主从同
步存在延迟，正常情况下延迟不超过1ms，优惠券的领取或状态变更存在一个耗时的过程，主从延迟对
于用户来说无感知。
```
page:25/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
依赖外部接口隔离熔断
```
```
优惠券内部依赖了第三方的系统，为了防止因为依赖方服务不可用，产生连锁效应，最终导致优惠券服
务雪崩的事情发生，优惠券对依赖外部接口做了隔离和熔断。
用户维度优惠券字段冗余
```
```
查询用户相关的优惠券数据是优惠券最频繁的查询操作之一，用户优惠券数据做了分库分表，在查询时
无法关联券规则表进行查询，为了减少IO次数，用户优惠券表中冗余了部分券规则的字段。优惠券规则
表字段较多，冗余的字段不能很多，要在性能和字段数之间做好平衡。
```
**四、总结及展望**

```
最后对优惠券系统进行一个总结：
```
```
不停机迁移，平稳过渡。自独立后已稳定运行 2 年，性能足以支撑vivo商城未来3-5年的高速发展。
系统解耦，迭代效率大幅提升。
针对业务问题，原则是选择合适实用的方案。
具备完善的优惠券业务能力。
展望：目前优惠券系统主要服务于vivo商城，未来我们希望将优惠券能力开放，为内部其他业务方提供
通用一体化的优惠券平台。
```
```
作者：vivo互联网开发团队-Yan Chao
分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。
```
page:26/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
发布于: 2022-11-22阅读数: 39
```
```
版权声明: 本文为 InfoQ 作者【vivo互联网技术】的原创文章。
原文链接:【https://xie.infoq.cn/article/5d9a6b64987aafe10cdc6224d】。文章转载请联系作者。
```
page:27/27 of 尼恩Java硬核架构班：狠卷3高架构，卷透底层技术，走向技术自由！


```
疯狂创客圈^
```
# 硬核推荐：尼恩Java硬核架构班

## 又名疯狂创客圈社群VIP

## 详情：https://www.cnblogs.com/crazymakercircle/p/9904544.html


疯狂创客圈^


```
疯狂创客圈^
```
##### 架构班（社群VIP）的起源：^

最初的视频，主要是给读者加餐。很多的读者，需要一些高质量的实操、理论视频，所以，我就围绕书，和
底层，做了几个实操、理论视频，然后效果还不错，后面就做成迭代模式了。

##### 架构班（社群VIP）的功能：^

提供高质量实操项目整刀真枪的架构指导、快速提升大家的:
 开发水平
 设计水平
 架构水平
弥补业务中CRUD开发短板，帮助大家尽早脱离具备 3 高能力，掌握：
 高性能
 高并发
 高可用
作为一个高质量的架构师成长、人脉社群，把所有的卷王聚焦起来，一起卷：
 卷高并发实操
 卷底层原理
 卷架构理论、架构哲学
 最终成为顶级架构师，实现人生理想，走向人生巅峰

##### 架构班（社群VIP）的目的：^

 高质量的实操，大大提升简历的含金量，吸引力，增强面试的召唤率
 为大家提供九阳真经、葵花宝典，快速提升水平
 进大厂、拿高薪
 一路陪伴，提供助学视频和指导，辅导大家成为架构师
 自学为主，和其他卷王一起，卷高并发实操，卷底层原理、卷大厂面试题，争取狠卷 3 月成高手，狠卷
3 年成为顶级架构师


```
疯狂创客圈^
```
##### N个超高并发实操项目：简历压轴、个顶个精彩


```
疯狂创客圈^
```
【样章】第 17 章：横扫全网Rocketmq视频第 2 部曲: 工业级rocketmq高可用（HA）
底层原理和实操
工业级rocketmq高可用底层原理，包含：消息消费、同步消息、异步消息、单向消息等不同消息的底层原理
和源码实现；消息队列非常底层的主从复制、高可用、同步刷盘、异步刷盘等底层原理。
工业级rocketmq高可用底层原理和搭建实操，包含：高可用集群的搭建。
解决以下难题：
1 、技术难题：RocketMQ如何最大限度的保证消息不丢失的呢？RocketMQ消息如何做到高可靠投递？
2 、技术难题：基于消息的分布式事务，核心原理不理解
3 、选型难题： kafka or rocketmq ，该娶谁？
下图链接：https://www.processon.com/view/6178e8ae0e3e7416bde9da19


```
疯狂创客圈^
```
##### 成功案例：^2 年翻^3 倍，^35 岁卷王成功转型为架构师^

详情：http://topcoder.cloud/forum.php?mod=forumdisplay&fid=43&page=1


疯狂创客圈^


疯狂创客圈^


疯狂创客圈^


```
疯狂创客圈^
```
### 简历优化后的成功涨薪案例（VIP含免费简历优化）


疯狂创客圈^


疯狂创客圈^


疯狂创客圈^


疯狂创客圈^


疯狂创客圈^


```
疯狂创客圈^
```
# 修改简历找尼恩（资深简历优化专家）

 如果面试表达不好，尼恩会提供 简历优化指导

 如果项目没有亮点，尼恩会提供 项目亮点指导

 如果面试表达不好，尼恩会提供 面试表达指导

作为 40 岁老架构师，尼恩长期承担技术面试官的角色：

 从业以来，“阅历”无数，对简历有着点石成金、改头换面、脱胎换骨的指导能力。

 尼恩指导过刚刚就业的小白，也指导过P8级的老专家，都指导他们上岸。

如何联系尼恩。尼恩微信，请参考下面的地址：

语雀：https://www.yuque.com/crazymakercircle/gkkw8s/khigna
码云：https://gitee.com/crazymaker/SimpleCrayIM/blob/master/疯狂创客圈总目录.md


