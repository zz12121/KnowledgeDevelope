```
技术自由圈
```
# 牛逼的职业发展之路

40 岁老架构尼恩用一张图揭秘: Java 工程师的高端职业发展路径，走向食物链顶端的之路

链接：https://www.processon.com/view/link/618a2b62e0b34d73f7eb3cd


```
技术自由圈^
```
# 史上最全：价值 10 W 的架构师知识图谱

此图梳理于尼恩的多个 3 高生产项目：多个亿级人民币的大型 SAAS 平台和智慧城市项目

链接：https://www.processon.com/view/link/60fb9421637689719d


```
技术自由圈
```
# 牛逼的架构师哲学

40 岁老架构师尼恩对自己的 20 年的开发、架构经验总结

链接：https://www.processon.com/view/link/616f801963768961e9d9aec


```
技术自由圈
```
# 牛逼的 3 高架构知识宇宙

尼恩 3 高架构知识宇宙，帮助大家穿透 3 高架构，走向技术自由，远离中年危机

链接：https://www.processon.com/view/link/635097d2e0b34d40be778ab


```
技术自由圈
```
# 尼恩 Java 面试宝典

40 个专题（卷王专供+ 史上最全 + 2023 面试必备）
详情：https://www.cnblogs.com/crazymakercircle/p/13917138.html


```
技术自由圈^
```
# 未来职业，如何突围：三栖架构师


## 专题 1 ：JVM 面试题（史上最全、定期更新）

#### 本文版本说明：V

```
此文的格式，由 markdown 通过程序转成而来，由于很多表格，没有来的及调整，出现一个格式
问题，尼恩在此给大家道歉啦。
```
```
由于社群很多小伙伴，在面试，不断的交流最新的面试难题，所以，《尼恩Java面试宝典》， 后
面会不断升级，迭代。
本专题，作为 《尼恩Java面试宝典》专题之一，《尼恩Java面试宝典》一共 41 个面试专题。
```
###### 《尼恩 Java 面试宝典》升级的规划为：

后续基本上， **每一个月，都会发布一次** ，最新版本，可以扫描扫架构师尼恩微信，发送 “领电子书” 获
取。

尼恩的微信二维码在哪里呢 ？ 具体可以百度搜索 **疯狂创客圈总目录**

###### 面试问题交流说明：

如果遇到面试难题，或者职业发展问题，或者中年危机问题，都可以来疯狂创客圈社群交流，

加入交流群，加尼恩微信即可，

尼恩的微信二维码在哪里呢 ？ 具体参见文末

###### 升级说明：

**V 107 升级说明（2023-09-09）：**

微博一面：JVM 预热，你的方案是啥？

**V 87 升级说明（2023-06-17）：**

面试真题：你们用什么版本的 jdk？聊一聊不同版本的 jdk 的新特性？

**V 81 升级说明（2023-06-17）：**

美团一面：OOM 后，JVM 一定会退出吗？为什么？


**V 13 升级说明（2022-12-06）：**

```
大厂面试题：Java中的对象一定是在堆上分配的吗？
大厂面试题：聊聊，什么是即时编译？
```
**V 10 升级说明（2022-11-08）：**

```
问：Java中的String对象的大小?
场景题：说说JVM相关的类的加载、链接和初始化的问题？
```
**V 4 升级说明（2022-5-20），增加了方法区的 4 个连环炮：**

```
问：介绍一下方法区和永久代的区别?
问：说是方法区和堆的区别？
问：如何设置方法区内存的大小?
问：如何解决方法区的OOM？
```
**V 3 升级说明（2022-5-16）：**

升级了 3 个面试连环炮

**JVM 内存连环炮：**

JVM 内存包括哪些？什么是堆内存? 什么是非堆内存? 什么是直接内存? 方法区和永久代有何区别?

**对象结构连环炮：**

给定一个具体的类，请分析对象的内存占用? 怎么计算出来一个对象的内存占用? 对象头中包含哪些部
分？

**JVM 调优连环炮：**

常用的 JVM 启动参数有哪些? 调优命令有哪些？设置堆内存 XMX 应该考虑哪些因素？假设物理内存是
8 G，设置多大堆内存比较合适? 怎样开启 GC 日志？

#### 社群真题

以下真题，来自于卷王群，是小伙伴碰到的。

###### 社群真题 1 ：元空间会产生内存溢出么？在什么情况下会产生内存溢

###### 出？

```
具体问题：元空间会产生内存溢出么？在什么情况下会产生内存溢出？。
```

java 8 及以后的版本使用 Metaspace 来代替永久代，Metaspace 是方法区在 HotSpot 中的实现，它与永
久代最大区别在于，Metaspace 并不在虚拟机内存中而是使用本地内存也就是在 JDK 8 中, classe
metadata (the virtual machines internal presentation of Java class), 被存储在叫做 Metaspace 的
native memory.
永久代（java 8 后被元空间 Metaspace 取代了）存放了以下信息：

```
虚拟机加载的类信息
常量池
静态变量
即时编译后的代码
```
**出现问题原因**

错误的主要原因, 是加载到内存中的 class 数量太多或者体积太大。

**解决办法**

增加 Metaspace 的大小

**代码演示**

模拟 Metaspace 空间溢出，我们不断生成类往元空间灌，类占据的空间是会超过 Metaspace 指定的空间
大小的

查看元空间大小

设置配置这里设置 10 m 方便演示效果

```
-XX:MaxMetaspaceSize=512m
```
```
java -XX:+PrintFlagsInitial
```
```
-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m
```

编写代码

```
import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;
```
```
import java.lang.reflect.Method;
```
```
public class MetaspaceDemo {
static class OOM{}
public static void main(String[] args) {
int i = 0 ;//模拟计数多少次以后发生异常
try {
while (true){
i++;
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(OOM.class);
enhancer.setUseCache(false);
enhancer.setCallback(new MethodInterceptor() {
@Override
public Object intercept(Object o, Method method, Object[] objects,
MethodProxy methodProxy) throws Throwable {
return methodProxy.invokeSuper(o,args);
}
});
enhancer.create();
}
} catch (Throwable e) {
System.out.println("=================多少次后发生异常："+i);
e.printStackTrace();
}
}
}
```

运行结果：

```
更多面试真题，请来 疯狂创客圈社群的 微信群交流，具体请参考 Java 高并发 发烧友社群：疯狂
创客圈（总入口）
```
#### 正式内容 1 ：Java 内存区域

###### 问：说一下 Java 堆空间及 GC？

当通过 Java 命令启动 Java 进程的时候，会为它分配内存。

内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。

GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。

###### 问： 说一下 JVM 的主要组成部分及其作用？


JVM 包含两个子系统和两个组件，两个子系统为 Class loader (类装载)、Execution engine (执行引擎)；

两个组件为 Runtime data area (运行时数据区)、Native Interface (本地接口)。

```
Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到
Runtime data area中的method area。
Execution engine（执行引擎）：执行classes中的指令。
Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。
Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。
```
**作用** ：

首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其
放在运行时数据区（Runtime data area）的方法区内，

而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令
解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，

同事，java 代码中，可以调用其他语言的本地库接口（Native Interface）来，进行一些系统调用或者 c
函数调用。


**下面是 Java 程序运行机制详细说明**

Java 程序运行机制步骤

```
首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java；
再利用编译器(javac命令)将源代码编译成字节码文件，字节码文件的后缀名为.class；
运行字节码的工作是由解释器(java命令)来完成的。
```

从上图可以看，java 文件通过编译器变成了. class 文件，接下来类加载器又将这些. class 文件加载到 JVM
中。

其实可以一句话来解释：类的加载指的是将类的. class 文件中的二进制数据读入到内存中，将其放在运
行时数据区的方法区内，然后在堆区创建一个 java. lang. Class 对象，用来封装类在方法区内的数据结
构。

###### 问: 说一下 JVM 运行时数据区？ 或：说一下 JVM 内存模型？

**思路：** 给面试官画一下 JVM 内存模型图，并描述每个模块的定义，作用，以及可能会存在的问题，如栈
溢出等。

Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区
域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依
赖线程的启动和结束而建立和销毁。

Java 虚拟机所管理的内存被划分为如下几个区域：


```
程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解
析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳
转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；
Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方
法出口等信息；
本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java
方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；
Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实
例都在这里分配内存；
方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的
代码等数据。
```
###### JVM 内存连环炮，问：JVM 内存包括哪些？

JVM 总内存= 栈 + 堆 +Native

Native= 堆外内存（直接内存） + 元空间

非堆 = 元空间

**JVM 8 结构**


**程序计数器（Program Counter Register）**

程序计数器就是当前线程所执行的字节码的行号指示器，通过改变计数器的值，来选取下一行指令，通
过他来实现跳转、循环、恢复线程等功能。

```
在任何时刻，一个处理器内核只能运行一个线程，多线程是通过线程轮流切换，分配时间来完成
的，这就需要有一个标志来记住每个线程执行到了哪里，这里便需要到了程序计数器。
程序计数器是线程私有的，每个线程都已自己的程序计数器 。
```
**虚拟机栈（JVM Stacks）**

虚拟机栈是线程私有的，随线程生灭。虚拟机栈描述的是线程中的方法的内存模型：

每个方法被执行的时候，都会在虚拟机栈中同步创建一个栈帧（stack frame）。
每个栈帧的包含如下的内容

```
局部变量表: 局部变量表中存储着方法里的java基本数据类型
（byte/boolean/char/int/long/double/float/short）以及对象的引用（注：这里的基本数据类型
指的是方法内的局部变量）
操作数栈
动态连接
方法返回地址
方法被执行时入栈，执行完后出栈
```
虚拟机栈可能会抛出两种异常：

```
如果线程请求的栈深度大于虚拟机所规定的栈深度，则会抛出StackOverFlowError即栈溢出
如果虚拟机的栈容量可以动态扩展，那么当虚拟机栈申请不到内存时会抛出OutOfMemoryError
即OOM内存溢出
```
产生 StackOverFlowError 的原因是：

```
无限递归循环调用（最常见）。
执行了大量方法，导致线程栈空间耗尽。
方法内声明了海量的局部变量。
```
**本地方法栈（Native Method Stacks）**


本地方法栈与虚拟机栈的作用是相似的, 都会抛出 OutOfMemoryError 和 StackOverFlowError，都是线
程私有的，主要的区别在于：

```
虚拟机栈执行的是java方法
本地方法栈执行的是native方法
```
**Java 堆（Java Heap）**

java 堆是 JVM 内存中最大的一块，由所有线程共享, 是由垃圾收集器管理的内存区域，主要存放对象实
例，当然由于 java 虚拟机的发展，堆中也多了许多东西，现在主要有：

**对象实例**

```
类初始化生成的对象
基本数据类型的数组也是对象实例
```
**字符串常量池**

```
字符串常量池原本存放于方法区，从jdk7开始放置于堆中。
字符串常量池存储的是string对象的直接引用，而不是直接存放的对象，是一张string table
```
**静态变量**

```
静态变量是有static修饰的变量，jdk7时从方法区迁移至堆中
```
**线程分配缓冲区（Thread Local Allocation Buffer）**

```
线程私有，但是不影响java堆的共性
增加线程分配缓冲区是为了提升对象分配时的效率
```
java 堆既可以是固定大小的，也可以是可扩展的（通过参数-Xmx 和-Xms 设定），如果堆无法扩展或者
无法分配内存时也会报 OOM。

**方法区 (Method Area)**

```
它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。
```
**A. 类型信息** ：

对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存
储以下类型信息：

```
这个类型的 完整有效名称 （全名=包名.类名）。
这个类型 直接父类 的完整有效名（对于interface或是java.lang. Object，都没有父类）。
这个类型的修饰符（ public, abstract,final的某个子集）。
这个类型实现接口的一个有序列表。
```
**B. 域（Field）信息：**

JVM 必须在方法区中保存类型的所有 **域的相关信息** 以及 **域的声明顺序** 。

域的相关信息包括：

```
域名称
域类型
域修饰符（public，private，protected，static，final， volatile，transient的某个子集）。
```
**C. 方法（Method）信息：**

JVM 必须在方法区中保存类型的所有 **方法的相关信息** 以及 **方法的声明顺序** 。

方法的相关信息包括：


```
方法名称
方法的返回类型（或void）
方法参数的数量和类型（按顺序）
方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的
一个子集）
方法的字节码（bytecodes）、操作数栈、局部变量表及大小（ abstract和native方法除外）
异常表（abstract和 native方法除外）
每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常
类的常量池索引
```
**D. 静态变量（non-final 的）**

静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。类变量被类的所
有实例共享，即使没有类实例时你也可以访问它。

补充说明：被声明为 final 的静态变量的处理方法则不同，被 static 和 final 修饰的变量也称为全局变量，
每个全局常量在编译的时候就会被赋值了。

通过 javap 命令反编译后的 class 文件：

**E. 运行时常量池：**

理解运行时常量池，需要了解字节码文件（ClassFile）中的常量池；方法区内部包含运行时常量池，字
节码文件内部包含了常量池。

```
public class Order {
public static int num = 10 ;
public static final int COUNT = 20 ;
}
```

首先简单说明常量池：

一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信
息，那就是常量池（ Constant Pool Table），包括各种 **字面量（数量值和字符串值）和对类型、域和
方法的符号引用** 。常量池可以看做是一张表，虚拟机指令根据这张常量表，找到要执行的字面量、类
名、方法名、参数类型等。

然后说明运行时常量池：

```
运行时常量池（Runtime Constant pool）是方法区的一部分。
常量池（Constant Pool Table）是class文件的一部分，用于存放 编译期生成 的各种字面量与符号
引用，这部分内容将在 类加载后存放到方法区的运行时常量池 中。
在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
JVM为 每个 已加载的类型（类或接口）都维护一个运行时常量池，池中的数据项像数组项一样，是
通过索引访问的。
运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析
后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，会转换为真实地址。
运行时常量池，相对于Class文件中的常量池的另一重要特征是：具备 动态性 。比如
String.intern()方法会动态地向池中增加内容
运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据比符号表要
更加丰富。
如果构造类或接口的运行时常量池时，所需的内存空间超过了方法区所能提供的最大值，则JVM会
抛出OutOfMemoryError异常。
```
**直接内存 (Direct Memory)**

jdk 1.4 中加入了 NIO (New Input/Putput) 类，引入了一种基于通道 (channel) 与缓冲区 (buffer) 的新 IO 方
式，它可以使用 native 函数直接分配堆外内存，然后通过存储在 java 堆中的 DirectByteBuffer 对象作为
这块内存的引用进行操作，这样可以在一些场景下大大提高 IO 性能，避免了在 java 堆和 native 堆来回复
制数据

java 的 NIO 库允许 java 程序使用直接内存。直接内存是在 java 堆外的、直接向系统申请的内存空间。
通常访问直接内存的速度会优于 java 堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接
内存。由于直接内存在 java 堆外，因此它的大小不会直接受限于 Xmx （虚拟机参数）指定的最大堆大
小，但是系统内存是有限的， java 堆和直接内存的总和依然受限于操作系统能给出的最大内存。直接
内存位于本地内存，不属于 JVM 内存，不受 GC 管理，但是也会在物理内存耗尽的时候报 OOM。

注意：direct buffer 不受 GC 影响，但是 direct buffer 归属的 JAVA 对象是在堆上且能够被 GC 回收的，一
旦它被回收，JVM 将释放 direct buffer 的堆外空间

直接内存 (Direct Memory) 的特点：

```
直接内存并非 JVMS 定义的标准 Java 运行时内存。
JDK1.4 加入了新的 NIO 机制，目的是防止 Java 堆 和 Native 堆之间往复的数据复制带来的性能损
耗，此后 NIO 可以使用 Native 的方式直接在 Native 堆分配内存。
直接内存区域是全局共享的内存区域。
直接内存区域可以进行自动内存管理(GC)，但机制并不完善。
本机的 Native 堆(直接内存) 不受 JVM 堆内存大小限制。可能出现 OutOfMemoryError 异常。
```
###### JVM 内存连环炮：什么是堆内存?


以 Hotspot 为例，堆内存（HEAP）主要由 GC 模块进行分配和管理，可分为以下部分：

```
新生代(伊甸园区+幸存者区)
老年代
```
其中， 1 伊甸园区 + 2 幸存者区一般称为年轻代。如下图所示（jdk 1.6）

我们在 jvm 参数中只要使用-Xms，-Xmx 等参数就可以设置堆的大小和最大值，

理解 jvm 的堆还需要知道下面这个公式：

如下面的图所示：

再来一个图：

在使用堆内内存（on-heap memory）的时候，完全遵守 JVM 虚拟机的内存管理机制，采用垃圾回收器
（GC）统一进行内存管理，

GC 会在某些特定的时间点进行一次彻底回收，也就是 Full GC，GC 会对所有分配的堆内内存进行扫描，

在这个过程中会对 JAVA 应用程序的性能造成一定影响，还可能会产生 Stop The World。

常见的垃圾回收算法主要有：

```
引用计数器法（Reference Counting）
标记清除法（Mark-Sweep）
复制算法（Coping）
标记压缩法（Mark-Compact）
分代算法（Generational Collecting）
分区算法（Region）
```
###### JVM 内存连环炮：什么是非堆内存?

除堆内存之外，JVM 的内存池还包括非堆（NON_HEAP），

非堆内存大概包括：

```
MetaSpace
CodeCache
Compressed Class Space
```
```
堆内内存 = 新生代+老年代
```

对应于 **JVM 规范中的方法区** ，也就是 jdk 1.8 的元空间

通常 Mehtod Area 又称之为 Non-Heap，与 Heap 进行区分理解 (JDK 8 之前的 Method Area 实现是 Perm
Space，JDK 8 及之后的 Method Area 实现叫 Meta Space)

###### JVM 内存连环炮：什么是堆外内存/直接内存（direct memory）？

堆外内存, 常常又叫做直接内存。和堆内内存相对应，堆外内存就是把内存对象分配在 **Java 虚拟机的
堆** 以外的内存，

这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对
应用程序造成的影响。

作为 JAVA 开发者我们经常用 java. nio. DirectByteBuffer 对象进行堆外内存的管理和使用，它会在对象创
建的时候就分配堆外内存。

DirectByteBuffer 类是在 Java Heap 外分配内存，对堆外内存的申请主要是通过成员变量 unsafe 来操
作，下面介绍构造方法。

```
DirectByteBuffer(int cap) {
super(-1, 0, cap, cap);
//内存是否按页分配对齐
boolean pa = VM.isDirectMemoryPageAligned();
//获取每页内存大小
int ps = Bits.pageSize();
//分配内存的大小，如果是按页对齐方式，需要再加一页内存的容量
long size = Math.max(1L, (long)cap + (pa? ps : 0));
//用Bits类保存总分配内存(按页分配)的大小和实际内存的大小
```

注：在 Cleaner 内部中通过一个列表，维护了一个针对每一个 directBuffer 的一个回收堆外内存的线程
对象 (Runnable)，回收操作是发生在 Cleaner 的 clean () 方法中。

###### JVM 内存连环炮：介绍一下方法区和永久代的区别

**方法区**

```
Bits.reserveMemory(size, cap);
long base = 0;
try {
//在堆外内存的基地址，指定内存大小
base = unsafe.allocateMemory(size);
} catch (OutOfMemoryError x) {
Bits.unreserveMemory(size, cap);
throw x;
}
unsafe.setMemory(base, size, (byte) 0);
//计算堆外内存的基地址
if (pa && (base % ps != 0)) {
// Round up to page boundary
address = base + ps - (base & (ps - 1));
} else {
address = base;
}
cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
att = null;
}
```
```
private static class Deallocator implements Runnable {
private static Unsafe unsafe = Unsafe.getUnsafe();
private long address;
private long size;
private int capacity;
private Deallocator(long address, long size, int capacity) {
assert (address != 0);
this.address = address;
this.size = size;
this.capacity = capacity;
}
```
```
public void run() {
if (address == 0) {
// Paranoia
return;
}
unsafe.freeMemory(address);
address = 0;
Bits.unreserveMemory(size, capacity);
}
}
```

方法区属于 JVM 规范的内容，

JVM 规范中，

方法区主要用于存储类的信息、常量池、方法数据、方法代码等。

方法区是 JVM 的规范，所有虚拟机必须遵守的。常见的 JVM 虚拟机 Hotspot 、 JRockit（Oracle）、
J 9（IBM）

**PermGen（永久代）**

PermGen ，就是 PermGen space ，全称是 Permanent Generation space ，是指内存的永久保存区
域。

这块内存主要是被 JVM 存放 Class 和 Meta 信息的， Class 在被 Loader 时就会被放到 PermGen space
中。

绝大部分 Java 程序员应该都见过 java. lang. OutOfMemoryError: PermGen space 这个异常。

这里的 PermGen space 其实指的就是方法区。

**PermGen space 则是 HotSpot 虚拟机基于 JVM 规范对方法区的一个落地实现，**

PermGen space 是 HotSpot 虚拟机有，而如 JRockit（Oracle）、J 9（IBM） 虚拟机有方法区，但是
就没有 PermGen space。

**强调： 只有 HotSpot 才有 PermGen space。**

**PermGen space 则是 HotSpot 虚拟机基于 JVM 规范对方法区的一个落地实现，**

PermGen space 是 JDK 7 及之前， HotSpot 虚拟机对方法区的一个落地实现。

HotSpot jdk 1.6 的 PermGen space 如下：


HotSpot 也有去永久代的趋势，在 JDK 1.7 中 HotSpot 已经开始了“去永久化”，把原本放在永久代的字
符串常量池移出。

HotSpot 1.7 永久代主要存放常量、类信息、 **静态变量** 等数据，与垃圾回收关系不大，新生代和老年代
是垃圾回收的主要区域。

永久代在 JDK 8 被移除, JDK 1.8 方法区叫做元空间：

**Metaspace（元空间）是 JDK 8 及之后， HotSpot 虚拟机对方法区的新的实现。**

###### HotSpot 方法区变迁


```
版本 演进细节
```
```
JDK6及
之前
```
```
方法区的实现为永久代，静态变量存放在永久代中，字符串常量池（StringTable）位
于运行时常量池中。
```
```
JDK7
```
```
方法区的实现为永久代，但已经逐步“去永久代”，静态变量、字符串常量池移除，保
存在堆中
```
```
JDK8 方法区的实现为本地内存的元空间，字符串常量池、静态变量仍在堆中
```
**JDK 1.2 ~ JDK 6**

在 JDK 1.2 ~ JDK 6 的实现中，HotSpot 使用永久代（永久代）实现方法区；

HotSpot 使用 GC 分代实现方法区带来了很大便利；

**JDK 7**

由于 GC 分代技术的影响，使之许多优秀的内存调试工具无法在 Oracle HotSpot 之上运行，必须单独处
理；

并且 Oracle 同时收购了 BEA 和 Sun 公司，同时拥有 JRockit 和 HotSpot，在将 JRockit 许多优秀特性
移植到 HotSpot 时，由于 GC 分代技术遇到了种种困难，所以从 JDK 8 开始 Oracle HotSpot 开始移除
永久代。

JDK 7 中符号表被移动到 Native Heap 中，字符串常量和类引用被移动到 Java NON_HEAP 中。

**JDK 8**

在 JDK 8 中，永久代已完全被元空间 (Meatspace) 所取代。


###### 问：为什么用元空间替换永久代？

为永久代设置最大空间大小是难以确定的。

```
在某些场景下，如果动态加载类过多，容易产生 Perm区的OOM ：比如某个实际Web工程中，因
为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误；而元空间和永久代
之间最大的区别在于：元空间并不在虚拟机中，而是 使用本地内存 ，因此，默认情况下，元空间的
最大大小仅受本地内存限制。
对永久代进行调优是很困难的。
```
###### 问：为什么调整字符串常量池的位置？


JDK 7 中将字符串常量池放到了堆空间中：因为永久代的回收效率很低，在 Full GC 时才会触发，而 Full
GC 在老年代的空间不足、永久代不足时才会触发，这就导致字符串常量池 **回收效率不高** ；

而我们开发中会有大量的字符串被创建，回收效率低会导致永久代内存不足。

将字符串常量池放到堆里，能及时回收内存。

###### 问：几种不同的变量引用存放在哪里？

以上代码中，静态变量 staticObj 随着 Test 的类型信息存放在方法区，

实例变量 instanceObj 随着 Test 的对象实例存放在堆区，

局部变量 localObj 则是存放在 foo () 方法栈帧的局部变量表中。

三个变量引用对应的对象实体都是在堆空间。

###### 问： 什么是执行引擎？

执行引擎是 java 虚拟机的最核心组件之一，它负责执行虚拟机的字节码，有即时编译和解释执行，通
常采用解释执行方式。解释执行是指解释器通过每次解释并执行一小段代码来完成. class 程序的所有操
作。即时编译则是将. class 文件翻译成机器码在执行（比如：经常多次访问的代码可以全部编译）

垃圾回收系统是 java 虚拟机的重要组成部分，垃圾回收器可以对栈堆进行回收。其中， java 堆是垃圾
收集器的工作重点。有三类：增量垃圾回收，分代复制垃圾回收，标记垃圾回收

和 C/C++不同， java 中所有的对象空间释放都是隐式的，也就是说， java 中没有类似 free () 或者
delete () 这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工
作，默默查找、标识并释放垃圾对象，完成包括 java 堆、方法区和直接内存中的全自动化管理。

```
public class StaticObjTest {
static class Test{
// 静态变量
// 一个java.lang.Class类型的对象实例引用了此变量
static ObjectHolder staticObj = new ObjectHolder();
// 实例变量
ObjectHolder instanceObj = new ObjectHolder();
```
```
void foo() {
// 局部变量
ObjectHolder localObj = new ObjectHolder()();
System.out.println("done");
}
```
```
}
```
```
private static class ObjectHolder{
}
```
```
public static void main(String[] args) {
Test test = new StaticObjTest.Test();
test.foo();
}
}
```

#### 问题：成员变量、局部变量、类变量分别存储在内存的什

#### 么地方？

**类变量**

```
类变量是用static修饰符修饰，定义在方法外的变量，随着java进程产生和销毁
在java8之前把静态变量存放于方法区，在java8时存放在堆中
成员变量
成员变量是定义在类中，但是没有static修饰符修饰的变量，随着类的实例产生和销毁，是类实例
的一部分
由于是实例的一部分，在类初始化的时候，从运行时常量池取出直接引用或者值，与初始化的对象
一起放入堆中
局部变量
局部变量是定义在类的方法中的变量
在所在方法被调用时放入虚拟机栈的栈帧中，方法执行结束后从虚拟机栈中弹出，所以存放在虚拟
机栈中
```
#### 问题：类常量池、运行时常量池、字符串常量池有什么关

#### 系？有什么区别？

类常量池与运行时常量池都存储在方法区，而字符串常量池在 jdk 7 时就已经从方法区迁移到了 java 堆
中。

在类编译过程中，会把类元信息放到方法区，类元信息的其中一部分便是类常量池，主要存放字面量和
符号引用，而字面量的一部分便是文本字符，在类加载时将字面量和符号引用解析为直接引用存储在运
行时常量池；

对于文本字符来说，它们会在解析时查找字符串常量池，查出这个文本字符对应的字符串对象的直接引
用，将直接引用存储在运行时常量池；字符串常量池存储的是字符串对象的引用，而不是字符串本身。

#### 使用堆外内存的优点

```
减少了垃圾回收
因为垃圾回收会暂停其他的工作。
加快了复制的速度
堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略
掉了这个工作。
```
#### 深拷贝和浅拷贝

浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，


深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内
存，

使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。

浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改
变。

深复制：在计算机中开辟一块 **新的内存地址** 用于存放复制的对象。

#### 说一下堆栈的区别？

物理地址

堆的物理地址分配对对象是不连续的。因此性能慢些。在 GC 的时候也要考虑到不连续的分配，所以有
各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——
压缩）

栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。

内存分别

堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。

栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。

存放的内容

堆存放的是对象的实例和数组。因此该区更关注的是数据的存储

栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。

PS：

```
1. 静态变量放在方法区
2. 静态的对象还是放在堆。
```
程序的可见度

堆对于整个应用程序都是共享、可见的。

栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。

#### Java 中堆和栈有什么区别？

JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在
堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

#### 队列和栈是什么？有什么区别？

队列和栈都是被用来预存储数据的。

```
操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为
出栈。
可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈
顶进行的，无法对栈底直接进行操作。
操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的
成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈
```

```
为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元
素，而最先插入的被放在栈的底部，要到最后才能删除。
```
#### 虚拟机栈 (线程私有)

是描述 java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储
局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应
着一个栈帧在虚拟机栈中入栈到出栈的过程。
栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接 (Dynamic
Linking)、方法返回值和异常分派（ Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束
而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。

#### 程序计数器 (线程私有)

一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数
器，这类内存也称为“线程私有” 的内存。
正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。如果还是
Native 方法，则为空。这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的
区域。


#### 什么是直接内存？

直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于
Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用
DirectByteBuffer 对象作为这块内存的引用进行操作 (详见: Java I/O 扩展), 这样就避免了在 Java 堆和
Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。

#### HotSpot 虚拟机对象探秘

###### 对象的创建

说到对象的创建，首先让我们看看 Java 中提供的几种对象创建方式：


```
Header 解释
```
```
使用new关键字 调用了构造函数
```
```
使用Class的newInstance方法 调用了构造函数
```
```
使用Constructor类的newInstance方法 调用了构造函数
```
```
使用clone方法 没有调用构造函数
```
```
使用反序列化 没有调用构造函数
```
下面是对象创建的主要流程:

虚拟机遇到一条 new 指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加
载。类加载通过后，接下来分配内存。若 Java 堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；
如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，
也有两种方式: CAS 同步处理，或者本地线程分配缓冲 (Thread Local Allocation Buffer, TLAB)。然后内
存空间初始化操作，接着是做一些必要的对象设置 (元信息、哈希码...)，最后执行<init>方法。

###### 为对象分配内存

类加载完成后，接着会在 Java 堆中划分一块内存分配给对象。内存分配根据 Java 堆是否规整，有两种方
式：

```
指针碰撞：如果 Java 堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配
内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内
存工作。
空闲列表：如果 Java 堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用
的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。
```
选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带
有压缩整理功能决定。

###### 处理并发安全问题


对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也
是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指
针来分配内存的情况。解决这个问题有两种方案：

```
对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；
把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块
内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，
就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-
UserTLAB 参数来设定虚拟机是否使用 TLAB。
```
###### 对象结构连环炮： 给定一个具体的类，请分析对象的内存占用

一般来说，MyOrder 类的每个对象会占用 40 个字节。

###### 对象结构连环炮：怎么计算出来一个对象的内存占用?

计算方式为：

对象头占用 12 字节。

每个 long 类型的字段占用 8 字节， 3 个 long 字段占用 24 字节。

byte 字段占用 1 个字节。

以上合计 37 字节，按照 4 字节对齐，则实际占用 40 个字节。

```
public class MyOrder{
private long orderId;
private long userId;
private byte state;
private long createMillis;
}
```

###### 对象结构连环炮：对象头中包含哪些部分？

对象头中一般包含两个部分：

```
标记字（mark word），占用一个机器字，也就是 8 字节。
类型指针，占用一个机器字，也就是 8 个字节。
```
```
这个，请阅读《Java 高并发核心编程卷 1 》，非常细致
```
如果堆内存小于 32 GB，JVM 默认会开启指针压缩，则只占用 4 个字节。

所以，前面的计算中，对象头占用 12 字节。

如果是数组，对象头中还会多出一个部分：

数组长度， int 值，占用 4 字节。

###### 对象的访问定位

Java 程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实
现。目前主流的访问方式有 **句柄** 和 **直接指针** 两种方式。

```
指针： 指向对象，代表一个对象在内存中的起始地址。
```
```
句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的
指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。
```
**句柄访问**

```
[InnerLockTest. showObjectStructSize]：object status:
[InnerLockTest. showObjectStructSize]：lock =
com. crazymakercircle. innerlock. InnerLockTest$MyOrder object internals:
OFFSET SIZE TYPE DESCRIPTION VALUE
0 4 (object header) 05 00 00 00
(00000101 00000000 00000000 00000000) (5)
4 4 (object header) 00 00 00 00
(00000000 00000000 00000000 00000000) (0)
8 4 (object header) e 6 f 2 01 f 8
(11100110 11110010 00000001 11111000) (-134090010)
12 1 byte MyOrder. state 0
13 3 (alignment/padding gap)
16 8 long MyOrder. orderId 0
24 8 long MyOrder. userId 0
32 8 long MyOrder. createMillis 0
Instance size: 40 bytes
Space losses: 3 bytes internal + 0 bytes external = 3 bytes total
```

Java 堆中划分出一块内存来作为 **句柄池** ，引用中存储对象的 **句柄地址** ，而句柄中包含了 **对象实例数据**
与 **对象类型数据** 各自的 **具体地址** 信息，具体构造如下图所示：

**优势** ：引用中存储的是 **稳定** 的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只
会改变 **句柄中** 的 **实例数据指针** ，而 **引用** 本身不需要修改。

**直接指针**

如果使用 **直接指针** 访问， **引用** 中存储的直接就是 **对象地址** ，那么 Java 堆对象内部的布局中就必须考虑
如何放置访问 **类型数据** 的相关信息。

**优势** ：速度更 **快** ，节省了 **一次指针定位** 的时间开销。由于对象的访问在 Java 中非常频繁，因此这类开
销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。

###### 64 位 JVM 中，int 的长度是多数？

Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。


意思就是说，在 32 位和 64 位的 Java 虚拟机中，int 类型的长度是相同的。

###### 32 位和 64 位的 JVM，int 类型变量的长度是多数？

32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4 个字节。

###### Java 中的 String 对象的大小

**空 String 占用的空间**

**当前内存大小是在默认开启压缩指针的条件下**

```
对象头 12
char[]数组引用 4
int 类型 hash 数据大小 4
loss due to the next object alignment 对齐填充 4
总结： 24
```
**我们来看看 String 类中的成员变量。**

**非空 String 占用的空间**

```
/** The value is used for character storage. */
private final char value[];
```
```
/** Cache the hash code for the string */
private int hash; // Default to 0
```
```
/** use serialVersionUID from JDK 1.0.2 for interoperability */
private static final long serialVersionUID = - 6849794470754667710 L;
```

**当前内存大小是在默认开启压缩指针的条件下**

```
对象头 12
char[]数组引用 4
int 类型 hash 数据大小 4
loss due to the next object alignment 对齐填充 4
总结： 24
```
###### 怎样通过 Java 程序来判断 JVM 是 32 位还是 64 位？

你可以检查某些系统属性如 sun. arch. data. model 或 os. arch 来获取该信息。

###### 32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？

理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4 GB，但实际上会比这个小很多。不同操作系统之
间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3 GB。 64 位 JVM 允许指定最大的堆内存，理论上
可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100 GB。甚至有的 JVM，如
Azul，堆内存到 1000 G 都是可能的。

###### JRE、JDK、JVM 及 JIT 之间有什么不同？

JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。

JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包
含 JRE。

JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。

JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节
码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性
能。


#### 内存溢出异常

###### Java 会存在内存泄漏吗？请简单描述

内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java 是有 GC 垃圾回收机制
的，也就是说，不再被使用的对象，会被 GC 自动回收掉，自动从内存中清除。

但是，即使这样，Java 也还是存在着内存泄漏的情况，java 导致内存泄露的原因很明确：长生命周期的
对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为
长生命周期对象持有它的引用而导致不能被回收，这就是 java 中内存泄露的发生场景。

###### 什么情况下会发生栈内存溢出。

**思路：** 描述栈定义，再描述为什么会溢出，再说明一下相关配置参数，OK 的话可以给面试官手写是一
个栈溢出的 demo。

**参考答案：**

```
栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储
局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用
类型
如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常，方法递
归调用产生这种结果。
如果 Java 虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成
扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么 Java 虚拟机将抛出一
个 OutOfMemory 异常。(线程启动过多)
参数 -Xss 去调整 JVM 栈的大小
```
#### 垃圾收集器

###### 简述 Java 垃圾回收机制

在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一
个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不
足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

###### GC 是什么？为什么要 GC

GC 是垃圾收集的意思（Gabage Collection）, 内存处理是编程人员容易出现问题的地方，忘记或者错误
的内存

回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而
达到自动

回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。

###### 垃圾回收的优点和原理。并考虑 2 种回收机制


java 语言最显著的特点就是引入了垃圾回收机制，它使 java 程序员在编写程序时不再考虑内存管理的问
题。

由于有这个垃圾回收机制，java 中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。

垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。

垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长
时间没有用过的对象进行清除和回收。

程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。

垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。

###### 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有

###### 什么办法主动通知虚拟机进行垃圾回收？

对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。

通常，GC 采用有向图的方式记录和管理堆 (heap) 中的所有对象。通过这种方式确定哪些对象是"可达
的"，哪些对象是"不可达的"。当 GC 确定一些对象为"不可达"时，GC 就有责任回收这些内存空间。

可以。程序员可以手动执行 System.gc ()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。

###### 你能保证 GC 执行吗？

不能，虽然你可以调用 System.gc () 或者 Runtime.gc ()，但是没有办法保证 GC 的执行。

###### Java 中都有哪些引用类型？

```
强引用：发生 gc 的时候不会被回收。
软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
弱引用：有用但不是必须的对象，在下一次 GC 时会被回收。
虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，
虚引用的用途是在 gc 时返回一个通知。
```
###### 介绍一下强引用、软引用、弱引用、虚引用的区别？

**思路：** 先说一下四种引用的定义，可以结合代码讲一下，也可以扩展谈到 ThreadLocalMap 里弱引用用
处。

**参考答案：**

1 ）强引用

我们平时 new 了一个对象就是强引用，例如 Object obj = new Object (); 即使在内存不足的情况下，JVM
宁愿抛出 OutOfMemory 错误也不会回收这种对象。

2 ）软引用

如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会
回收这些对象的内存。

```
SoftReference<String> softRef=new SoftReference<String>(str); // 软引用
```

**用处：** 软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容
是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。

（ 1 ）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构
建

（ 2 ）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出

如下代码：

3 ）弱引用

具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦
发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

4 ）虚引用

如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚
引用主要用来跟踪对象被垃圾回收器回收的活动。

###### 怎么判断对象是否可以被回收？

垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」
的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。

一般有两种方法来判断：

```
引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，
当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；
可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC
Roots 没有任何引用链相连时，则证明此对象是可以被回收的。
```
###### 在 Java 中，对象什么时候可以被垃圾回收

当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。
垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收 (Full GC)。如
果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小
对避免 Full GC 是非常重要的原因。

```
Browser prev = new Browser (); // 获取页面进行浏览
SoftReference sr = new SoftReference (prev); // 浏览完毕后置为软引用
if (sr.get ()!=null){
rev = (Browser) sr.get (); // 还没有被回收器回收，直接获取
}else{
prev = new Browser (); // 由于内存吃紧，所以对软引用的对象回收了
sr = new SoftReference (prev); // 重新构建
}
```
```
String str=new String ("abc");
WeakReference<String> abcWeakRef = new WeakReference<String>(str);
str=null;
等价于
str = null;
System.gc ();
```

###### JVM 运行时堆内存如何分代?

Java 堆从 GC 的角度还可以细分为: 新生代 (Eden 区、 From Survivor 区和 To Survivor 区) 和老年代。

参考图 1 ：

参考图 2 ：

从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。

默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 **1:2** ( 该值可以通过参数 –XX: NewRatio 来指定
)，

即： **新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小** 。

其中，新生代 ( Young ) 被细分为 Eden 和两个 Survivor 区域，这两个 Survivor 区域分别被命名为
from 和 to，以示区分

默认的， **Eden: from : to = 8 : 1 : 1** ( 可以通过参数 **–XX:SurvivorRatio** 来设定 )，即： **Eden = 8/10 的
新生代空间大小，from = to = 1/10 的新生代空间大小** 。

JVM **每次只会使用 Eden 和其中的一块 Survivor 区域** 来为对象服务，所以 **无论什么时候，总是有一块
Survivor 区域是空闲着的** 。

因此，新生代实际可用的内存空间为 9/10 ( 即 90% ) 的新生代空间。

**新生代**


是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC
进行垃圾回收。新生代又分为 Eden 区、 ServivorFrom、 ServivorTo 三个区。
**Eden 区**
Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够
的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。
**Servivor from 区**
上一次 GC 的幸存者，作为这一次 GC 的被扫描者。
**Servivor to 区**
保留了一次 MinorGC 过程中的幸存者。
**MinorGC 的过程（复制->清空->互换）**
MinorGC 采用复制算法。

```
1. eden、 servicorFrom 复制到 ServicorTo，年龄+1
首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以
及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位
置了就放到老年区）；
2. 清空 eden、 servicorFrom
然后，清空 Eden 和 ServicorFrom 中的对象；
3. ServicorTo 和 ServicorFrom 互换
最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom 区。
```
**老年代**

主要存放应用程序中生命周期长的内存对象。
老年代的对象比较稳定，所以 MajorGC （常常称之为 FULL GC）不会频繁执行。在进行 FULL GC 前一
般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法
找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空
间。
FULL GC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对
象。 ajorGC 的耗时比较长，因为要扫描再回收。 FULL GC 会产生内存碎片，为了减少内存损耗，我
们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出
OOM（Out of Memory）异常。

**永久代 （或者 jdk 1.8 元空间）**

指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息, Class 在被加载的时候被放入永久
区域，它和和存放实例的区域不同, GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久
代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。

###### JVM 内存为什么要分成新生代，老年代，永久代。新生代中为什么要

###### 分为 Eden 和 Survivor。

**思路：** 先讲一下 JAVA 堆，新生代的划分，再谈谈它们之间的转化，相互之间一些参数的配置（如： –
XX: NewRatio，–XX: SurvivorRatio 等），再解释为什么要这样划分，最好加一点自己的理解。

**参考答案：**

这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。

1 ）共享内存区划分

```
共享内存区 = 永久代 + 堆
```

```
永久代 = 方法区 + 其他
Java 堆 = 老年代 + 新生代
新生代 = Eden + S 0 + S 1
```
2 ）一些参数的配置

```
默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX: NewRatio 配
置。
默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX: SurvivorRatio 来设定)
Survivor 区中的对象被复制次数为 15 (对应虚拟机参数 -XX:+MaxTenuringThreshold)
```
3) 为什么要分为 Eden 和 Survivor? 为什么要设置两个 Survivor 区？

```
如果没有 Survivor，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代。老年代很快被
填满，触发 Major GC. 老年代的内存空间远大于新生代，进行一次 Full GC 消耗的时间比 Minor GC
长得多, 所以需要分为 Eden 和 Survivor。
Survivor 的存在意义，就是减少被送到老年代的对象，进而减少 Full GC 的发生，Survivor 的预筛选
保证，只有经历 16 次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。
设置两个 Survivor 区最大的好处就是解决了碎片化，刚刚新建的对象在 Eden 中，经历一次 Minor
GC，Eden 中的存活对象就会被移动到第一块 survivor space S 0，Eden 被清空；等 Eden 区再满
了，就再触发一次 Minor GC，Eden 和 S 0 中的存活对象又会被复制送入第二块 survivor space
S 1（这个过程非常重要，因为这种复制算法保证了 S 1 中来自 S 0 和 Eden 两部分的存活对象占用连续
的内存空间，避免了碎片化的发生）
```
###### JVM 中一次完整的 GC 流程是怎样的，对象如何晋升到老年代

**思路：** 先描述一下 Java 堆内存划分，再解释 Minor GC，Major GC，full GC，描述它们之间转化流程。

**我的答案：**

```
Java 堆 = 老年代 + 新生代
新生代 = Eden + S 0 + S 1
当 Eden 区的空间满了， Java 虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对
象，则会转移到 Survivor 区。
大对象 （需要大量连续内存空间的 Java 对象，如那种很长的字符串） 直接进入老年态；
如果对象在 Eden 出生，并经过第一次 Minor GC 后仍然存活，并且被 Survivor 容纳的话，年龄设为
1 ，每熬过一次 Minor GC，年龄+1，若年龄超过一定限制（ 15 ），则被晋升到老年态。即长期存
活的对象进入老年态。
老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行 Full GC，Full GC 清理整个内存
堆 – 包括年轻代和年老代。
Major GC 发生在老年代的 GC ，清理老年区，经常会伴随至少一次 Minor GC，比 Minor GC 慢 10
倍以上。
```
###### 聊聊：什么是分代，分代的必要性

Java 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对
HotSpot 虚拟机而言），这就是

JVM 的内存分代策略。

JDK 1.7 之前，Java 虚拟机将堆内存划分为新生代、老年代和永久代（或者元空间），

永久代是 HotSpot 虚拟机特有的概念（JDK 1.8 之后为 metaspace 元空间替代永久代），它采用永久代
的方式来实现方法区，其他的虚拟机实现没有这一概念，


而且 HotSpot 也有去永久代的趋势，在 JDK 1.7 中 HotSpot 已经开始了“去永久化”，把原本放在永久代
的字符串常量池移出。永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代
和老年代是垃圾回收的主要区域。

堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例
都存放在堆内存中。

给堆内存分代是为了 **提高对象内存分配和垃圾回收的效率** 。

试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序
的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间
代价是巨大的，会严重影响我们的 GC 效率。

有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对
象存放在老年代中，

静态属性、类信息等存放在永久代（或者元空间）中，

新生代中的对象存活时间短，只需要在新生代区域中频繁进行 GC，老年代中对象生命周期长，内存回
收的频率相对较低，不需要频繁进行回收，

永久代（或者元空间）中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的
垃圾收集算法。

分代收集大大提升了收集效率，这些都是内存分代带来的好处。

###### JVM 中的永久代中会发生垃圾回收吗

垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收 (Full GC)。

如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。

这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。

###### JAVA 8 与元数据

在 Java 8 中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。

元空间的本质和永久代类似，元空间与永久代之间最大的区别在于： 元空间并不在虚拟机中，而是使用
本地内存。

因此，默认情况下，元空间的大小仅受本地内存限制。

类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数
据就不再由 MaxPermSize 控制, 而由系统的实际可用空间来控制。

###### 如何判断对象可以被回收？

判断对象是否存活一般有两种方式：

```
引用计数：
```
每个对象有一个引用计数属性，新增一个引用时计数加 1 ，引用释放时计数减 1 ，计数为 0 时可以回收。
此方法简单，无法解决对象相互循环引用的问题。

```
可达性分析（Reachability Analysis）：
```

从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相
连时，则证明此对象是不可用的，不可达对象。

###### 引用计数法

在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办
法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，
即他们的引用计数都不为 0 ，则说明对象不太可能再被用到，那么这个对象就是可回收对象。

###### 可达性分析

为了解决引用计数法的循环引用问题， Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作
为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，
不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍
然是可回收对象，则将面临回收。

###### Minor GC 与 Full GC 分别在什么时候发生？

新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC

###### 垃圾收集算法有哪些类型？

GC 最基础的算法有三类： 标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都
采用分代收集算法。

标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶
段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用
其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的
内存空间一次清理掉。

标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，
而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

分代收集算法，“分代收集”（Generational Collection）算法，把 Java 堆分为新生代和老年代，这样就
可以根据各个年代的特点采用最适当的收集算法

###### 说一下 JVM 有哪些垃圾回收算法？

```
标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。
复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块
上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。
标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的
内存。
```

```
分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用
复制算法，老年代采用标记整理算法。
```
**（ 1 ）标记-清除算法**

该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没
有被标记的对象。 **适用场合** ：存活对象较多的情况、适用于年老代。

标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：

```
标记阶段：标记出可以回收的对象。
清除阶段：回收被标记的对象所占用的空间。
```
标记-清除算法的执行的过程如下图所示

**优点** ：实现简单，不需要对象进行移动。

**缺点** ：

**1. 空间问题** ，易产生内存碎片，当为一个大对象分配空间时可能会提前触发垃圾回收（例如，对象的大
小大于空闲表中的每一块儿大小但是小于其中两块儿的和）。

**2. 效率问题** ，扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象）。标记、
清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。

**总之：**

标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。

**（ 2 ）标记-复制算法**

为了解决标记-清除算法的效率不高的问题，产生了标记-复制算法。

它把内存空间划为两个相等的区域，每次只使用其中一个区域。

垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回
收的对象进行回收。

**优点** ：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。


**缺点** ：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。

复制算法的执行过程如下图所示

**（ 3 ）标记-整理算法**

在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较
高，这样会有较多的复制操作，导致效率变低。

标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。

因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收
的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进
行回收。

回收后，已用和未用的内存都各自一边。

**优点** ：解决了标记-清理算法存在的内存碎片问题。

**缺点** ：仍需要进行局部对象移动，一定程度上降低了效率。

标记-整理算法的执行过程如下图所示


**标记-整理算法适用场合** ：存活对象较少的情况下比较高效、用于年轻代（即新生代）。

**（ 4 ）分代收集算法**

分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为
不同的域，一般情况下将 GC 堆划分为老生代 (Tenured/Old Generation) 和新生代
(YoungGeneration)。

老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃
圾需要被回收，因此可以根据不同区域选择不同的算法。

当前商业虚拟机都采用 **分代收集** 的垃圾收集算法。分代收集算法，顾名思义是根据对象的 **存活周期** 将内
存划分为几块。一般包括 **年轻代** 、 **老年代** 和 **永久代** ，如图所示：

当前主流 VM 垃圾收集都采用”分代收集” (Generational Collection) 算法, 这种算法会根据对象存活周期
的不同将内存划分为几块, 如 JVM 中的新生代、老年代、永久代，这样就可以根据各年代特点分别采用
最适当的 GC 算法

###### 新生代与复制算法

每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复
制成本就可以完成收集

目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分
对象，即要复制的操作比较少，但通常并不是按照 1 ： 1 来划分新生代。

一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间 (From Space, To Space)，每次
使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一
块 Survivor 空间中。

###### 老年代与标记复制算法

因为老年代对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理” 算
法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。因而采用 Mark-Compact 算法。


```
1. JAVA 虚拟机提到过的处于方法区的永生代 (Permanet Generation)，它用来存储 class 类，常量，
方法描述等。对永生代的回收主要包括废弃常量和无用的类。
2. 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space (Survivor 目前存
放对象的那一块)，少数情况会直接分配到老生代。
3. 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后， EdenSpace
和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 FromSpace 进行清理。
4. 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。
5. 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。
6. 当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到
老生代中。
```
###### GC 垃圾收集器

Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；年老代
主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收
集器， JDK 1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：

###### 说一下 JVM 有哪些垃圾回收器？

如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了 7 种
作用于不同分代的收集器，其中用于回收新生代的收集器包括 Serial、PraNew、Parallel Scavenge，回
收老年代的收集器包括 Serial Old、Parallel Old、CMS，还有用于回收整个 Java 堆的 G 1 收集器。不同收
集器之间的连线表示它们可以搭配使用。


```
Serial 收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；
ParNew 收集器 (复制算法): 新生代收并行集器，实际上是 Serial 收集器的多线程版本，在多核 CPU
环境下有着比 Serial 更好的表现；
Parallel Scavenge 收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量
= 用户线程时间/(用户线程时间+GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程
序的运算任务，适合后台应用等对交互相应要求不高的场景；
Serial Old 收集器 (标记-整理算法): 老年代单线程收集器，Serial 收集器的老年代版本；
Parallel Old 收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge 收集器
的老年代版本；
CMS (Concurrent Mark Sweep) 收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收
停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。
G 1 (Garbage First) 收集器 (标记-整理算法)： Java 堆并行收集器，G 1 收集器是 JDK 1.7 提供的一个新
收集器，G 1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G 1 收集器不同
于之前的收集器的一个重要特点是：G 1 回收的范围是整个 Java 堆 (包括新生代，老年代)，而前六种
收集器回收的范围仅限于新生代或老年代。
```
###### Serial 与 Parallel GC 之间的不同之处？

Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认
的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行。

###### 类似的问题：你知道哪几种垃圾收集器，各自的优缺点，重点讲下

###### cms 和 G 1，包括原理，流程，优缺点。

**思路：** 一定要记住典型的垃圾收集器，尤其 cms 和 G 1，它们的原理与区别，涉及的垃圾回收算法。

**参考答案：**


1 ）几种垃圾收集器：

```
Serial 收集器： 单线程的收集器，收集垃圾时，必须 stop the world，使用复制算法。
ParNew 收集器： Serial 收集器的多线程版本，也需要 stop the world，复制算法。
Parallel Scavenge 收集器： 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达
到一个可控的吞吐量。如果虚拟机总共运行 100 分钟，其中垃圾花掉 1 分钟，吞吐量就是 99%。
Serial Old 收集器： 是 Serial 收集器的老年代版本，单线程收集器，使用标记整理算法。
Parallel Old 收集器： 是 Parallel Scavenge 收集器的老年代版本，使用多线程，标记-整理算法。
CMS (Concurrent Mark Sweep) 收集器： 是一种以获得最短回收停顿时间为目标的收集器，标
记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎
片。
G 1 收集器： 标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选
标记。不会产生空间碎片，可以精确地控制停顿。
```
2 ）CMS 收集器和 G 1 收集器的区别：

```
CMS 收集器是老年代的收集器，可以配合新生代的 Serial 和 ParNew 收集器一起使用；
G 1 收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
CMS 收集器以最小的停顿时间为目标的收集器；
G 1 收集器可预测垃圾回收的停顿时间
CMS 收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
G 1 收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。
```
###### 详细介绍一下 CMS 垃圾回收器？

CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾
回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-
XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。

CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足
程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行
垃圾清除，此时的性能将会被降低。

###### Serial 垃圾收集器（单线程、复制算法）

Serial（英文连续） 是最基本垃圾收集器，使用复制算法，曾经是 JDK 1.3.1 之前新生代唯一的垃圾收集
器。 Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且
在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。
Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单
个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial 垃圾收集
器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。

###### ParNew 垃圾收集器（Serial+多线程）

ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收
集之外，其余的行为和 Serial 收集器完全一样， ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所
有其他的工作线程。
ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX: ParallelGCThreads 参数来限制垃圾
收集器的线程数。 【Parallel：平行的】


ParNew 虽然是除了多线程外和 Serial 收集器几乎完全一样，但是 ParNew 垃圾收集器是很多 java 虚拟
机运行在 Server 模式下新生代的默认垃圾收集器。

###### Parallel Scavenge 收集器（多线程复制算法、高效）

Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集
器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput， CPU 用于运行用户代码的时间/CPU
总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效
率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。
自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。

```
新生代 ：Parallel Scavenge 收集器也是一个新生代垃圾收集器；
复制算法 ：Parallel Scavenge 收集器同样使用复制算法；
多线程 ：Parallel Scavenge 收集器也是一个多线程的垃圾收集器；
高吞吐量 ：Parallel Scavenge 重点关注的是程序达到一个可控制的吞吐量（Thoughput，吞吐量
= 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)），高吞吐量可以最高效率地利用 CPU
时间，尽快地完成程序的运算任务；
适用场景 ：主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是
ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。
新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似：
```
```
1. 都是多线程的收集器；
2. 都使用的是复制算法；
3. 在垃圾收集过程中都需要暂停所有的工作线程。
```
###### Serial Old 收集器（单线程标记整理算法 ）

Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收
集器也主要是运行在 Client 默认的

```
老年代 ：Serial Old 是 Serial 垃圾收集器老年代的版本；
标记-整理算法 ：Serial Old 使用标记-整理算法；
单线程 ：Serial Old 与 Serial 一样是单线程收集器；
Client 模式 ：JVM 运行在 Client 模式下，Serial Old 是默认的老年代垃圾收集器；
Server 模式 ：JVM 运行在 Server 模式下，Serial Old 主要有两个用途：
```
```
1. 在 JDK 1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用；
2. 作为年老代中使用 CMS 收集器的后备垃圾收集方案。
```
新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图：


新生代 ParallelScavenge/ParNew 与年老代 Serial Old 搭配垃圾收集过程图：

新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使用的是
复制算法，在垃圾收集过程中都需要暂停所有的工作线程。

###### Parallel Old 收集器（多线程标记整理算法）

Parallel Old 收集器是 Parallel Scavenge 的年老代版本，使用多线程的标记-整理算法，在 JDK 1.6 才开始
提供。

在 JDK 1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证
新生代的吞吐量优先，无法保证整体的吞吐量，

在 JDK 1.6 才开始， Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞
吐量要求比较高，可以优先考虑新生代 Parallel Scavenge 和年老代 Parallel Old 收集器的搭配策略。

```
老年代 ：Parallel Old 收集器是 Parallel Scavenge 的老年代版本；
标记-整理算法 ：Parallel Old 收集器使用标记-整理算法；
多线程 ：Parallel Old 收集器是多线程收集器；
```

```
高吞吐量 ：Parallel Old 是能够为老年代提供吞吐量优先的垃圾收集器；
JDK 1.6 ：Parallel Old 是 JDK 1.6 才开始提供的。
```
新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图

新生代 Parallel Scavenge 收集器，使用的是标记-复制算法，在垃圾收集过程中都需要暂停所有的工作
线程。

老生代 Parallel Old 收集器，使用的是标记-整理算法，在垃圾收集过程中都需要暂停所有的工作线程。

Parallel Old 收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及
CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

###### CMS 收集器（多线程标记清除算法）

Concurrent mark sweep (CMS) 收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停
顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿
时间可以为交互比较高的程序提高用户体验。

```
老年代 ：CMS（Concurrent mark sweep）收集器是一种年老代垃圾收集器；
标记-清理算法 ：和其他年老代使用标记-整理算法，CMS 使用标记-清除算法；
多线程 ：CMS 采用的是多线程并发的标记-清除算法；
停顿时间端 ： CMS 最主要目标是获取最短垃圾回收停顿时间，最短的垃圾收集停顿时间可以为交
互比较高的程序提高用户体验。
```
CMS 工作机制相比其他的垃圾收集器来说更复杂。整个过程分为以下 4 个阶段：

**初始标记**
只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。
**并发标记**
进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。
**重新标记**
为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然
需要暂停所有的工作线程。
**并发清除**
清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和


并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看 CMS 收集器的内存回
收和用户线程是一起并发地执行。

CMS 收集器工作过程

漂亮点的图

###### G 1 收集器

Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G 1 收集器
两个最突出的改进是：

```
1. 基于标记-整理算法，不产生内存碎片。
2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
```
G 1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃
圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区
域。区域划分和优先级区域回收机制，确保 G 1 收集器可以在有限时间获得最高的垃圾收集效率

**G 1 特点**

```
无分代 ：G 1 将新生代，老年代的物理空间划分取消了。这样我们再也不用单独的空间对每个代进
行设置了，不用担心每个代内存是否足够；
标记-整理算法 ：G 1 收集器采用标记-整理算法，无内存碎片产生；
```

```
分区回收 ：G 1 虽然没有了新生代与老年代的物理限制，但是 G 1 采取内存分区策略，将堆内存划
分为大小固定的几个独立区域。在分区中，同时存在新生代与老年代；
```
**分区**

**新生代区域** ：G 1 收集器中新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老
年代或者 Survivor 空间；
**老年代区域** ：G 1 收集器通过将对象从一个区域复制到另外一个区域，以此来完成老年代的清理工作；
**Humongous 区域** ：巨型对象区域。如果一个对象占用的空间超过了分区容量 50% 以上，G 1 收集器就
认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨
型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G 1 划分了一个 Humongous 区，它用
来专门存放巨型对象。如果一个 H 区装不下一个巨型对象，那么 G 1 会寻找连续的 H 分区来存储。为
了能找到连续的 H 区，有时候不得不启动 Full GC。

**对象分配策略**

说起大对象的分配，我们不得不谈谈对象的分配策略。

它分为 3 个阶段：

```
1. TLAB (Thread Local Allocation Buffer) 线程本地分配缓冲区
2. Eden 区中分配
3. Humongous 区分配
```
TLAB 为线程本地分配缓冲区，它的目的为了使对象尽可能快的分配出来。

如果对象在一个共享的空间中分配，我们需要采用一些同步机制来管理这些空间内的空闲空间指针。

在 Eden 空间中，每一个线程都有一个固定的分区用于分配对象，即一个 TLAB。分配对象时，线程之间
不再需要进行任何的同步。

对 TLAB 空间中无法分配的对象，JVM 会尝试在 Eden 空间中进行分配。

如果 Eden 空间无法容纳该对象，就只能在老年代中进行分配空间。

最后，G 1 提供了两种 GC 模式，Young GC 和 Mixed GC，两种都是 Stop The World (STW) 的。

下面我们将分别介绍一下这 2 种模式。

**G 1 Young GC**


Young GC 主要是对 Eden 区进行 GC ，它在 Eden 空间耗尽时会被触发。在这种情况下，Eden 空间的
数据移动到 Survivor 空间中，如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到年老代空
间。Survivor 区的数据移动到新的 Survivor 区中，也有部分数据晋升到老年代空间中。最终 Eden 空
间的数据为空，GC 停止工作，应用线程继续执行。

**G 1 Young GC 阶段：**

```
1. 根扫描 ：静态和本地对象被扫描；
2. 更新 RS : 处理 Dirty Card 队列更新 RS（Remembered Set，作用是跟踪指向某个 Heap 区内的对
象引用）；
3. 处理 RS : 检测从年轻代指向年老代的对象；
4. 对象拷贝 ：拷贝存活的对象到 Survivor/Old 区域；
5. 处理引用队列 : 软引用，弱引用，虚引用处理。
```
**G 1 Mix GC**

Mix GC 不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。

**G 1 Mix GC 运行步骤：**

```
1. 全局并发标记 （global concurrent marking）
1.1. 初始标记（initial mark，STW） ：在此阶段，G 1 GC 对根进行标记。该阶段与常规的 (STW)
年轻代垃圾回收密切相关；
1.2. 根区域扫描（root region scan） ：G 1 GC 在初始标记的存活区扫描对老年代的引用，并标
记被引用的对象。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下
一次 STW 年轻代垃圾回收；
1.3. 并发标记（Concurrent Marking） ：G 1 GC 在整个堆中查找可访问的（存活的）对象。该
阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断；
1.4. 最终标记（Remark，STW） ： 该阶段是 STW 回收，帮助完成标记周期。G 1 GC 清空 SATB
缓冲区，跟踪未被访问的存活对象，并执行引用处理；
1.5. 清除垃圾（Cleanup，STW） ：在这个最后阶段，G 1 GC 执行统计和 RSet 净化的 STW 操
作。在统计期间，G 1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将
空白区域重置并返回到空闲列表时为部分并发。
2. 拷贝存活对象 （evacuation）
G 1 收集器与 CMS 收集器相比，G 1 收集器两个最突出的改进是：
```
```
1. 基于标记-整理算法，不产生内存碎片；
2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
```
###### 新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？

```
新生代回收器：Serial、ParNew、Parallel Scavenge
老年代回收器：Serial Old、Parallel Old、CMS
整堆回收器：G 1
```
```
// G 1 收集器参数设置
```
- XX:+UseG 1 GC - Xmx 32 g - XX:MaxGCPauseMillis= 200
// -XX:+UseG 1 GC —— 为开启 G 1 垃圾收集器，
// -Xmx 32 g —— 设计堆内存的最大内存为 32 G，
// -XX:MaxGC


新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回
收器一般采用的是标记-整理的算法进行垃圾回收。

###### 简述分代垃圾回收器是怎么工作的？

分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是
2/3。

新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占
比是 8:1:1，它的执行流程如下：

```
把 Eden + From Survivor 存活的对象放入 To Survivor 区；
清空 Eden 和 From Survivor 分区；
From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From
Survivor。
```
每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15 （默认配置是
15 ）时，升级为老生代。大对象也会直接进入老生代。

老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循
环往复就构成了整个分代垃圾回收的整体执行流程。

###### 什么时候会触发 FullGC？

除直接调用 System. gc 外，触发 Full GC 执行的情况有如下四种。
**1. 旧生代空间不足**
老生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行 Full GC 后空
间仍然不足，则抛出如下错误：
java. lang. OutOfMemoryError: Java heap space
为避免以上两种状况引起的 FullGC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生
代多存活一段时间及不要创建过大的对象及数组。
**2. Permanet Generation 空间满**
PermanetGeneration 中存放的为一些 class 的信息等，当系统中要加载的类、反射的类和调用的方法较
多时，Permanet Generation
可能会被占满，在未配置为采用 CMS GC 的情况下会执行 Full GC。如果经过 Full GC 仍然回收不了，那么
JVM 会抛出如下错误信息：
java. lang. OutOfMemoryError: PermGen space
为避免 Perm Gen 占满造成 Full GC 现象，可采用的方法为增大 Perm Gen 空间或转为使用 CMS GC。
**3. CMS GC 时出现 promotion failed 和 concurrent mode failure**
对于采用 CMS 进行老生代 GC 的程序而言，尤其要注意 GC 日志中是否有 promotion failed 和 concurrent
mode failure 两种状况，当这两种状况出现时可能会触发 Full GC。
promotionfailed 是在进行 Minor GC 时，survivor space 放不下、对象只能放入老生代，而此时老生代
也放不下造成的；concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老生代，而此
时老生代空间不足造成的。
应对措施为：增大 survivorspace、老生代空间或调低触发并发 GC 的比率，但在 JDK 5.0+、6.0+的版本
中有可能会由于 JDK 的 bug 29 导致 CMS 在 remark 完毕后很久才触发 sweeping 动作。对于这种状况，可
通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为 ms）来避免。
**4. 统计得到的 Minor GC 晋升到旧生代的平均大小大于旧生代的剩余空间**
这是一个较为复杂的触发情况，Hotspot 为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的
现象，在进行 Minor GC 时，做了一个判断，如果之前统计所得到的 Minor GC 晋升到旧生代的平均大小
大于旧生代的剩余空间，那么就直接触发 Full GC。
例如程序第一次触发 MinorGC 后，有 6 MB 的对象晋升到旧生代，那么当下一次 Minor GC 发生时，首先
检查旧生代的剩余空间是否大于 6 MB，如果小于 6 MB，则执行 Full GC。


当新生代采用 PSGC 时，方式稍有不同，PS GC 是在 Minor GC 后也会检查，例如上面的例子中第一次
Minor GC 后，PS GC 会检查此时旧生代的剩余空间是否大于 6 MB，如小于，则触发对旧生代的回收。除
了以上 4 种状况外，对于使用 RMI 来进行 RPC 或管理的 Sun JDK 应用而言，默认情况下会一小时执行一次
Full GC。可通过在启动时通过- java-Dsun. rmi. dgc. client. gcInterval=3600000 来设置 Full GC 执行的间
隔时间或通过-XX:+ DisableExplicitGC 来禁止 RMI 调用 System. gc

#### 方法区的垃圾回收

《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收
集；

事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在，如 JDK 11 时期的 ZGC 收集器就不
支持类卸载。

一般来说，方法区的回收效果比较难令人满意，尤其是 **类型的卸载，条件相当苛刻** 。

但是这部分区域的回收 **有时又确实是必要的** 。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的
Bug 就是由于低版本的 Hotspot 虚拟机对此区域未完全回收而导致内存泄漏。

方法区的垃圾收集主要回收两部分内容：

```
运行时常量池中废弃的常量
不再使用的类型。
```
**A. 运行时常量池中废弃的常量**

方法区内运行时常量池之中，主要存放的两大类常量：字面量和符号引用。

字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等；而符号引用则属
于编译原理方面的概念，包括下面三类常量： 1 ）类和接口的全限定名； 2 ）字段的名称和描述符； 3 ）
方法的名称和描述符。

Hotspot 虚拟机对运行时常量池的回收策略是很明确的，只要常量池中的常量 **没有被任何地方引用，就
可以被回收** 。

**B. 不再使用的类型**

判定一个类型是否属于“不再被使用的类型”的条件比较苛刻，需要同时满足下面三个条件：

```
该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。
加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如
OSGi、JSP 的重加载等，否则通常是很难达成的。
该类对应的 java. lang. Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方
法。
```

Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的 **仅仅是“被允许”** ，而并不是和对象
一样，没有引用了就必然会回收。

在大量使用反射、动态代理、 CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的
场景中，通常都需要 Java 虚拟机具备 **类型卸载** 的能力，以保证不会对方法区造成过大的内存压力。

#### 问： 说是方法区和堆的区别？

逻辑上，方法区是属于堆的一部分，

但实现上，一些简单的 jvm 实现，可能不会对方法区选择进行垃圾收集或者进行压缩。

HotSpot 虚拟机的方法区还有一个别名，叫做 Non-Heap（非堆），目的就是要和堆分开。

所以，方法区看作是一块独立于 Java 堆的内存空间。

```
方法区是各线程共享的内存区域。
方法区在 JVM 启动的时候被创建，它的实例的物理内存空间可以是不连续的。
方法区的大小，可以选择固定大小或者可扩展。如果方法区无法满足新的内存分配需求时，将抛出
OOM 异常。
方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，会导致方法区溢出，虚拟
机会抛出内存溢出错误：
```
```
或者
```
```
比如，以下情况：
加载大量的第三方的 jar 包；
Tomcat 部署的工程过多（30-50 个）；
```
```
java. lang. OutOfMemoryError: PermGen space
```
```
java. lang. OutOfMemoryError: Metaspace
```

```
大量动态的生成反射类。
关闭 JVM 就会释放该区域的内存。
```
方法区是虚拟机规范中提出的，不同的虚拟机可以有不同的实现，在 HotSpot 不同版本中方法区的演进
如下：

```
在 JDK 7 及以前，习惯上把方法区称为永久代（PermGen），从 JDK 8 开始，使用元空间
（Metaspace）作为方法区的实现。
In JDK 8，classes metadata is now stored in the native heap and this space is
called Metaspace.
```
```
本质上，方法区和永久代并不等价，这两个概念仅是对 hotspot 而言的。《Java 虚拟机规范》对如
何实现方法区，不做统一要求，例如：BEA JRockit 和 IBMJ 9 中，就不存在永久代的概念。
现在来看，当年使用永久代，不是好的 idea，导致 Java 程序更容易出现 OOM（超过-
XX: MaxPermsize 上限）。
元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。两者的最大区别是：元空间不在虚
拟机设置的内存中，而是使用本地内存。
```
#### 问：如何解决方法区的 OOM？

要解决 OOM 异常或 heap space 的异常，一般手段是通过内存映像分析工具（如 Eclipse Memory
Analyzer）对 dump 出来的堆转储快照文件进行分析，

重点是确认内存中的对象是否还都是必要存活的，即要先分清楚到底是出现了内存泄漏（Memory
Leak）还是内存溢出（Memory Overflow）。

```
如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链，就能找到泄漏对象是通
过怎样的路径与 GC Roots 相关联，并导致垃圾收集器无法自动回收它们的。掌握泄漏对象的类型
信息，以及 GC Roots 引用链的信息后，就可以比较准确地定位出泄漏代码的位置。
如果不存在内存泄漏，即内存中的对象确实都还必须存活着，就应当根据机器物理内存，检查虚拟
机的堆参数（-Xmx 与-Xms），看是否还可以调大；从代码上检査是否存在某些对象生命周期过
长、持有状态时间过长的情况（其实也算是内存泄漏），尝试减少程序运行期的内存消耗。
```
#### 问：如何设置方法区内存的大小


方法区的大小不是固定的，JVM 可以根据应用的需要进行动态调整。

JDK 7 及之前：

```
通过-XX: Permsize 来设置永久代的初始分配空间，默认值是 20.75 M。
通过-XX: MaxPermsize 来设置永久代的最大可分配空间， 32 位机器默认是 64 M， 64 位机器模式是
82 M。
当 JVM 加载的类信息容量超过最大值，会报异常 OutOfMemoryError: PermGen space。
```
JDK 8 及之后：

```
通过设置参数-XX: MetaspaceSize 和-XX: MaxMetaspaceSize 来设置元空间的初始分配空间和最
大可分配空间。
上述参数的默认值依赖于平台，Windows 系统下，-XX: MetaspaceSize 是 21 M，-
XX: MaxMetaspaceSize 的值是-1，即没有限制。
如果不指定元空间大小，使用默认值，方法区可能耗尽所有的可用系统内存。如果元空间发生溢
出，虚拟机会抛出异常 OutOfMemoryError: Metaspace。
通过-XX: Metaspacesize 设置的初始元空间大小是一个初始的高水位线，一旦触及这个水位线，
Full GC 将会被触发并卸载不再使用的类，然后这个高水位线将会重置。新的高水位线的值取决于
GC 后释放了多少元空间，如果释放的空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高
该值。如果释放空间过多，则适当降低该值。所以，如果初始化的高水位线设置过低，高水位线调
整情况会发生很多次，通过垃圾回收器的日志，可以观察到 Full GC 多次调用。为了避免频繁 Full
GC，建议将-XX: MetaspaceSize 设置为一个相对较高的值。
```
#### 内存分配策略

###### 简述 java 内存分配与回收策率以及 Minor GC 和 Major GC

所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这
里我们再来聊聊内存分配。

对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，
后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在
TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取
决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种
「普世」规则：

**对象优先在 Eden 区分配**

多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发
起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内
存。

这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC/Full
GC。

```
Minor GC 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频
繁，一般回收速度也非常快；
Major GC/Full GC 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。
Major GC 的速度通常会比 Minor GC 慢 10 倍以上。
```
**大对象直接进入老年代**

所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间
的情况下提前触发 GC 以获取足够的连续空间来安置新对象。


前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会
导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分
配。

**长期存活对象将进入老年代**

虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对
象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，
并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1 。对象在 Survivor 区
中每「熬过」一次 Minor GC 年龄就加 1 ，当年龄达到一定程度（默认 15 ） 就会被晋升到老年代。

###### 对象分配规则

```
1. 对象优先分配在 Eden 区，如果 Eden 区没有足够的空间时，虚拟机执行一次 Minor GC。
2. 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在
Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
3. 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了 1 次
Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加 1 ，知道达到
阀值对象进入老年区。
4. 动态判断对象的年龄。如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一
半，年龄大于或等于该年龄的对象可以直接进入老年代。
5. 空间分配担保。每次进行 Minor GC 时，JVM 会计算 Survivor 区移至老年区的对象的平均大小，如
果这个值大于老年区的剩余值大小则进行一次 Full GC，如果小于检查 HandlePromotionFailure 设
置，如果 true 则只进行 Monitor GC, 如果 false 则进行 Full GC
```
#### 虚拟机类加载机制

###### 简述 java 类加载机制?

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被
虚拟机直接使用的 java 类型。

###### 描述一下 JVM 加载 Class 文件的原理机制

Java 中的所有类，都需要由类加载器装载到 JVM 中才能运行。类加载器本身也是一个类，而它的工作就
是把 class 文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐
式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。

类装载方式，有两种 ：

1. 隐式装载，程序在运行过程中当碰到通过 new 等方式生成对象时，隐式调用类装载器加载对应的类到
jvm 中，

2. 显式装载，通过 class.forname () 等方法，显式加载需要的类

Java 类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类 (像是
基类) 完全加载到 jvm 中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。


###### 描述一下 JVM 加载 class 文件的原理机制

JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的类加载器是一个重要的
Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。
由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当
Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类
的加载是指把类的. class 文件中的数据读入到内存中，通常是创建一个字节数组读入. class 文件，然后
产生与所加载类对应
的 Class 对象。

加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段
包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三
个步骤。最后 JVM 对
类进行初始化，包括：1) 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)
如果类中存在初始化语句，就依次执行这些初始化语句。
类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、
系统加载器（System）和用户自定义类加载器（java. lang. ClassLoader 的子类）。

从 Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台
的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载
器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会
向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类
加载器的说明：

```
1. Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt. jar）；
2. Extension：从 java. ext. dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap；
3. System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量
classpath 或者系统属性
java. class. path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。
```
###### JVM 类加载机制

JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过
程。

**加载**
加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java. lang. Class 对象，
作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从
ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其
它文件生成（比如将 JSP 文件转换成对应的 Class 类）。
**验证**
这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不
会危害虚拟机自身的安全。
**准备**


准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内
存空间。注意这里所说的初始值概念，比如一个类变量定义为：
实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080 ，将 v 赋值为 8080 的 put static 指令是程序
被编译后，存放于类构造器方法之中。
但是注意如果声明为：public static final int v = 8080;
在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值
为 8080 。
解析
解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：

```
public static int v = 8080;
```
实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080 ，将 v 赋值为 8080 的 put static 指令是程序
被编译后，存放于类构造器方法之中。但是注意如果声明为：
在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v
赋值为 8080 。解析
解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：

```
public static final int v = 8080;
```
在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值
为 8080 。
解析
解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：

```
1. CONSTANT_Class_info
2. CONSTANT_Field_info
3. CONSTANT_Method_info
等类型的常量。
```
**符号引用**
符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内
存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义
在 Java 虚拟机规范的 Class 文件格式中。
**直接引用**
直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，
那引用的目标必定已经在内存中存在。
**初始化**
初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以
外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。
**类构造器**
初始化阶段是执行类构造器方法的过程。方法是由编译器自动收集类中的类变量的赋值操作和静态语句
块中的语句合并而成的。虚拟机会保证子方法执行之前，父类的方法已经执行完毕，如果一个类中没有
对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成 () 方法。注意以下几种情况不会执
行类初始化：

```
1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
2. 定义对象数组，不会触发该类的初始化。
3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常
量所在的类。
4. 通过类名获取 Class 对象，不会触发类的初始化。
5. 通过 Class. forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，
其实这个参数是告诉虚拟机，是否要对类进行初始化。
6. 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。
```

###### 什么是类加载器，类加载器有哪些?

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。

主要有一下四种类加载器:

```
1. 启动类加载器 (Bootstrap ClassLoader) 用来加载 java 核心类库，无法被 java 程序直接引用。
2. 扩展类加载器 (extensions class loader): 它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一
个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
3. 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java
类。一般来说，Java 应用的类都是由它来完成加载的。可以通过
ClassLoader.getSystemClassLoader () 来获取它。
4. 用户自定义类加载器，通过继承 java. lang. ClassLoader 类的方式实现。
```
###### 说一下类装载的执行过程？

类装载分为以下 5 个步骤：

```
加载：根据查找路径找到相应的 class 文件然后导入；
验证：检查加载的 class 文件的正确性；
准备：给类中的静态变量分配内存空间；
解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直
接引用直接指向内存中的地址；
初始化：对静态变量和静态代码块执行初始化工作。
```
###### 什么是双亲委派模型？

在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身
一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全
限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。


类加载器分类：

```
启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载 Java_HOME/lib/目
录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；
其他类加载器：
扩展类加载器（Extension ClassLoader）：负责加载\lib\ext 目录或 Java. ext. dirs 系统变量指定的
路径中的所有类库；
应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类
库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加
载器。
```
双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请
求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启
动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会
尝试去加载类。

当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果
此时父类不能加载，反馈给子类，由子类去完成类的加载。

###### 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。

**思路：** 先说明一下什么是类加载器，可以给面试官画个图，再说一下类加载器存在的意义，说一下双亲
委派模型，最后阐述怎么打破双亲委派模型。

**参考的答案：**

1) 什么是类加载器？


**类加载器** 就是根据指定全限定名称将 class 文件加载到 JVM 内存，转为 Class 对象。

```
启动类加载器（Bootstrap ClassLoader）：由 C++语言实现（针对 HotSpot）, 负责将存放在
<JAVA_HOME>\lib 目录或-Xbootclasspath 参数指定的路径中的类库加载到内存中。
其他类加载器：由 Java 语言实现，继承自抽象类 ClassLoader。如：
```
```
扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext 目录或
java. ext. dirs 系统变量指定的路径中的所有类库。
应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上
的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载
器默认就是用这个加载器。
```
2 ）双亲委派模型

**双亲委派模型工作过程是：**

```
如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派
给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的
类时（即 ClassNotFoundException），子加载器才会尝试自己去加载。
```
双亲委派模型图：

3 ）为什么需要双亲委派模型？

在这里，先想一下，如果没有双亲委派，那么用户是不是可以 **自己定义一个 java. lang. Object 的同名
类** ， **java. lang. String 的同名类** ，并把它放到 ClassPath 中, 那么 **类之间的比较结果及类的唯一性将无法
保证** ，因此，为什么需要双亲委派模型？ **防止内存中出现多份同样的字节码**

4 ）怎么打破双亲委派模型？

打破双亲委派机制则不仅 **要继承 ClassLoader** 类，还要 **重写 loadClass 和 findClass** 方法。


###### 什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？

Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节
码文件。 Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或
者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

#### 场景题：说说 JVM 相关的类的加载、链接和初始化的问

#### 题？

一个 Java 类从字节代码到能够在 JVM 中被使用，需要经过加载、链接和初始化这三个步骤。

这三个步骤中，对开发人员直接可见的是 Java 类的加载，通过使用 Java 类加载器（class loader）可以
在运行时刻动态的加载一个 Java 类；

链接和初始化对开发人员直接可见不直接可见，因为：链接和初始化是在使用 Java 类之前会发生的动
作,

###### Java 的类加载机制

我们知道一个 Java 类要想运行，必须由 jvm 将其装载到内存中才能运行，装载的目的就是把 Java 字节代
码转换成 JVM 中的 java. lang. Class 类的对象。

这样 Java 就可以对该对象进行一系列操作，装载过程有两个比较重要的特征：层次组织结构和代理模
式。

层次组织结构指的是每个类加载器都有一个父类加载器，通过 getParent () 方法可以获取到。

类加载器通过这种父亲-后代的方式组织在一起，形成树状层次结构。

代理模式则指的是一个类加载器既可以自己完成 Java 类的定义工作，也可以代理给其它的类加载器来完
成。

由于代理模式的存在，启动一个类的加载过程的类加载器和最终定义这个类的类加载器可能并不是一
个。

ClassLoader 的加载类过程主要使用 loadClass 方法，该方法中封装了中加载机制：双亲委派模式。

```
一般来说，父类优先的策略就足够好了。
```
```
在某些情况下，可能需要采取相反的策略，即先尝试自己加载，找不到的时候再代理给父类加载
器。
这种做法在 Java 的 Web 容器中比较常见，也是 Servlet 规范推荐的做法。比如，Apache Tomcat 为
每个 Web 应用都提供一个独立的类加载器，使用的就是自己优先加载的策略。
```
```
IBM WebSphere Application Server 则允许 Web 应用选择类加载器使用的策略。
```
```
类加载器的一个重要用途是在 JVM 中为相同名称的 Java 类创建隔离空间。
```
```
在 JVM 中，判断两个类是否相同，不仅是根据该类的二进制名称，还需要根据两个类的定义类加
载器。
```

```
只有两者完全一样，才认为两个类的是相同的。因此，即便是同样的 Java 字节代码，被两个不同
的类加载器定义之后，所得到的 Java 类也是不同的。
```
```
如果试图在两个类的对象之间进行赋值操作，会抛出 java. lang. ClassCastException。这个特性为
同样名称的 Java 类在 JVM 中共存创造了条件。
```
```
在实际的应用中，可能会要求同一名称的 Java 类的不同版本在 JVM 中可以同时存在。通过类加载器
就可以满足这种需求。这种技术在 OSGi 中得到了广泛的应用
```
Java 类的加载过程：

1. 通过类的全名产生对应类的二进制数据流。（如果没找到对应类文件，只有在类实际使用时才抛出错
误。）

2. 分析并将这些二进制数据流转换为方法区特定的数据结构（这些数据结构是实现有关的，不同 JVM 有
不同实现）。这里处理了部分检验，比如类文件的魔数的验证，检查文件是否过长或者过短，确定是否
有父类（除了 Obecjt 类）。

3. 创建对应类的 java. lang. Class 实例（注意，有了对应的 Class 实例，并不意味着这个类已经完成了加
载链链接！）。

###### Java 类的链接

Java 类的链接指的是将 Java 类的二进制代码合并到 JVM 的运行状态之中的过程。

在链接之前，这个类必须被成功加载。

链接的过程比加载过程要复杂很多，这是实现 java 的动态性的重要一步！

分为三部分：verification （检测）， preparation（准备） 和 resolution（解析）

**1. verification（检测）：**

验证是用来确保 Java 类的二进制表示在结构上是完全正确的。如果验证过程出现错误的话，会抛出
java. lang. VerifyError 错误。

linking 的 resolve 会把类中成员方法、成员变量、类和接口的符号引用替换为直接引用，而在这之前，
需要检测被引用的类型正确性和接入属性是否正确（就是 public ,private 的的问题）诸如，检查 final
class 没有被继承，检查静态变量的正确性等等。
验证是用来确保 Java 类的二进制表示在结构上是完全正确的。如果验证过程出现错误的话，会抛出
java. lang. VerifyError 错误。

**2. preparation（准备）：**

准备过程则是创建 **Java 类中的静态域，并将这些域的值设为默认值** 。'准备过程并不会执行代码。

在一个 Java 类中会包含对其它类或接口的形式引用，包括它的父类、所实现的接口、方法的形式参数和
返回值的 Java 类等。

对类的成员变量分配空间。

虽然有初始值，但这个时候不会对他们进行初始化（因为这里不会执行任何 Java 代码）。

具体如下：

所有原始类型的值都为 0 。如 float: 0 f, int: 0, boolean: 0 (注意 boolean 底层实现大多使用 int)，

引用类型则为 null。

值得注意的是，JVM 可能会在这个时期给一些有助于程序运行效率提高的数据结构分配空间。

**3. resolution（解析）：**


解析的过程就是确保这些被引用的类能被正确的找到。解析的过程可能会导致其它的 Java 类被加载。

为类、接口、方法、成员变量的 **符号引用定位直接引用** ，完成内存结构的布局。

这一步是可选的。可以在符号引用第一次被使用时完成，即所谓的 **延迟解析** (late resolution)。

但对用户而言，这一步永远是延迟解析的，即使运行时会执行 early resolution，但程序不会显示的在
第一次判断出错误时抛出错误，而会在对应的类第一次主动使用的时候抛出错误！

另外，这一步与之后的类初始化是不冲突的，并非一定要所有的解析结束以后才执行类的初始化。

不同的 JVM 实现不同。

看下面一段代码：

类 LinkTest 引用了类 ToBeLinked，但是并没有真正使用它，只是声明了一个变量，并没有创建该类的
实例或是访问其中的静态域。

如果把编译好的 ToBeLinked 的 Java 字节代码删除之后，再运行 LinkTest，程序不会抛出错误。

这是因为 ToBeLinked 类没有被真正用到。

链接策略使得 ToBeLinked 类不会被加载，因此也不会发现 ToBeLinked 的 Java 字节代码实际上是不存在
的。

如果把代码改成 ToBeLinked toBeLinked = new ToBeLinked (); 之后，再按照相同的方法运行，就会抛
出异常了。

因为这个时候 ToBeLinked 这个类被真正使用到了，会需要加载这个类。

###### Java 类的初始化

开发 Java 时，接触最多的是对象的初始化。实际上类也是有初始化的。相比对象初始化，类的初始化
机制要简单不少。

类的初始化也是延迟的，直到类第一次被主动使用 (active use)，JVM 才会初始化类。

当一个 Java 类第一次被真正使用到的时候，JVM 会进行该类的初始化操作。初始化过程的主要操作是执
行静态代码块和初始化静态域。在一个类被初始化之前，它的直接父类也需要被初始化。

但是，一个接口的初始化，不会引起其父接口的初始化。在初始化的时候，会按照源代码中从上到下的
顺序依次执行静态代码块和初始化静态域。

```
public class LinkTest {
public static void main (String[] args) {
ToBeLinked toBeLinked = null;
System.out.println ("Test link.");
}
}
```
```
public class StaticTest {
public static int X = 10;
public static void main (String[] args) {
System.out.println (Y); //输出 60
}
static {
X = 30;
}
public static int Y = X 2;
}
```

在上面的代码中，在初始化的时候，静态域的初始化和静态代码块的执行会从上到下依次执行。因此变
量 X 的值首先初始化成 10 ，后来又被赋值成 30 ；而变量 Y 的值则被初始化成 60 。
类的初始化分两步：

```
1. 如果基类没有被初始化，初始化基类。
2. 有类构造函数，则执行类构造函数。
```
类构造函数是由 Java 编译器完成的。

它把类成员变量的初始化和 static 区间的代码提取出，放到一个方法中。

这个方法不能被一般的方法访问（注意，static final 成员变量不会在此执行初始化，它一般被编译器生
成 constant 值）。

同时，中是不会显示的调用基类的的，因为 1 中已经执行了基类的初始化。该初始化过程是由 Jvm 保证
线程安全的。。

Java 类和接口的初始化只有在特定的时机才会发生，这些时机包括：

通过 Java 反射 API 也可能造成类和接口的初始化。需要注意的是，当访问一个 Java 类或接口中的静态域的
时候，只有真正声明这个域的类或接口才会被初始化。考虑下面的代码：

```
创建一个 Java 类的实例。如
```
```
MyClass obj = new MyClass ()
```
```
调用一个 Java 类中的静态方法。如
```
```
MyClass.sayHello ()
```
```
给 Java 类或接口中声明的静态域赋值。如
```
```
MyClass. value = 10
```
```
访问 Java 类或接口中声明的静态域，并且该域不是常值变量。如
```
```
int value = MyClass. value
```
```
在顶层 Java 类中执行 assert 语句。
```
```
class B {
static int value = 100;
static {
System.out.println ("Class B is initialized."); //输出
}
}
class A extends B {
static {
System.out.println ("Class A is initialized."); //不会输出
}
}
public class InitTest {
public static void main (String[] args) {
System.out.println (A.value); //输出 100
}
```

在上述代码中，类 InitTest 通过A.value 引用了类 B 中声明的静态域 value。由于 value 是在类 B 中声明的，
只有类 B 会被初始化，而类 A 则不会被初始化。

#### JVM 调优

###### JVM 调优连环炮：常用的 JVM 启动参数有哪些?

JVM 可配置参数已经达到 1000 多个，其中 GC 和内存配置相关的 JVM 参数就有 600 多个。

但在绝大部分业务场景下，常用的 JVM 配置参数也就 10 来个。

**附带：JVM 上的随机数与熵池策略**

在 apache-tomcat 官方文档提到了一些启动时的优化项，其中一项是关于随机数生成时，采用的“熵源”
(entropy source) 的策略。

```
}
```
```
# JVM 启动参数不换行
# 设置堆内存
```
- Xmx 4 g -Xms 4 g
# 指定 GC 算法
- XX:+UseG 1 GC -XX:MaxGCPauseMillis= 50
# 指定 GC 并行线程数
- XX:ParallelGCThreads= 4
# 打印 GC 日志
- XX:+PrintGCDetails -XX:+PrintGCDateStamps
# 指定 GC 日志文件
- Xloggc: gc. log
# 指定 Meta 区的最大值
- XX:MaxMetaspaceSize=2 g
# 设置单个线程栈的大小
- Xss 1 m
# 指定堆内存溢出时自动进行 Dump
- XX:+HeapDumpOnOutOfMemoryError
- XX:HeapDumpPath=/usr/local/

```
# 指定默认的连接超时时间
```
- Dsun. net. client. defaultConnectTimeout= 2000
- Dsun. net. client. defaultReadTimeout= 2000
# 指定时区
- Duser. timezone=GMT+ 08
# 设置默认的文件编码为 UTF- 8
- Dfile. encoding=UTF- 8
# 指定随机数熵源 (Entropy Source)
- Djava. security. egd=file:/dev/./urandom


他提到 tomcat 7 的 session id 的生成主要通过 java. security. SecureRandom 生成随机数来实现，随机
数算法使用的是”SHA 1 PRNG”

在 sun/oracle 的 jdk 里，这个算法的提供者在底层依赖到操作系统提供的随机数据，

在 linux 上，与之相关的是/dev/random 和/dev/urandom，对于这两个设备块的描述以前也见过讨论
随机数的文章，wiki 中有比较详细的描述，摘抄过来，先看/dev/random ：

```
在读取时，/dev/random 设备会返回小于熵池噪声总数的随机字节。
```
```
/dev/random 可生成高随机性的公钥或一次性密码本。
```
```
若熵池空了，对/dev/random 的读操作将会被阻塞，直到收集到了足够的环境噪声为止
```
而 /dev/urandom 则是一个非阻塞的发生器:

```
dev/random 的一个副本是/dev/urandom （”unlocked”，非阻塞的随机数发生器），
```
```
它会重复使用熵池中的数据以产生伪随机数据。
```
```
这表示对/dev/urandom 的读取操作不会产生阻塞，但其输出的熵可能小于/dev/random 的。
它可以作为生成较低强度密码的伪随机数生成器，不建议用于生成高强度长期密码。
```
另外 wiki 里也提到了为什么 linux 内核里的随机数生成器采用 SHA 1 散列算法而非加密算法，是为了避开
法律风险 (密码出口限制)。

回到 tomcat 文档里的建议，采用非阻塞的熵源 (entropy source)，通过 java 系统属性来设置：

这个系统属性 egd 表示熵收集守护进程 (entropy gathering daemon)，但这里值为何要在 dev 和
random 之间加一个点呢？

是因为一个 jdk 的 bug，在这个 bug 的连接里有人反馈及时对 securerandom. source 设置为
/dev/urandom

它也仍然使用的 /dev/random，有人提供了变通的解决方法，其中一个变通的做法是对
securerandom. source 设置为 /dev/./urandom 才行。

也有人评论说这个不是 bug，是有意为之。

###### 举例：常用的 JVM 调优的参数都有哪些？

```
-Xms 2 g：初始化推大小为 2 g；
-Xmx 2 g：堆最大内存为 2 g；
-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；
-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；
–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
```
```
private String secureRandomAlgorithm = "SHA 1 PRNG";
```
```
-Djava. security. egd=file:/dev/./urandom
```

```
-XX:+PrintGC：开启打印 gc 信息；
-XX:+PrintGCDetails：打印 gc 详细信息。
```
###### 说说：你知道的几种主要的 JVM 参数

**思路：** 可以说一下堆栈配置相关的，垃圾收集器相关的，还有一下辅助信息相关的。

**参考答案：**

1 ）堆栈配置相关

**-Xmx 3550 m：** 最大堆大小为 3550 m。

**-Xms 3550 m：** 设置初始堆大小为 3550 m。

**-Xmn 2 g：** 设置年轻代大小为 2 g。

**-Xss 128 k：** 每个线程的堆栈大小为 128 k。

**-XX:MaxPermSize：** 设置永久代大小为 16 m

**-XX:NewRatio=4:** 设置年轻代（包括 Eden 和两个 Survivor 区）与年老代的比值（除去永久代）。

**-XX:SurvivorRatio=4：** 设置年轻代中 Eden 区与 Survivor 区的大小比值。设置为 4 ，则两个 Survivor 区
与一个 Eden 区的比值为2:4，一个 Survivor 区占整个年轻代的 1/6

**-XX:MaxTenuringThreshold=0：** 设置垃圾最大年龄。如果设置为 0 的话，则年轻代对象不经过
Survivor 区，直接进入年老代。

2 ）垃圾收集器相关

**-XX:+UseParallelGC：** 选择垃圾收集器为并行收集器。

**-XX:ParallelGCThreads=20：** 配置并行收集器的线程数

**-XX:+UseConcMarkSweepGC：** 设置年老代为并发收集。

**-XX:CMSFullGCsBeforeCompaction** ：由于并发收集器不对内存空间进行压缩、整理，所以运行一段
时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次 GC 以后对内存空间进行压缩、整理。

**-XX:+UseCMSCompactAtFullCollection：** 打开对年老代的压缩。可能会影响性能，但是可以消除碎
片

3 ）辅助信息相关

**-XX:+PrintGC 输出形式:**

```
java - Xmx 3550 m - Xms 3550 m - Xmn 2 g - Xss 128 k - XX:MaxPermSize= 16 m - XX:NewRatio= 4 -
XX:SurvivorRatio= 4 - XX:MaxTenuringThreshold= 0
```
- XX:+UseParallelGC-XX:ParallelGCThreads= 20 - XX:+UseConcMarkSweepGC -
XX:CMSFullGCsBeforeCompaction= 5 - XX:+UseCMSCompactAtFullCollection：
- XX:+PrintGC-XX:+PrintGCDetails


[GC 118250 K->113543 K (130112 K), 0.0094143 secs] [Full GC 121376 K->10414 K (130112 K),
0.0650971 secs]

**-XX:+PrintGCDetails 输出形式:**

[GC [DefNew: 8614 K->781 K (9088 K), 0.0123035 secs] 118250 K->113543 K (130112 K), 0.0124633
secs] [GC [DefNew: 8614 K->8614 K (9088 K), 0.0000665 secs][Tenured: 112761 K->10414 K (121024 K),
0.0433488 secs] 121376 K->10414 K (130112 K), 0.0436268 secs

###### 说一下 JVM 调优的工具？

JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视
图监控工具。

```
jconsole：用于对 JVM 中的内存、线程和类等进行监控；
jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的
变化、gc 变化等。
```
###### JVM 调优连环炮：调优命令有哪些？

Sun JDK 监控和故障处理命令有 jps jstat jmap jhat jstack jinfo

```
1. jps，JVM Process Status Tool, 显示指定系统内所有的 HotSpot 虚拟机进程。
2. jstat，JVM statistics Monitoring 是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机
进程中的类装载、内存、垃圾收集、JIT 编译等运行数据。
3. jmap，JVM Memory Map 命令用于生成 heap dump 文件
4. jhat，JVM Heap Analysis Tool 命令是与 jmap 搭配使用，用来分析 jmap 生成的 dump，jhat 内置了
一个微型的 HTTP/HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看
5. jstack，用于生成 java 虚拟机当前时刻的线程快照。
6. jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数
```
###### 调优工具

常用调优工具分为两类, jdk 自带监控工具：jconsole 和 jvisualvm，第三方有：MAT (Memory
AnalyzerTool)、GChisto。

```
1. jconsole，Java Monitoring and Management Console 是从 java 5 开始，在 JDK 中自带的 java 监控
和管理控制台，用于对 JVM 中内存，线程和类等的监控
2. jvisualvm，jdk 自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC 变化等。
3. MAT，Memory Analyzer Tool，一个基于 Eclipse 的内存分析工具，是一个快速、功能丰富的
Javaheap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗
4. GChisto，一款专业分析 gc 日志的工具
```
###### JVM 调优连环炮：设置堆内存 XMX 应该考虑哪些因素？


需要根据系统的配置来确定，要给操作系统和 JVM 本身留下一定的剩余空间。
推荐配置系统或容器里可用内存的 70 -80% 最好。

###### JVM 调优连环炮：假设物理内存是 8 G，设置多大堆内存比较合适?

比如说系统有 8 G 物理内存，系统自己可能会用掉一点，大概还有 7.5 G 可以用，那么建议配置 ‐Xmx 6
说明：

7.5 G*0.8 = 6 G

如果知道系统里有明确使用堆外内存的地方，还需要进一步降低这个值。

###### XM 设置的值与 JVM 进程所占用的内存有什么关系?

JVM 总内存=栈+堆+非堆+直接内存+Native

整个堆大小=年轻代大小 + 年老代大小 + 永久代大小.

**设置:**

java -Xmx 3550 m -Xms 3550 m -Xmn 2 g -Xss 128 k
①、 **-Xmx 3550 m** : 设置 JVM 最大可用内存为 3550 M.
②、 **-Xms 3550 m** : 设置 JVM 初始内存为 3550 m. 此值可以设置与-Xmx 相同, 以避免每次垃圾回收完成后
JVM 重新分配内存.
③、 **-Xmn 2 g** : 设置年轻代大小为 2 G. 永久代一般固定大小为 64 m, 所以增大年轻代后, 将会减小年老代大
小. 此值对系统性能影响较大, Sun 官方推荐配置为整个堆的 3/8.
④、 **-Xss 128 k** : 设置每个线程的堆栈大小. JDK 5.0 以后每个线程堆栈大小为 1 M, 以前每个线程堆栈大小为
256 K. 更具应用的线程所需内存大小进行调整. 在相同物理内存下, 减小这个值能生成更多的线程. 但是操
作系统对一个进程内的线程数还是有限制的, 不能无限生成, 经验值在 3000~5000 左右.

java -Xmx 3550 m -Xms 3550 m -Xss 128 k -XX:NewRatio=4 -XX:SurvivorRatio=4 -
XX:MaxPermSize=16 m -XX:MaxTenuringThreshold=0
①、 **-XX:NewRatio=4** :设置年轻代 (包括 Eden 和两个 Survivor 区) 与年老代的比值 (除去永久代). 设置为 4,
则年轻代与年老代所占比值为1:4, 年轻代占整个堆栈的 1/5
②、 **-XX:SurvivorRatio=4** : 设置年轻代中 Eden 区与 Survivor 区的大小比值. 设置为 4, 则两个 Survivor 区与
一个 Eden 区的比值为2:4, 一个 Survivor 区占整个年轻代的 1/6
③、 **-XX:MaxPermSize=16 m** : 设置永久代大小为 16 m.
④、 **-XX:MaxTenuringThreshold=0** : 设置垃圾最大年龄. 如果设置为 0 的话, 则年轻代对象不经过
Survivor 区, 直接进入年老代. 对于年老代比较多的应用, 可以提高效率. 如果将此值设置为一个较大值, 则
年轻代对象会在 Survivor 区进行多次复制, 这样可以增加对象再年轻代的存活时间, 增加在年轻代即被回
收的概论.

###### JVM 调优连环炮：怎样开启 GC 日志？

一般来说，JDK 8 及以下版本通过以下参数来开启 GC 日志：


如果是在 JDK 9 及以上的版本，则格式略有不同：

###### JVM 调优连环炮：怎么打出线程栈信息。

**思路：** 可以说一下 jps，top ，jstack 这几个命令，再配合一次排查线上问题进行解答。

**参考答案：**

```
输入 jps，获得进程号。
top -Hp pid 获取本进程中所有线程的 CPU 耗时性能
jstack pid 命令查看当前 java 进程的堆栈状态
或者 jstack -l > /tmp/output. txt 把堆栈信息打到一个 txt 文件。
可以使用 fastthread 堆栈定位，fastthread. io/
```
###### JVM 调优连环炮：请指定使用 G 1 垃圾收集器来启动程序

java ‐XX:+UseG 1 GC
‐Xms 4 g
‐Xmx 4 g
‐Xloggc: gc. log
‐XX:+PrintGCDetails
‐XX:+PrintGCDateStamps Hello

###### Java 8 默认使用的垃圾收集器是什么?

Java 8 版本的 Hotspot JVM，默认情况下使用的是并行垃圾收集器（Parallel GC）。

其他厂商提供的 JDK 8 基本上也默认使用并行垃圾收集器。

###### Java 11 的默认垃圾收集器是什么?

Java 9 之后，官方 JDK 默认使用的垃圾收集器是 G 1。

###### 常见的垃圾收集器有哪些?

常见的垃圾收集器包括：

串行垃圾收集器： ‐XX:+UseSerialGC

- XX:+PrintGCDetails
- XX:+PrintGCDateStamps
- Xloggc: gc. log
- # JDK 11 环境，输出 info 级别的 GC 日志
java -Xms 512 m -Xmx 512 m
-Xlog:gc*=info:file=gc. log:time:filecount=0
demo. jvm 0204. GCLogAnalysis


并行垃圾收集器： ‐XX:+UseParallelGC

CMS 垃圾收集器：‐XX:+UseConcMarkSweepG

G 1 垃圾收集器： ‐XX:+UseG 1 GC

###### 什么是串行垃圾收集?

就是只有单个 worker 线程来执行 GC 工作。

###### 什么是并行垃圾收集?

并行垃圾收集，是指使用多个 GC worker 线程并行地执行垃圾收集，能充分利用多核
CPU 的能力，缩短垃圾收集的暂停时间。
除了单线程的 GC，其他的垃圾收集器，比如 PS，CMS， G 1 等新的垃圾收集器都使

用了多个线程来并行执行 GC 工作。

###### 什么是并发垃圾收集器?

并发垃圾收集器，是指在应用程序在正常执行时，有一部分 GC 任务，由 GC 线程在应用线程一起并发执
行。

例如 CMS/G 1 的各种并发阶段。

###### 什么是增量式垃圾收集?

首先， G 1 的堆内存不再单纯划分为年轻代和老年代，而是划分为多个（通常是 2048 个）可以存放对象
的小块堆区域（smaller heap regions）。

每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者 Old 区。

这样划分之后，使得 G 1 不必每次都去回收整个堆空间，而是以增量的方式来进行处理： 每次只处理一
部分内存块，称为此次 GC 的回收集（collection set）。

下一次 GC 时在本次的基础上，再选定一定的区域来进行回收。

增量式垃圾收集的好处是大大降低了单次 GC 暂停的时间。

###### 什么是年轻代？

年轻代是分来垃圾收集算法中的一个概念，相对于老年代而言，年轻代一般包括：

新生代，Eden 区。

存活区，执行年轻代 GC 时，用存活区来保存活下来的对象。

存活区也是年轻代的一部分，但一般有 2 个存活区，所以可以来回倒腾。

###### 什么是 GC 停顿 (GC pause)?


因为 GC 过程中，有一部分操作需要等所有应用线程都到达安全点，暂停之后才能执行，
这时候就叫做 GC 停顿，或者叫做 GC 暂停。

###### GC 停顿与 STW 停顿有什么区别？

这两者一般可以认为就是同一个意思。

###### 如果 CPU 使用率突然飙升，你会怎么排查？

缺乏经验的话，针对当前问题，往往需要使用不同的工具来收集信息，例如：收集不同的指标（CPU，
内存，磁盘 IO，网络等等）

然后进行专项分析：

```
分析应用日志
分析 GC 日志
获取线程转储并分析
获取堆转储来进行分析
```
#### 聊聊：什么是逃逸分析

和下面的题目一致

#### 聊聊：Java 中的对象一定是在堆上分配的吗？

**对于 JVM“逃逸分析” 特性，也是近年来大厂面试、高薪面试的常见面试题。**

和逃逸分析有关的常见面试题：

```
Java 中的对象一定是在堆上分配的吗？
```
###### JVM 的内存分配策略

首先回顾一下 JVM 的内存分配策略。

JVM 的内存包括方法区、堆、虚拟机栈、本地方法栈、程序计数器。

一般情况下 JVM 运行时的数据都是存在栈和堆上的。

```
栈用来存放一些基本变量和对象的引用，
堆用来存放数组和对象，也就是说 new 出来的实例。
```
**但是：凡事都有例外**

随着 JIT 编译器的发展和逃逸分析的技术成熟，栈上分配、标量替换等优化技术，使对象不一定全都分配
在堆中。


**so，重点来了：对象不一定全都分配在堆中**

在 JVM 的实现中，为了提高 JVM 的性能和节省内存空间，JVM 提供了一种叫做 “逃逸分析” 的特性，逃逸
分析是目前 Java 虚拟机中比较前沿的优化技术，也是 JIT 中一个很重要的优化技术。

###### “逃逸分析” 的直观认知

直接说这些概念，确实有点晕啊，那我们就来“逃逸分析” 的直观认知。

三连问： “逃逸分析” 的本质是什么呢？为什么叫逃逸？逃逸的范围是什么呢？

**“逃逸分析” 的本质：**

**主要就是分析对象的动态作用域，分析一个对象的动态作用域是否会逃逸出方法范围、或者线程范围。**

**简单的说：**

如果一个对象在一个方法内定义，如果被方法外部的引用所指向，那认为它逃逸了。

否者，这个对象，没有发生逃逸。

**尼恩提示：**

看起来一个很牛逼轰轰的概念，其实就是这么简单。

###### 逃逸分析的概念

先以官方的形式来说下什么是逃逸分析。

逃逸分析就是：一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针。

在 JVM 的即时编译语境下，逃逸分析将判断新建的对象是否逃逸。

即时编译判断对象是否逃逸的依据：

一种是对象是否被存入堆中（静态字段或者堆中对象的实例字段），另一种就是对象是否被传入未知代
码。

###### 逃逸分析的类型

逃逸分析的类型有两种：

```
方法逃逸
线程逃逸
```
什么是：方法逃逸 (对象逃出当前方法)：

当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其它方法中。

什么是：线程逃逸 ((对象逃出当前线程)：

这个对象甚至可能被其它线程访问到，例如赋值给类变量或可以在其它线程中访问的实例变量

**方法逃逸**

当一个对象在方法里面被定义后，它可能被外部方法所引用，这种称为方法逃逸

方法逃逸包括：


```
通过调用参数，将对象地址传递到其他方法中，
对象通过 return 语句将对象指针，返回给其他方法
等等
```
我们可以用下面的代码来表示这个现象。

上面的例子中，StringBuffer 对象通过 return 语句返回。

StringBuffer sb 是一个方法内部变量，上述代码中直接将 sb 返回，这样这个 StringBuffer 有可能被其他
方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。

甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃
逸。

不直接返回 StringBuffer，那么 StringBuffer 将不会逃逸出方法。

具体的代码如下：

可以看出，想要逃逸方法的话，需要让对象本身被外部调用，或者说，对象的指针，传递到了 **方法之
外** 。

**线程逃逸**

当一个对象可能被外部线程访问到，这种称为线程逃逸。

例如赋值给类变量或可以在其它线程中访问的实例变量

###### 逃逸分析后的代码优化

从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。

如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径访问到
这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不
同程度的优化。

通过逃逸分析，编译器会对代码进行优化。

```
//StringBuffer 对象发生了方法逃逸
public static StringBuffer createStringBuffer (String s 1, String s 2) {
StringBuffer sb = new StringBuffer ();
sb.append (s 1);
sb.append (s 2);
return sb;
}
```
```
// 非方法逃逸
public static String createString (String s 1, String s 2) {
StringBuffer sb = new StringBuffer ();
sb.append (s 1);
sb.append (s 2);
return sb.toString ();
}
```

如果能够证明一个对象不会逃逸到方法外或者线程外，或者说逃逸程度比较低，则可以对这个对象采用
不同程度的优化：

```
栈上分配
标量替换
消除同步锁
```
###### 栈上分配

**对象不分配在堆上，而是分配在栈内存上。**

**前提是** ：对象没有逃逸，很老实的话。

**具体而言：**

完全不会逃逸的局部变量和不会逃逸出的线程对象，采用栈上分配，

对于发生逃逸的、不老实的对象，才使用堆上分配。

栈上分配可以快速地在栈帧上创建和销毁对象，不用再将对象分配到堆空间，可以有效地减少 JVM 垃圾
回收的压力。

###### 标量替换

一个对象可能不需要作为一个连续的存储空间，也能被访问到，那么对象的部分可以不存储的在连续的
内存，而是存可以打散存储，甚至部分存储或者打散在 CPU 寄存器中。

通过逃逸分析确定该对象不会被外部访问后，JVM 判断对象是否可以被进一步分解，如果对象可以打散
为变量，则 JVM 不会创建该对象，而是化整为零，将该对象成员变量分解若干个被这个方法使用的成
员变量，

JVM 将一个大的对象打散成若干变量的过程，叫做 **标量替换** ，也称之为 **分离对象** 。

比如如下代码：

从以上代码可以看出，Point 对象并没有逃逸出 alloc 方法，并且 Point 对象是可以拆解成标量的。

此时，JIT 就会不会直接创建 Point 对象，而是直接使用两个标量 int x, int y 来替代 Point 对象

为啥要 **化整为零** 呢？

```
public static void main (String[] args) {
alloc ();
}
```
```
private static void alloc () {
Point point = new Point（1,2）;
System.out.println ("point. x="+point. x+"; point. y="+point. y);
}
class Point{
private int x;
private int y;
}
```

因为栈空间是非常有限的，很多的场景下，一个线程的栈空间就是 1 M 的大小。

标量替换之后的成员变量，可以选择在栈帧分配，也可以就近在寄存器上分配空间，这样就不会因为没
有一大块连续空间导致对象内存不够分配。

开启标量替换参数-XX:+EliminateAllocations，JDK 7 之后默认开启。

**总之：**

当 JVM 通过逃逸分析，确定要将对象分配到栈上时，即时编译可以将对象打散，将对象替换为一个个很
小的局部变量，我们将这个打散的过程叫做标量替换。

将对象替换为一个个局部变量后，就可以非常方便的在栈上进行分配了。

###### 同步锁消除

如果 JVM 通过逃逸分析，发现一个对象只能从一个线程被访问到，则访问这个对象时，可以不加同步
锁。

具体来说：

如果同步块所使用的锁对象通过这种分析后，发现只能够被一个线程访问，根本用不着同步，

那么，JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步锁。

所以：如果程序中使用了 synchronized 内置锁锁，则 JVM 会将 synchronized 内置锁消除。

**注意：**

**这种情况针对的是 synchronized 锁，而对于非内置锁，比如 Lock 显示锁、CAS 乐观锁等等，则 JVM 并
不能消除。**

要开启同步消除，需要加加上两个 JVM 启动选项：

-XX:+EliminateLocks 启动选项，表示启动同步锁消除。

-XX:+DoEscapeAnalysis 选项，表示启动逃逸分析。

因为同步锁消除依赖逃逸分析，所以同时要打开 -XX:+DoEscapeAnalysis 选项。

###### 逃逸分析相关 JVM 参数

###### 逃逸分析的底层原理是什么呢？

```
-XX:+EliminateLocks
-XX:+DoEscapeAnalysis
```
```
-XX:+DoEscapeAnalysis 开启逃逸分析
-XX:+PrintEscapeAnalysis 开启逃逸分析后，可通过此参数查看分析结果。
-XX:+EliminateAllocations 开启标量替换
-XX:+EliminateLocks 开启同步消除
-XX:+PrintEliminateAllocations 开启标量替换后，查看标量替换情况。
```

在 Java 的编译体系中，一个 Java 的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编
译：

第一段编译，指前端编译器把 **. java 文件** 转换成 **. class 文件** (字节码文件)。

前端编译器产品可以是 JDK 的 Javac、Eclipse JDT 中的增量式编译器。

第二编译阶段，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入字节码，逐条解释翻译成机
器码。

很显然，由于有一个解释的中间过程，其执行速度必然会比可执行的二进制字节码程序慢很多。

这就是传统的 JVM 的解释器（Interpreter）的功能。

如何去掉中间商，提升效率？

为了解决这种效率问题，引入了 JIT（即时编译器，Just In Time Compiler）技术。

引入了 JIT 技术后，Java 程序还是通过解释器进行解释执行，也就是说，主体还是解释执行，只是局部
去掉中间环节。

怎么做局部去掉中间环节呢？

当 JVM 发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。

然后 JIT 会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存
起来，以备下次使用。

把翻译后的机器码缓存在哪里呢？ 这个缓存，叫做 Code Cache。可见，JVM 和 WEB 应用实现高并发
的手段是类似的，还是使用了缓存架构。

当 JVM 下次遇到相同的热点代码时，跳过解释的中间环节，直接从 Code Cache 加载机器码，直接执
行，无需再编译。

所以，JIT 总的目标是发现热点代码，热点代码变成了提升性能的关键，hotspot JVM 的名字，也就是这
么来的，把识别热点代码，写在名字上，作为毕生的追求。

所以，JVM 总的策略为：

```
对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式
运行；
另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速
度。
```
JIT (即时编译) 的出现与解释器的区别

（ 1 ）解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释。

（ 2 ）JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需
再编译。

（ 3 ）解释器是将字节码解释为针对所有平台都通用的机器码。

（ 4 ）JIT 会根据平台类型，生成平台特定的机器码。

JVM 包含多个即时编译器，主要有 C 1 和 C 2，还有个 Graal (实验性的)。

多个即时编译器, 都会对字节码进行优化并生成机器码


C 1 会对字节码进行简单可靠的优化，包括方法内联、去虚拟化、冗余消除等，编译速度较快，可以通
过-client 强制指定 C 1 编译

C 2 会对字节码进行激进优化，包括分支频率预测、同步擦除等，

可以通过-server 强制指定 C 2 编译

JVM 将执行状态分成了 5 个层次：

```
0 层，解释执行（Interpreter）
1 层，使用 C 1 即时编译器编译执行（不带 profiling）
2 层，使用 C 1 即时编译器编译执行（带基本的 profiling）
3 层，使用 C 1 即时编译器编译执行（带完全的 profiling）
4 层，使用 C 2 即时编译器编译执行
```
JVM 不会直接启用 C 2，而是先通过 C 1 编译收集程序的运行状态，再根据分析结果判断是否启用 C 2。

分层编译模式下, 虚拟机执行状态由简到繁、由快到慢分为 5 层

在编译期间，JIT 除了对热点代码做缓存提速，会对代码做很多优化。

其中有一部分优化的目的就是 **减少内存堆分配压力** ，其中 JIT 优化中一种重要的技术叫做逃逸分析。根据
逃逸分析，即时编译器会在编译过程中对代码做如下优化：

```
锁消除：当一个锁对象只被一个线程加锁时，即时编译器会把锁去掉
栈上分配：当一个对象没有逃逸时，会将对象直接分配在栈上，随着线程回收，由于 JVM 的大量代
码都是堆分配，所以目前 JVM 不支持栈上分配，而是采用标量替换
标量替换：当一个对象没有逃逸时，会将当前对象打散成若干局部变量，并分配在虚拟机栈的局部
变量表中
```
###### 关于面试题答案：Java 中的对象一定是在堆上分配的吗？

答：不一定。

如果满足了逃逸分析的条件，一个对象，完全可以在栈上分配。 **减少堆内存的分配和 GC 压力。**

由于栈内存有限，所以，如果对象符合标量替换的条件， **进一步为对象来一次化整为零的手术**

标量替换具体的做法是：

JVM 会将对象进一步打散，将对象分解为若干个被这个方法使用的成员变量， **从而，达到更好的利用栈
内存和寄存器的目标**

#### 聊聊：什么是即时编译？


###### 1 、Java 与编译相关的三个概念

首先了解三个概念

```
前端编译
解释执行
编译执行
```
**1.1、前端编译**

编译器（javac）将源文件（. java）编译成 java 字节码文件（. class）的步骤是前端编译。

**1.2、解释执行**

在 JVM 加载字节码后，每次执行方法调用时，JVM 都会将字节码翻译成机器码，然后执行机器码，这个
过程叫 **解释执行** 。

解释执行为了提升启动效率，并没有在启动时将字节码全部翻译成机器码，所以 **启动效率较高**

**但是，**

由于字节码不行执行，要机器码才能执行，所以，执行时要进行字节码翻译，所以 **执行效率相对较低**

**1.3、编译执行**

什么是编译执行？

与解释执行相反，JVM 加载字节码的时候，直接将字节码转换为机器码，在执行方法调用时直接执行机
器码，不需要做翻译工作，这样的过程叫 **编译执行** 。

编译执行的问题是什么呢？

和解释执行相反，编译执行在启动时将字节码全部翻译成机器码，所以启动效率较低

**但是**

编译执行时省去了翻译的步骤，所以执行效率相对较高

###### 2 、即时编译

解释执行的特点是：启动效率高、执行效率低

编译执行的特点是：启动效率低、执行效率高

JVM 如何实现双高呢？实现，启动效率高、执行效率也高。

**2.1、如何平衡启动速度和执行的速度**

为了平衡启动和执行的效率，JVM 结合解释执行和编译执行的特点，进行综合和平衡，形成了一种折中
的性能优化策略。

JVM 以解释执行，编译执行为辅，达到启动速度和执行速度的最优化。

那些代码需要编译执行呢？热点代码。

JVM 并不对全部代码进行编译执行，仅仅对热点代码进行编译优化，这样的执行过程叫即时编译

**2.2、什么是“热点代码”（Hot Spot Code)？**


当 JVM 发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。

然后 JIT 会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存
起来，以备下次使用。

把翻译后的机器码缓存在哪里呢？ 这个机器码缓存，叫做 Code Cache。

当 JVM 下次遇到相同的热点代码时，跳过解释的中间环节，直接从 Code Cache 加载机器码，直接执
行，无需再编译。

所以，JIT 总的目标是发现热点代码，热点代码变成了提升性能的关键，

Java 官方给自家开源的 JVM 取字为 hotspot JVM，也就是这么来的。

说得更大白话一点，Java 官方把识别“热点代码”（Hot Spot Code) 这个任务，写在名字上，作为毕生的
追求。

所以，JVM 总的策略为：

```
对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式
运行；
另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，并且缓存起来，后面省
略编译的过程，直接从缓存当中取得机器码，从而以达到理想的运行速度。
```
**2.2 架构师视角解读：JVM 中的缓存架构**

**“热点代码”（Hot Spot Code) 编译后，放入到 Code Cache 中，当 JVM 下次遇到相同的热点代码时，直
接从 Code Cache 加载机器码，跳过中间的编译环节，无需再编译。**

从架构的角度来说，这里应用到了尼恩常说的 3 高架构的三板斧之一： **缓存架构** 。

可见，JVM 和 WEB 应用实现高并发的手段，是非常类似的。JVM 为了实现高性能和高并发，也会使用缓
存架构。

在《Java 高并发核心编程卷 2 加强版中》，大家知道，CPU 内部，为了提升性能，也用了缓存架构，并
且是多级缓存架构。

同时，在缓存架构中，热点数据非常重要。

在 WEB 应用的缓存架构中，识别热点数据（HotKey），是提升三级缓存命中率的核心环节。我们会通
过有效的识别组件，识别其中的 HotKey。

这种 HotKey 的理论和思想，在 JVM 中的缓存架构也是想通的。

**JVM 中的缓存架构中，不能什么都缓存，需要缓存的同样是他的 HotKey，这里叫做 Hot Spot
Code，仅仅换了一个名字而已。**

**所以，正如尼恩三高架构的思想所云，缓存架构都是相通的：**

```
高并发 WEB 三级缓存架构里边，有 hotkey 和本地高速缓存
JVM 架构里边有 Hot Spot 和 Code Cache
```
**3.1、即时编译器**

JVM 包含多个即时编译器，主要有 C 1 和 C 2，还有个 Graal (实验性的)。

多个即时编译器, 都会对字节码进行优化并生成机器码。


但是不同的即时编译器，优化的程度不同：C 1 会对字节码进行简单可靠的优化，C 2 会对字节码进行激
进优化。

```
C 1 会对字节码进行简单可靠的优化，包括方法内联、去虚拟化、冗余消除等，编译速度较快，可
以通过-client 强制指定 C 1 编译
C 2 会对字节码进行激进优化，包括分支频率预测、同步擦除等，可以通过-server 强制指定 C 2 编译
```
如果没有强制指定，JVM 默认会使用分层编译模式。

**3.2、分层编译模式**

JVM 不会直接启用 C 2，而是先通过 C 1 编译收集程序的运行状态，再根据分析结果判断是否启用 C 2。

分层编译模式下, 虚拟机执行状态由简到繁、由快到慢分为 5 层

```
0 层，解释执行（Interpreter）
1 层，使用 C 1 即时编译器编译执行，无 profiling
2 层，使用 C 1 即时编译器编译执行，带基本的 profiling（仅方法调用次数及循环回边执行次数的
profiling）
3 层，使用 C 1 即时编译器编译执行，带完全的 profiling
4 层，使用 C 2 即时编译器编译执行
```
**什么是 profiling?**

profiling 是 C 0/C 1 在编译过程中收集程序执行状态的过程

收集的执行状态记录为 profile (概述/ 印象)，包括分支跳转频率、是否出现过空值和异常等，主要用于
触发 C 2 编译。

如何实现呢？

**profiling 是指在程序执行过程中，JVM 织入的一些协助收集数据的辅助代码，这些织入的辅助代码** ，
收集能够反映程序执行状态的数据。这里所收集的数据我们称之为程序的 profile。

**profiling 在思想上，非常类似于 Java Agent 的字节码增强。只是 Java Agent 的字节码增强发生在
字节码层面，profiling 的指令织入，发生在机器码的层面。**

至于 profiling 的指令织入，织入了啥？ 咱们不需要深究，除非不想再从事 Java 开发，而是去用 C++ 开发
JVM。否则，不用关系织入了啥，了解这个思想就行。

**什么是完全的 profiling？**

除了基本的 profiling（仅方法调用次数及循环回边执行次数的 profiling）外，

还包括分支 profile（针对分支跳转字节码，包括跳转次数和不跳转次数）以及 receiver type（针对成员
方法调用或类检测，如 checkcast，instanceof，aastore 字节码）的类型 profile

分层编译 5 层执行状态之间的关系，具体如下图：


第一条执行路径，指的是通常情况下，一个方法先被解释执行（level 0），然后被 C 1 编译（level 3），
再然后被得到 profile 数据的 C 2 编译（level 4）

第二条执行路径，指的是编译对象非常简单的情况下，如 getter 和 setter，虚拟机认为通过 C 1 编译或通
过 C 2 编译并无区别，就会在 3 层编译后，直接由 C 1 编译且不插入 profiling 代码（level 1）。

第三条执行路径，指的是 C 1 繁忙时，JVM 会在解释执行时收集 profiling，而后直接由 4 层的 C 2 编译。

第四条执行路径，指的是 C 2 繁忙时，先由 2 层的 C 1 编译再由 3 层的 C 1 编译，这样可以减少方法在 3 层的
执行时间，最终再交给 C 2 执行。

注意：这个收集的动作，叫做 **profiling** ，这个收集的结果，叫做 **profile** 。

分层编译中的 0 层、 2 层和 3 层都会进行 profiling，织入的一些协助收集数据的辅助代码，收集能够
反映程序执行状态的数据。

其中，最为基础的便是 2 层进行的 profiling，它只需要统计方法的调用次数以及循环回边的执行次数，
当统计之和超过阈值就会触发 **即时编译** 。

**所以，方法的调用次数以及循环回边的执行次数达到阈值，这部分的代码，就会被识别成为—— 热点
代码。**

0 层和 3 层相较于 2 层复杂一些，需要收集用于 4 层 C 2 编译的数据。

比如说分支跳转字节码的分支 profile（branch profile），包括跳转次数和不跳转次数，

比如 receiver 类型 profile（receiver type profile）：非私有实例方法调用指令、强制类型转换
checkcast 指令、类型测试 instanceof 指令，和引用类型的数组存储 aastore 指令。

**上述数据分为两大类：分支 profile 和类型 profile。**

根据图片中的编译途径可知，分层编译下，无论何种情况，大概率都要进行分支 profile 和类型 profile
的收集。

但是，需要注意的是，有利必有弊： 分支 profile 和类型 profile 的收集，将给应用程序带来不少的性
能开销。

据统计，正是因为这部分额外的 profiling，导致的一个结果是：

**3 层 C 1 代码（带完全的 profile）的性能比 2 层 C 1 代码（带基本的 profiling）低 30%** 。


那么这些耗费巨大代价收集而来的 profile 具体有什么作用呢？

答案是：

**C 2 可以根据收集得到的数据进行猜测，从而作出比较激进的优化。**

当然： 4 层的 C 2 代码有一个前提，就是假设接下来的执行，同样会 C 1 代码按照所收集的 profile 进行。

###### 3.3、profiling

###### 3.4、触发 C 2 的时机

当方法调用次数 profile 或循环次数 profile 达到阈值时，会触发即时编译

阈值不仅需要通过-XX: TierXInvocationThreshold、-XX: TierXMINInvocationThreshold 和-
XX: TierXCompileThreshold 设置，还跟待编译方法的数目和编译线程的总数有关。

编译线程的数量是处理器动态指定的，参数为-XX:+CICompilerCountPerCPU 默认开启，

可以通过-XX:+CICompilerCount=N 强制指定编译线程总数。

JVM 会将这些线程以1:2的比例分配给 C 1 和 C 2

###### 3.5、去优化

去优化是当 C 2 编译的机器码假设失败时，将即时编译切换回解释执行的过程

在 C 2 编译生成机器码时，会在假设失败的一端设置一条指令。

当假设失败时，调用指令让 JVM 将栈帧的方法返回地址从机器码所在的本地内存地址改回运行时常量池
中的方法地址，并进行解释执行

###### 4 、方法内联

在即时编译方法时，将目标方法的方法体取代方法调用的过程叫方法内联，增加了编译的代码量，但是
降低了方法调用带来的入栈出栈的成本

**4.1、静态方法内联**

即时编译器会根据方法调用层数，目标方法的调用次数及字节码大小等决定该方法是否允许被内联

```
-XX: CompileCommand 配置中的 inline 指令指定的方法会被强制内联，dontinline 和 exclude 指定
的方法始终不会被内联
@ForceInline 注解的 jdk 内部方法会被强制内联，@DontInline 注解 jdk 内部方法始终不会被内联
方法的符号引用未被解析、目标方法所在类未被初始化、目标方法是 native 方法，都会导致方法无
法内联
C 2 默认不支持 9 层以上的方法调用（-XX:MaxInlineLevel），以及 1 层的直接递归调用（-
XX:MaxRecursiveInlineLevel）
自动拆箱总会被内联，Throwable 类的方法不能被其他类内联等
```
**4.2、动态方法内联**

即时编译器需要将动态绑定的虚方法转化为直接调用，才能进行方法内联，这样的过程叫虚方法的去虚
化

```
根据字节码生成的 IR 图确定调用者类型的过程叫基于类型推导的完全去虚化
```

```
根据 JVM 中已加载的类找到接口的唯一实现的过程叫基于类层次分析的完全去虚化
根据编译时收集的类型 profile，依次匹配方法调用者的动态类型与 profile 中的类型
```
###### 5 、逃逸分析

当方法内部定义的对象被外部代码引用时，称为该对象逃逸，JVM 对对象的分析过程叫逃逸分析

根据逃逸分析，即时编译器会在编译过程中对代码做如下优化：

```
锁消除：当一个锁对象只被一个线程加锁时，即时编译器会把锁去掉
栈上分配：当一个对象没有逃逸时，会将对象直接分配在栈上，随着线程回收，由于 JVM 的大量代
码都是堆分配，所以目前 JVM 不支持栈上分配，而是采用标量替换
标量替换：当一个对象没有逃逸时，会将当前对象打散成若干局部变量，并分配在虚拟机栈的局部
变量表中
```
###### 6 、即时编译的其他优化

字段读取优化：缓存多次读取的数据，减少出入栈次数

字段存储优化：将被覆盖的赋值操作优化掉，减少无用的入栈

循环无关代码外提：避免重复执行表达式，减少出入栈次数

```
public String register (User user, String username, String password){
user. username = username;
return user. username + password;
}
```
```
class User{
private String username;
}
```
```
public String register (User user, String username){
String s = user. username; //user. username 被缓存成了 s
s = username;
return s + password;
}
```
```
private void test (){
int a = 1;
a = 2;
}
```
```
private void test (){
int a = 2;//a=1 被优化掉了
}
```
```
private void test (String s){
String password;
for (int i=0; i<10; i++){
password = s.replaceAll ("/","");
System.out.println (i);
```

循环展开：将相同的循环逻辑多次重复在一次迭代中，以减少循环次数

循环的自动向量化：对循环中地址连续的数组操作，会按顺序批量出入栈（这段是伪代码）

```
}
}
```
```
private void test (String s){
String password = s.replaceAll ("/","");//与循环无关的代码被编译器外提了
for (int i=0; i<10; i++){
System.out.println (i);
}
}
```
```
private void test (int[] arr){
int sum=0;
for (int i=0; i<8; i++){
sum +=arr[i];
}
}
```
```
private void test (int[] arr){
int sum=0;
for (int i=0; i<8; i+=2){//循环次数减少
sum +=arr[i];
sum +=arr[i+1];//重复循环体内相同逻辑
}
}
```
```
private void test (int[] arr 1, int[] arr 2){
for (int i=0; i<arr 1. length; i++){
arr 1[i] = arr 2[i];
}
}
```
```
private void test (int[] arr 1, int[] arr 2){
for (int i=0; i<arr 1. length; i+=4){
arr 1[i:i+4] = arr 2[i:i+4];//可以看成是在循环展开的基础上，将多个数组一块出入
栈
}
}
```

## 美团一面：OOM 后，JVM 一定会退出吗？为

## 什么？

#### 说在前面

在 40 岁老架构师尼恩的 **读者交流群** (50+) 中，最近有小伙伴拿到了一线互联网企业如美团、拼多多、极
兔、有赞、希音的面试资格，遇到一几个很重要的面试题：

```
OOM 后，JVM 一定会退出吗？为什么？
```
生产环境，很多小伙伴，也遇到过 OOM 后，JVM 会退出的问题。

这里尼恩给大家做一下系统化、体系化的梳理，使得大家可以充分展示一下大家雄厚的 “技术肌肉”， **让
面试官爱到 “不能自已、口水直流”** 。

也一并把这个题目以及参考答案，收入咱们的《尼恩 Java 面试宝典》V 70 版本，供后面的小伙伴参考，
提升大家的 3 高架构、设计、开发水平。

```
最新《尼恩架构笔记》《尼恩高并发三部曲》、《尼恩 Java 面试宝典》的 PDF 文件，请通过公众
号（技术自由圈）获取。
```
#### 问题背景

问题是，咱们常常说：发生 OOM，程序就会挂。

很多情况是： 发生 OOM 了，JVM 没有挂。

###### 回顾一下 OOM 与异常

来看一下 OutOfMemoryError，说到底，OutOfMemoryError 也只是一个 java 中的异常而已，

OutOfMemoryError 属于 Error 一系非检查异常，其继承关系如下

再来看看，堆内存不够与 OutOfMemoryError 异常的关系

线程发生 OutOfMemoryError，首先是堆空间不够了，然后再由 jvm 在申请分配空间的的时候，在调用
上抛出 OOM 异常。

申请内存的线程，会会像处理普通的其他异常一样，处理 OutOfMemoryError。

线程是资源调度的基本单位，Java 在设计线程时充分考虑了线程的独立性。

在异常方面，线程也保持了线程异常的独立性。

在线程执行中，如果发生的异常，都由线程进行独立的处理，而不是也不会抛出到其它的线程。这就是
保证了这种线程的独立性。

从线程的实现维度，也可以看到异常处理的策略。

```
Object
Throwable
Error
VirtualMachineError
OutOfMemoryError
```

线程 Thread 里边，最终会执行内部 target 对象的 run 方法，也就是 java. lang. Runnable 接口实现方法，
线程通过其 run 方法运行，方法签名如下：

注意这个方法，run 方法不能声明抛出任何检查异常（checked exception）。因此在线程方法执行中发
生的任何检查异常，必须在线程中处理。

线程拿到异常，有两种处理方式：

```
捕获并且处理异常，线程继续执行
线程停止执行
```
###### 默认异常处理器

如果没有被捕获

除了检查异常，java 中还有非检查异常（unchecked exception），这种异常无需显式声明也能沿着方
法调用链向上抛出。

线程对于这种未处理的异常，提供了默认异常处理器：

Thread 的 init () 方法线程至少有一个默认异常处理器，兜底的异常处理器是当前线程父线程的线程组
ThreadGroup，可以看到线程组是有能力处理异常的：

线程通过这两种机制，保证内部发生的异常，在线程内解决，而不会抛出给启动线程的外部线程。

#### JVM 退出条件

java 虚拟机退出的条件是：JVM 不存在非守护线程（前台线程），JVM 就会退出。

线程发生未处理的异常（未处理异常由默认异常处理器处理）会导致线程结束，而线程结束了，如果还
有非守护线程（前台线程），JVM 也不会退出。

OOM 也是一种异常，它的发生也不会导致 JVM 退出。

所以，OOM 与 JVM 的退出，没有很强的关系。

以下实例说明：

实例一：线程 OOM，JVM 不一定退出

实例二：线程池 OOM，JVM 不一定退出

```
public abstract void run ();
```
```
/**
* Dispatch an uncaught exception to the handler. This method is
* intended to be called only by the JVM. (将未被捕获的异常分发给处理器。这个方法只被 JVM
调用)
*/
private void dispatchUncaughtException (Throwable e) {
getUncaughtExceptionHandler (). uncaughtException (this, e);
}
```
```
public class ThreadGroup implements Thread. UncaughtExceptionHandler {}
```

###### 实例一：线程 OOM，JVM 不一定退出

thread-0 线程抛出 OOM 后线程结束后，main 线程依旧会循环打印"我还行....."。


线程中发生 OOM 异常，和发生其他异常一样，只是那个线程终止了，但是不影响其他线程，

thread-0 线程线程 OOM，也不会导致 JVM 退出。

###### 实例二：线程池 OOM，JVM 不一定退出

```
class OOMThreadPool {
private final Byte[] toLeak;
```
```
public OOMThreadPool () {
toLeak = new Byte[1024 * 1024];
}
```
```
static final Thread[] t = new Thread[1];
static ThreadPoolExecutor threadPool = new ThreadPoolExecutor (1, 1, 5,
TimeUnit. SECONDS, new ArrayBlockingQueue<>(9),
```
```
new ThreadFactory () {
public Thread newThread (Runnable r) {
t[0] = new Thread (r);
t[0]. setDaemon (false);
t[0]. setPriority (Thread. NORM_PRIORITY);
t[0]. setUncaughtExceptionHandler (new
Thread.UncaughtExceptionHandler () {
@Override
public void uncaughtException (Thread t, Throwable e) {
e.printStackTrace ();
System.out.println (t.getName () + " 的状态：" +
t.getState ());
System.out.println ("这里是没有捕获的处理 ====> " +
t.getId () + "==> " + e.getLocalizedMessage ());
}
});
return t[0];
}
},
new ThreadPoolExecutor.DiscardOldestPolicy ()) {
```
```
@Override
protected void afterExecute (Runnable r, Throwable t) {
System.out.println (Thread.currentThread (). getName () + " 任务执行完成，
但是线程不会结束");
if (null != t) {
System.out.println (Thread.currentThread (). getName () + "任务异常
了");
t.printStackTrace ();
```
```
}
```
```
}
};
```
```
// 为快速发生 oom，设置堆大小; VM args: -Xms 10 m -Xmx 10 m
public static void main (String[] args) throws InterruptedException {
List<OOMThreadPool> list = new LinkedList<>();
```

在线程池中，thread-0 线程抛出 OOM 后线程的 task 任务结束，thread-0 线程并没有结束，而是可以接
收新的任务。当然，main 线程依旧会循环打印"我还行....."。

啰嗦一下：在线程池中，thread-0 线程当前的 task 任务结束了，但是线程没有结束，还是可以执行新
任务的。

```
Runnable target = () -> {
System.out.println (Thread.currentThread (). getName () + " 开始了");
try {
while (true) {
list.add (new OOMThreadPool ());
}
}catch ( Throwable throwable)
{
throwable.printStackTrace ();
}
```
```
};
```
```
threadPool.submit (target);
while (true) {
System.out.println (Thread.currentThread (). getName () + " 我还行...");
System.out.println (t[0]. getName () + " 的状态：" + t[0]. getState ());
Thread.sleep (1000 L);
}
}
}
```

###### OOM 与 JVM 退出的关系

什么时候发生 OOM、JVM 才退出呢？

```
场景 1 ：所有的非守护线程由于申请不到内存而 OOM，所有非守护线程退出，JVM 退出，这个属于
主动退出
```
OOM 的发生表示了此刻 JVM 堆内存告罄，不能分配出更多的资源，或者 GC 回收效率不可观。

一个线程的 OOM，在一定程度的并发下，若此时其他线程（含非守护线程）也需要申请堆内存，那么
其他线程也会因为申请不到内存而 OOM，甚至连锁反应导致整个 JVM 的退出。

```
场景 1 ：OOM 溢出，说明内存耗尽，如果操作系统内存耗尽，就会发生 OOM killer (Out Of
Memory killer)，干掉 JVM 进程，导致被动退出
```
Linux 内核有个机制叫 OOM killer (Out Of Memory killer)，该机制会监控那些占用内存过大，尤其是瞬
间占用内存很快的进程，然后防止内存耗尽而自动把该进程杀掉。内核检测到系统内存不足、挑选并杀
掉某个进程的过程可以参考内核源代码 linux/mm/oom_kill. c，当系统内存不足的时候，
out_of_memory () 被触发，然后调用 select_bad_process () 选择一个”bad”进程杀掉。如何判断和选择一
个”bad 进程呢？linux 选择”bad”进程是通过调用 oom_badness ()，挑选的算法和想法都很简单很朴实：
最 bad 的那个进程就是那个最占用内存的进程。

#### 说在最后

OOM 相关面试题，是非常常见的面试题。

以上的答案，如果大家能对答如流，如数家珍，基本上面试官会被你震惊到、吸引到。

最终， **让面试官爱到 “不能自已、口水直流”** 。 offer，也就来了。

学习过程中，如果有啥问题，大家可以来找 40 岁老架构师尼恩交流。

## 面试真题：你们用什么版本的 jdk？聊一聊不

## 同版本的 jdk 的新特性？

#### 说在前面

在 40 岁老架构师尼恩的 **读者交流群** (50+) 中，最近有小伙伴拿到了一线互联网企业如美团、拼多多、极
兔、有赞、希音的面试资格，遇到一几个很重要的面试题：


```
你们用什么版本的 jdk？
为啥你们还在用 java 8？
聊一聊不同版本的 jdk 的新特性？
Oracle JDK 和 OpenJDK 的对比
......
```
这里尼恩给大家做一下系统化、体系化的梳理，使得大家可以充分展示一下大家雄厚的 “技术肌肉”， **让
面试官爱到 “不能自已、口水直流”** 。

也一并把这个题目以及参考答案，收入咱们的《尼恩 Java 面试宝典》V 87 版本，供后面的小伙伴参考，
提升大家的 3 高架构、设计、开发水平。

```
最新《尼恩架构笔记》《尼恩高并发三部曲》《尼恩 Java 面试宝典》的 PDF 文件，请关注公众号
【技术自由圈】领取，暗号：领电子书
```
#### Oracle 的 JAVA 收费新规则：一人使用全员买单

2023 年 1 月 23 日，甲骨文公司公布名为《 Oracle Java SE Universal Subscription Global Price List 》
的文件，对 Java SE 制定了新的收费标准。

Oracle 表示，全新的 Java SE 收费标准将基于 **企业员工的总数进行收费，**

**注意，是员工总数，而不是企业中使用 Java 的开发人员数量** 。

简单来说就是： **1 人使用，全员买单** 。

文件中，甲骨文公司在新发布订阅文件中将 Java SE 收费标准划分为 8 个不同档位：

```
总员工数量 1-999：$15 /人/月
总员工数量 1000-2999：$12 /人/月
总员工数量 3000-9999：$10.5 /人/月
总员工数量 10000-19999：$8.25 /人/月
总员工数量 20000-29999：$6.75 /人/月
总员工数量 30000-39999：$5.70 /人/月
总员工数量 40000-49999：$5.25 /人/月
总员工数量 50000+：没有给出具体定价，需要详询甲骨文。
```
按照文件估计，我们假设有一家公司，员工总数为 500 人（包括全职和兼职员工以及代理、顾问和承
包商），

在 500 人中有 20 个 Java 开发人员。

按照旧模式的收费标准，每年将被收取 20 X 25 X 12 = 6000 美元（旧版本付费按 25 美元/月来举
例）；

按照新模式的收费标准，每年将被收取 500 X 15 X 12 = 90000 美元。

由此可见，一个在 500 人的公司每年在 Java SE 上的支付成本将上升 15 倍。

简单推算，一个 5 W 人的公司，假设还是 20 个 Java 开发人员，每年提升 1500 倍，费用要到 900 W 美
元， 5000 千多人民币。

**像阿里、华为这种员工人数在 20 W 人以上的公司** ，每年要给 Oracle 纳贡 **2 个亿** 以上。

更要命的是，那种规模庞大、人数众多的 **外包公司** ，也是需要大量纳贡的。外包公司本来利润微薄，这
次全部要给 Oracle 纳贡了。


据估算，全球约有 150 亿台设备在运行 Java™。约 900 万 Java 程序员.... 看起来，oracle 可以狠狠的撸
一波了。

#### JDK 各大版本的收费情况

打开 oracle jdk 的下载链接，尼恩给大家展示一下，各大 JDK 版本的收费情况

Java Archive | Oracle

一个小小的例外情况：oracle 官方曾经发过通知，说 JDK 17 可以免费商用，但是那是有时间限制的，时
间截止到 2024 年 9 月，共计 3 年。

这其实又是一个坑，为啥？如果用了 JDK 17，就可能回不去了

所以，尼恩这里把 JDK 17 归类为潜在收费版本，最终还是要费用的，所以，JDK 17 其实还是收费版本。

#### 最后的晚餐：jdk-8 u 202 免费版本

从图中可以看到，Java 8 及之前的版本都是免费， jdk-8 u 202 所有 jdk 中最后一个免费的版本，jdk-
8 u 202 就是最后的晚餐。

那是不是我们就下载 jdk-8 u 202 呢？并不是， **而是他的前一个版本，也就是 jdk-8 u 201** 。

这就是另一个知识要点。这也是 jdk 版本的一个小常识

```
Java SE 重要补丁更新 (CPU) 包含安全漏洞修复和重要漏洞修复。Java SE CPU 版本号采用奇数编
号。
Java SE 补丁集更新 (PSU) 包含相应 CPU 中的所有修复以及其他非重要修复。
```
Java SE CPU 版本号采用 **奇数** 编号。反过来说： **奇数** 编号版本，包含了安全漏洞修复和重要漏洞修复。

并且， **Oracle 官方也是强烈建议所有 Java SE 用户及时升级到最新的 CPU 版本。**


换句话说，oracle 官方推荐大家下载奇数编号的版本。

所以说，jdk-8 u 202 之前的那个版本，也就是 jdk-8 u 201 是“天选之子”，

所以说，jdk-8 u 201 天选打工人的最爱

天选之子的地址如下：

Java Archive Downloads - Java SE 8 (oracle. com)

#### jdk-8 u 202 之后的版本，到底谁来收钱？

jdk-8 u 202 之后的版本是收费版本，但是也没有支付链接，大家从官方也能下载的，不用付款也能安装
的。

安装完了之后，大家直接用，也是没人来收钱的。

于是，大家对收费版本有一种误解： **不用白不用，反正没人管** 。

尼恩只能说：呵呵。用吧。

如果大胆一点，甚至可以像 Google 一样，敞开了用。

要知道，世界级大厂 Google 也就是不付钱，直接敞开了用 jdk。

没有过多久，最后收到的法院一张超级大传票：“因为在 Android 中用了 Java，Oracle 向 Google 索赔 **88
亿美元** ”

所以，大家如果敞开了用 JDK 收费版本，就得要像 Google 一样，有着雄厚的家底，最好就想 google 一
样：有 **超过 88 亿美元** 的雄厚家底。然后，等着法院的超级大传票.

如果没有 **超过 88 亿美元** 的雄厚家底，那就最好不敞着用哈。

其实，除了 JDK 收费版本，到国外一些大公司的软件都能下载安装使用，比如 IBM、Oracle 都可以在官
网上下载，

正常情况下，是要购买他们的 lisence 的，一般是按用户量收费或者按 CPU 核数收费。

那么，为什么他们没有来找你，两个原因：


```
第一，养猪要养肥后才杀，公司大了，肥了就有人联系你了；
第二, 打这种跨国官司也有成本的。如果收费还不够官司的成本，他们也不急于收钱。
```
#### 版本任你发，我用 java 8

从 1996 年初 JDK 1.0 发布到现在已经二十多年了， Oracle 的版本发布已经形成了一个规律：

```
Oracle 每隔 6 个月就会有一个短期维护版本 (non-LTS) 发布出来；
然后每隔 2 年，就会发布一款得到 8 年长期支持维护（LTS）的 JDK 版本，
```
所谓 LTS 版本就是可以得到至少八年产品支持的版本。

到目前为止，有四个 LTS 版本，JDK 7、JDK 8、JDK 11、JDK 17，下一个 LTS 版本是 JDK 21。

最新一个版本已经到 JDK 20，JDK 17 是最新的一个 LTS (Long-Term Support) 版本。

**“版本任你发，我用 java 8”**

虽然 JDK 疯狂升级，但是 java 社区一直都是 “版本任你发，我用 java 8”，

不管哪个版本发出来，很少有人愿意升级，不升级的原因，就是大家有两个大的担忧：

```
第一个大担忧：收费的达摩克斯之剑
第二个大担忧：使用新版本容易踩坑
```
那么，通过市场调查，来具体看看，大家的 Jdk 版本如何选择?

JDK 的版本首选 LTS 版本。根据调查，各个 jdk LTS 版本的近三年的使用情况如下图：

jdk LTS 版本增长情况

从这份结果可以看出，很多公司要么用了 openjdk，如果是盲目用 Oracle JDK 新版本的，就慢慢被养成
一条被宰的肥猪了。


2023 年， 56%的公司使用 Java 11 ，呵呵，这些公司估计得找 oracle 缴费了。如果没有缴费，并且有
只要一个服务器使用了 oracle jdk 11，将来的某一天，就等着 oracle 公司发过来的巨大额度的收费清单
吧

另外 %9 的公司，使用了 Java 17，这些公司在时间截止到 2024 年 9 月，共计 3 年，是免费的。从明年开
始，如果没有主动缴费，并且有只要一个服务器使用了 oracle jdk 17，呵呵，将来的某一天，同样就等
着 oracle 公司发过来的巨大额度的收费清单吧

用 openjdk 固然能避免收费，但是用了就回不去了。

尼恩通过后面的分析给大家证明：

**jdk 新版本的 250 个特性的性能提升，指标不治本、外层挠痒痒，根本没啥用。升了还不如别升，jdk 8
更稳定。**

#### 著名中间件如 spring 依赖 jdk 17

虽然企业不能轻易升级，但是 oracle 有很多好队友，小跟班，他们带节奏，跟着升，怎么办？

这些 oracle 小跟班，就是各大开源软件厂商

不知道这些 oracle 小跟班，是不是收到 oracle 的投资，总之就是，现在各开源软件前后呼应的追赶 Jdk 新
版本，也正在全面拥抱 jdk 17.

另外，spring 6 和 springboot 3 相继推出直接要求最低依赖是 jdk 17，spring 和 springboot 的版本升级
强制要求 JDK 版本升级 17 。

如果某些中间件，一定要用 java 17，然后咱们主要的 java 版本，是 java 8 或者 java 11，怎么办？

```
使用对于的免费版本，也就是 OpenJDK 版本，能用阿里的就阿里的，不行就是 Oracle 的 OpenJDK
使用容器的方式，容器里边用免费的 OpenJDK 版本
```
比如，尼恩在讲云原生架构的时候，发现 Jenkins 就是依赖了 jdk 11，导致尼恩作为一个 Java 8 的铁杆
用户，最终只能通过容器的方案绕过安装 Java 11，去通过容器安装 Jenkins。

#### 免费的 OpenJDK


虽然 Oracle JDK 是 Java 官方 Oracle 公司基于 OpenJDK 构建，收费。

除了官方的 Oracle JDK，大家可以使用开源的 OpenJDK。这个是免费的。

###### 如何选择免费的 OpenJDK

要注意的是，要关注第三方 openJDK 的稳定性及可用度。

一般来说，建议使用经历过大规模生产历练、长时间稳定运行、有强大的技术团队支撑的版本。

比如建议是阿里的 Dragonwell JDK。

只是，阿里的 Dragonwell JDK 只适配 Java 8 和 Java 11，没有其他的 JDK 版本的适配。

###### 主要的开源 OpenJDK 版本

接下来，看看主要的开源 OpenJDK 版本：

**1. OpenJDK**

OpenJDK 是 JDK 的社区版，社区主要由 Oracle 主导，免费。

OpenJDK

Java 的开源版本 OpenJDK，OpenJDK 目前由 Oracle 主导，汇聚了社区的力量进行开发，IBM，红帽等企
业都有参与。

使用 Oracle 的 openJDK，需要及时跟进版本更新，可能需要比较高的开发迁移能力。

另外，可以使用第三方发布的 openJDK，不过，取决于三方 openJDK 的稳定性及可用度。

**2. 阿里巴巴 Dragonwell JDK**

Alibaba Dragonwell 是阿里巴巴公司基于 OpenJDK 的构建，免费。

Dragonwell-Java 开发工具包 (OpenJDK) - 阿里云 (aliyun. com)

**3. 腾讯 Kona JDK**

腾讯 Kona (Tencent Kona) 是腾讯公司基于 OpenJDK 的构建，免费。


腾讯开源的 TencentKona 8 是腾讯基于 OpenJDK 的一个免费的、生产级别的开源产品。

Kona 是腾讯内部默认 JDK，针对超大规模的大数据、机器学习以及云计算环境做了特别的优化。

**4. 华为毕昇 JDK**

华为毕昇 JDK 是华为公司基于 OpenJDK 的构建，免费

**5. Eclipse Temurin**

Eclipse Temurin (曾用名：AdoptOpenJDK) 是 Eclipse 基金会基于 OpenJDK 的构建，支持 Oracle 公司的
HotSpot 虚拟机和 Eclipse 基金会的 OpenJ 9 虚拟机，免费。

**6. Azul Zulu OpenJDK**

Azul Zulu OpenJDK 是总部位于加州桑尼维尔的 Azul 公司基于 OpenJDK 的构建，免费。

**7. SAP SapMachine**

SAP SapMachine 是 OpenJDK 项目的贡献者之一 SAP 公司基于 OpenJDK 的构建，免费。

**8. Red Hat build of OpenJDK**

Red Hat build of OpenJDK 是 Red Hat (红帽子) 公司基于 OpenJDK 的构建，免费。

**9. Microsoft Build of OpenJDK**

Microsoft Build of OpenJDK 是微软公司基于 OpenJDK 的构建，免费。

#### java 性能不高的核心原因

java 性能不高的原因很多，非常非常多，很多人通过博客的形式，从不同的维度进行各种分析

但是尼恩在这里，浓缩再浓缩，归纳再归纳，

本质上 java 性能不高的核心原因，有两个本质的架构缺陷，具体如下

```
核心原因之一：一对一线程架构缺陷
核心原因之二：二元运行架构缺陷
```
一个一个来看吧。

**核心原因之一：一对一线程架构缺陷**

用户线程和内核线程一对一绑定，导致多线程场景用户态和内核态频繁切换。

和 Java 相比，GO 的线程架构就优越得多，去掉了用户线程和内核线程一对一绑定。

GO 的业务线程的切换以及线程操作，发生在用户态，所以不需要系统调用，省去了大量的系统调用开
销和用户态和内核态频繁切换开销。

**核心原因之二：二元运行架构缺陷**

为了跨平台，Java 的执行架构进行了彻底的解耦，将一元的二进制程序，解耦为二元运行架构，包括一
份 JVM 程序和一份二进制业务程序。

Java 将执行字节码程序的程序进行独立，独立为 JVM。

并且，不同的操作系统，Java 提供不同的 JVM 实现版本，通过这种变 JVM 不变业务字节码的方式，实现
跨平台。


不同的平台，使用同一份字节码业务程序，从而实现： **一次编译，到处运行** ，最终完成业务代码的
跨平台执行。

Java 二元的运行架构，实现了： **跨平台执行** 。然而，任何事情都是双面的， Java 二元的运行架构的有一
个大的缺陷： **运行速度慢、启动速度慢** 。

**运行速度慢的根本原因：** 主要是字节码还不是机器码，字节码需要解释执行。

那么，JVM 如何提升运行速度呢？通过进行热点字节码编译成为二进制机器码的方式，进行不断的优化
进行不断的性能提升，运行的速度也有质的飞越。 **运行速度慢慢慢得到了解决**

**但是，启动速度慢是一个巨大的硬伤，没法解决** 。Java 的 JVM 字节码执行程序和业务程序分离之后，
启动的时候，需要把大量的字节码文件，加载在内存，然后进行解释执行，或者预编译执行。Java 中
单个类的字节码文件的加载过程，需要进行大量的安全校验、符号解析、初始化等工作，是非常耗时
间的。 **一个 Java 应用可能涉及成百上千的 Java 类，这就是一个很长的时间周期** 。

在线上我们常常发现，一个 springboot 应用的启动过程要 10 s，甚至 30 s，这是一段非常长的时间周
期。

和 Java 相比，GO 不存在 Java 的这个问题，GO 的一元运行架构。

GO 的跨平台方式是跨平台编译，不同平台，编译出一份不同的可执行文件。GO 程序在执行的时候，
不存在 Java 的那种单个类文件的加载过程，哪怕成百上千的 GO 结构体，也是很短的时间内实现启动。

这使得在 Golang 中，程序的启动速度非常快，可以在数十毫秒内启动一个应用程序。

#### jdk 的迭代之路，并没有治本

接着，我们来简单看下，从 jdk 9 到 jdk 17 都有哪些新特性。

从 JDK 诞生到现在，其长期支持的版本主要有 JDK 7、JDK 8 、JDK 11 以及 JDK 17，JDK 17 将是继 Java
8 以来最重要的 LTS 版本，是 Java 社区八年努力的成果。

首先，我们看下 jdk 8 到 jdk 19 各版本新增特性的数量如下：

jdk 各版本新特性

从上图可以看到从 Java 8 到 Java 19 总共引入了超过 250 个新特性，其中 Java 9 中包含了 91 个新特
性，这是由于之前的发布周期较长所导致的，在应用新的发布模型后，各版本的新增特性数量都维持在
10 个左右的水平。

后面的内容，尼恩给大家列了 250 个新特性。


虽然新特性足够多，但是这些特性都是指标不治本，没有解决本质上 java 性能不高的核心原因，就是
没有解决这两个本质的架构缺陷：

```
核心原因之一：一对一线程架构缺陷
核心原因之二：二元运行架构缺陷
```
Java 当然想解决这个两个架构缺陷，但是这两个问题都是 JVM 里边核心的核心，牵一发而动全身的架
构。

总之，不论他们是没有魄力、或者他们是没有耐心，总之就是没有解决。所以，java 的版本升级，就是
指标不治本，没有质的飞跃。

既然如此，与其用新版本导致后面被 oracle 巨额收费，还不如用 java 8。

#### 3 高场景 Java 8 应用如何降本增效

Java 由于其最早的开放性，造就了他的最为活跃的开源社区，最为全面的开源生态。

用 Java 开发的应用，如果 **从 1 qps 一路成长，如果平滑升级到 1 亿 qps** ，而不去换语言的话，那么 java 是
最佳选择，为什么？ 很简单，java 生态体系中的工具链、中间件是最全的、最完善的。

但是，使用 java 的劣势是：单体服务性能低，比较耗费资源，如果要提供其他高性能语言一样的能力，
Java 需要做大量的横向扩展。

尼恩的《golang 学习圣经》里有一组实验数据：

```
尼恩通过 springcloud gateway 和 golang Bff 的对比测试，java 性能弱 8 倍。
尼恩也通过 dubbo rpc 和 dubbo-go RPC 的对比测试， java 性能弱 8 倍。
```
也就是说，要提供 golang 一样的能力，简单的测算， **Java 要提供 8 倍的服务器资源。**

3 高场景 Java 应用如何降本增效？

**很简单，就是取长补短，借助其他语言提升性能：**

```
没有 go 之前，在京东的架构中，大量的使用了 Nginx lua，也就是说，京东是 Java + Nginx lua
相结合的架构。
有了 go 之后，如果京东的重来，一定是大量的使用了 go，也就是说如果重来，京东一定是 Java +
go 相结合的架构。
```
现在很多的互联网公司，已经是 java +go 结合的架构，为啥这么说？

```
3 高+简单业务场景，用 go 提升性能
低并发场景或者负责业务场景，仍然使用 java
```
**所以，结论是：**

**说一千道一万，目前的技术选择还是死守 Java 8 ，利用 golang 补齐 Java 的性能短板。**

毕竟 java 8 是那么的稳定，那么的稳若磐石。

未来，Java +Go 架构将会越来越普遍，主要的原因有两个：

```
go 的学习成本低：具体可以参考尼恩的《go 学习圣经》，java 高手一周可以掌握
Java +Go 结合起来，才是最大的降本增效：使用 go 是节省服务器成本，使用 java 是节省造轮子成
本
```
站在 Java +Go 架构这个大的架构下，已经不依赖 java 的版本升带来大的性能飞越。

**咱们之前的架构师 Java + Lua，未来的架构是 Java+ GO。**


**Java 的版本，依然就是 8 ，免去被收取天价授权费的烦恼。**

所以，不用担心 Java 版本怎么升级。Oracle 爱怎么升级，就让他升级去吧。

#### 附录：从 jdk 9 到 jdk 20（ 2023 年 3 月）的升级过程

###### jdk 9（ 2017 年 9 月）

java 9 提供了超过 150 项新功能特性，包括备受期待的模块化系统、可交互的 REPL 工具：JShell，JDK
编译工具，Java 公共 API 和私有代码，以及安全增强、扩展提升、性能管理改善等。

可以说 Java 9 是一个庞大的系统工程，完全做了一个整体改变。

新特性主要有以下几个：

```
jdk 和 jre 的改变
Java 平台模块系统
Jshell 集合、Stream 和 Optional
进程 API
平台日志 API 和服务
反应式流 （ Reactive Streams ）
变量句柄
改进方法句柄（Method Handle）
并发
Nashorn
I/O 流新特性
改进应用安全性能
用户界面
统一 JVM 日志
```
**重要特性：主要是 API 的优化，如支持 HTTP 2 的 Client API、JVM 采用 G 1 为默认垃圾收集器。**

**jdk 和 jre 的改变**

在 jdk SE 9 之前，jdk 构建系统用于生成两种类型的运行时映射- **JRE** (java 运行时环境) 和 **JDK** (java 开发工
具包)。

JRE 是 java SE 平台的完整实现，JDK 包含了 JRE 和开发工具和类库。

java SE 9 之前的 JDK 文件目录


jdk 9 之前的目录

目录说明：

```
bin 目录用于包含命令行开发和调试工具，如 javac，jar 和 javadoc。它还用于包含 Java 命令来启动
Java 应用程序。
include 目录包含在编译本地代码时使用的 C/C++头文件。
lib 目录包含 JDK 工具的几个 JAR 和其他类型的文件。它有一个 tools. jar 文件，其中包含 javac 编译器
的 Java 类。
jre\bin 目录包含基本命令，如 Java 命令。在 Windows 平台上，它包含系统的运行时动态链接库
（DLL）
jre\lib 目录包含用户可编辑的配置文件，如 .properties 和 .policy 文件。包含几个 JAR。rt. jar 文
件包含运行时的 Java 类和资源文件。
```
Java SE 9 调整了 JDK 的目录层次结构如下图所示：

jdk 9 以后目录

最大的区别： **从 jdk 9 开始删除了 JDK 和 JRE 之间的区别，在 jdk 9 中，没有名为 jre 的目录。**

目录说明：

```
bin 目录包含所有命令。在 Windows 平台上，它继续包含系统的运行时动态链接库。
conf 目录包含用户可编辑的配置文件，例如以前位于 jre\lib 目录中的. properties 和. policy 文件。
include 目录包含要在以前编译本地代码时使用的 C/C++头文件。它只存在于 JDK 中。
jmods 目录包含 JMOD 格式的平台模块。创建自定义运行时映像时需要它。它只存在于 JDK 中。
legal 目录包含法律声明。
lib 目录包含非 Windows 平台上的动态链接本地库。其子目录和文件不应由开发人员直接编辑或使
用。
```

**访问资源的优化**

**在 jdk 9 之前** ，可以从类路径上的任何 JAR 访问资源。在 java 代码中，资源由资源名称标识，资源名称是
由斜线（/）分隔的一串字符串。对于存储在 JAR 中的资源，资源名称仅仅是存储在 JAR 中的文件的路
径。

例如，存储在 rt. jar 中的 java. lang 包中的 Object. class 文件, 它也是一个资源，其资源名称是
java/lang/Object. class。

可以使用以下两个类中的方法来访问资源：

```
java. lang. Class
java. lang. ClassLoader
```
资源由 ClassLoader 定位。一个 Class 代理中的资源寻找方法到它的 ClassLoader。

在两个类中有两种不同的命名实例方法：

（ 1 ）URL getResource (String name)

（ 2 ）InputStream getResourceAsStream (String name)

两种方法都会以相同的方式找到资源。它们的差异仅在于返回类型。第一个方法返回一个 URL，而第二
个方法返回一个 InputStream。第二种方法相当于调用第一种方法，然后在返回的 URL 对象上调用
openStream ()。

ClassLoader 类包含三个额外的查找资源的静态方法：

在考虑使用哪一种方式获取资源之前，先要弄清楚获取的资源是哪一种资源。

资源可以分为两种类型，如下：

```
系统资源 ：系统资源是在 bootstrap 类路径，扩展目录中的 JAR 和应用程序类路径中找到的资源。
非系统资源 ：可以存储在除路径之外的位置，例如在特定目录，网络上或数据库中。
```
getSystemResource () 方法使用应用程序类加载程序找到一个资源，委托给它的父类，它是扩展类加
载器，扩展类加载器又委托给它的父类（引导类加载器）。

如果你的应用程序是独立的应用程序，并且它只使用三个内置的 JDK 类加载器，getSystemResource*
() 的静态方法是最佳选择。它将在类路径中找到所有资源，包括运行时映像中的资源，如 rt. jar 文件。

如果你的应用程序是在浏览器中运行的小程序，或在应用程序服务器和 Web 服务器中运行的企业应用程
序，则应使用 getResource ()，它可以使用特定的类加载器来查找资源。

**从 jdk 9 开始** ，类和资源封装在模块中。

在第一次尝试中，JDK 9 设计人员强制执行模块封装规则，模块中的资源必须对该模块是私有的，因此
它们只能在该模块内的代码中访问。虽然这个规则在理论上看起来很好，但是对于跨模块共享资源的框
架和加载的类文件作为来自其他模块的资源，就会带来问题。为了有限地访问模块中的资源，做了一些
妥协，但是仍然强制执行模块的封装。

JDK 9 包含三类资源查找方法：

```
//(1) 返回找到的第一个资源的 URL
static URL getSystemResource (String name);
//(2) 返回找到的第一个资源的 InputStream
static InputStream getSystemResourceAsStream (String name)
//(3) 返回使用指定的资源名称找到的所有资源的 URL 枚举
static Enumeration<URL> getSystemResources (String name)
```

Class 和 ClassLoader 类没新增任何新的方法。

Module 类包含一个 getResourceAsStream (String name) 方法，如果找到该资源，返回一个
InputStream；否则返回 null。

**模块化**

java 从 1995 年发布，到现在 java 已经发展了快 30 年，但是 java 与相关生态在不断丰富的同时也暴露除了
很多问题：

```
java 运行环境的膨胀与臃肿。在 JVM 启动的时候，至少会有 30 ～60 MB 的内存加载，主要原因是
JVM 需要加载 rt. jar，不管其中的类是否被 classloader 加载，第一步整个 jar 都会被 JVM 加载到内存
中。
代码库越来越大，创建复杂。盘根错节的意大利面条式代码的几率呈指数级的增长。不同版本的
类库交叉依赖导致让人头疼的问题，这些都阻碍了 Java 开发和运行效率的提升。
每一个公共类都可以被类路径之下任何其它的公共类所访问到，这样就会导致无意中使用了并不想
被公开访问的 API。
类路径本身也存在问题 : 无法知晓所需要的 JAR 是否是全都存在还是部分存在。
```
受兼容性、代码库庞大等问题的掣肘，想要对 java 进行大刀阔斧的革新是越来越困难，

Jigsaw 从 Java 7 阶段就开始筹备，Java 8 阶段进行了大量工作，最终在 Java 9 里落地，有一种千呼万
唤始出来的意味。

```
提示：
```
```
Jigsaw 的中文直译为：
```
```
拼图 ; 线锯; 拼板玩具; 钢丝锯; 谜团; 镂花锯; 神秘莫测的事物 (或状况);
```
Jigsaw 是 OpenJDK 项目下的一个子项目，旨在为 Java SE 平台设计、实现一个标准的模块系统，并应用到
该平台和 JDK 中。该项目由 Java 编程语言编译器小组赞助。

提及 Java 9，最大的功能莫过于 Jigsaw 项目下的核心 Java 平台模块化系统（JPMS，Java Platform
Module System) 。Jigsaw 本身是一项很有野心的项目，它的目标是改进 Java SE 平台，使其可以适应
不同大小的计算设备；改进其安全性，可维护性，提高性能；简化各种类库和大型应用的开发和维护，
包括 JDK 本身的模块化。

JPMS（Java Platform Module System）是 Java 9 发行版的核心亮点。 **JPMS 似于 OSGI 框架的功能** ，模
块之间存在相互的依赖关系，可以导出一个公共的 API，并且隐藏实现的细节。

JPMS 包括为编写模块化应用程序提供支持，以及将 JDK 源代码模块化。JDK 9 附带了大约 92 个模块（在
GA 版本中可以进行更改）。其中 JSR 376 Java 平台模块化系统（JPMS，Java Platform Module
System）作为 Jigsaw 项目的核心，其主体部分被分解成 6 个 JEP（JDK Enhancement Proposals）。

Java 9 Module System 有一个"java. base"模块，它被称为基本模块。它是一个独立的模块，不依赖于任
何其他模块。默认情况下，所有其他模块都依赖于"java. base"。

在 java 模块化编程中，一个模块通常只是一个 jar 文件，在根目录下有一个文件 module-info. class。

如果需要使用模块，请将 jar 文件包含到 modulepath 而不是 classpath. 添加到类路径的模块化 jar 文件
是普通的 jar 文件，module-info. class 文件将被忽略。

典型的 module-info. java 类如下：

```
java. lang. Class
java. lang. ClassLoader
java. lang. Module
```

其项目结构如下：

本质上将，模块其实就是 package 外再裹一层，用模块来管理各个 package，通过声明某个 package 暴
露，不声明默认就是隐藏。

因此，模块化使得代码组织上更安全，因为它可以指定哪些部分可以暴露，哪些部分隐藏。

模块化（以 Java 平台模块系统的形式）将 JDK 分成一组模块，可以在编译时，运行时或者构建时进行
组合。其实现目标如下：

```
主要目的在于减少内存的开销
只须必要模块，而非全部 JDK 模块，可简化各种类库和大型应用的开发和维护
改进 Java SE 平台，使其可以适应不同大小的计算设备
改进其安全性，可维护性，提高性能
```
Java 发展到 9 之后，整个 JDK 的产品形态发生了一个很大的变化，从一个大的单体应用，作了一定的解
耦，

```
module jdk 9. client {
requires jdk 9. test;
}
```

模块化解耦之后，JMC、OpenJFX 等以软件包的形式独立于 JDK 之外，Oracle 也将其商业特性都开源了
出来，所以 Oracle JDK 9 和 OpenJDK 9 仅存在 License 的不同。

**JShell**

Python 和 Scala 之类的语言早就有交互式编程环境 REPL（read - evaluate - print - loop），以交互式
的方式对语句和表达式进行求值。

开发者只需要输入一些代码，就可以在编译前获得对程序的反馈。而之前的 Java 版本要想执行代码，
必须创建文件、声明类、提供测试方法方可实现。

Java 9 中终于拥有了 REPL 工具：JShell。利用 JShell 在没有创建类的情况下直接声明变量，计算表达
式，执行语句。即开发时可以在命令行里直接运行 Java 的代码，而无需创建 Java 文件，无需跟人解释
public static void main (String[] args) 这句废话。

JShell 也可以从文件中加载语句或者将语句保存到文件中。

JShell 也可以是 Tab 键进行自动补全和自动添加分号。


**语法糖**

**接口的私有方法**

在 jdk 8 中规定了接口中的方法除了抽象方法之外，还可以定义静态方法和默认的方法。在一定程度上，
扩展了接口的功能，这个时候的接口更像一个抽象类。

在 jdk 9 中，接口就更加的灵活和强大，连方法的访问权限修饰符都可以声明为 private 的了，此时方法
将不会成为你对外暴露的 API 的一部分。

```
public interface Animal {
//jdk 7 : 只能声明全局常量 (public static final) 和抽象方法 (public abstract)
void setAnimalName (String name);
```
```
// jdk 8 : 声明静态方法和默认方法
static void setAge (int age){
System.out.println ("age =" + age);
```
```
}
default void setColor (String color){
getWeight ();
System.out.println ("color =" + color);
}
```
```
//jdk 9
private void getWeight (){
System.out.println ("获取 animal 的体重");
}
}
```

执行结果如下：

**<> 操作符使用升级**

在 jdk 9 之前，匿名实现类使用<>操作符会报错，如下：

在 jdk 9 中使用可以正常编译通过：

**try 语句**

在 jdk 8 之前，我们习惯使用如下方式关闭资源：

```
public class Dog implements Animal{
@Override
public void setAnimalName (String name) {
System.out.println ("name = " + name);
}
}
```
```
//测试单元
@Test
public void DogNameTest (){
Dog dog = new Dog ();
dog.setAnimalName ("黑妞");
dog.setColor ("red");
}
```
```
public void readFile () throws FileNotFoundException {
```

Java 8 中，可以实现资源的自动关闭，但是要求执行后必须关闭的所有资源必须在 try 子句中初始化，
否则编译不通过。如下例所示：

Java 9 中，用资源语句编写 try 将更容易，我们可以在 try 子句中使用已经初始化过的资源，此时的资
源是 final 的：

**下划线_使用限制**

在 jdk 8 中，标识符可以独立使用_命名，如下：

```
FileReader fr = null;
BufferedReader br = null;
try{
fr = new FileReader ("d:/input. txt");
br = new BufferedReader (fr);
String s = "";
while ((s = br.readLine ()) != null){
System.out.println (s);
}
} catch (IOException e) {
e.printStackTrace ();
}finally {
try {
br.close ();
fr.close ();
} catch (IOException e) {
e.printStackTrace ();
}
}
}
```
```
public void readFile () throws FileNotFoundException {
```
```
try (FileReader fr = new FileReader ("d:/input. txt"); BufferedReader br = new
BufferedReader (fr);){
String s = "";
while ((s = br.readLine ()) != null){
System.out.println (s);
}
} catch (IOException e) {
e.printStackTrace ();
}
}
```
```
public void readFile () throws FileNotFoundException {
FileReader fr = new FileReader ("d:/input. txt");
BufferedReader br = new BufferedReader (fr);
try ( fr ;br){
String s = "";
while ((s = br.readLine ()) != null){
System.out.println (s);
}
} catch (IOException e) {
e.printStackTrace ();
}
}
```

在 Java 9 中规定 _ 不再可以单独命名标识符了，如果使用，会报错, 如下

**String 存储结构变更**

String 类的当前实现将字符存储在字符数组，每个字符使用两个字节（ 16 位）。

数据从许多不同的应用程序收集的数据表明字符串是堆使用的主要组成部分，而且最重要的是对象仅包
含拉丁字母 1 。这样的角色只需要一个字节的存储空间，因此占内部字符数组空间的一半许多这样的字
符串对象将被闲置。

jdk 9 之前，String 使用 char[]来存储，如下：

从 jdk 9 开始，使用 byte[]加上编码标记，节约了一些空间：

与字符串相关的类，如 AbstractStringBuilder、StringBuilder、StringBuffer 底层也更新为使用 byte[]
存储，

**快速创建只读集合**

在 jdk 9 之前，要创建一个只读、不可改变的计划，必须构造和分配它，然后添加元素，最后包装成一个
不可修改的集合。

例如使用 Collections 提供的 unmodifiableList 方法可以创建只读、不可改变的 List 集合：代码如下：

```
String _ ="hello";
System.out.println (_);
```
```
As of Java 9 , '_' is a keyword, and may not be used as an identifier
```

jdk 9 给各个集合引入了 of () 静态方法，该方法代替 Collections. unmodifiableXXX 创建出只读、不可改
变的集合。

调用集合中静态方法 of ()，可以将不同数量的参数传输到此工厂方法中。此功能可用于 Set 和 List，也
可用于 Map 的类似形式。此时得到的集合，是不可变的：在创建后，继续添加元素到这些集合会导致
UnsupportedOperationException。

**增强的 Stream API**

Java 的 Steam API 是 Java 标准库最好的改进之一，让开发者能够快速运算，从而能够有效的利用数据
并行计算。

Java 8 提供的 Steam 能够利用多核架构实现声明式的数据处理。

在 Java 9 中，Stream API 变得更好，Stream 接口中添加了 4 个新的方法：dropWhile、takeWhile、
ofNullable，还有个 iterate 方法的新重载方法，可以让你提供一个 Predicate（判断条件）来指定什么
时候结束迭代。

除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。现在可以通过 Optional
的新方法 stream () 将一个 Optional 对象转换为一个（可能是空的）Stream 对象。

**takeWhile () 的使用**

用于从 Stream 中获取一部分数据，接收一个 Predicate 来进行选择。在有序的 Stream 中，takeWhile
碰到不符合元素时，把前面符合的元素返回。

```
public void test () {
List<String> namesList = new ArrayList <>();
//添加元素
namesList.add ("Joe");
namesList.add ("Bob");
namesList.add ("Bill");
//包装成一个不可修改的集合
namesList = Collections.unmodifiableList (namesList);
System.out.println (namesList);
}
```
```
List firsnamesList = List.of ("Joe", "Bob", "Bill");
```

执行结果：

找到不符合条件的元素后，停止寻找，虽然后面还有一些元素符合条件，也不会获取。

**dropWhile () 的使用**

dropWhile 的行为与 takeWhile 相反，碰到第一个不符合的元素后，把剩余的元素返回。

执行结果：

**ofNullable () 的使用**

Java 8 中 Stream 不能完全为 null，否则会报空指针异常。而 Java 9 中的 ofNullable 方法允许我们创
建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。

```
@Test
public void takeWhileTest (){
List<Integer> list = Arrays.asList ( 32 , 65 , 36 , 96 , 35 , 14 , 78 , 98 , 52 , 41 , 69 , 64 , 99 );
Stream<Integer> stream = list.stream ();
stream.takeWhile (x->x< 70 ). forEach (System. out::println);
System.out.println ();
}
```
```
32,65,36
```
```
@Test
public void dropWhileTest (){
List<Integer> list = Arrays.asList ( 32 , 65 , 36 , 96 , 35 , 14 , 78 , 98 , 52 , 41 , 69 , 64 , 99 );
Stream<Integer> stream = list.stream ();
stream.dropWhile (x->x< 50 ). forEach (System. out::println);
System.out.println ();
}
```
```
96,35,14,78,98,52,41,69,64,99
```
```
@Test
public void ofNullableTest () {
Stream<Integer> stream 1 = Stream.of ( 1 , 2 , 3 , null);
stream 1.forEach (System. out::println); //1, 2, 3, null
```
```
System.out.println ();
```
```
// 如果只有单个元素，此元素不能为 null. 否则报 NullPointerException
// Stream<Object> stream 2 = Stream.of (null);
```
```
// jdk 9：新增 ofNullable (T t)
Stream<String> stream 3 = Stream.ofNullable ("Tom");
System.out.println (stream 3.count ()); // 1
```
```
Stream<String> stream 4 = Stream.ofNullable (null);
System.out.println (stream 4.count ()); // 0
```

**iterator () 重载的使用**

Stream 的实例化有以下三种方式

（ 1 ）通过集合的 stream ()；

（ 2 ）通过数组工具类：Arrays.stream ()；

（ 3 ）Stream 中静态方法：of ()、iterator () / generate ()

**输出流直接转输入流**

InputStream 类中提供了 **transferTo ()** ,可以用来将数据直接传输到 OutputStream，这是在处理原始数
据流时非常常见的一种用法。

执行结果：

从执行结果可以看到 input. txt 与 out. txt 的内容一致。

**设置 G 1 为 JVM 默认垃圾收集器**

Java 9 移除了在 Java 8 中被废弃的垃圾回收器配置组合，同时把 G 1 设为默认的垃圾回收器实现。替代
了之前默认使用的 Parallel GC，

相对于 Parallel 来说，G 1 会在应用线程上做更多的事情，而 Parallel 几乎没有在应用线程上做任何事情，
它基本上完全依赖 GC 线程完成所有的内存管理。这意味着切换到 G 1 将会为应用线程带来额外的工作，
从而直接影响到应用的性能

###### jdk 10（ 2018 年 3 月）

jdk 10 的新特性主要有以下几个：

```
局部变量类型推断
整合 JDK 代码仓库
统一的垃圾回收接口
并行全垃圾回收器 G 1
应用程序类数据共享
线程-局部管控
移除 Native-Header 自动生成工具
```
```
}
```
```
@Test
public void transferToTest () throws IOException {
try (InputStream is = new FileInputStream ("src/main/resources/input. txt");
OutputStream os = new FileOutputStream ("out 1. txt")) {
//把输入流中的所有数据直接自动地复制到输出流中
is.transferTo (os);
} catch (IOException e) {
throw new RuntimeException (e);
}
}
```

```
额外的 Unicode 语言标签扩展
备用存储装置上的堆分配
基于 Java 的实验性 JIT 编译器
根证书认证
基于时间的版本发布模式
```
**重要特性：通过 var 关键字实现局部变量类型推断，使 Java 语言变成弱类型语言、JVM 的 G 1 垃圾回收由
单线程改成多线程并行处理，降低 G 1 的停顿时间。**

**局部变量类型推断（程序员的福音）**

许多流行的编程语言都已经支持某种形式的局部变量类型推断，如 C++ (auto), C# (var), Scala (var/val),
Go (declaration with :=) 等。

java 从 jdk 10 开始，也可以使用 var 作为局部变量类型推断标识符，仅适用于局部变量。

示例：

反编译 class 文件如下：

适合使用 var 场景如下：

（ 1 ）带有初始化程序的局部变量；

```
@Test
public void varTest (){
//根据推断为字符串类型
var str = "ABC";
//根据 10 L 推断 long 类型
var l = 10 L;
//根据 true 推断 boolean 类型
var flag = true;
//这里会推断 boolean 类型。 0 表示 false 非 0 表示 true
var flag 1 = 1 ;
// 推断 ArrayList<String>
var list = new ArrayList<String>();
// 推断 Stream<String>
var stream = list.stream ();
}
```
```
@Test
public void varTest () {
String str = "ABC";
long l = 10 L;
boolean flag = true;
int flag 1 = true;
ArrayList<String> list = new ArrayList ();
Stream<String> stream = list.stream ();
}
```

（ 2 ）for 循环，增强 for 循环索引；

（ 3 ）for 循环内部的局部变量;

var 不适用情况：

（ 1 ）初始值为 null；

（ 2 ）方法引用；

（ 3 ）Lambda 表达式；

（ 4 ）为数组静态数组化。

JDK 这么做的原因也是考虑到兼容的问题，兼容有些老系统使用了 var 作为变量名。

不用担心使用 var 会影响代码阅读，在鼠标放到由 var 声明的变量上时，IDEA 会显示它真实的类型。

var 的工作原理是在处理 var 时, 编译器先是查看表达式右边部分，并根据右边变量值的类型进行推断，
作为左边变量的类型，然后将该类型写入字节码当中。

**多线程并行 GC**

在 JDK 9 中 G 1 被选定为默认的垃圾收集器，G 1 的设计目标是避免发生 Full GC，由于 Full GC 较难产生所以
在设计之初只有 Young GC 和 Mixed GC 是并行的，而 Full GC 是单线程使用标记-清理-合并算法进行垃圾
回收。

G 1 只是避免发生 Full GC，在极端情况下，当 G 1 的回收速度相对于产生垃圾的速度不是足够快时，就会
发生 Full GC。

为了最大限度地减少 Full GC 造成的应用停顿的影响，在 JDK 10 中添加了 G 1 垃圾收集器并行 Full GC。

同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更
好的性能提升、更大的吞吐量。

```
//正确用法
var numsList = List.of ( 1 , 3 , 5 , 9 , 10 );
```
```
//错误用法
var str ;
```
```
for (var number : numbers) {
System.out.println (number);
}
```
```
for (var i = 0 ; i < numbers.size (); i++) {
System.out.println (numbers.get (i));
}
```

线程的数量可以由-XX: ParallelGCThreads 选项来控制，这个参数也用来控制 Young GC 和 Mixed GC 的线
程数。

**应用程序类数据（AppCDS）共享**

CDS 的全称是 Class-Data Sharing, CDS 的作用是让类可以被预处理放到一个归档文件中，后续 Java 程
序启动的时候可以直接带上这个归档文件，这样 JVM 可以直接将这个归档文件映射到内存中，以节约应
用启动的时间。

这个特性在 JDK 1.5 就开始引入, 但是 CDS 只能作用与 Boot Class Loader 加载的类，不能作用于 App
Class Loader 或者自定义的 Class Loader 加载的类。

在 JDK 10 中， CDS 扩展为 AppCDS，AppCDS 不止能够作用于 Boot Class Loader，App Class
Loader 和自定义的 Class Loader 也都能够起作用，进一步提高了应用启动性能。

**线程-局部管控**

这是在 JVM 内部相当低级别的更改，现在将允许在不运行全局虚拟机安全点的情况下实现线程回调。这
将使得停止单个线程变得可能和便宜，而不是只能启用或停止所有线程。

**基于 Java 的实验性 JIT 编译器 Graal**

Graal 是一个以 Java 为主要编程语言，面向 Java bytecode 的编译器。与用 C++ 实现的 C 1 及 C 2 相
比，它的模块化更加明显，也更加容易维护。Graal 既可以作为动态编译器，在运行时编译热点方法；
亦可以作为静态编译器，实现 AOT 编译。在 JDK 10 中，Graal 作为试验性 JIT compiler 一同发布

###### jdk 11（ 2018 年 9 月 LTS）

北京时间 2018 年 9 月 26 日，Oracle 官方宣布 Java 11 正式发布。

这是 Java 大版本周期变化后的第一个长期支持版本，也是继 jdk 8 版本发布之后第一个 LTS 版本。

从时间节点来看，jdk 11 的发布正好处于 jdk 8 免费更新到期的前夕，同时 jdk 9、jdk 10 也将陆续成为历
史版本。

jdk 11 的新特性主要有以下几个：

```
基于嵌套的访问控制
标准 HTTP Client 升级
Epsilon：低开销垃圾回收器
简化启动单个源代码文件的方法
用于 Lambda 参数的局部变量语法
低开销的 Heap Profiling
支持 TLS 1.3 协议
ZGC：可伸缩低延迟垃圾收集器
飞行记录器
动态类文件常量
```
**重要特性：对于 JDK 9 和 JDK 10 的完善，主要是对于 Stream、集合等 API 的增强、新增 ZGC 垃圾收集
器。**

**增加字符串处理方法**

jdk 11 增加了一系列的字符串处理方法：


**Files.readString () 和 Files.writeString ()**

在 jdk 11 中，Files 类中新增 readString 和 writeString 静态方法可以更容易读取和写入文件。

**Collection.toArray ()**

在 Java 11 之前，Collection 接口提供了两个 toArray () 方法来将集合转换为数组。

从 Java 11 开始，我们还可以编写以下代码：

此方法允许 Collection 类使用传递的数组构造函数引用创建必要大小的数组。

在 Java 11 中 Collection 接口新增了一个 default 方法，用 generator 创建一个空数组，然后调用现
有的 toArray () 方法：

```
// 判断字符串是否为空
" ".isBlank (); // true
// 去除字符串首尾空格
" JDK 11 ".strip ();// "JDK 11"
// 去除字符串首部空格
" JDK 11 ".stripLeading (); // "JDK 11 "
// 去除字符串尾部空格
" JDK 11 ".stripTrailing ();  // " JDK 11"
// 重复字符串多少次
"JDK 11 ".repeat ( 3 ); // "JDK 11 JDK 11 JDK 11 "
// 返回由行终止符分隔的字符串集合
"A\nB\nC".lines (). count ();  // 3
```
```
//把字符串写入文件
Path filePath = Files.writeString (Files.createTempFile (tempDir, "demo", ". txt"),
"Sample text");
```
```
//读取文件内容为字符串
String fileContent = Files.readString (filePath);
assertThat (fileContent). isEqualTo ("Sample text");
```
```
List<String> list = List.of ("foo", "bar", "baz");
//返回一个 Object 数组，由于类型擦除，在运行时不再知道 list 的类型信息。
Object[] strings 1 = list.toArray ();
```
```
//需要一个请求类型的数组。如果此数组至少与集合一样大，则元素将存储在此数组中 (strings 2 a)。否
则，将创建所需大小的新数组 (strings 2 b)。
String[] strings 2 a = list.toArray (new String[list.size ()]);
String[] strings 2 b = list.toArray (new String[ 0 ]);
```
```
String[] strings = list.toArray (String[]::new);
```

**Optional.isEmpty ()**

Optional 是一个容器对象，它可能包含也可能不包含非空值。

如果不存在任何值，则该对象被认为是空的。

isPresent () 方法如果值存在则返回 true，否则返回 false。

isEmpty () 方法与 isPresent () 方法相反，如果存在值则返回 false，否则返回 true

所以无论如何都不要写否定条件。适当时使用这两种方法中的任何一种。

**允许在隐式类型 lambda 表达式的参数中使用 var**

在理解隐形 lambda 表达式之前，我们先来看下显式类 lambda 表示式。

我们先来看个示例：

在实例中，显式表示指定了 lambda 参数 l 和 s 的数据类型，即 List 和 String。

但是，编译器也可以从上下文派生类型，因此也允许使用以下隐式类型表示法：

从 Java 11 开始，我们可以使用 Java 10 中引入的“var”关键字来代替显式类型：

**支持 TLS 1.3 协议**

```
default <T> T[] toArray (IntFunction<T[]> generator) {
return toArray (generator.apply ( 0 ));
}
```
```
public static void main (String[] args) {
String currentTime = null;
assertTrue (! Optional.ofNullable (currentTime). isPresent ());
assertTrue (Optional.ofNullable (currentTime). isEmpty ());
currentTime = "12:00 PM";
assertFalse (! Optional.ofNullable (currentTime). isPresent ());
assertFalse (Optional.ofNullable (currentTime). isEmpty ());
}
```
```
(List<String> l, String s) -> l.add (s);
```
```
(List<String> l, String s) -> l.add (s);
```
```
(var l, var s) -> l.add (s);
```

实现 TLS 协议 1.3 版本, 替换了之前版本中包含的 TLS，包括 TLS 1.2，同时还改进了其他 TLS 功能, 在安
全性和性能方面也做了很多提升。

**HTTP Client**

在 jdk 11 之前，使用原生 JDK 资源，例如通过 HTTP POST 发生数据需要大量代码。

在 JDK 11 中 Http Client API 得到了标准化的支持。使用 HTTPClient 编写更短且更优雅的代码如下：

```
public String post (String url, String data) throws IOException {
URL urlObj = new URL (url);
HttpURLConnection con = (HttpURLConnection) urlObj.openConnection ();
con.setRequestMethod ("POST");
con.setRequestProperty ("Content-Type", "application/json");
```
```
// Send data
con.setDoOutput (true);
try (OutputStream os = con.getOutputStream ()) {
byte[] input = data.getBytes (StandardCharsets. UTF_8);
os.write (input, 0 , input. length);
}
```
```
// Handle HTTP errors
if (con.getResponseCode () != 200 ) {
con.disconnect ();
throw new IOException ("HTTP response status: " + con.getResponseCode ());
}
```
```
// Read response
String body;
try (InputStreamReader isr = new InputStreamReader (con.getInputStream ());
BufferedReader br = new BufferedReader (isr)) {
body = br.lines (). collect (Collectors.joining ("n"));
}
con.disconnect ();
```
```
return body;
}
```
```
//方式一： 同步
public String post (String url, String data) throws IOException,
InterruptedException {
HttpClient client = HttpClient.newHttpClient ();
```
```
HttpRequest request =
HttpRequest.newBuilder ()
.uri (URI.create (url))
.header ("Content-Type", "application/json")
.POST (BodyPublishers.ofString (data))
.build ();
```
```
HttpResponse<String> response = client.send (request,
BodyHandlers.ofString ());
```
```
if (response.statusCode () != 200 ) {
throw new IOException ("HTTP response status: " + response.statusCode ());
```

作为 JDK 11 中正式推出的新 Http 连接器，支持的功能还是比较新的，主要的特性有：

（ 1 ）完整支持 HTTP 2.0 或者 HTTP 1.1

（ 2 ）支持 HTTPS/TLS

（ 3 ）有简单的阻塞使用方法

（ 4 ）支持异步发送，异步时间通知

（ 5 ）支持 WebSocket

（ 6 ）支持响应式流

HTTP 2.0 其他的客户端也能支持，而 HttpClient 使用 CompletableFuture 作为异步的返回数据。
WebSocket 的支持则是 HttpClient 的优势。响应式流的支持是 HttpClient 的一大优势。

HttpClient 中的 NIO 模型、函数式编程、CompletableFuture 异步回调、响应式流让 HttpClient 拥有极强
的并发处理能力，所以其性能极高，而内存占用则更少。

飞行记录器：JFR

Java 飞行记录器 (Java Flight Recorder) 已经变成 JDK 11 的一部分了，之前它是一个商业功能，但是伴随
JDK 11 发布，它从 OracleJDK 开源到了 OpenJDK。

飞行记录器类似飞机上的黑盒子，是一种低开销的事件信息收集框架，主要用于对应用程序和 JVM 进行
故障检查、分析。飞行记录器记录的主要数据源于应用程序、JVM 和 OS，这些事件信息保存在单独的
事件记录文件中，故障发生后，能够从事件记录文件中提取出有用信息对故障进行分析

```
}
```
```
return response.body ();
}
```
```
//异步
public void postAsync (
String url, String data, Consumer<String> consumer, IntConsumer
errorHandler) {
HttpClient client = HttpClient.newHttpClient ();
```
```
HttpRequest request =
HttpRequest.newBuilder ()
.uri (URI.create (url))
.header ("Content-Type", "application/json")
.POST (BodyPublishers.ofString (data))
.build ();
```
```
client
.sendAsync (request, BodyHandlers.ofString ())
.thenAccept (
response -> {
if (response.statusCode () == 200 ) {
consumer.accept (response.body ());
} else {
errorHandler.accept (response.statusCode ());
}
});
}
```

Epsilon：低开销垃圾回收器

新增的垃圾回收器，一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存
吞吐延迟时间

###### jdk 12（ 2019 年 3 月）

jdk 12 的新特性主要有以下几个：

```
新功能和库的更新
JVM 常量 API
默认 CDS 归档
Microbenchmark 测试套件
新的平台支持
移除多余 ARM 64 实现
JVM 优化
G 1 的可中断 mixed GC
G 1 归还不使用的内存
新功能的预览和实验
低暂停时间垃圾收集器（实验）
Switch 表达式 (预览版本)
```
**重要特性：switch 表达式语法扩展、G 1 收集器优化、新增 Shenandoah GC 垃圾回收算法。**

**G 1 收集器优化**

jdk 12 为垃圾收集器 G 1 带来了两项更新：

```
可中止的混合收集集合
为了达到用户提供的停顿时间目标，通过把要被回收的区域集（混合收集集合）拆分为强制和可选
部分，使 G 1 垃圾回收器能中止垃圾回收过程。G 1 可以中止可选部分的回收以达到停顿时间目
标。
集市返回未使用的已分配内存
由于 G 1 尽量避免完整的 GC，并且仅基于 Java 堆占用和分配活动来触发并发周期，因此在许多情
况下，除非从外部强制执行，否则它不会返还 Java 堆内存。JDK 12 增强了 G 1 GC，可以在空闲时
自动将 Java 堆内存返回给操作系统。
```
###### jdk 13（ 2019 年 9 月）

jdk 13 的新特性主要有以下几个：

```
新功能和库的更新
动态应用程序类-数据共享
Socket API 重构
JVM 优化
增强 ZGC 释放未使用内存
新功能预览
Switch 表达式扩展（预览功能）
文本块（预览功能）
```
**重要特性：ZGC 优化，释放内存还给操作系统、socket 底层实现引入 NIO。**

**SocketAPI 重构**


Java 中的 Socket API 已经存在了二十多年了，尽管这么多年来，一直在维护和更新中，但是在实际使
用中遇到一些局限性，并且不容易维护和调试。

Java Socket API（java. net. ServerSocket 和 java. net. Socket）包含允许监听控制服务器和发送数据的
套接字对象。

可以使用 ServerSocket 来监听连接请求的端口，一旦连接成功就返回一个 Socket 对象，可以使用该对
象读取发送的数据和进行数据写回操作，而这些类的繁重工作都是依赖于 SocketImpl 的内部实现，服
务器的发送和接收两端都基于 SOCKS 进行实现的。

在 Java 13 之前，通过使用 PlainSocketImpl 作为 SocketImpl 的具体实现。

ava 13 中的新底层实现，引入 NioSocketImpl 的实现用以替换 SocketImpl 的 PlainSocketImpl 实现，
此实现与 NIO（新 I/O）实现共享相同的内部基础结构，并且与现有的缓冲区高速缓存机制集成在一
起，因此不需要使用线程堆栈。

除此，还可以使用 java. lang. ref. Cleaner 机制来关闭套接字（如果 SocketImpl 实现在尚未关闭的套接
字上被进行了垃圾收集），以及在轮询时套接字处于非阻塞模式时处理超时操作。

**增强 ZGC 释放未使用内存**

ZGC 是 Java 11 中实验性的引入的最为瞩目的垃圾回收器，是一种可伸缩、低延迟的垃圾收集器，

ZGC 主要用来改善 GC 停顿时间，并支持几百 MB 至几个 TB 级别大小的堆，并且应用吞吐能力下降不
会超过 15%，目前只支持 Linux/x 64 位平台的这样一种新型垃圾收集器。

通过在实际中的使用，发现 ZGC 收集器中并没有像 Hotspot 中的 G 1 和 Shenandoah 垃圾收集器一
样，能够主动将未使用的内存释放给操作系统的功能。对于大多数应用程序来说，CPU 和内存都属于有
限的紧缺资源，特别是现在使用的云上或者虚拟化环境中。

如果应用程序中的内存长期处于空闲状态，并且还不能释放给操作系统，这样会导致其他需要内存的应
用无法分配到需要的内存，而这边应用分配的内存还处于空闲状态，处于”忙的太忙，闲的太闲”的非公
平状态，并且也容易导致基于虚拟化的环境中，因为这些实际并未使用的资源而多付费的情况。由此可
见，将未使用内存释放给系统主内存是一项非常有用且亟需的功能。

ZGC 堆由一组称为 ZPages 的堆区域组成。在 GC 周期中清空 ZPages 区域时，它们将被释放并返回到
页面缓存 ZPageCache 中，此缓存中的 ZPages 按最近最少使用（LRU）的顺序，并按照大小进行组
织。

在 Java 13 中，ZGC 将向操作系统返回被标识为长时间未使用的页面，这样它们将可以被其他进程重
用。同时释放这些未使用的内存给操作系统不会导致堆大小缩小到参数设置的最小大小以下，如果将最
小和最大堆大小设置为相同的值，则不会释放任何内存给操作系统。

Java 13 中对 ZGC 的改进，主要体现一下几点：

（ 1 ）释放未使用内存给操作系统；

（ 2 ）支持最大堆大小为 16 TB；

（ 3 ）添加参数：-XX: SoftMaxHeapSize 来软限制堆大小

Java 13 中，ZGC 内存释放功能，默认情况下是开启的，不过可以使用参数：-XX：-ZUncommit 显式关
闭，同时如果将最小堆大小 (-Xms) 配置为等于最大堆大小 (-Xmx)，则将隐式禁用此功能。

还可以使用参数：-XX：ZUncommitDelay =（默认值为 300 秒）来配置延迟释放，此延迟时间可以指
定释放多长时间之前未使用的内存。

###### jdk 14（ 2020 年 3 月）

jdk 14 的新特性主要有以下几个：


```
语言特性增强
Switch 表达式（正式版）
新功能和库的更新
改进 NullPointerExceptions 提示信息
旧功能的删除和弃用
删除 pack 200 和 unpack 200 工具
JVM 相关
G 1 的 NUMA 可识别内存分配
删除 CMS 垃圾回收器
ZGC 支持 MacOS 和 Windows 系统（实验阶段）
弃用 ParallelScavenge 和 SerialOld GC 的组合使用
新功能的预览和实验
instanceof 模式匹配（预览阶段）
Record 类型（预览功能）
文本块（第二预览版本）
打包工具（孵化器版本）
外部存储器访问 API（孵化器版）
```
**Switch 表达式（正式版）**

在 jdk 12 之前，传统的 Switch 语句写法如下：

在 Java 12 中引入了 Switch 表达式作为预览特性，关于 Switch 表达式的写法改进为如下：

```
public static void main (String[] args) {
String season = "spring";
switch (season){
case "spring":
PrintOut.print ("春暖花开");
break;
case "summer":
PrintOut.print ("酷暑难耐");
break;
case "autumn":
PrintOut.print ("艳阳高照");
break;
case "winter":
PrintOut.print ("白雪皑皑");
break;
default:
PrintOut.print ("四季如春");
break;
}
}
```

在 Java 13 中对 Switch 表达式做了增强改进，在块中引入了 yield 语句来返回值，而不是使用 break。

这意味着，有返回值的 Switch 表达式应该使用 yield，而不返回值的 Switch 语句应该使用 break。但是
只是处于预览状态。

JDK 13 在简化的基础上增加了返回值：

yield 返回值形式如下：

Java 12 和 Java 13 中 Switch 表达式的增强功能，在 jdk 14 中终于成为稳定版本，能够正式使用。

switch 表达式将之前 switch 语句从编码方式上简化了不少，但是还是需要注意下面几点：

（ 1 ）需要保持与之前 switch 语句同样的 case 分支情况。

（ 2 ）之前需要用变量来接收返回值，而现在直接使用 yield 关键字来返回 case 分支需要返回的结果。

```
public static void main (String[] args) {
String season = "spring";
switch (season){
case "spring" -> PrintOut.print ("春暖花开");
case "summer" -> PrintOut.print ("酷暑难耐");
case "autumn" -> PrintOut.print ("艳阳高照");
case "winter"-> PrintOut.print ("白雪皑皑");
default -> PrintOut.print ("四季如春");
}
}
```
```
public static void main (String[] args) {
String season = "spring";
String des =switch (season){
case "spring" -> "春暖花开";
case "summer" ->"酷暑难耐";
case "autumn" -> "艳阳高照";
case "winter"-> "白雪皑皑";
default -> "四季如春";
};
PrintOut.print (des);
}
```
```
public String getSeasondes (String season){
return switch (season){
case "spring" :
yield "春暖花开";
case "summer" :
yield "酷暑难耐";
case "autumn":
yield "艳阳高照";
case "winter":
yield "白雪皑皑";
default :
yield "四季如春";
};
}
```

（ 3 ）现在的 switch 表达式中不再需要显式地使用 return、break 或者 continue 来跳出当前分支。

（ 4 ）现在不需要像之前一样，在每个分支结束之前加上 break 关键字来结束当前分支，如果不加，则
会默认往后执行，直到遇到 break 关键字或者整个 switch 语句结束，在 Java 14 表达式中，表达式默
认执行完之后自动跳出，不会继续往后执行。

（ 5 ）对于多个相同的 case 方法块，可以将 case 条件并列，而不需要像之前一样，通过每个 case 后
面故意不加 break 关键字来使用相同方法块。

使用 switch 表达式来替换之前的 switch 语句，确实精简了不少代码，提高了编码效率，同时也可以规
避一些可能由于不太经意而出现的意想不到的情况。

**改进 NullPointerExceptions 提示信息**

应该每位开发者在实际编码过程中都经历过 NullPointerException 的痛，每当遇到这种异常的时候，都
需要根据打印出来的详细信息来分析、定位出现问题的原因，以在程序代码中规避或解决。

直接运行会提示一下的错误：

针对这样的空指针异常打印，如果代码比较简单，并且异常信息中也打印出来了行号信息， **开发者可以
很快速定位到出现异常位置** 。

但是对于一些复杂或者嵌套的情况下出现 NullPointerException 时，仅根据打印出来的信息，很难判
断实际出现问题的位置，就如示例代码中，就无法判断出来是 animal 是 null 还是 fly 是 null。

jdk 14 中增强了对 NullPointerException 异常的处理，通过分析程序的字节码信息，能够做到准确的定
位到出现 NullPointerException 的变量，并且根据实际源代码打印出详细异常信息。这对于开发者来
说是一个福音。

这个功能需要通过选项-XX:+ShowCodeDetailsInExceptionMessages 启用，如下所示：

```
public class Npe {
@Test
public void npeTest () {
Animal animal = new Animal ();
animal.fly.fly ();
}
```
```
class Animal{
Fly fly;
}
class Fly{
public void fly (){
PrintOut.print ("一行白鹭上青天");
}
}
}
```
```
java. lang. NullPointerException
at com.th.test.Npe.npeTest (Npe. java: 9 )
```

输出的信息如下所示。错误消息明确的指出了 animal. fly 为 null。

可以看出，改进之后的 NullPointerException 信息，能够准确打印出具体哪个变量导致的
NullPointerException，减少了由于仅带行号的异常提示信息带来的困惑。该改进功能可以通过如下参
数开启。

该增强改进特性，不仅适用于属性访问，还适用于方法调用、数组访问和赋值等有可能会导致
NullPointerException 的地方。

**删除 CMS 垃圾回收器**

CMS 是老年代垃圾回收算法，通过标记-清除的方式进行内存回收，在内存回收过程中能够与用户线程
并行执行。

- XX:+ShowCodeDetailsInExceptionMessages

```
java. lang. NullPointerException: Cannot invoke "com. th. test. Npe$Fly.fly ()"
because "animal. fly" is null
```
```
at com.th.test.Npe.npeTest (Npe. java: 9 )
......
```

CMS 回收器可以与 Serial 回收器和 Parallel New 回收器搭配使用，CMS 主要通过并发的方式，适当减
少系统的吞吐量以达到追求响应速度的目的，比较适合在追求 GC 速度的服务器上使用。

因为 CMS 回收算法在进行 GC 回收内存过程中是使用并行方式进行的，如果服务器 CPU 核数不多的情
况下，进行 CMS 垃圾回收有可能造成比较高的负载。

同时在 CMS 并行标记和并行清理时，应用线程还在继续运行，程序在运行过程中自然会创建新对象、
释放不用对象，所以在这个过程中，会有新的不可达内存地址产生，而这部分的不可达内存是出现在标
记过程结束之后，本轮 CMS 回收无法在周期内将它们回收掉，只能留在下次垃圾回收周期再清理掉。
这样的垃圾就叫做浮动垃圾。

由于垃圾收集和用户线程是并发执行的，因此 CMS 回收器不能像其他回收器那样进行内存回收，需要
预留一些空间用来保存用户新创建的对象。

由于 CMS 回收器在老年代中使用标记-清除的内存回收策略，势必会产生内存碎片，内存当碎片过多
时，将会给大对象分配带来麻烦，往往会出现老年代还有空间但不能再保存对象的情况。

所以，在 Java 9 中已经决定放弃使用 CMS 回收器了，而这次在 Java 14 中彻底禁用 CMS，并删除与
CMS 有关的选项，同时清除与 CMS 有关的文档内容，至此曾经辉煌一度的 CMS 回收器，也将成为历
史。

当在 Java 14 版本中，通过使用参数：-XX:+UseConcMarkSweepGC，尝试使用 CMS 时，将会收到下
面信息：

**弃用 ParallelScavenge 和 SerialOld GC 的组合使用**

由于 Parallel Scavenge 和 Serial Old 垃圾收集算法组合起来使用的情况比较少，并且在年轻代中使用
并行算法，而在老年代中使用串行算法，这种并行、串行混搭使用的情况，本身已属罕见同时也很冒
险。

由于这两 GC 算法组合很少使用，却要花费巨大工作量来进行维护，所以在 Java 14 版本中，考虑将这
两 GC 的组合弃用。

具体弃用情况如下，通过弃用组合参数：-XX:+UseParallelGC -XX:-UseParallelOldGC，来弃用年轻
代、老年期中并行、串行混搭使用的情况；同时，对于单独使用参数：-XX:-UseParallelOldGC 的地方，
也将显示该参数已被弃用的警告信息。

###### jdk 15（ 2020 年 9 月）

jdk 15 的新特性主要有以下几个：

```
语言特性增强
文本块 (Text Blocks)
新功能和库的更新
Edwards-Curve 数字签名算法 (EdDSA)
隐藏类 Hidden Classes
重新实现 DatagramSocket API
JVM 优化
ZGC: 可伸缩低延迟垃圾收集器
禁用偏向锁定
Shenandoah：低暂停时间垃圾收集器 (转正)
旧功能的删除和弃用
```

```
移除 Nashorn JavaScript 引擎
移除了 Solaris 和 SPARC 端口
废除 RMI 激活
新功能的预览和孵化
instanceof 自动匹配模式（第二次预览）
密封的类和接口（预览）
外部存储器访问 API（二次孵化器版）
Records (二次预览)
```
**文本块**

早些时候，为了在代码中嵌入 JSON，我们将其声明为字符串文字：

jdk 13 预览发布文本块功能，jdk 15 正式发布文本框功能。文本块用来解决多行文本的问题，文本块以三
重双引号开头，并以同样的以三重双引号结尾终止。

文本块内允许插入 \ 阻止换行，如：

PS：每行末尾的空格会被忽略，除非主动将其替换为 /s。

**隐藏类 Hidden Classes**

此功能可帮助需要在运行时生成类的框架。框架生成类需要动态扩展其行为，但是又希望限制对这些类
的访问。

```
String json = "{\r\n" + "\"name\" : \"lingli\",\r\n" + "\"website\" :
\"https://www.alibaba.com/\"\r\n" + "}";
```
```
var block = """
lang: java
version: 13
dbname: mysql
ip: 192.168.9.202
usr: thtest
pwd: wekhd 222
""";
// 6 行
block.lines (). count ();
```
```
var block = """
lang: java\
version: 13 \
dbname: mysql\
ip: 192.168.9.202\
usr: thtest\
pwd: wekhd 222
""";
// 6 行
block.lines (). count ();
```

隐藏类很有用，因为它们只能通过反射访问，不能直接被其他类的字节码访问。

隐藏类可以独立于其他类加载、卸载，这可以减少框架的内存占用。

**Hidden Classes 是什么呢？**

Hidden Classes 就是不能直接被其他 class 的二进制代码使用的 class。

Hidden Classes 主要被一些框架用来生成运行时类，但是这些类不是被用来直接使用的，而是通过反射
机制来调用。

比如在 JDK 8 中引入的 lambda 表达式，JVM 并不会在编译的时候将 lambda 表达式转换成为专门的类，而
是在运行时将相应的字节码动态生成相应的类对象。

另外使用动态代理也可以为某些类生成新的动态类。

动态生成的类具有什么特征呢？

```
不可发现性 ：为某些静态的类动态生成的动态类，所以我们希望把这个动态生成的类看做是静态类
的一部分。
访问控制 ：希望在访问控制静态类的同时，也能控制到动态生成的类。
生命周期 ：动态生成类的生命周期一般都比较短，我们并不需要将其保存和静态类的生命周期一
致。
```
我们需要一些 API 来定义无法发现的且具有有限生命周期的隐藏类。这将提高所有基于 JVM 的语言实现的
效率。例如:

普通类是通过调用 ClassLoader:: defineClass 创建的，而隐藏类是通过调用 Lookup::defineHiddenClass
创建的。

这使 JVM 从提供的字节中派生一个隐藏类，链接该隐藏类，并返回提供对隐藏类的反射访问的查找对
象。

调用程序可以通过返回的查找对象来获取隐藏类的 Class 对象。

**可伸缩低延迟垃圾收集器 ZGC 成功转正**

ZGC 是 Jdk 11 引入的新的垃圾收集器（JDK 9 以后默认的垃圾回收器是 G 1），经过了多个实验阶段，终于
Jdk 15 中成为正式特性。

ZGC 是一个重新设计的并发的垃圾回收器，可以极大的提升 GC 的性能。支持任意堆大小而保持稳定的低
延迟（10 ms 以内），性能非常可观。

目前默认垃圾回收器仍然是 G 1，后续很有可以能将 ZGC 设为默认垃圾回收器。jdk 15 之前需要通过-
XX:+UnlockExperimentalVMOptions -XX:+UseZGC 来启用 ZGC，从 jdk 15 开始只需要-XX:+UseZGC 就可
以。

ZGC 是一个可伸缩的、低延迟的垃圾收集器，主要为了满足如下目标进行设计：

```
GC 停顿时间不超过 10 ms
即能处理几百 MB 的小堆，也能处理几个 TB 的大堆
应用吞吐能力不会下降超过 15%（与 G 1 回收算法相比）
```
```
// 可以定义隐藏类作为实现代理接口的代理类。
java. lang. reflect. Proxy
// 可以生成隐藏类来保存常量连接方法；
java. lang. invoke. StringConcatFactory
//可以生成隐藏的 nestmate 类，以容纳访问封闭变量的 lambda 主体；
java. lang. invoke. LambdaMetaFactory
```

```
方便在此基础上引入新的 GC 特性和利用 colord
针以及 Load barriers 优化奠定基础
在 Linux/X 64 平台上，停顿时间在 10 ms 以下，10 ms 其实是一个很保守的数据，即便是 10 ms
这个数据，也是 GC 调优几乎达不到的极值。
```
ZGC 是一个并发收集器，必须要设置一个最大堆的大小，应用需要多大的堆，主要有下面几个考量：对
象的分配速率，要保证在 GC 的时候，堆中有足够的内存分配新对象。一般来说，给 ZGC 的内存越多
越好，但是也不能浪费内存，所以要找到一个平衡。

**禁用偏向锁**

JDK 15 中， **默认情况下禁用偏向锁** ，并弃用所有相关的命令行选项。

目标是确定是否需要继续支持偏置锁定的高维护成本的遗留同步优化， HotSpot 虚拟机使用该优化来
减少非竞争锁定的开销。

尽管某些 Java 应用程序在禁用偏向锁后可能会出现性能下降，但 **偏向锁的性能提高通常不像以前那么明
显** 。

该特性默认禁用了 biased locking (-XX:+UseBiasedLocking)。

废弃了所有相关的命令行选型 (BiasedLockingStartupDelay, BiasedLockingBulkRebiasThreshold,
BiasedLockingBulkRevokeThreshold, BiasedLockingDecayTime, UseOptoBiasInlining,
PrintBiasedLockingStatistics and PrintPreciseBiasedLockingStatistics)

关于锁更多的内容请参考《Java 高并发编程卷 2 （加强版）》

**低暂停时间垃圾收集器 Shenandoah 成功转正**

Shenandoah 垃圾回收算法从 JDK 12 引入的回收算法，在 jdk 15 中成功转正。

Shenandoah 在 JDK 12 被作为 experimental 引入，在 JDK 15 变为 Production。

该算法通过与正在运行的 Java 线程同时进行疏散工作来减少 GC 暂停时间。Shenandoah 的暂停时间
与堆大小无关，无论堆栈是 200 MB 还是 200 GB，都具有相同的一致暂停时间。

Shenandoah 适用于 **高吞吐和大内存场景** ，不适合高实时性场景。

Shenandoah 算法设计目标主要是响应性和一致可控的短暂停顿，对于垃圾回收生命周期中安全点停顿
（TTSP) 和内存增长监控的时间开销并无帮助。

Shenandoah 算法为每个 Java 对象添加了一个间接指针，使得 GC 线程能够在 Java 线程运行时压缩堆。

标记和压缩是同时执行的，因此我们只需要暂停 Java 线程在一致可控的时间内扫描线程堆栈以查找和更
新对象图的根。

Shenandoah 和 ZGC 的关系如下

```
相同点：性能几乎可认为是相同的
不同点：
ZGC 是 Oracle JDK 的。Shenandoah 只存在于 OpenJDK 中，因此使用时需注意你的 JDK
版本打开方式：使用-XX:+UseShenandoahGC 命令行参数打开。
```
之前需要通过-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC 来启用，现在只需要-
XX:+UseShenandoahGC 即可启用。

###### jdk 16（ 2021 年 3 月）

jdk 16 的新特性主要有以下几个：


```
语言特性增强
instanceof 模式匹配（正式版）
Records (正式版)
新工具和库
Unix-Domain 套接字通道
对基于值的类发出警告
打包工具（正式版）
默认强封装 JDK 内部元素
JVM 优化
ZGC 并发线程处理
弹性元空间
新功能的预览和孵化
向量 API（孵化器）
外部链接器 API（孵化器）
外部存储器访问 API（第三次孵化）
密封类（第二预览）
提升 OpenJDK 开发人员的生产力
启用 C++14 语言特性（在 JDK 源代码中）
```
**JDK 16 相当于是将 JDK 14、JDK 15 的一些特性进行了正式引入，如 instanceof 模式匹配（Pattern
matching）、record 的引入等最终到 JDK 16 变成了 final 版本。**

**instanceof 模式匹配**

模式匹配（Pattern Matching）最早在 Java 14 中作为预览特性引入，在 Java 15 中还是预览特性，在
Java 16 中成为正式版。模式匹配通过对 instacneof 运算符进行模式匹配来增强 Java 编程语言。

instanceof 的增强的主要目的是为了创建对象更加简单、简洁和高效，并且可读性更强、提高安全性。

instanceof 主要用来检查对象的类型，然后根据类型对目标对象进行类型转换，之后进行不同的处理、
实现不同的逻辑，jdk 16 之前的经典写入：

在示例代码中，首先需要对 animal 对象进行类型判断，判断 animal 具体是 Dog 还是 Cat，因为这两种
角色对应不同操作，亦即对应到的实际逻辑实现，判断完 animal 类型之后，然后强制对 animal 进行类
型转换为局部变量，以方便后续执行属于该角色的特定操作。

上面这种写法，有下面两个问题：

```
每次在检查类型之后，都需要强制进行类型转换。
类型转换后，需要提前创建一个局部变量来接收转换后的结果，代码显得多余且繁琐。
```
对 instanceof 进行模式匹配改进之后，上面示例代码可以改写成：

```
if (animal instanceof Dog){
Dog dog = (Dog) animal;
dog.eat ();
}else if (animal instanceof Cat){
Cat cat = (Cat) animal;
cat.eat ();
}
```

首先在 if 代码块中，对 animal 对象进行类型匹配，校验 animal 对象是否为 Dog 类型，如果类型匹配
成功，则会转换为 Dog 类型，并赋值给模式局部变量 dog，并且只有当模式匹配表达式匹配成功是才会
生效和复制，同时这里的 dog 变量只能在 if 块中使用，而不能在 else if/else 中使用，否则会报编译错
误。

注意，如果 if 条件中有 && 运算符时，当 instanceof 类型匹配成功，模式局部变量的作用范围也可以
相应延长，示例代码如下：

但是这种作用范围延长，并不适用于或 || 运算符，因为即便 || 运算符左边的 instanceof 类型匹配没
有成功也不会造成短路，依旧会执行到||运算符右边的表达式，但是此时，因为 instanceof 类型匹配
没有成功，局部变量并未定义赋值，此时使用会产生问题。

与传统写法对比，可以发现模式匹配不但提高了程序的安全性、健壮性，另一方面，不需要显式的去进
行二次类型转换，减少了大量不必要的强制类型转换。

模式匹配变量在模式匹配成功之后，可以直接使用，同时它还被限制了作用范围，大大提高了程序的简
洁性、可读性和安全性。

instanceof 的模式匹配，为 Java 带来的有一次便捷的提升，能够剔除一些冗余的代码，写出更加简洁
安全的代码，提高码代码效率。

**Records**

Records 最早在 Java 14 中作为预览特性引入，在 Java 15 中还是预览特性，在 Java 16 中成为正式版。

Record 类型允许在代码中使用紧凑的语法形式来声明类，而这些类能够作为不可变数据类型的封装持
有者。Record 这一特性主要用在特定领域的类上；与枚举类型一样，Record 类型是一种受限形式的类
型，主要用于存储、保存数据，并且没有其它额外自定义行为的场景下。

在 jdk 14 之前，在开发过程中，被当作数据载体的类对象，在正确声明定义过程中，通常需要编写大量
的无实际业务、重复性质的代码，其中包括：构造函数、属性调用、访问以及 equals () 、
hashCode ()、toString () 等方法。

在 Java 14 中引入了 Record 类型，其效果有些类似 Lombok 的 @Data 注解、但是又不尽完全相同，
它们的共同点都是类的部分或者全部可以直接在类头中定义、描述，并且这个类只用于存储数据而已。

编译器会一次性代替用户生成 getters，constructors，toString 等方法。示例代码：

```
if (animal instanceof Dog dog){
dog.eat ();
}else if (animal instanceof Cat cat){
cat.eat ();
}
```
```
if (obj instanceof String s && s.length () > 5 ) {.. s.contains (..) ..}
```
```
public record animal (String name, int weight){
public static String fly;
```
```
public static String getFly () {
return fly;
}
}
```

编译后结果如下：

根据反编译结果，可以得出，当用 Record 来声明一个类时，该类将自动拥有下面特征：

```
拥有一个构造方法
获取成员属性值的方法：name ()、age ()
hashCode () 方法和 euqals () 方法
toString () 方法
类对象和属性被 final 关键字修饰，不能被继承，类的示例属性也都被 final 修饰，不能再被赋值
使用。
还可以在 Record 声明的类中定义静态属性、方法和示例方法。注意，不能在 Record 声明的类中
定义示例字段，类也不能声明为抽象类等。
```
可以看到，该预览特性提供了一种更为紧凑的语法来声明类，并且可以大幅减少定义类似数据类型时所
需的重复性代码。

另外 Java 14 中为了引入 Record 这种新的类型，在 java. lang. Class 中引入了下面两个新方法：

方法说明：

（ 1 ） getRecordComponents () 方法返回一组 java. lang. reflect. RecordComponent 对象组成的数组，
java. lang. reflect. RecordComponent 也是一个新引入类，该数组的元素与 Record 类中的组件相对应，
其顺序与在记录声明中出现的顺序相同，可以从该数组中的每个 RecordComponent 中提取到组件信
息，包括其名称、类型、泛型类型、注释及其访问方法。

（ 2 ） isRecord () 方法，则返回所在类是否是 Record 类型，如果是，则返回 true

**ZGC 并发线程堆栈处理**

```
public recordTest () {
}
```
```
public static record animal (String name, int weight) {
public static String fly;
```
```
public animal (String name, int weight) {
this. name = name;
this. weight = weight;
}
```
```
public static String getFly () {
return fly;
}
```
```
public String name () {
return this. name;
}
```
```
public int weight () {
return this. weight;
}
}
```
```
RecordComponent[] getRecordComponents ()
boolean isRecord ()
```

ZGC 是 JDK 11 引入的新的垃圾收集器，JDK 15 正式发布成正式特性，ZGC 是一个重新设计的并发的垃圾
回收器，可以极大的提升 GC 的性能。支持任意堆大小而保持稳定的低延迟（10 ms 以内），性能非常可
观。

JDK 16 将 ZGC 线程栈处理从安全点转移到一个并发阶段，甚至在大堆上也允许在毫秒内暂停 GC 安全
点。消除 ZGC 垃圾收集器中最后一个延迟源可以极大地提高应用程序的性能和效率。

**弹性元空间**

将未使用的 HotSpot 类元数据（即元空间，metaspace）内存更快速地返回到操作系统，从而减少元
空间的占用空间。具有大量类加载和卸载活动的应用程序可能会占用大量未使用的空间。新方案将元空
间内存按较小的块分配，它将未使用的元空间内存返回给操作系统来提高弹性，从而提高应用程序性能
并降低内存占用。

###### jdk 17（ 2021 年 9 月 LTS）

jdk 17 的新特性主要有以下几个：

```
语言特性增强
密封的类和接口（正式版）
工具库的更新
恢复始终严格的浮点语义
增强的伪随机数生成器
新的 macOS 渲染管道
新的平台支持
支持 macOS AArch 64
弃用 Applet API
旧功能的删除和弃用
弃用 Applet API
删除实验性 AOT 和 JIT 编译器
弃用安全管理器以进行删除
新功能的预览和孵化 API
新增 switch 模式匹配（预览版）
外部函数和内存 api （第一轮孵化）
Vector API（第二轮孵化）
外部链接器 API（孵化器）
外部存储器访问 API（第三次孵化）
```
**虽然 JDK 17 也是一个 LTS 版本，但是并没有像 JDK 8 和 JDK 11 一样引入比较突出的特性，主要是对前几个
版本的整合和完善。**

**恢复始终执行严格模式的浮点语义**

严格的浮点语义是 IEEE（电气和电子工程协会）为浮点计算和以各种格式存储浮点值制定了一种标准，
包括单精度（ 32 位，用于 java）float、双精度（ 64 位，用于 java）double，另外一些硬件还提供扩展
精度格式，以提供更高的精度和更大的指数范围。

在这样的架构下，使用扩展格式计算中间结果可能更有效，还能避免可能发生的舍入错误、上溢和下
溢，但是会导致程序在此类架构上产生不同的输出，且 x 87 浮点架构在 x 86 机器上使用扩展精度代价很
昂贵。

在 JVM 1.2 之前浮点计算是严格要求的，也就是说浮点值的计算结果都必须表现的和标准一样，这使得在
常见的 x 87 浮点指令集平台上在需要的地方发生溢出的代价变得昂贵。


在没有上溢和下溢的情况下，如果需要得到重复的结果，java 提供了一个当前已过时且未使用的关键字
strictfp ，strictfp 修饰符确保浮点计算在所有平台发生上溢和下溢的地方相同，且中间值表示为 IEEE 单
精度和双精度值。

该关键字可用于类、接口、非抽象方法。在方法上添加时内部所有计算都使用严格的浮点数学计算；在
类上添加时类中所有计算都使用严格的浮点数学计算。

由于当下支持 SSE 2 指令集的 x 86 处理器不再需要 x 87 浮点指令集，因此 JDK 17 再次严格要求所有浮点计
算，恢复了 1.2 之前的语义。

**增强型伪随机数发生器**

JDK 17 之前，我们可以借助 Random、ThreadLocalRandom 和 SplittableRandom 来生成随机数。

Random 类典型的使用如下：

ThreadLocalRandom 类提供线程间独立的随机序列。它只有一个实例，多个线程用到这个实例，也会
在线程内部各自更新状态。它同时也是 Random 的子类，不过它几乎把所有 Random 的方法又实现了
一遍。示例代码如下：

```
// random int
new Random (). nextInt ();
```
```
/**
* description 获取指定位数的随机数
*
* @param length 1
* @return java. lang. String
*/
public static String getRandomString (int length) {
String base = "abcdefghijklmnopqrstuvwxyz 0123456789";
Random random = new Random ();
StringBuilder sb = new StringBuilder ();
for (int i = 0 ; i < length; i++) {
int number = random.nextInt (base.length ());
sb.append (base.charAt (number));
}
return sb.toString ();
}
```
```
public void testNextIntBounded () {
for (int bound = 2 ; bound < MAX_INT_BOUND; bound += 524959 ) {
int f = ThreadLocalRandom.current (). nextInt (bound);
assertTrue ( 0 <= f && f < bound);
int i = 0 ;
int j;
while (i < NCALLS &&
(j = ThreadLocalRandom.current (). nextInt (bound)) == f) {
assertTrue ( 0 <= j && j < bound);
++i;
}
assertTrue (i < NCALLS);
}
}
```

SplittableRandom 类是非线程安全，但可以 fork 的随机序列实现，适用于拆分子任务的场景。示例代
码如下：

JDK 7 为伪随机数生成器（pseudorandom number generator，RPNG，又称为确定性随机位生成器）
提供新的接口类型和实现，使程序使用各种 PRNG 算法更加容易，更好的支持流式编程。

提供了一个新的接口 RandomGenerator ,为所有 PRNG 算法提供统一的 API，同时提供了一个新的类
RandomGeneratorFactory 来构造各种 RandomGenerator 实例。

通过 RandomGeneratorFactory.of (“随机数生成算法”) 方法获得生成器

执行结果：

RandomGeneratorFactory.all () 方法可以获得所有随机数生成算法，输出所有随机算法名称：

支持的随机数生成算法如下：

```
public void testNextLong () {
SplittableRandom sr = new SplittableRandom ();
long f = sr.nextLong ();
int i = 0 ;
while (i < NCALLS && sr.nextLong () == f)
++i;
assertTrue (i < NCALLS);
}
```
```
public static void main (String[] args) {
RandomGeneratorFactory<RandomGenerator> randomgf =
RandomGeneratorFactory.of ("L 128 X 1024 MixRandom");
RandomGenerator randomGenerator =
randomgf.create (System.currentTimeMillis ());
for (int i = 0 ; i < 10 ; i++){
PrintOut.print (randomGenerator.nextInt ( 10 ));
} } 6 4 4 5 0 2 5 5 1 4
```
```
// 获取所有随机数生成算法
RandomGeneratorFactory.all (). forEach (e ->PrintOut.print (e.group ()+"-
"+e.name ()));
```

**强封装 JDK 的内部 API**

java 内部的大部分类，除了关键的内部 API，如 sun. misc. Unsafe 类，都进行强封装，默认情况下不允许
开发人员利用反射等手段去访问内部非 public 的类、成员变量等，使 java 更加安全。

但是可以通过设置参数–add-export 或–add-opens 来指定哪些类可以被访问。

**密封类 sealed class，限制抽象类的实现**

封闭类可以是封闭类和或者封闭接口，用来增强 Java 编程语言，防止其他类或接口扩展或实现它们。
这个特性由 Java 15 的预览版本晋升为正式版本。

密封类可以是封闭类和或者封闭接口，用来增强 Java 编程语言，防止其他类或接口扩展或实现它们。

这个特性由 JDK 15 的预览版本在 JDK 17 晋升为正式版本。

密封类引入了 sealedclass 或 interface，这些 class 或者 interfaces 只允许被指定的类或者 interface 进行
扩展和实现。

使用修饰符 sealed，可以将一个类声明为密封类。

密封的类使用关键字 permits 列出可以直接扩展它的类。子类可以是最终的，非密封的或密封的。

例如：需要限制 Animal 类只鞥能被 Dog、Cat、Tiger 这三个类继承，不能被其他类继承，可以按如下方
法来做

```
LXM-L 32 X 64 MixRandom
LXM-L 128 X 128 MixRandom
LXM-L 64 X 128 MixRandom
Legacy-SecureRandom
LXM-L 128 X 1024 MixRandom
LXM-L 64 X 128 StarStarRandom
Xoshiro-Xoshiro 256 PlusPlus
LXM-L 64 X 256 MixRandom
Legacy-Random
Xoroshiro-Xoroshiro 128 PlusPlus
LXM-L 128 X 256 MixRandom
Legacy-SplittableRandom
LXM-L 64 X 1024 MixRando
Process finished with exit code 0
```
```
// 添加 sealed 修饰符，permits 后面跟上只能被继承的子类名称
public sealed class Animal permits Dog, Cat, Tiger{
```
```
}
```
```
// 子类可以被修饰为 final
final class Dog extends Animal{
```
```
}
// 子类可以被修饰为 non-sealed，此时 Tiger 类就成了普通类，谁都可以继承它
non-sealed class Tiger extends Animal{
```
```
}
// 任何类都可以继承 Tiger,
class Tigress extends Tiger{
```

**移除实验性的 AOT 和 JIT 编译器**

实验性的基于 Java 的提前 (AOT) 和即时 (JIT) 编译器是实验性功能，并未得到广泛采用。

作为可选，它们已经从 JDK 16 中删除。这个 JEP 从 JDK 源代码中删除了这些组件。

###### jdk 18（ 2022 年 3 月）

jdk 18 的新特性主要有以下几个：

```
工具库的更新
指定 UTF-8 作为标准 Java API 的默认字符集
引入一个简单的 Web 服务器
支持在 Java API 文档中加入代码片段
用方法句柄重新实现核心反射
互联网地址解析 SPI
旧功能的删除和弃用
弃用 Finalization 功能
新功能的预览和孵化 API
外部函数和内存 API（第二次孵化）
switch 模式匹配表达式 (第二次孵化)
Vector API（第三次孵化）
```
**指定 UTF-8 作为标准 Java API 的默认字符集**

JDK 一直都是支持 UTF-8 字符编码，这次是把 UTF-8 设置为了默认编码，也就是在不加任何指定的情况
下，默认所有需要用到编码的 JDK API 都使用 UTF-8 编码，这样就可以避免因为不同系统，不同地区，
不同环境之间产生的编码问题。

**互联网地址解析 SPI**

对于互联网地址解析 SPI，为主机地址和域名地址解析定义一个 SPI，以便 java. net. InetAddress 可以
使用平台内置解析器以外的解析器。

###### jdk 19（ 2022 年 9 月）

jdk 19 的新特性主要有以下几个：

```
记录模式 （预览版）
Linux/RISC-V 移植
外部函数和内存 API （预览版）
```
```
}
```
```
InetAddress inetAddress = InetAddress.getByName ("www.wdbyte.com");
System.out.println (inetAddress.getHostAddress ());
// 输出
// 106.14.229.49
```

```
虚拟线程（预览版）
Vector API （第四次孵化）
结构化并发（孵化阶段）
```
###### jdk 20（ 2023 年 3 月）

jdk 20 的新特性主要有以下几个：

```
作用域值（第一轮孵化)
记录模式 （第二轮预览）
switch 模式匹配（第四轮预览）
外部函数和内存 API（第二轮预览）
虚拟线程（第二轮预览）
结构化并发（第二轮孵化）
结构化并发（第五轮孵化）
```
#### JVM GC 发展回顾

```
JDK 9: 设置 G 1 为 JVM 默认垃圾收集器
JDK 10：并行全垃圾回收器 G 1，通过并行 Full GC, 改善 G 1 的延迟。目前对 G 1 的 full GC 的实现采用
了单线程-清除-压缩算法。JDK 10 开始使用并行化-清除-压缩算法。
JDK 11：推出 ZGC 新一代垃圾回收器（实验性）, 目标是 GC 暂停时间不会超过 10 ms，既能处理几百
兆的小堆，也能处理几个 T 的大堆。
JDK 14 ：删除 CMS 垃圾回收器; 弃用 ParallelScavenge + SerialOld GC 的垃圾回收算法组合; 将 zgc
垃圾回收器移植到 macOS 和 windows 平台
JDk 15 : ZGC (JEP 377) 和 Shenandoah (JEP 379) 不再是实验性功能。默认的 GC 仍然是 G 1。
JDK 16：增强 ZGC，ZGC 获得了 46 个增强功能和 25 个错误修复，控制 stw 时间不超过 10 毫秒
```
###### 性能指标测试

**吞吐量比较**


各 GC 吞吐量比较

在吞吐量方面，Parallel 中 JDK 8 和 JDK 11 差距不大，JDK 17 相较 JDK 8 提升 15% 左右；G 1 中 JDK
17 比 JDK 8 提升 18%；ZGC 在 JDK 11[2]引入，JDK 17 对比 JDK 11 提升超过 20%。

**延迟比较**

各 GC 延迟比较

在 GC 延迟方面，JDK 17 的提升更为明显。我们可以看到为缩短 GC 暂停时间所做的努力都得到了回报,
很多提升都是因为 GC 的改进。

在 Parallel 中 JDK 17 对比 JDK 8 和 JDK 11 提升 40%；在 G 1 中，JDK 11 对比 JDK 8 提升 26%，JDK 17
对比 JDK 8 提升接近 60%！ZGC 中 JDK 17 对比 JDK 11 提升超过 40%。

**暂停时间对比**


各 GC 暂停时间对比

我们可以看到 JDK 17 中的 ZGC 远低于目标：亚毫秒级的暂停时间。

G 1 的目标是在延迟和吞吐量之间保持平衡，远低于其默认的目标： 200 毫秒的暂停时间。

ZGC 的设计会保证暂停时间不随堆的大小而改变，我们可以清楚地看到当堆扩大到 128 GB 时的情况。

从暂停时间的角度来看，G 1 比 Parallel 更善于处理更大的堆，因为它能够保证暂停时间满足特定目标。

**资源占用**

各 GC 资源占用情况

上图比较了三个不同收集器原生内存的使用峰值。

由于从这个角度来看 Parallel 和 ZGC 都非常稳定，因此我们应该看一看原始数字。

我们可以看到 G 1 在这方面确实有所改进，主要原因是所有功能和增强功能都提高了记忆集管理的效率
。


**总结** ：无论使用哪种收集器，与旧版本相比，JDK 17 [3]的整体性能都有很大的提升。在 JDK 8 中，
Parallel 是默认设置，但在 JDK 9 中改为了 G 1。从那以后，G 1 的改进速度就超过了 Parallel，但在有些
情况下可能 Parallel 仍然是最佳选择。而 ZGC（JDK 15 正式使用）的加入，成为了第三种高性能替代
方案。

###### 堆内存布局的变化

JVM 堆内存布局最为经典的是分代模型，即年轻代和老年代进行区分，不同的区域采用的回收算法和策
略也完全不一样。

在一个在线应用（如微服务形态）的 request <-> response 模型中，所产生的对象 (Object) 绝大多数是
瞬时存活的对象，所以大部分的对象在年轻代就会被相对简单、轻量、且高频的 Minor GC 所回收。

在年轻代中经过几次 Minor GC 若依然存活则会将其晋升到老年代。在

老年代中，相比较而言由于对象存活多、内存容量大，所以所需要的 GC 时间相对也会很长，同时由于
每一次的回收会伴随着长时间的 Stop-The-World (简称 STW) 出现。

在内存需求比较大且对于时延和吞吐要求很高的应用中，其老年代的表现就会显得捉襟见肘。而且由于
不同的分代所采用的回收算法一般都不一样，随着业务复杂度的增加，GC 行为变得越来越难以理解，
调优处理也就愈发的复杂。

堆内存分布情况

单纯从堆内存布局来理解，一个简单的逻辑是内存区域越小，回收效率越高，经典分代模型中的 Young
区已经印证了这一点。为了解决上述问题，G 1 算法横空出世，引出基于区域（Region）的布局模型，
带来的变化是内存在物理上不再根据对象的“年龄”来划分布局，而是默认全部划分成等大小的 Region
和专门用来管理超级大对象的独占 Region，年轻代和老年代不再是一个物理划分，只是一个 Region 的
一个属性。直观理解上，除了能管理的内存更大（G 1 理论值 64 G）之外，这样带来一个显而易见的好
处就是可以预控制一次 FullGC 的 STW 的时间，因为 Region 大小一致，则可以根据停顿时间来推算这
次 GC 需要回收的 Region 个数，而没有必要每次都将所有的 Region 全部清理完毕。

固定分区模型

随着这项技术的进一步发展，到了现代化的 Pauseless (ZGC) 的算法场景中，有些算法暂时没有了分代
的概念，同时 Region 按照大小划分了 Small/Medium/Large 三个等级，更精细的 Region 管理，也进
一步来更少的内存碎片和内存利用率的提升、及其 STW 停顿时间更精准的预测与管理


灵活分区模型

###### 线程模型变化

在说线程模型之前，需要先了解一下 GC 线程与业务线程，GC 线程是指 JVM 专门用来处理 GC 相关任
务的线程，这在 JVM 启动时就已经决定。

在传统的串行算法中，是指只有一个 GC 线程在工作。在并行 (Parallel) 的算法中，存在多个 GC 线程一
起工作的情况（CMS 中 GC 线程个数默认是 CPU 的核数）。

同时一些算法的某些阶段中 (如：CMS 的并发标记阶段)，GC 线程也可以和业务线程一起工作；这个机
制就缩短了整体 STW 的时间，这也是我们所说的并发 (Concurrent) 模式。

在现代化的 GC 算法中，并不是所有和 GC 相关的任务都只能由 GC 线程完成，如 ZGC 中的 Remap 阶
段，业务线程可以通过内存读屏障 (Read Barrier)，来矫正对象在此阶段因为被重新分配到新区域后的
指针变化，进而进一步减少 STW 的时间。

###### 收集行为变化

收集行为是指的在识别出需要被收集的对象之后，JVM 对于对象和所在内存区域如何进行处理的行为。
从早期版本至今，大致分为以下几个阶段：


**第一阶段** ：Mark Copy，指直接将存活对象从原来的区域拷贝至另外一个区域。这是一种典型的空间换
时间的策略，好处显而易见：算法简单、停顿时间短、且调参优化容易；但同时也带来了近乎一倍的空
间闲置。在早期的 GC 算法使用的是经典的分代模型。其中对于年轻代 Survivor 区的收集行为便是这种
策略。如下图所示：

**第二阶段** ：Mark Sweep：为了减少空间成倍的浪费，其中一个策略就是在原有的区域直接对对象
Mark 后进行擦除。但由于是在原来的内存区域直接进行对象的擦除，应用进程运行久了之后，会带来
很多的内存碎片，其结果是内存持续增长，但真实利用率趋低。

**第三阶段** ：Mark Sweep-Compact: 这是对于 Mark Sweep 的一个改良行为，即擦除之后会对内存进行
重新的压缩整理，用以减少碎片从而提升内存利用率。但是如果每次都进行整理，就会延长每次 FullGC
后的 STW 时间。所以 CMS 的策略是通过一个开关 (-XX:+UseCMSCompactAtFullCollection 默认开) 和
一个计数器 (-XX: CMSFullGCsBeforeCompaction 默认值为 0) 进行控制，表示 FullGC 是否需要做压
缩，以及在多少次 FullGC 之后再做压缩。这个两个配置配合业务形态去做调优能起到很好的效果。

**第四阶段** ：Mark Sweep-Compact-Free: JVM 的应用有一个“内存吞噬器”的恶名，原因之一就是在进程
运行起来之后，他只会向操作系统要内存从来不会归还 (典型只借不还的渣男)。不过这些在现代化的分
区模型算法中开始有了改善，这些算法在 FullGC 之后，可以将整理之后的内存以区域 (Region) 为粒度归
还给操作系统，从而降低这一个进程的资源水位，以此来提升整个宿主机的资源利用率。


#### 说在最后

JDK 相关面试题，是非常常见的面试题。

以上的内容，如果大家能对答如流，如数家珍，基本上面试官会被你震惊到、吸引到。

最终， **让面试官爱到 “不能自已、口水直流”** 。offer，也就来了。

学习过程中，如果有啥问题，大家可以来找 40 岁老架构师尼恩交流。

## 微博一面：RPC 怎么做零呼损？

#### 说在前面

在 40 岁老架构师尼恩的 **读者交流群** (50+) 中，最近有小伙伴拿到了一线互联网企业如微博、阿里、汽车
之家、极兔、有赞、希音、百度、网易、滴滴的面试资格，遇到一几个很重要的面试题：

```
RPC 怎么做无损升级？
微服务发布的时候，RPC 怎么做零呼损？
```
与之类似的、其他小伙伴遇到过的问题还有：

```
微服务升级时，RPC 里怎么避免调用方业务受损呢？
```
所以，这里尼恩给大家做一下系统化、体系化的梳理，使得大家可以充分展示一下大家雄厚的 “技术肌
肉”， **让面试官爱到 “不能自已、口水直流”** 。

也一并把这个题目以及参考答案，收入咱们的《尼恩 Java 面试宝典》V 108 版本，供后面的小伙伴参
考，提升大家的 3 高架构、设计、开发水平。

```
注：本文以 PDF 持续更新，最新尼恩架构笔记、面试题的 PDF 文件，请从公众号 【技术自由
圈】获取。
```

#### 场景分析

微服务架构中，线上跑着几十个，甚至上百的微服务。

服务实例之间，有着错综复杂的 RPC 调用关系。

这些服务实例，归属到不同的小分队进行开发、设计、维护。

问题是：

在其中部分服务实例 **重启、升级的过程中** ，怎么做到让微服务 RPC 调用方系统不出问题呢？

#### 确保 RPC 零呼损的维度

如果要确保 RPC 零呼损，至少可以从以下两个维度进行规避：

```
维度一： rpc client 维度
维度一： rpc server 维度
```

rpc client 维度零呼损的有效措施是：重试

rpc server 维度零呼损的有效措施是：优雅启停

#### rpc client 维度的零呼损：重试

rpc client 在发生错误的时候，可以进行服务实例的重试。

常见的 rpc 框架如 OpenFeign 框架就有重试几次、重试间隔这样的参数。

当然，如果希望通过重试的机制，让 RPC 零呼损，那么要保证升级的时候，还有健康的实例可用。

不能所有的微服务实例都同时升级，从而同时不可以使用，这样的话，重试也没有意义。

所以，重试措施最好配套对应的线上滚动升级/滚动发布、或灰度升级/灰度发布等类似的策略。

#### rpc server 维度的零呼损：优雅启停

优雅启停包括：

```
优雅启动
优雅停止/优雅下线
```
###### 优雅启动

优雅启动，当微服务实例真正完成启动，甚至完成预热之后，真正具备处理 rpc 请求能力的时候，再将
实例自己注册到注册中心。

为啥要优雅启动呢？核心原因是： 避免了 RPC 请求发进来，没有完成启动流程的微服务实例却无法处
理。

优雅启动的流程，还包含 JVM 预热的流程，有关 JVM 预热的方案，请查看尼恩的上一篇文章：

微博一面：JVM 预热，你的方案是啥？

###### 优雅停止/优雅下线

在服务下线前，先通过“某种方式”把要下线的实例从调用方维护的“健康列表”里面删除就可以了，这样
负载均衡就选不到这个节点

这个操作，一般来说，都是依赖注册中心完成的。

当服务提供方关闭前，先通知注册中心进行下线，然后通过注册中心告诉调用方进行节点摘除。


如上图所示，整个关闭过程中依赖了两次 RPC 调用：

```
一次是服务提供方通知注册中心下线操作
一次是注册中心通知服务调用方下线节点操作。
```
需要注意的是： 两次通知都是异步的，只保证最终一致性，并不保证强一致性。

这个中间，有一定的时间周期，所以，如果要做到应用无损升级，需要在发出通知之后，隔一段时间，
再把服务实例正式关闭。

###### 优雅停止/优雅下线的简单流程

```
1. 下线实例在注册中心进行注销，注销该实例元数据信息；
2. 注册中心节点元数据更新周期为 15 s，调用方在感知注册中心实例变更后，更新本地缓存服务地
址，不再将流量路由到下线实例，期间保障业务无中断；
3. 下线实例等待 30 s（ 2 个心跳周期）后，进行实际下线操作；
```
优雅停止的总结：优雅停止是当微服务快要下线的时候，先从注册中心进行去注销，然后把接收到的
RPC 调用消息，处理完毕后，再彻底关闭。通过优雅停机，可以有效地防止升级期间，发送到老节点的
呼损。需要注意发送下线通知，到正式下线之间的时间间隔。

#### 确保 RPC 零呼损的维度

如果要确保 RPC 零呼损，至少可以从以下两个维度进行规避：

```
维度一： rpc client 维度
维度一： rpc server 维度
```
rpc client 维度的核心策略是重试

rpc server 维度的核心策略是优雅启停

两个维度都不可或缺，都需要实现。

#### 说在最后

RPC 相关面试题，是非常常见的面试题。


以上的内容，如果大家能对答如流，如数家珍，基本上面试官会被你震惊到、吸引到。

在面试之前，建议大家系统化的刷一波 5000 页《尼恩 Java 面试宝典》，并且在刷题过程中，如果有啥
问题，大家可以来找 40 岁老架构师尼恩交流。

最终， **让面试官爱到 “不能自已、口水直流”** 。offer，也就来了。

#### 参考文献

https://blog.csdn.net/Weixiaohuai/article/details/125391957

https://www.cnblogs.com/daoqidelv/p/7043696.html

清华大学出版社《Java 高并发核心编程卷 2 加强版》

## 参考文献

虚拟机规范 https://docs.oracle.com/javase/specs/index.html

https://tin.js.org/2021/02/14/openjdk-constant-pool/

[http://ifeve.com/jvm-random-and-entropy-source/](http://ifeve.com/jvm-random-and-entropy-source/)

https://blog.csdn.net/m0_49095721/article/details/120710937

https://blog.csdn.net/u012060033/article/details/100604722

https://blog.csdn.net/weixin_43215305/article/details/120028825

[http://www.hollischuang.com/archives/201](http://www.hollischuang.com/archives/201)

https://www.cnblogs.com/knqiufan/p/16345488.html

https://www.bbsmax.com/A/WpdKp1ymzV/

https://blog.csdn.net/weixin_39841589/article/details/112597193

https://blog.csdn.net/Herishwater/article/details/123698633

## 推荐阅读

《百亿级访问量，如何做缓存架构设计》

《多级缓存架构设计》

《消息推送架构设计》

《阿里 2 面：你们部署多少节点？1000 W 并发，当如何部署？》

《美团 2 面： 5 个 9 高可用 99.999%，如何实现？》

《网易一面：单节点 2000 Wtps，Kafka 怎么做的？》

《字节一面：事务补偿和事务重试，关系是什么？》


《网易一面：25 Wqps 高吞吐写 Mysql，100 W 数据 4 秒写完，如何实现？》

《亿级短视频，如何架构？》

《炸裂，靠“吹牛”过京东一面，月薪 40 K》

《太猛了，靠“吹牛”过顺丰一面，月薪 30 K》

《炸裂了... 京东一面索命 40 问，过了就 50 W+》

《问麻了... 阿里一面索命 27 问，过了就 60 W+》

《百度狂问 3 小时，大厂 offer 到手，小伙真狠！》

《饿了么太狠：面个高级 Java，抖这多硬活、狠活》

《字节狂问一小时，小伙 offer 到手，太狠了！》

《收个滴滴 Offer：从小伙三面经历，看看需要学点啥？》


```
技术自由圈
```
## 未来职业，如何突围：三栖架构师


```
技术自由圈
```
### 成功案例： 2 年翻 3 倍， 35 岁卷王成功转型为架构师

详情：http://topcoder.cloud/forum.php?mod=forumdisplay&fid=43&page=1


技术自由圈


技术自由圈


技术自由圈


```
技术自由圈
```
### 硬核推荐：尼恩 Java 硬核架构班

详情：https://www.cnblogs.com/crazymakercircle/p/9904544.html


技术自由圈


```
技术自由圈
```
##### 架构班（社群 VIP）的起源：

最初的视频，主要是给读者加餐。很多的读者，需要一些高质量的实操、理论视频，所以，我就围绕书，和底层，做了几个
实操、理论视频，然后效果还不错，后面就做成迭代模式了。

##### 架构班（社群 VIP）的功能：^

提供高质量实操项目整刀真枪的架构指导、快速提升大家的:
⚫ 开发水平
⚫ 设计水平
⚫ 架构水平
弥补业务中 CRUD 开发短板，帮助大家尽早脱离具备 3 高能力，掌握：
⚫ 高性能
⚫ 高并发
⚫ 高可用
作为一个高质量的架构师成长、人脉社群，把所有的卷王聚焦起来，一起卷：
⚫ 卷高并发实操
⚫ 卷底层原理
⚫ 卷架构理论、架构哲学
⚫ 最终成为顶级架构师，实现人生理想，走向人生巅峰

##### 架构班（社群 VIP）的目的：^

⚫ 高质量的实操，大大提升简历的含金量，吸引力，增强面试的召唤率
⚫ 为大家提供九阳真经、葵花宝典，快速提升水平
⚫ 进大厂、拿高薪
⚫ 一路陪伴，提供助学视频和指导，辅导大家成为架构师
⚫ 自学为主，和其他卷王一起，卷高并发实操，卷底层原理、卷大厂面试题，争取狠卷 3 月成高手，狠卷 3 年成为顶级架
构师


```
技术自由圈
```
##### N 个超高并发实操项目：简历压轴、个顶个精彩


```
技术自由圈
```
【样章】第 17 章：横扫全网 Rocketmq 视频第 2 部曲: 工业级 rocketmq 高可用（HA）底层原
理和实操

工业级 rocketmq 高可用底层原理，包含：消息消费、同步消息、异步消息、单向消息等不同消息的底层原理和源码实现；
消息队列非常底层的主从复制、高可用、同步刷盘、异步刷盘等底层原理。
工业级 rocketmq 高可用底层原理和搭建实操，包含：高可用集群的搭建。
解决以下难题：
1 、技术难题：RocketMQ 如何最大限度的保证消息不丢失的呢？RocketMQ 消息如何做到高可靠投递？
2 、技术难题：基于消息的分布式事务，核心原理不理解
3 、选型难题： kafka or rocketmq ，该娶谁？
下图链接：https://www.processon.com/view/6178e8ae0e3e7416bde9da19


```
技术自由圈
```
### 简历优化后的成功涨薪案例（ VIP 含免费简历优化）


技术自由圈


技术自由圈


技术自由圈


技术自由圈


技术自由圈


技术自由圈


技术自由圈


```
技术自由圈
```
### 修改简历找尼恩（资深简历优化专家）

⚫ 如果面试表达不好，尼恩会提供简历优化指导

⚫ 如果项目没有亮点，尼恩会提供项目亮点指导

⚫ 如果面试表达不好，尼恩会提供面试表达指导

作为 40 岁老架构师，尼恩长期承担技术面试官的角色：

⚫ 从业以来，“阅历”无数，对简历有着点石成金、改头换面、脱胎换骨的指导能力。

⚫ 尼恩指导过刚刚就业的小白，也指导过 P 8 级的老专家，都指导他们上岸。

如何联系尼恩。尼恩微信，请参考下面的地址：

语雀：https://www.yuque.com/crazymakercircle/gkkw8s/khigna
码云：https://gitee.com/crazymaker/SimpleCrayIM/blob/master/疯狂创客圈总目录.md


