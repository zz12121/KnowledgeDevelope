```
技术自由圈
```
# 牛逼的职业发展之路

40 岁老架构尼恩用一张图揭秘: Java 工程师的高端职业发展路径，走向食物链顶端的之路

链接：https://www.processon.com/view/link/618a2b62e0b34d73f7eb3cd


```
技术自由圈^
```
# 史上最全：价值 10 W 的架构师知识图谱

此图梳理于尼恩的多个 3 高生产项目：多个亿级人民币的大型 SAAS 平台和智慧城市项目

链接：https://www.processon.com/view/link/60fb9421637689719d


```
技术自由圈
```
# 牛逼的架构师哲学

40 岁老架构师尼恩对自己的 20 年的开发、架构经验总结

链接：https://www.processon.com/view/link/616f801963768961e9d9aec


```
技术自由圈
```
# 牛逼的 3 高架构知识宇宙

尼恩 3 高架构知识宇宙，帮助大家穿透 3 高架构，走向技术自由，远离中年危机

链接：https://www.processon.com/view/link/635097d2e0b34d40be778ab


```
技术自由圈
```
# 尼恩 Java 面试宝典

40 个专题（卷王专供+ 史上最全 + 2023 面试必备）
详情：https://www.cnblogs.com/crazymakercircle/p/13917138.html


```
技术自由圈^
```
# 未来职业，如何突围：三栖架构师


## 史上最全 Java 面试题：算法篇（入群获取资

## 料）

#### 刷算法的秘籍

如何刷算法，这块有秘籍，具体找 40 岁老架构尼恩，微信交流就可以了

文后有尼恩微信

#### 算法刷题宝典

刷题任务的题目，是根据题目的类型来汇总的，总结了八个类别，每个类别下面也总结了 5 个左右的题
型，帮助大家分门别类的突破，所以刷起来相对会更有重点和针对性。如果从头到尾的刷，每周按顺序
刷 42 题，很容易让自己坚持不下来，也会觉得很枯燥。所以在制定计划的时候可以让这个计划变得更
“有趣"和针对性，让它看起来更容易实现一点，才会更容易坚持。


**部分内容展示：**



#### LeetCode（ 520 道题）

除此之外，这里再跟大家推荐一本前不久火爆 GitHub 的 LeetCode 中文刷题手册， **这本小册里面共包
含刷 LeetCode 后整理的 520 道题，每道题均附有详细题解过程。自发布以后，受到技术圈内广大开
发者的赞赏，建议大家收藏阅读。** 目录如下：

**部分目录展示：**



**力扣** Cookbook 是@halfrost（中文名： **霜神** ）去年刷的 **力扣** 整理出的 520 题，每道题都写了解题思
路，并且每题都 runtime beats 100% 了。

**至于为什么要求每题都 runtime beats 100%？**

霜神是这样回复的：优化到 beats 100% 才算是把这题做出感觉了。有好几道 Hard 题，可以用暴力解
法 AC 了，但只 beats 了 5%，这题就如同没做一样；

而且面试中如果给了暴力的答案，面试官也不会满意，通过自己的思考给出更优解，面试官也会更满意
一些。

所以如果你把这些题解都摸透，相信在面试环节你可以从容的回答“还有没有更优解”这个问题。

现在就把这本电子书分享给大家，希望能帮助大家克服刷题的恐惧，顺利拿到大厂 offer。


#### Linux 归纳笔记

此外这里还有一份华为大牛总结的 Linux 归纳笔记，一并分享给大家。

这份资料非常全面且详细，从 **Linux 常用命令** 到 **Linux 常用操作** ，再到 **网络管理** 、 **性能优化** ，几乎覆
盖了 Linux 基础学习的方方面面，非常适合初学者入门！

资料也按目录进行编排，每一章下面都有更具体的内容：

而且，这份资料不是扫描版的，里面的文字都可以直接复制，非常便于我们学习：


## 获取方式

找尼恩获取

## 一些来自互联网的算法题

#### 题目一：有 10 亿个 url，每个 url 大小小于 56 B，要求去

#### 重，内存只给你 4 G

**思路：**

1. 首先将给定的 url 调用 hash 方法计算出对应的 hash 的 value，在 10 亿的 url 中相同 url 必然有着相同的
value。

2. 将文件的 hash table 放到第 value%n 台机器上。

3. value/n 是机器上 hash table 的值。

将文件分布在多个机器上，这样要处理网路延时。假设有 n 台机器。

```
首先hash文件得到hash value v
```
```
将文件的hash table 放到第v%n 台机器上。
v/n是机器上hash table的值。
```
**分析：**


将文件的 url 进行 hash，得到值 value，相同的 url 的文件具有相同的 value，所以会被分配到同一台机器
v%n 上。在同一台机器上的重复的 url 文件具有相同的 value/n 值，如果出现了冲突，不同的 url 在同一台
机器上也可能有相同的 value/n 值。在每个机器上将 value/n 值作为 key，url 值作为 value 构成 hash 表进
行去重。最后将内存中去重后的 hash 表中的 value 值即 url 写入磁盘。合并磁盘中的各部分 url 文件，完成
去重。

56 byte;

4 G =4 _1024=4096 kb=4096_ 1024 byte;

#### 题目二：给定 a、b 两个文件，各存放 50 亿个 url，每个 url

#### 各占 64 字节，内存限制是 4 G，让你找出 a、b 文件共同的

#### url?

假如每个 url 大小为 10 bytes，那么可以估计每个文件的大小为 50 G×64=320 G，远远大于内存限制的
4 G，所以不可能将其完全加载到内存中处理，可以采用分治的思想来解决。

Step 1：遍历文件 a，对每个 url 求取 hash (url)%1000，然后根据所取得的值将 url 分别存储到 1000 个小文
件 (记为 a 0, a 1,..., a 999，每个小文件约 300 M);

Step 2: 遍历文件 b，采取和 a 相同的方式将 url 分别存储到 1000 个小文件 (记为 b 0, b 1,..., b 999);

巧妙之处：这样处理后，所有可能相同的 url 都被保存在对应的小文件 (a 0 vsb 0, a 1 vsb 1,..., a 999 vsb 999)
中，不对应的小文件不可能有相同的 url。然后我们只要求出这个 1000 对小文件中相同的 url 即可。

Step 3：求每对小文件 ai 和 bi 中相同的 url 时，可以把 ai 的 url 存储到 hash_set/hash_map 中。然后遍历 bi
的每个 url，看其是否在刚才构建的 hash_set 中，如果是，那么就是共同的 url，存到文件里面就可以
了。

草图如下 (左边分解 A，右边分解 B，中间求解相同 url)：


#### 题目三：有一个 1 G 大小的一个文件，里面每一行是一个

#### 词，词的大小不超过 16 字节，内存限制大小是 1 M，要求返

#### 回频数最高的 100 个词。

Step 1：顺序读文件中，对于每个词 x，取 hash (x)%5000，然后按照该值存到 5000 个小文件 (记为 f 0, f 1,
..., f 4999) 中，这样每个文件大概是 200 k 左右，如果其中的有的文件超过了 1 M 大小，还可以按照类似的
方法继续往下分，直到分解得到的小文件的大小都不超过 1 M;

Step 2：对每个小文件，统计每个文件中出现的词以及相应的频率 (可以采用 trie 树/hash_map 等)，并取
出出现频率最大的 100 个词 (可以用含 100 个结点的最小堆)，并把 100 词及相应的频率存入文件，这样又
得到了 5000 个文件;

Step 3：把这 5000 个文件进行归并 (类似与归并排序);

草图如下 (分割大问题，求解小问题，归并)：

#### 题目四：现有海量日志数据保存在一个超级大的文件中，

#### 该文件无法直接读入内存，要求从中提取某天出访问百度

#### 次数最多的那个 IP。

Step 1：从这一天的日志数据中把访问百度的 IP 取出来，逐个写入到一个大文件中;

Step 2：注意到 IP 是 32 位的，最多有 2^32 个 IP。同样可以采用映射的方法，比如模 1000 ，把整个大文件
映射为 1000 个小文件;

Step 3：找出每个小文中出现频率最大的 IP (可以采用 hash_map 进行频率统计，然后再找出频率最大的
几个) 及相应的频率;

Step 4：在这 1000 个最大的 IP 中，找出那个频率最大的 IP，即为所求。

草图如下：


## 腾讯二面： 40 亿 QQ 号, 1 G 内存，怎么去重？

#### 说在前面

在 40 岁老架构师尼恩的 **读者交流群** (50+) 中，最近有小伙伴拿到了一线互联网企业如腾讯、美团、阿
里、拼多多、极兔、有赞、希音的面试资格，遇到一几个很重要的面试题：

```
40 亿QQ号如何设计算法去重，相同的QQ号码仅保留一个，内存限制为 1 个G?
40 亿个QQ号，限制1G内存，如何去重？
```
与之类似的、其他小伙伴遇到过的问题还有：

```
60 亿个URL，限制1G内存，如何去重？
文件中有 40 亿个QQ号码，请设计算法对QQ号码去重，相同的QQ号码仅保留一个，内存限制1G.
等等等等.....
```
这里尼恩给大家做一下系统化、体系化的梳理，使得大家可以充分展示一下大家雄厚的 “技术肌肉”， **让
面试官爱到 “不能自已、口水直流”** 。

也一并把这个题目以及参考答案，收入咱们的《尼恩 Java 面试宝典》V 70 版本，供后面的小伙伴参考，
提升大家的 3 高架构、设计、开发水平。


```
最新《尼恩 架构笔记》《尼恩高并发三部曲 》、《尼恩Java面试宝典》 的PDF文件，请通过公众
号（技术自由圈）获取。
```
#### 问题场景分析

分析一下 QQ 号码的数量：

腾讯的 QQ 号都是 4 字节正整数 32 个 bit 位，所以 QQ 号码的个数是 43 亿左右，理论值 2^32-1 个，

又因为是无符号的，翻倍了一下，所以 43 亿左右。

回顾一下问题： 40 亿 QQ 号如何设计算法去重，相同的 QQ 号码仅保留一个，内存限制为 1 个 G?

问题的本质： 这个就是一个海量数据去重的问题，但是有一个受限条件，内存限制为 1 个 G。

解决方案有很多，但是主流的方案有两种：

```
方案 1 ： 使用BitMap进行海量数据去重
方案 2 ： 使用布隆过滤器进行海量数据去重
```
#### 方式 1 ： 使用 BitMap 进行海量数据去重

首先看看，什么是 BitMap？BitMap 的使用场景

###### 什么是 BitMap？有什么用？

所谓位图（BitMap）其实就是一个 bit 数组，即每一个位置都是一个 bit，其中的取值可以是 0 或者 1

位图（BitMap）思想：就是用一个 bit 来标记元素，bit 是计算机中最小的单位，也就是我们常说的计算
机中的 0 和 1 ，这种就是用一个位来表示的。

像上面的这个位图，可以用来记录三个数： 1 ， 4 ， 6 。为啥呢？ 第 1 位、第 4 位、第 6 位三个位置为 1 。

如果不用位图的话，我们想要记录 1 ， 4 ， 6 这三个整型的话，怎么办？

就需要用三个 unsigned int，已知每个 unsigned int 占 4 个字节，那么就是 3*4 = 12 个字节，一个字节
有 8 bit，那么就是 12*8 = 96 个 bit。

结论是：位图最大的好处就是节省空间。这里节省了 12 倍。

###### 如何使用 BitMap 进行 40 亿个 QQ 号去重？


回到问题： 40 亿个 QQ 号，限制 1 G 内存，如何去重？

前面分析过：一个 qq 号码，就是一个 unsigned int。

40 亿个 QQ 号，就是 40 亿个 unsigned int，一个 unsigned int 占用 4 个字节。

假如， 40 亿个 unsigned int 直接用内存存储的话，需要多少内存呢？

简单计算一下：

所以，如果直接把 40 亿个 QQ 号放入内存，需要 15 个 G，1 G 的空间也是不够用的。

那么，怎么办呢？

qq 号是数字，刚好可以使用 bitmap。

比如要把一个 QQ 号"12345678"放到 Bitmap 中，就需要找到第 12345678 这个位置，然后把他设置成 1
就可以了。

这样，把 40 亿个数字都放到 Bitmap 之后，位置上是 1 的表示存在，不为 1 的表示不存在。

相同的 QQ 号只需要设置一次 1 就可以了，那么，最终就把所有是 1 的数字遍历出来就行了。

使用位图的话，一个数字只需要占用 1 个 bit，那么 40 亿个数字也就是：

相比于之前的 14.9 G 来说，大大的节省了很多空间。

大约节省了 30 倍的空间。

###### BitMap 位图的优势和不足

```
1 4000000000*4 /1024/1024/1024 = 14.9G
```
```
1 4000000000 * 1 / 8 / 1024 / 1024 = 476 M
```

位图（BitMap），基本思想就是用一个 bit 来标记元素，bit 是计算机中最小的单位，也就是我们常说的
计算机中的 0 和 1 ，这种就是用一个位来表示的。

BitMap 位图的主要优势在于它可以非常高效地进行集合运算。具体来说，如果我们需要对一个集合进
行多次交集、并集、差集等操作，使用 BitMap 可以将这些操作的时间复杂度降低到 O (1) 级别，而传统
的集合实现则需要 O (n) 的时间复杂度，其中 n 是集合的大小。

此外，BitMap 还可以节省存储空间。对于一个只包含 0 和 1 的集合，我们可以使用一个比特位来表示
一个元素是否在集合中，这样可以将集合的存储空间降低到原来的 1/8 左右。

所以，位图最大的好处就是节省空间。

位图有很多种用途，特别适合用在去重、排序等场景中，著名的布隆过滤器就是基于位图实现的。

但是位图也有着一定的限制，那就是他只能表示 0 和 1 ，无法存储其他的数字。

所以 BitMap 只适合这种能表示 ture or false 的场景。

其次，BitMap 只适用于值域比较小的集合，因为如果值域过大，BitMap 的存储空间也会过大，这时候
使用布隆过滤器可能更为合适。

最后，BitMap 不支持删除操作，因为删除一个元素需要将对应的比特位设置为 0 ，这可能会影响到其
他元素的状态。

#### 方式 2 ： 使用布隆过滤器进行海量数据去重

如果值域过大，BitMap 的存储空间也会过大，这个时候，需要使用布隆过滤器，进一步进行空间的压
缩。

###### 什么是布隆过滤器，实现原理是什么？

布隆过滤器是一种数据结构，用于快速检索一个元素是否可能存在于一个集合 (bit 数组) 中。

它的基本原理是利用多个哈希函数，将一个元素映射成多个位，然后将这些位设置为 1 。

本质上：布隆过滤器内部包含一个 bit 数组和多个哈希函数，每个哈希函数都会生成一个 index 索引值。

由两个部分组成：

```
一个bit数组， 存储数据
多个哈希函数， 计算key的 index 索引
```
如下图所示，里边有三个 key： 尼恩 Java 面试宝典、史上最棒、八股文


问题：如何做 exist（key）这种存在性的判定呢？

答案：当查询一个元素时，如果这些位都被设置为 1 ，则认为元素可能存在于集合中，否则肯定不存在

比如说：

但是： 布隆过滤器可以准确的判断一个元素是否一定不存在。注意，是判断一定不存在。

为啥呢？ 因为哈希冲突的存在。

###### 什么是哈希冲突

什么是哈希冲突？ 哈希冲突是指两个或多个不同的 key 键值被映射到了同一个哈希值。

下面有个例子：

比如说，来了一个新的 key "技术自由圈" ，现在要判是否存在？

```
1 exist（"尼恩Java面试宝典"） 的结果为 true
```
```
1 exist（"技术自由圈"） 的结果为 true
```

结果是存在的。

为啥呢？

hash 1（"技术自由圈"）=1，为啥呢？ 这个之前被 hash 1（"史上最棒"）， hash 2（"尼恩 Java 面试
宝典"）设置过了，设置两次 1.

hash 2（"技术自由圈"）=1，为啥呢？ 这个之前被 hash 2（"史上最棒"）设置过了 1.

hash 3（"技术自由圈"）=1，为啥呢？ 这个之前被 hash 1（"尼恩 Java 面试宝典"）设置过了 1.

由于， hash 1（"技术自由圈"）=1 、 hash 2（"技术自由圈"）=1、 hash 3（"技术自由圈"）=1，所
以，exist（"技术自由圈"） 的结果为 true。

可以，key "技术自由圈" 之前真的没有设置过，是不存在的。

结论是：由于 hash 冲突，布隆过滤器没办法判断一个元素一定存在。只能判断可能存在。或者判不存
在。

如何降低存在性误判的概率

想要降低这种存在性误判的概率，主要的办法就是降低哈希冲突的概率及引入更多的哈希算法。

###### 布隆过滤器的工作过程

下面是布隆过滤器的工作过程：

1 、初始化布隆过滤器

在初始化布隆过滤器时，需要指定集合的大小和误判率。

2 、添加元素到布隆过滤器

要将一个元素添加到布隆过滤器中，首先需要将该元素通过多个哈希函数生成多个索引值，然后将这些
索引值对应的位设置为 1 。如果这些索引值已经被设置为 1 ，则不需要再次设置。

3 、查询元素是否存在于布隆过滤器中

要查询一个元素是否存在于布隆过滤器中，需要将该元素通过多个哈希函数生成多个索引值，并判断这
些索引值对应的位是否都被设置为 1 。如果这些位都被设置为 1 ，则认为元素可能存在于集合中，否则
肯定不存在。

布隆过滤器的主要优点是可以快速判断一个元素是否属于某个集合，并且可以在空间和时间上实现较高
的效率。

但是，它也存在一些缺点，例如：

（ 1 ）. 布隆过滤器在判断元素是否存在时，有一定的误判率。、

（ 2 ）. 布隆过滤器删除元素比较困难，因为删除一个元素需要将其对应的多个位设置为 0 ，但这些位可
能被其他元素共享。

###### 布隆过滤器举例

1. 布隆过滤器初始状态

布隆过滤器也是用一个二进制数组进行数据存储。

一开始，二进制数组里是没有值的


2. 存储操作

假设，存储一个数据数据 hello

首先，对数据 hello 经过三次 hash 运算，分别得到三个值（假设 1 ， 3 ， 5 ）。

然后，在对应的二进制数组里，将下标为 1 ， 3 ， 5 的值置为 1 。

3. 查询操作

对于数据 hello。对数据 hello 经过三次 hash 运算，分别得到三个值（假设 1 ， 3 ， 5 ）。

在二进制数组里，将下标为 1 ， 3 ， 5 的值取出来，如果都为 1 ，则表示该数据已经存在。

4. 删除操作

布隆过滤器在使用的时候，不建议进行删除操作。

布隆过滤器里边的部分 bit 位，完全可能被复用。

假设两个 key： hello、world，如果 hash 2 (hello) 结果为 3 ，hash 2 (world) 结果也为 3 ，那么如果删除了
hello 的 hash 2 (hello) 值，就意味着 world 的 hash 2 (world) 值也会被其删除。造成数据的误删。

5. 误判率

假设保存两个值，hello 和 world。hello 对应的三个 hash 计算后的 index 为 1 ， 3 ， 5 ，world 三个 hash
对应的 index（也就是 hash 计算后的值）也为 1 ， 3 ， 5 ，那么 exist (world) = true ，就是一种误判

###### 布隆过滤器应用场景

布隆过滤器因为他的效率非常高，所以被广泛的使用，比较典型的场景有以下几个：

1 、网页爬虫：爬虫程序可以使用布隆过滤器来过滤掉已经爬取过的网页，避免重复爬取和浪费资源。


2 、缓存系统：缓存系统可以使用布隆过滤器来判断一个查询是否可能存在于缓存中，从而减少查询缓
存的次数，提高查询效率。布隆过滤器也经常用来解决缓存穿透的问题。

3 、分布式系统：在分布式系统中，可以使用布隆过滤器来判断一个元素是否存在于分布式缓存中，避
免在所有节点上进行查询，减少网络负载。

4 、垃圾邮件过滤：布隆过滤器可以用于判断一个邮件地址是否在垃圾邮件列表中，从而过滤掉垃圾邮
件。

5 、黑名单过滤：布隆过滤器可以用于判断一个 IP 地址或手机号码是否在黑名单中，从而阻止恶意请
求。

###### 如何实现实现布隆过滤器

Java 中可以使用第三方库来实现布隆过滤器，常见的有 Google Guava 库和 Apache Commons 库以及
Redis。

**Guava 版本的布隆过滤器:**

尼恩特别说明： 这个版本的布隆过滤器，尼恩指导简历的时候，指导小伙伴用过。

Guava 20.0 版本已经引入了布隆过滤器 (BloomFilter) 的实现。你可以使用以下步骤来使用 Guava 的布隆
过滤器：

```
1. 引入Guava依赖：
```
```
2. 创建布隆过滤器：
```
其中，expectedInsertions 表示预期插入的元素数量，fpp 表示误判率 (false positive
probability)，Funnels.stringFunnel (Charset.defaultCharset ()) 表示元素类型为 String。

```
3. 添加元素：
```
```
4. 判断元素是否存在：
```
```
<dependency>
<groupId>com.google.guava</groupId>
<artifactId>guava</artifactId>
<version>20.0</version>
</dependency>
```
```
1
2
3
4
5
```
```
int expectedInsertions = 1000000 ;
double fpp = 0.01;
BloomFilter<String> bloomFilter =
BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()),
expectedInsertions, fpp);
```
```
1
2
3
```
```
bloomFilter.put("hello");
bloomFilter.put("world");
```
```
1
2
```
```
bloomFilter.mightContain("hello"); // true
bloomFilter.mightContain("world"); // true
bloomFilter.mightContain("test"); // false
```
```
1
2
3
```

注意，布隆过滤器判断元素是否存在，有一定的误判率。如果 mightContain 返回 false，则可以确定
该元素一定不存在；如果 mightContain 返回 true，则该元素可能存在，需要进一步验证。

```
5. 序列化和反序列化：
```
注意，序列化和反序列化的过程中，需要将 BloomFilter 类实现 Serializable 接口。

**Redisson 版本的布隆过滤器**

Redisson 是一个基于 Redis 的 Java 客户端，提供了丰富的分布式对象和服务，其中包括布隆过滤器。
Redisson 的布隆过滤器实现了标准的布隆过滤器算法，并提供了一些额外的功能，如自动扩容和持久
化等。

使用 Redisson 的布隆过滤器非常简单，只需要创建一个 RedissonClient 对象，然后通过该对象获取一
个 RBloomFilter 对象即可。

RBloomFilter 提供了一系列的方法，包括添加元素、判断元素是否存在、清空过滤器等。

以下是一个简单的使用 Redisson 布隆过滤器的示例代码：

```
// 序列化
FileOutputStream fos = new FileOutputStream("bloom_filter.bin");
ObjectOutputStream oos = new ObjectOutputStream(fos);
oos.writeObject(bloomFilter);
oos.close();
```
```
// 反序列化
FileInputStream fis = new FileInputStream("bloom_filter.bin");
ObjectInputStream ois = new ObjectInputStream(fis);
BloomFilter<String> bloomFilter2 = (BloomFilter<String>) ois.readObject();
ois.close();
```
```
1 2 3 4 5 6 7 8 9
```
```
10
11
12
```
```
// 创建 Redisson 客户端
Config config = new Config();
config.useSingleServer().setAddress("redis://127.0.0.1:6379");
RedissonClient redisson = Redisson.create(config);
```
```
// 获取布隆过滤器对象
RBloomFilter<String> bloomFilter = redisson.getBloomFilter("bloom-filter");
```
```
// 初始化布隆过滤器，设置预计元素数量和误判率
bloomFilter.tryInit( 10000 , 0.03);
```
```
// 添加元素
bloomFilter.add("hello");
bloomFilter.add("world");
```
```
// 判断元素是否存在
System.out.println(bloomFilter.contains("hello"));
System.out.println(bloomFilter.contains("redis"));
```
```
// 清空过滤器
bloomFilter.delete();
```
```
1 2 3 4 5 6 7 8 9
```
```
10
11
12
13
14
15
16
17
18
19
20
21
22
```

需要注意的是，Redisson 的布隆过滤器并不支持动态修改预计元素数量和误判率，因此在初始化时需
要仔细考虑这两个参数的取值。

**Jedis 版本的布隆过滤器**

如果没有用 Redisson， Jedis 也可以使用布隆过滤器，参考代码如下 ：

由于布隆过滤器存在一定的误判率，因此不能完全替代传统的数据结构，应该根据具体应用场景进行选
择。

#### 海量数据去重场景：布隆过滤器和位图如何选择

布隆过滤器和位图都是常用的数据结构，但它们的应用场景和实现方式不同。

布隆过滤器是一种概率型数据结构，用于判断一个元素是否存在于一个集合中。但有一定的误判概率。
因此，Bloom Filter 不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter
通过极少的错误换取了存储空间的极大节省。

位图是一种简单的数据结构，用于表示一个二进制序列。它通过一个比特位数组来表示一个集合，其中
每个比特位表示一个元素是否存在于集合中。当需要判断一个元素是否存在于集合中时，只需要检查对
应的比特位是否为 1 或 0 即可。

相比之下，布隆过滤器的空间效率更高，但存在一定的误判概率；而位图的空间效率较低，但不存在误
判。因此，在实际应用中，需要根据具体的场景选择合适的数据结构。

#### 说在最后

海量数据去重的的方案，是非常常见的面试题。

以上 2 大方案，如果大家能对答如流，如数家珍，基本上面试官会被你震惊到、吸引到。

最终， **让面试官爱到 “不能自已、口水直流”** 。 offer，也就来了。

学习过程中，如果有啥问题，大家可以来找 40 岁老架构师尼恩交流。

#### 参考文献：

清华大学出版社《尼恩 Java 高并发核心编程卷 2 加强版》

4000 页《尼恩 Java 面试宝典》中专题 29 多线程面试专题

[1]. https://www.infoq.cn/article/1afyz3b6hnhprrg12833

[2].https://www.iamle.com/archives/2900.html

```
Jedis jedis = new Jedis("localhost");
jedis.bfCreate("myfilter", 100 , 0.01);
jedis.bfAdd("myfilter", "Lynn");
jedis.bfAdd("myfilter", "666");
jedis.bfAdd("myfilter", "八股文");
System.out.println(jedis.bfExists("myfilter", "Lynn"));
System.out.println(jedis.bfExists("myfilter", "张三"));jedis.close();
```
```
1 2 3 4 5 6 7 8
```

[3].https://blog.51cto.com/lianghecai/4755693

[4].https://qinyuanpei.github.io/posts/1333693167/

[5].https://github.com/alibaba/canal/wiki/ClientAdapter

## 面试题：海量数据去重、Top-k、BitMap 问

## 题整理

精选原创

wx 641137 f 3 e 6 d 322023-04-03 14:38:20博主文章分类：Java©著作权

**文章标签 mavenjavaintellij-idea 海量数据数据*** *文章分类 Python 后端开发阅读数 411**

###### 问题引入

首先直接进入正题， 40 亿 QQ 号如何设计算法去重，相同的 QQ 号码仅保留一个，内存限制为 1 个 G。
（腾讯的 QQ 号都是 4 字节正整数，所以 QQ 号码的个数是 43 亿左右，理论值 2^32-1 个，又因为是无符号
的，翻倍了一下，所以 43 亿左右）

```
方法 1 ：排序
```
这估计也是最多人能够想到的解决方法，那就是排序，重复的 QQ 肯定会挨在一起，然后保留第一个，
去重就行了。排序后的去重比较简单就不在这里赘述。

但是这么做的问题显然很大，时间复杂大太高了，效率低下。

```
方法 2 ：hsahmap
hashmap的意思：
如果使用hashmap，好处是由于hashmap的去重性质，就可以做到去重。看似上个问题的效率问
题解决了，但是又遇到了新的问题，1g的内存太小，解决不了。
方法 3 ：文件切割
```
对于海量数据问题，可以使用文件切割方式，避免内存过大。但是还是需要使用文件间的归并排序、桶
排序、堆排序等等，但是这么多文件操作， 40 亿的数据量还是比较大，那么有没有更好的方法。

```
方法 4 ：bitmap位图操作
```
可以对 hashmap 进行优化，采用 bitmap 这种数据结构，可以顺利地同时解决时间问题和空间问题。

在很多实际项目中，bitmap 经常用到。

bitmap 就是一种位图。（位图的每一位都只有 0 和 1 两个状态）


上面是一个 unsigned char 类型的位图，一共有八位，那么取值范围就是 0-255，就可以标识 0-7 数字都
在，就比如说 bitmap【 6 】=1，那么就可以理解为，QQ 号为 6 的号码是存在的。

那么可以理解为实际上是利用他的下标来表示某个号码是否存在的。

一个 unsigned int 类型数据是 4 个字节，那么就是可以表示 0-31 这 32 个数字是否存在。
那么两个 unsigned int 就是 8 个字节，那么 8 x 8 bit 就是 0-63 个数字表示是否存在。

显然，容易推到，只需要申请 512 MB 的空间大小就可以标识所有 QQ 号码是否存在，那么就可以完成题
目要求了。形成一个 bitmap，例如 bitmap【 118677520 】= 1（ture）就代表我这个 QQ 号码是存在
的。

然后从小到大遍历所有的正整数（ 4 个字节），当 bitmap【】=1 的时候，就可以表明是存在的了。

这里再回顾下最开始的问题： 40 亿 QQ 号如何设计算法去重，相同的 QQ 号码仅保留一个，内存限制为 1
个 G。

现在进行问题拓展：
1 、文件中有 40 亿个互不相同的 QQ 号码，请设计算法对 QQ 号码进行排序，内存限制 1 G.
很显然还是上面的思路，直接用 bitmap，然后输出，输出后的正整数序列就是排序后的序列了。

2 、文件中有 40 亿个互不相同的 QQ 号码，求这些 QQ 号码的中位数，内存限制 1 G.
还是用 bitmap 排序比较合适。

3 、文件中有 40 亿个互不相同的 QQ 号码，求这些 QQ 号码的 top-K，内存限制 1 G.
可以使用小顶堆或者文件切割，但是用 bitmap 会更好一些。

经过上面的问题，会发现这类问题有趣多了，明显是有套路通解的。

#### 海量数据题总结

#### 1. Hash 算法处理海量数据部分

【题目 1 】(安卓越 2012) 给定 a、b 两个文件，各存放 50 亿个 url，每个 url 各占 64 字节，内存限制是 4 G，
让你找出 a、b 文件共同的 url？
【题目 2 】海量日志数据，提取出某日访问百度次数最多的那个 IP。
【题目 3 】有 10 个文件，每个文件 1 G，每个文件的每一行存放的都是用户的 query，每个文件的 query
都可能重复。要求你按照 query 的频度排序。
【题目 4 】有一个 1 G 大小的一个文件，里面每一行是一个词，词的大小不超过 16 字节，内存限制大小是
1 M。返回频数最高的 100 个词。

#### 2. Top-K 海量数据部分

【题目 1 】(360 公司 2012) 100 万条记录的文本文件，取出重复数最多的前 10 条。
【题目 2 】(360 公司 2012) 100 亿条记录的文本文件，取出重复数最多的前 10 条。
【题目 3 】(腾讯公司 2011) 服务器内存 1 G，有一个 2 G 的文件，里面每行存着一个 QQ 号（5-10 位数），
怎么最快找出出现过最多次的 QQ 号。
【题目 4 】(腾讯公司 2015 牛客网) 搜索引擎的日志要记录所有查询串, 有一千万条查询, 不重复的不超过


三百万，要统计最热门的 10 条查询串，内存<1 G，字符串长 0-255。
(1) 主要解决思路；(2) 算法及其复杂度分析。

#### 3. bit 海量数据部分

【题目 1 】(腾讯公司) 给 40 亿个不重复的 unsigned int 的整数，没排过序的，然后再给一个数，如何快速
判断这个数是否在那 40 亿个数当中？
【题目 2 】(July 整理) 在 2.5 亿个整数中找出不重复的整数，注，内存不足以容纳这 2.5 亿个整数。
【题目 3 】 40 亿 QQ 号如何设计算法去重，相同的 QQ 号码仅保留一个，内存限制为 1 个 G。

#### Hash 算法处理海量数据

hash：任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压
缩映射，其实 hash 就是找到一种数据内容和数据存放地址之间的映射关系。

hash 有几种常用的 hash 函数：
直接取余法、乘法取余法、平方取中法。

数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。那么我们
能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是哈希
表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为
“链表的数组”，如上图所示。

适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存。

那么 hash 算法在海量数据中的应用过程可以分这么几步：


1 、分而治之思想、hash 思想。
也就是说采用 hash 取模进行等价映射，将巨大的文件进行等价分割，注意，如果采用 hash 取模，不论
是什么 hash 函数，符合一定规律也就是同一种规律或同类数据都是会被分割到同一个小文件中的，变成
若干个小文件的操作。这个方法对于数据量很大的时候，内存有限制的时候是十分有效的。

2 、利用 haspmap 在内存中进行统计。
通过 Hash 映射将大文件分割为小文件后，就可以采用 HashMap 这样的存储结构来对小文件中的关注项
进行频率统计。具体的做法是将要进行统计的 Item 作为 HashMap 的 key，此 Item 出现的次数作为
value。

3 、对存储在 HashMap 中的数据根据出现的次数进行排序。
排序我们可以采用堆排序、快速排序、归并排序等方法。

现在可以看看具体的解法了。

题目 1 ：给定 a、b 两个文件，各存放 50 亿个 url，每个 url 各占 64 字节，内存限制是 4 G，让你找出 a、b 文
件共同的 url？

思路: 还是老一套，先 Hash 映射降低数据规模，然后统计排序。
具体做法：
**(1) 分析现有数据的规模**
按照每个 url 64 字节来算，每个文件有 50 亿个 url，那么每个文件大小为 5 G*64=320 G（按照 1000 换算 10
亿字节=1 GB）。320 G 远远超出内存限定的 4 G，所以不能将其全部加载到内存中来进行处理，需要采用
分而治之的方法进行处理。

**(2) Hash 映射分割文件**
逐行读取文件 a，采用 hash 函数：Hash (url)%1000 将 url 分割到 1000 个小文件中，文件即为
f 1_1, f 1_2, f 1_3,..., f 1_1000。那么理想情况下每个小文件的大小大约为 300 M 左右。再以相同的方法对大
文件 b 进行相同的操作再得到 1000 个小文件，记为： f 2_1, f 2_2, f 2_3,..., f 2_1000。

经过一番折腾后我们将大文件进行了分割并且将相同 url 都分割到了这 2 组小文件中下标相同的两个文件
中, 其实我们可以将这 2 组文件看成一个整体：

f 1_1& f 2_1， f 1_2& ,f 2_2, f 1_3& f 2_3,..., f 1_1000& f 2_1000

那么我们就可以将问题转化成为求这 1000 对小文件中相同的 url 就可以了。接下来，求每对小文件中的
相同 url，首先将每对对小文件中较小的那个的 url 放到 HashSet 结构中，然后遍历对应这对小文件中的
另一个文件，看其是否存才刚刚构建的 HashSet 中，如果存在说明是一样的 url，将这 url 直接存到结果
文件就 ok 了。如果存在大文件接着 hash 划分即可。


#### Top-K 问题解决

#### bitmap 处理海量数据


这类题的方法涉及到很多知识，包括：

Bloom Filter、Hash、Bit-Map、堆 (Heap)、分而治之、数据库索引、倒排索引、外排序、Trie 树 (字典
树)、MapReduce


```
技术自由圈
```
## 未来职业，如何突围：三栖架构师


```
技术自由圈
```
### 成功案例： 2 年翻 3 倍， 35 岁卷王成功转型为架构师

详情：http://topcoder.cloud/forum.php?mod=forumdisplay&fid=43&page=1


技术自由圈


技术自由圈


技术自由圈


```
技术自由圈
```
### 硬核推荐：尼恩 Java 硬核架构班

详情：https://www.cnblogs.com/crazymakercircle/p/9904544.html


技术自由圈


```
技术自由圈
```
##### 架构班（社群 VIP）的起源：

最初的视频，主要是给读者加餐。很多的读者，需要一些高质量的实操、理论视频，所以，我就围绕书，和底层，做了几个
实操、理论视频，然后效果还不错，后面就做成迭代模式了。

##### 架构班（社群 VIP）的功能：^

提供高质量实操项目整刀真枪的架构指导、快速提升大家的:
⚫ 开发水平
⚫ 设计水平
⚫ 架构水平
弥补业务中 CRUD 开发短板，帮助大家尽早脱离具备 3 高能力，掌握：
⚫ 高性能
⚫ 高并发
⚫ 高可用
作为一个高质量的架构师成长、人脉社群，把所有的卷王聚焦起来，一起卷：
⚫ 卷高并发实操
⚫ 卷底层原理
⚫ 卷架构理论、架构哲学
⚫ 最终成为顶级架构师，实现人生理想，走向人生巅峰

##### 架构班（社群 VIP）的目的：^

⚫ 高质量的实操，大大提升简历的含金量，吸引力，增强面试的召唤率
⚫ 为大家提供九阳真经、葵花宝典，快速提升水平
⚫ 进大厂、拿高薪
⚫ 一路陪伴，提供助学视频和指导，辅导大家成为架构师
⚫ 自学为主，和其他卷王一起，卷高并发实操，卷底层原理、卷大厂面试题，争取狠卷 3 月成高手，狠卷 3 年成为顶级架
构师


```
技术自由圈
```
##### N 个超高并发实操项目：简历压轴、个顶个精彩


```
技术自由圈
```
【样章】第 17 章：横扫全网 Rocketmq 视频第 2 部曲: 工业级 rocketmq 高可用（HA）底层原
理和实操

工业级 rocketmq 高可用底层原理，包含：消息消费、同步消息、异步消息、单向消息等不同消息的底层原理和源码实现；
消息队列非常底层的主从复制、高可用、同步刷盘、异步刷盘等底层原理。
工业级 rocketmq 高可用底层原理和搭建实操，包含：高可用集群的搭建。
解决以下难题：
1 、技术难题：RocketMQ 如何最大限度的保证消息不丢失的呢？RocketMQ 消息如何做到高可靠投递？
2 、技术难题：基于消息的分布式事务，核心原理不理解
3 、选型难题： kafka or rocketmq ，该娶谁？
下图链接：https://www.processon.com/view/6178e8ae0e3e7416bde9da19


```
技术自由圈
```
### 简历优化后的成功涨薪案例（ VIP 含免费简历优化）


技术自由圈


技术自由圈


技术自由圈


技术自由圈


技术自由圈


技术自由圈


技术自由圈


```
技术自由圈
```
### 修改简历找尼恩（资深简历优化专家）

⚫ 如果面试表达不好，尼恩会提供简历优化指导

⚫ 如果项目没有亮点，尼恩会提供项目亮点指导

⚫ 如果面试表达不好，尼恩会提供面试表达指导

作为 40 岁老架构师，尼恩长期承担技术面试官的角色：

⚫ 从业以来，“阅历”无数，对简历有着点石成金、改头换面、脱胎换骨的指导能力。

⚫ 尼恩指导过刚刚就业的小白，也指导过 P 8 级的老专家，都指导他们上岸。

如何联系尼恩。尼恩微信，请参考下面的地址：

语雀：https://www.yuque.com/crazymakercircle/gkkw8s/khigna
码云：https://gitee.com/crazymaker/SimpleCrayIM/blob/master/疯狂创客圈总目录.md


