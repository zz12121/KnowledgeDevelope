```
疯狂创客圈^
```
# 牛逼的职业发展之路

40 岁老架构尼恩用一张图揭秘: Java 工程师的高端职业发展路径，走向食物链顶端的之路

链接：https://www.processon.com/view/link/618a2b62e0b34d73f7eb3cd


```
疯狂创客圈
```
# 史上最全：价值 10 W 的架构师知识图谱

此图梳理于尼恩的多个 3 高生产项目：多个亿级人民币的大型 SAAS 平台和智慧城市项目

链接：https://www.processon.com/view/link/60fb9421637689719d


```
疯狂创客圈
```
# 牛逼的架构师哲学

40 岁老架构师尼恩对自己的 20 年的开发、架构经验总结

链接：https://www.processon.com/view/link/616f801963768961e9d9aec


```
疯狂创客圈
```
# 牛逼的 3 高架构知识宇宙

尼恩 3 高架构知识宇宙，帮助大家穿透 3 高架构，走向技术自由，远离中年危机

链接：https://www.processon.com/view/link/635097d2e0b34d40be778ab


```
疯狂创客圈
```
# 尼恩 Java 高并发三部曲（卷 1 加强版）

老版本：《Java 高并发核心编程卷 1 ：NIO、Netty、Redis、ZooKeeper》（已经过时，不建
议购买）

###### 新版本：《Java 高并发核心编程卷 1 加强版 ：NIO、Netty、Redis、ZooKeeper》

 由浅入深地剖析了高并发 IO 的底层原理。
 图文并茂的介绍了 TCP、HTTP、WebSocket 协议的核心原理。
 细致深入地揭秘了 Reactor 高性能模式。
 全面介绍了 Netty 框架，并完成单体 IM、分布式 IM 的实战设计。
 详尽地介绍了 ZooKeeper、Redis 的使用，以帮助提升高并发、可扩展能力

详情：https://www.cnblogs.com/crazymakercircle/p/16868827.html


```
疯狂创客圈
```
# 尼恩 Java 高并发三部曲（卷 2 加强版）

老版本：《Java 高并发核心编程卷 2 ：多线程、锁、JMM、JUC、高并发设计模式》
（已经过时，不建议购买）

###### 新版本：《Java 高并发核心编程卷 2 加强版 ：多线程、锁、JMM、JUC、高并发设计模式》

 由浅入深地剖析了 Java 多线程、线程池的底层原理。
 总结了 IO 密集型、CPU 密集型线程池的线程数预估算法。
 图文并茂的介绍了 Java 内置锁、JUC 显式锁的核心原理。
 细致深入地揭秘了 JMM 内存模型。
 全面介绍了 JUC 框架的设计模式与核心原理，并完成其高核心组件的实战介绍。
 详尽地介绍了高并发设计模式的使用，以帮助提升高并发、可扩展能力

详情参阅：https://www.cnblogs.com/crazymakercircle/p/16868827.html


```
疯狂创客圈
```
# 尼恩 Java 高并发三部曲（卷 3 加强版）

老版本：《SpringCloud Nginx 高并发核心编程》（已经过时，不建议购买）

###### 新版本：《Java 高并发核心编程卷 3 加强版 ：亿级用户 Web 应用架构与实战》

 在当今的面试场景中， 3 高知识是大家面试必备的核心知识，本书基于亿级用户 3 高 Web 应用
的架构分析理论，为大家对 3 高架构系统做一个系统化和清晰化的介绍。
 从 Java 静态代理、动态代理模式入手，抽丝剥茧地解读了 Spring Cloud 全家桶中 RPC 核心原
理和执行过程，这是高级 Java 工程师面试必备的基础知识。
 从 Reactor 反应器模式入手，抽丝剥茧地解读了 Nginx 核心思想和各配置项的底层知识和原理，
这是高级 Java 工程师、架构师面试必备的基础知识。
 从观察者模式入手，抽丝剥茧地解读了 RxJava、Hystrix 的核心思想和使用方法，这也是高级
Java 工程师、架构师面试必备的基础知识。

详情：https://www.cnblogs.com/crazymakercircle/p/16868827.html


```
疯狂创客圈
```
# 尼恩 Java 面试宝典

35 个专题（卷王专供+ 史上最全 + 2023 面试必备）
详情：https://www.cnblogs.com/crazymakercircle/p/13917138.html


## 专题 28 ：JVM 内存溢出实战（史上最全、定

## 期更新）

### 本文版本说明：V

```
此文的格式，由markdown 通过程序转成而来，由于很多表格，没有来的及调整，出现一个格式
问题，尼恩在此给大家道歉啦。
由于社群很多小伙伴，在面试，不断的交流最新的面试难题，所以，《Java面试红宝书》， 后面
会不断升级，迭代。
本专题，作为 《Java面试红宝书》专题之一， 《Java面试红宝书》一共 30 个面试专题，后续还
会增加
```
```
###
```
### V 16 版本升级说明：

```
聊聊：如何进行内存溢出OOM实操分析
聊聊：如何进行内存泄漏实操分析
```
##### 《Java 面试红宝书》升级的规划为：

```
后续基本上， 每一个月，都会发布一次 ，最新版本，可以扫描扫架构师尼恩微信， 发送 “领取电子书”
获取。
尼恩的微信二维码在哪里呢 ？ 请参见文末
```
##### 面试问题交流说明：

```
如果遇到面试难题，或者职业发展问题， 或者中年危机问题，都可以来 疯狂创客圈社群交流，
加入交流群，加尼恩微信即可，
入交流群 ，加尼恩微信即可， 发送 “入群”
```
page: 1/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


## JVM 性能优化面试题

```
JVM内存区域常见问题
Java 中会存在内存泄漏吗，简述一下？
Java 内存分配？
Java 堆的结构是什么样子的？
什么是堆中的永久代（Perm Gen space）?
简述各个版本内存区域的变化？
说说各个区域的作用？
```
**JVM 的执行子系统常见问题**
Java 类加载过程？
page: 2/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
描述一下 JVM 加载 Class 文件的原理机制?什么是类加载器？
类加载器有哪些？
类加载器双亲委派模型机制？
垃圾回收常见问题
什么是GC?
为什么要有 GC？
简述一下Java 垃圾回收机制？
如何判断一个对象是否存活？
垃圾回收的优点和原理，并考虑 2 种回收机制？
垃圾回收器的基本原理是什么？
垃圾回收器可以马上回收内存吗？
有什么办法主动通知虚拟机进行垃圾回收？
深拷贝和浅拷贝？
System.gc() 和 Runtime.gc() 会做些什么？
如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？
什么是分布式垃圾回收（DGC）？
它是如何工作的？
串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
在 Java 中，对象什么时候可以被垃圾回收？简述Minor GC 和 Major GC？JVM 的永久代中会发生垃圾
回收么？Java 中垃圾收集的方法有哪些？
```
```
性能优化常见问题
讲讲你理解的性能评价及测试指标？
常用的性能优化方式有哪些？
什么是GC调优？
```
### JVM 调优工具

```
Jconsole，jProfile，VisualVM
Jconsole : jdk自带，功能简单，但是可以在系统有一定负荷的情况下使用。对垃圾回收算法有很详细
的跟踪。详细说明参考这里
JProfiler ：商业软件，需要付费。功能强大。详细说明参考这里
VisualVM ：JDK自带，功能强大，与JProfiler类似。推荐。
```
page: 3/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
本文章向大家介绍JVM调优工具详解，主要内容包括前言、jdk自带工具、一、Jmap、1.2 jmap -
histo、1.3 jmap -heap、1.4 jmap -dump、二、Jstack、三、Jinfo、四、Jstat、垃圾回收统计、JVM运
行情况预估、内存泄露到底是怎么回事、五、Arthas、dashboard、thread、总结、基本概念、基础应
用、原理机制和需要注意的事项等，并结合实例形式分析了其使用技巧，希望通过本文能帮助到大家理
解应用这部分内容。
```
##### jps

```
事先启动一个web应用程序，用jps查看其进程id，接着用各种jdk自带命令优化应用
```
##### jmap -histo

```
可以使用“jmp -histo 进程id ” 此命令可以用来查看 内存信息，实例个数以及占用内存大小
打开log.txt，文件内容如下：
```
```
num：序号
instances：实例数量
bytes：占用空间大小
class name：类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int[][]
```
##### jmap -heap

```
查看对应 进程id 堆信息可以看到下面打印出堆的配置最大小容量等及Eden区From和Old区使用情况
```
##### jmap -dump

```
可以直接使用命令导出选择进程ID的dump文件
jmap ‐dump:format=b,file=eureka.hprof 14660
```
```
1. -XX:+HeapDumpOnOutOfMemoryError
2. -XX:HeapDumpPath=./ （路径） 也可以设置内存溢出自动导出dump文件(内存很大的时候，可
能会导不出来)
代码如下：
package com.jvm;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
public class OOMTest {
```
page: 4/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
当然也可以用jvisualvm命令工具导入该dump文件分析使用jvisualvm就更简单了只需要在cmd下输入
jvisualvm就可以打开
```
```
导入输出的dump文件
```
##### Jstack

```
用jstack加进程id查找死锁，代码见如下示例：
```
```
public static List<Object> list = new ArrayList<>();
// JVM设置
// -Xms10M -Xmx10M -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError
```
- XX:HeapDumpPath=D: jvm. dump
public static void main (String[] args) {
List<Object> list = new ArrayList<>();
int i = 0;
int j = 0;
while (true) {
list.add (new User (i++, UUID.randomUUID (). toString ()));
new User (j--, UUID.randomUUID (). toString ());
}
}
}

```
package com. jvm;
public class DeadLockTest {
```
```
private static Object lock 1 = new Object ();
private static Object lock 2 = new Object ();
public static void main (String[] args) {
new Thread (() ->{
synchronized (lock 1) {
try {
System.out.println ("thread 1 begin");
Thread.sleep (5000);
} catch (InterruptedException e) {
```
}
synchronized (lock 2) {
System.out.println ("thread 1 end");
}
page: 5/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
运行后打印线程详细信息
```
```
Thread-1′′ 线程名 prio=5 优先级=5 tid=0 x 000000001 fa 9 e 000 线程 id nid=0 x 2 d 64 线程对应的本地线
程标识 nid java. lang. Thread. State: BLOCKED 线程状态
```
```
图上详细的说明了 Thread-0 与 Thread-1 相互引用而造成死锁就连代码出现的行号也是打印出来了。
还可以用 jvisualvm 自动检测死锁只需要查看对应运行 java 的进程即可
```
##### Jinfo

```
查看正在运行的 Java 应用程序的扩展参数查看 jvm 的参数
查看 jvm 的参数 jinfo -flags 进程 ID
```
```
查看 java 系统参数 jinfo -sysprops 进程 ID
```
##### Jstat

```
jstat 命令可以查看堆内存各部分的使用量，以及加载类的数量。
命令的格式如下： jstat [-命令选项] [vmid] [间隔时间 (毫秒)] [查询次数] 注意：使用的 jdk 版本是 jdk
```
```
}
}). start ();
new Thread (() ->{
synchronized (lock 2) {
try {
System.out.println ("thread 2 begin");
Thread.sleep (5000);
} catch (InterruptedException e) {
```
```
}
synchronized (lock 1) {
System.out.println ("thread 2 end");
}
}
}). start ();
System.out.println ("main thread end");
}
```
```
}
```
page: 6/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


##### jstat -gc 垃圾回收统计

```
jstat -gc pid 最常用，可以评估程序内存使用及 GC 压力整体情况
```
```
S 0 C：第一个幸存区的大小，单位 KB
S 1 C：第二个幸存区的大小
S 0 U：第一个幸存区的使用大小
S 1 U：第二个幸存区的使用大小
EC：伊甸园区的大小
EU：伊甸园区的使用大小
OC：老年代大小
OU：老年代使用大小
MC：方法区大小 (元空间)
MU：方法区使用大小
CCSC: 压缩类空间大小
CCSU: 压缩类空间使用大小
YGC：年轻代垃圾回收次数
YGCT：年轻代垃圾回收消耗时间，单位 s
FGC：老年代垃圾回收次数
FGCT：老年代垃圾回收消耗时间，单位 s
GCT：垃圾回收消耗总时间，单位 s
```
###### JVM 运行情况预估

```
用 jstat gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，
先给自己的系统设置一些初始性的 JVM 参数，比如堆内存大小，年轻代大小，Eden 和 Survivor 的比例，
老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。
```
###### 年轻代对象增长的速率

```
可以执行命令 jstat -gc pid 1000 10 (每隔 1 秒执行 1 次命令，共执行 10 次)，通过观察 EU (eden 区的使用)
来估算每秒 eden 大概新增多少对象，如果系统负载不高，可以把频率 1 秒换成 1 分钟，甚至 10 分钟来观
察整体情况。注意，一般系统可能有高峰期和日常期，所以需要在不同的时间分别估算不同情况下对象
增长速率。
```
###### Young GC 的触发频率和每次耗时

```
知道年轻代对象增长速率我们就能推根据 eden 区的大小推算出 Young GC 大概多久触发一次，Young
GC 的平均耗时可以通过 YGCT/YGC 公式算出，根据结果我们大概就能知道系统大概多久会因为 Young
GC 的执行而卡顿多久。
```
###### 每次 Young GC 后有多少对象存活和进入老年代

```
这个因为之前已经大概知道 Young GC 的频率，假设是每 5 分钟一次，那么可以执行命令 jstat -gc pid
300000 10 ，观察每次结果 eden， survivor 和老年代使用的变化情况，在每次 gc 后 eden 区使用一般会
大幅减少，survivor 和老年代都有可能增长，这些增长的对象就是每次 Young GC 后存活的对象，同时
还可以看出每次 Young GC 后进去老年代大概多少对象，从而可以推算出老年代对象增长速率。
```
###### Full GC 的触发频率和每次耗时

```
知道了老年代对象的增长速率就可以推算出 Full GC 的触发频率了，Full GC 的每次耗时可以用公式
FGCT/FGC 计算得出。
```
page: 7/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
优化思路其实简单来说就是尽量让每次 Young GC 后的存活对象小于 Survivor 区域的 50%，都留存在年
轻代里。尽量别让对象进入老年代。尽量减少 Full GC 的频率，避免频繁 Full GC 对 JVM 性能的影响。
```
##### 内存泄露到底是怎么回事

```
再给大家讲一种情况，一般电商架构可能会使用多级缓存架构，就是 redis 加上 JVM 级缓存，大多数同学
可能为了图方便对于 JVM 级缓存就简单使用一个 hashmap，于是不断往里面放缓存数据，
但是很少考虑这个 map 的容量问题，结果这个缓存 map 越来越大，一直占用着老年代的很多空间，时
间长了就会导致 full gc 非常频繁，这就是一种内存泄漏，
对于一些老旧数据没有及时清理导致一直占用着宝贵的内存资源，
时间长了除了导致 full gc，还有可能导致 OOM。
这种情况完全可以考虑采用一些成熟的 JVM 级缓存框架来解决，比如 Caffiene 等自带一些 LRU 数据淘汰
算法的框架来作为 JVM 级的缓存。
```
### Arthas

```
Arthas 是 Alibaba 在 2018 年 9 月开源的 Java 诊断工具。
支持 JDK 6+，采用命令行交互模式，可以方便的定位和诊断线上程序运行问题。
Arthas 官方文档十分详细，详见：https://arthas.aliyun.com/en-us/
```
##### Arthas 使用

```
github 下载 arthas wget https://alibaba.github.io/arthas/arthas‐boot.jar
或者 Gitee 下载 wget https://arthas.gitee.io/arthas‐boot.jar
用 java -jar 运行即可，可以识别机器上所有 Java 进程 (我们这里之前已经运行了一个 Arthas 测试程序，代
码见下方
package com. jvm;
import java. util. HashSet;
public class Arthas {
```
private static HashSet hashSet = new HashSet ();
public static void main (String[] args) {
// 模拟 CPU 过高
cpuHigh ();
// 模拟线程死锁
deadThread ();
// 不断的向 hashSet 集合增加数据
addHashSetThread ();
}
/** * 不断的向 hashSet 集合添加数据 */
public static void addHashSetThread () {
// 初始化常量
new Thread (()-> {
page: 8/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
int count = 0;
while (true){
try {
hashSet.add ("count" + count);
Thread.sleep (1000);
count++;
}catch (InterruptedException e) {
e.printStackTrace ();
}
}
}). start ();
}
public static void cpuHigh () {
new Thread (()->{
while (true){
```
```
}
}). start ();
}
/** * 死锁 */
private static void deadThread () {
/** 创建资源 */
Object resourceA = new Object ();
Object resourceB = new Object ();
Thread threadA = new Thread (()->{
synchronized (resourceA){
System.out.println (Thread.currentThread () + " get ResourceA");
try {
Thread.sleep (1000);
}catch (InterruptedException e) {
e.printStackTrace ();
}
System.out.println (Thread.currentThread () + "waiting get
resourceB");
synchronized (resourceB){
System.out.println (Thread.currentThread () + " get
resourceB");
}
}
});
Thread threadB = new Thread (()->{
```
page: 9/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
选择进程序号 1 ，进入进程信息操作
```
### dashboard

```
输入 dashboard 可以查看整个进程的运行情况，线程、内存、GC、运行环境信息：
```
### thread

```
输入 thread 可以查看线程详细情况
```
```
输入 thread 加上线程 ID 可以查看线程堆栈
```
```
输入 thread -b 可以查看线程死锁
```
```
其实 Arthas 这个工具并没有大家想象的那么难
使用起来非常的简单
具体的命令可以用 help 命令查看，或查看文档：
https://arthas.aliyun.com/doc/advanced-use.html#id
更多的还是需要自己去摸索
```
```
synchronized (resourceB){
System.out.println (Thread.currentThread () + " get ResourceB");
try {
Thread.sleep (1000);
}catch (InterruptedException e) {
e.printStackTrace ();
}
System.out.println (Thread.currentThread () + "waiting get
resourceA");
synchronized (resourceA){
System.out.println (Thread.currentThread () + " get
resourceA");
}
}
});
threadA.start ();
threadB.start ();
}
}
```
page: 10/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


## JVisualVM 初探

```
VisualVM 是 Netbeans 的 profile 子项目，
已在 JDK 6.0 update 7 中自带 (java 启动时不需要特定参数，监控工具在 bin/jvisualvm. exe)，
能够监控线程，内存情况，查看方法的 CPU 时间和内存中的对象，已被 GC 的对象，反向查看分配的堆
栈 (如 100 个 String 对象分别由哪几个对象分配出来的)。
在 JDK_HOME/bin 目录下面，有一个 jvisualvm. exe 文件，
```
```
双击打开，从 UI 上来看，这个软件是基于 NetBeans 开发的了。
```
page: 11/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
其默认页面为：
```
```
左侧分为本地和远程。
可以进行远程和本地监控
本地监控，打开 VisualVM 后，会直接检测到本地的 Java 进程。
远程监控需要打开 jmx，通过 IP 地址，进行远程的连接。
```
```
双击本地中 VisualVM 线程，可以看到如下监控内容：
```
page: 12/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
具体的介绍参看：
http://www.ibm.com/developerworks/cn/java/j-lo-visualvm/
```
### VisualVM 插件

```
默认情况下，很多插件是没有的。比如 virtual GC 插件
```
```
VisualVM 可以根据需要安装不同的插件，
每个插件的关注点都不同，有的主要监控 GC，有的主要监控内存，有的监控线程等。
```
page: 13/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


### 如何安装插件：

```
1 、从主菜单中选择“工具”>“插件”。
2 、在“可用插件”标签中，选中该插件的“安装”复选框。单击“安装”。
3 、逐步完成插件安装程序。
我这里以 Eclipse (pid 22296) 为例，双击后直接展开，主界面展示了系统和 jvm 两大块内容，点击右下
方 jvm 参数和系统属性可以参考详细的参数信息.
```
```
因为 VisualVM 的插件太多，我这里主要介绍三个我主要使用几个：监控、线程、Visual GC
监控的主页其实也就是，cpu、内存、类、线程的图表
```
page: 14/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
线程和 jconsole 功能没有太大的区别
```
```
Visual GC 是常常使用的一个功能，可以明显的看到年轻代、老年代的内存变化，以及 gc 频率、gc 的时
间等。
```
page: 15/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
以上的功能其实 jconsole 几乎也有，VisualVM 更全面更直观一些，另外 VisualVM 非常多的其它功能，
可以分析 dump 的内存快照，
dump 出来的线程快照并且进行分析等，还有其它很多的插件大家可以去探索
```
##### JDK 自带的 jvisualvm 安装插件时报错

```
需要给 jvisualvm 添加个 visual gc 插件时，需要访问 github. io 但是发现访问如下图。
```
###### 在线更新插件地址

```
无法连接 Java VisualVM 插件中心,
因为 Zero sized file reported at
https://visualvm.java.net/uc/8u40/updates.xml.gz?unique=039f77b95-689f-47b0-96cd-62e51dd6
6456_be 47 e 117-6183-4 d 0 b-8579-66 f 262 b 40 b 35
```
page: 16/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
先到https://visualvm.github.io/pluginscenters.html
找到与你 jdk 版本相对应的 url
我是 1.8 的所以选择这个
```
```
复制对应的链接：https://visualvm.github.io/uc/8u131/updates.xml.gz
```
page: 17/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
然后修改 URL
```
```
然后就可以看到插件列表了
```
page: 18/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


##### 离线下载插件包

```
在线地址，不能开启，在线更新插件地址，没有路了
```
```
离线下载插件包
```
page: 19/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
打开 jdk 安装后 bin 目录下的 jvisualvm -> 工具 -> 插件 -> 已下载 -> 添加插件 -> 打开下载好的离线插件 -
> 安装
```
```
安装完后就可以看到监控信息多了个 Visual GC (如果安装完了没有，尝试重启 jvisualvm)
```
page: 20/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
注意：如果打开 Visual GC 工具，提示: 不受此 JVM 支持，
那是因为远程服务器上需要启动 jstatd 代理程序。
打开本地 java 应用 jvm 连接的 Visual GC 可以看到内存信息，是因为本地 jvisualvm 默认启动了 jstatd 代
理程序
```
##### 解决网络问题：

```
visualvm. github. io
https://visualvm.github.io/pluginscenters.html
```
###### dns 域名不能解析

```
出现原因是商的 dns 服务器有问题，所以改成了外部 dns 服务器，114.114.114.114，然后就可以访问
了。
```
```
测试后无效
```
###### 自己找 IP

最后一个办法了。
[http://tool.chinaz.com/dns](http://tool.chinaz.com/dns)
page: 21/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
如果没有 IP，多刷几次就可以了。
然后改 hosts 文件，需要用管理员权限才可以生效。
```
```
https://185.199.111.153/pluginscenters.html
https://visualvm.github.io/pluginscenters.html
```
### 实战内容:

##### 实操 1 ：OOM 后系统已挂，使用 JVisualVM 分析内存溢出 OOM

```
前置条件：
oom 时导出了堆的 dump 文件
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=
分析路径：
查看占用内存多的对象
找到对象实例的 GCRoot 对象
查看线程栈、找到业务代码
```
##### 实操 2 ：内存泄漏，使用 JVisualVM 分析内存泄漏

```
185.199.109.153 visualvm. github. io
```
page: 22/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
分析路径：
系统运行中、内存消耗越来越大
对比 dump 文件，看看那些对象实例，是不断增加的，就有可能存在内存溢出
```
### 实操 1 ：使用 JVisualVM 分析内存溢出 OOM

```
OOM 后系统已挂，使用 JVisualVM 分析内存溢出 OOM
```
```
分析路径：
查看占用内存多的对象
找到对象实例的 GCRoot 对象
查看线程栈、找到业务代码
```
```
前置条件：
oom 时导出了堆的 dump 文件
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=
分析路径：
查看占用内存多的对象
找到 GCRoot
查看线程栈、找到业务代码
```
##### 前提：oom 时导出了堆的 dump 文件

###### HeapDumpOnOutOfMemoryError 使用方法

```
1 、配置方法
在 JAVA_OPTIONS 变量中增加
```
```
例如：
```
```
2 、参数说明
```
```
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${目录}。
```
```
export JAVA_OPTS="-Xms 2048 M -Xmx 2048 M -Xmn 682 M -XX:MaxPermSize=96 M"
```
page: 23/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
（ 1 ）-XX:+HeapDumpOnOutOfMemoryError 参数表示当 JVM 发生 OOM 时，自动生成 DUMP 文件。
（ 2 ）-XX:HeapDumpPath=${目录}参数表示生成 DUMP 文件的路径，也可以指定文件名称，
例如：
```
```
如果不指定文件名，默认为：
```
###### HeapDumpPath

```
使用-XX: HeapDumpPath 配置的时候，需要保证目录的文件夹都是存在，
因为它在到处 dump 文件的时候，不会帮你去创建不存在的目录。
使用相对路径：
```
```
使用绝对路径：
```
##### 准备模拟内存泄漏 demo

```
1 、定义静态变量 HashMap
2 、分段循环创建对象，并加入 HashMap
代码如下：
```
```
-XX:HeapDumpPath=${目录}/java_heapdump. hprof
```
```
java_<pid>_<date>_<time>_heapDump. hprof
```
```
nohup java - Xms 512 M - Xmx 512 M - XX:+HeapDumpOnOutOfMemoryError -
XX:HeapDumpPath=./ - jar xxx. jar >/dev/null 2 >& 1 &
```
```
nohup java - Xms 512 M - Xmx 512 M - XX:+HeapDumpOnOutOfMemoryError -
XX:HeapDumpPath=/vagrant/chapter 26/ - jar xxx. jar >/dev/null 2 >& 1 &
```
```
package com. crazymaker. springcloud. demo. controller;
import com. alibaba. fastjson. JSONObject;
import com. crazymaker. springcloud. common. result. RestOut;
import com. crazymaker. springcloud. common. util. ThreadUtil;
import io. swagger. annotations. Api;
import io. swagger. annotations. ApiOperation;
import org. springframework. web. bind. annotation. GetMapping;
import org. springframework. web. bind. annotation. RequestMapping;
import org. springframework. web. bind. annotation. RestController;
```
page: 24/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
3 、配置 jvm 参数如下：
```
```
import java. util. HashMap;
import java. util. Map;
```
```
@Api (value = "JvmMemoryDemo", tags = {"JvmMemory"})
@RestController
@RequestMapping ("/jvm/file")
public class JvmMemoryDemoController {
private int count=0;
static class TestMemory {
int foo;
}
//声明缓存对象
private static final Map map = new HashMap ();
```
```
@GetMapping ("/addObject/v 1")
@ApiOperation (value = "添加对象到缓存")
public RestOut<JSONObject> addObject ()
{
//循环添加对象到缓存
for (int i=0; i<1_000_000; i++){
TestMemory t = new TestMemory ();
map.put ("key"+i, t);
}
JSONObject data = new JSONObject ();
data.put ("第 N 次操作：", ++count);
return RestOut.success (data). setRespMsg ("操作成功");
}
}
```
```
-Xms 150 m
-Xmx 150 m
```
page: 25/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


##### 第 1 步： 点击测试接口

```
http://192.168.56.121:7700/demo-provider/swagger-ui.html
```
##### 第 2 步： Jvm 发生内存溢出，再说导出堆

page: 26/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


##### 第 3 步： 找到 dump 文件

##### 第 4 步： 装入 dump 文件到 JvirtualVm

```
java. lang. OutOfMemoryError: Java heap space
Dumping heap to /vagrant/chapter 26/java_pid 26149. hprof ...
Heap dump file created [208327083 bytes in 1.117 secs]
```
page: 27/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


##### 第 5 步： JVisualVM 查看类的信息

##### 第 6 步： JVisualVM 查看实例的信息

page: 28/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
通过 GC-Root 对象，查看线程信息
```
##### 第 7 步： JVisualVM 查看线程的信息

### 实操 2 ：使用 JVisualVM 分析内存泄漏

```
分析路径：
系统运行中、内存消耗越来越大
```
page: 29/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
对比 dump 文件，看看那些对象实例，是不断增加的，就有可能存在内存溢出
```
##### 相关命令：导出堆的 dump 文件

```
1. 查看进程 id
jps
```
```
2. 查看内存状态
jmap -heap 进程 ID
```
```
3. 查看 JVM 堆中对象详情占用情况
jmap -histo 进程 ID
```
```
4. 导出整个 JVM 中内存信息，可以利用其它工具打开 dump 文件分析，例如 jdk 自带的 visualvm 工具
jmap -dump:file=文件名. dump [pid]
jmap -dump:format=b, file=文件名 [pid]
format=b 指定为二进制格式文件
```
```
一般情况下，是在 shell 脚本，配置这些选项：
使用脚本，速度更快：
```
##### 第 1 步：调整配置

```
function dump () {
pid=$(ps -ef | grep -v 'grep' | egrep $JAR_NAME| awk '{printf $2 " "}')
jps
echo "${JAR_NAME} is running and pid is $pid"
if [ "$pid" != "" ]; then
# jmap -dump:format=b, file=文件名
cmd="jmap -dump:format=b, file=dump 001. hprof $pid"
echo $cmd
eval $cmd
ls -l
else
echo "${JAR_NAME} is stopped"
fi
status
}
```
page: 30/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
免得一次就 oom 了，这一次，需要晚点 oom
```
##### 第 2 步：开始启动应用

```
http://192.168.56.121:7700/demo-provider/swagger-ui.html
```
##### 第 3 步：JVisualVM 远程监控 SpringBoot 应用

```
1 、修改远程 jvm 的启动命令，在其中增加：
```
```
这次配置先不走权限校验。
只是打开 jmx 端口。
```
```
2 、打开 jvisualvm，右键远程，选择添加远程主机：
```
```
PRO_NAME="demo-provider-1.0-SNAPSHOT"
JAR_NAME="${PRO_NAME}. jar"
WORK_PATH="/work/${PRO_NAME}"
MAIN_CLASS="com. crazymaker. springcloud. demo. start. DemoCloudApplication"
#JVM ="-server -Xms 64 m -Xmx 256 m"
#JVM ="-server -Xms 150 m -Xmx 150 m -XX:+HeapDumpOnOutOfMemoryError -
XX:HeapDumpPath=/vagrant/chapter 26/"
JVM="-server -Xms 500 m -Xmx 4 G -XX:+HeapDumpOnOutOfMemoryError -
XX:HeapDumpPath=/vagrant/chapter 26/"
```
```
JVM_monitor="-Djava. rmi. server. hostname=192.168.56.121 -
Dcom. sun. management. jmxremote. port=18999 -
Dcom. sun. management. jmxremote. rmi. port=18998 -Dcom. sun. management. jmxremote -
Dcom. sun. management. jmxremote. local. only=false -
Dcom. sun. management. jmxremote. authenticate=false -
Dcom. sun. management. jmxremote. ssl=false"
```
page: 31/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
3 、输入主机的名称，直接写 ip，如下：
```
```
右键新建的主机，选择添加 JMX 连接，输入在 tomcat 中配置的端口即可。
4 、双击打开。
```
```
导入 JVisualVM，并且 Visual GC 标签，内容如下，
这是输出 first 的截图
```
##### 第 4 步：第一次请求和 dump

page: 32/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
dump 堆，这里使用脚本，没有直接使用 jmap 命令
```
```
第 1 次请求之后，
```
page: 33/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


##### 第 5 步：第 2 次请求和 dump

```
第 2 次请求之后
```
```
dump 堆，这里使用脚本，没有直接使用 jmap 命令
```
page: 34/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


##### 第 6 步：第 6 次请求和 dump

```
第 6 次请求之后
```
```
dump 堆，这里使用脚本，没有直接使用 jmap 命令
```
page: 35/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


##### 第 3 步：对照三个 dump 文件

```
进入最后 dump 出来的堆标签，点击类：
```
```
点击右上角：“与另一个堆存储对比”。如图选择第一次导出的 dump 内容比较：
```
page: 36/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
比较结果如下：
```
page: 37/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
可以看出在两次间隔时间内 TestMemory 对象实例一直在增加并且多了，说明该对象引用的方法可能存
在内存泄漏。
如何查看对象引用关系呢？
右键选择类 TestMemory，选择“在实例视图中显示”，如下所示：
```
```
左侧是创建的实例总数，
右侧上部为该实例的结构，
下面为引用说明，
```
```
从图中可以看出在类 JvmMemoryDemoController 里面被引用了，并且被 HashMap 引用。
```
```
如此可以确定泄漏的位置，进而根据实际情况进行分析解决。
```
page: 38/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


### 如何进行 JVM 调优

```
观察内存释放情况、集合类检查、对象树
上面这些调优工具都提供了强大的功能，但是总的来说一般分为以下几类功能
堆信息查看
```
```
可查看堆空间大小分配（年轻代、年老代、持久代分配）
提供即时的垃圾回收功能
垃圾监控（长时间监控回收情况）
```
```
查看堆内类、对象信息查看：数量、类型等
```
page: 39/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
对象引用情况查看
有了堆信息查看方面的功能，我们一般可以顺利解决以下问题：
```
- 年老代年轻代大小划分是否合理
- 内存泄漏
- 垃圾回收算法设置是否合理

### 线程监控

```
线程信息监控：系统线程数量。
线程状态监控：各个线程都处在什么样的状态下
```
page: 40/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
Dump 线程详细信息：查看线程内部运行情况
死锁检查
热点分析
```
```
这两个东西对于系统优化很有帮助。
我们可以根据找到的热点，有针对性的进行系统的瓶颈查找和进行系统优化，而不是漫无目的的进行所
有代码的优化。
```
```
CPU 热点：检查系统哪些方法占用的大量 CPU 时间
内存热点：检查哪些对象在系统中数量最大（一定时间内存活对象和销毁对象一起统计）
```
page: 41/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
快照分析
快照是系统运行到某一时刻的一个定格。
在我们进行调优的时候，不可能用眼睛去跟踪所有系统变化，
依赖快照功能，我们就可以进行系统两个不同运行时刻，对象（或类、线程等）的不同，以便快速找到
问题
举例说，我要检查系统进行垃圾回收以后，是否还有该收回的对象被遗漏下来的了。
那么，我可以在进行垃圾回收前后，分别进行一次堆情况的快照，然后对比两次快照的对象情况。
```
### 内存泄漏检查

```
内存泄漏是比较常见的问题，而且解决方法也比较通用，这里可以重点说一下，而线程、热点方面的问
题则是具体问题具体分析了。
内存泄漏一般可以理解为系统资源（各方面的资源，堆、栈、线程等）在错误使用的情况下，导致使用
完毕的资源无法回收（或没有回收），从而导致新的资源分配请求无法完成，引起系统错误。
内存泄漏对系统危害比较大，因为他可以直接导致系统的崩溃。
需要区别一下，内存泄漏和系统超负荷两者是有区别的，虽然可能导致的最终结果是一样的。
内存泄漏是用完的资源没有回收引起错误，而系统超负荷则是系统确实没有那么多资源可以分配了（其
他的资源都在使用）。
年老代堆空间被占满
异常： java. lang. OutOfMemoryError: Java heap space
说明：
```
```
这是最典型的内存泄漏方式，简单说就是所有堆空间都被无法回收的垃圾对象占满，虚拟机无法再在分
配新空间。
如上图所示，这是非常典型的内存泄漏的垃圾回收情况图。
所有峰值部分都是一次垃圾回收点，所有谷底部分表示是一次垃圾回收后剩余的内存。
连接所有谷底的点，可以发现一条由底到高的线，这说明，随时间的推移，系统的堆空间被不断占满，
最终会占满整个堆空间。因此可以初步认为系统内部可能有内存泄漏。
（上面的图仅供示例，在实际情况下收集数据的时间需要更长，比如几个小时或者几天）
```
page: 42/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
解决：
这种方式解决起来也比较容易，一般就是根据垃圾回收前后情况对比，同时根据对象引用情况（常见的
集合对象引用）分析，基本都可以找到泄漏点。
持久代被占满
异常： java. lang. OutOfMemoryError: PermGen space
说明：
Perm 空间被占满。
无法为新的 class 分配存储空间而引发的异常。这个异常以前是没有的，但是在 Java 反射大量使用的今天
这个异常比较常见了。主要原因就是大量动态反射生成的类不断被加载，最终导致 Perm 区被占满。
更可怕的是，不同的 classLoader 即便使用了相同的类，但是都会对其进行加载，相当于同一个东西，
如果有 N 个 classLoader 那么他将会被加载 N 次。因此，某些情况下，这个问题基本视为无解。当然，存
在大量 classLoader 和大量反射类的情况其实也不多。
解决：
1. -XX:MaxPermSize=16 m
2. 换用 JDK。比如 JRocket。
堆栈溢出
异常： java. lang. StackOverflowError
说明： 这个就不多说了，一般就是递归没返回，或者循环调用造成
线程堆栈满
异常 ：Fatal: Stack size too small
说明 ：java 中一个线程的空间大小是有限制的。JDK 5.0 以后这个值是 1 M。与这个线程相关的数据将会
保存在其中。但是当线程空间满了以后，将会出现上面异常。
解决 ：增加线程栈大小。-Xss 2 m。但这个配置无法解决根本问题，还要看代码部分是否有造成泄漏的
部分。
系统内存被占满
异常 ：java. lang. OutOfMemoryError: unable to create new native thread
说明 ：
这个异常是由于操作系统没有足够的资源来产生这个线程造成的。系统创建线程时，除了要在 Java 堆中
分配内存外，操作系统本身也需要分配资源来创建线程。因此，当线程数量大到一定程度以后，堆中或
许还有空间，但是操作系统分配不出资源来了，就出现这个异常了。
分配给 Java 虚拟机的内存愈多，系统剩余的资源就越少，因此，当系统内存固定时，分配给 Java 虚拟机
的内存越多，那么，系统总共能够产生的线程也就越少，两者成反比的关系。同时，可以通过修改-Xss
来减少分配给单个线程的空间，也可以增加系统总共内生产的线程数。
解决：
3. 重新设计系统减少线程数量。
4. 线程数量不能减少的情况下，通过-Xss 减小单个线程大小。以便能生产更多的线程。
```
page: 43/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


## jvm 参数优化建议

```
如果是频繁创建对象的应用，可以适当增加新生代大小。常量较多可以增加持久代大小。对于单例较多
的对象可以增加老生代大小。比如 spring 应用中。
GC 选择，在 JDK 5.0 以后，JVM 会根据当前系统配置进行判断。一般执行-Server 命令便可以。
gc 包括三种策略：串行，并行，并发。
吞吐量大大应用，一般采用并行收集，开启多个线程，加快 gc 的是否。
响应速度高的应用，一般采用并发收集，比如应用服务器。
```
## 如何防止被 Linux 系统 OOM ( Out Of

## Memory Killer) 暗杀

```
Linux 内核根据服务器上当前运行应用的需要来分配内存。
因为这通常是预先发生的，所以应用并不会使用所有分配的内存。这将会导致资源浪费，Linux 内核允
许超分内存以提高内存使用效率。
Linux 内核允许超分内存，比如总共 8 G 内存，可以分给 10 个进程各 1 G，这通常没问题。
但问题发生在太多应用一起占用内存，有 8 个进程各占了 1 G，剩下两个进程要喝西北风了。
由于内存不足，服务器有崩溃的风险。
The server runs the risk of crashing because it ran out of memory。
为了防止服务器到达这个临近状态，内核中有一个 OOM Killer 杀手进程。
To prevent the server from reaching that critical state, the kernel also contains a process known
as the OOM Killer。
内核利用这个杀手进程开始屠杀那些非必要进程，以便服务器正常运行。
The kernel uses this process to start killing non-essential processes so the server can remain
operational.
```
```
本质上是减少 GC 的次数。
```
```
年老代建议配置为并发收集器，由于并发收集器不会压缩和整理磁盘碎片，因此建议配置：
-XX:+UseConcMarkSweepGC #并发收集年老代
-XX:CMSInitiatingOccupancyFraction=80 # 表示年老代空间到 80%时就开始执行 CMS
-XX:+UseCMSCompactAtFullCollection # 打开对年老代的压缩。可能会影响性能，但是可以消除内
存碎片。
-XX:CMSFullGCsBeforeCompaction=10 # 由于并发收集器不对内存空间进行压缩、整理，所以运行一
段时间以后会产生“碎片”，使得运行效率降低。此参数设置运行次 FullGC 以后对内存空间进行压缩、整理。
```
page: 44/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
当你认为这一切都不是问题时，因为 OOM Killer 只杀掉那些非必要的，不是用户需要的进程。
举例，两个应用 (Apache 和 MySQL) 通常先被杀掉，因为占用大量的内存。但这将导致一个 web 网站立马
瘫痪了。
为啥某个进程被杀?
当尝试找到为什么一个应用程序或进程被 OOM killer 杀掉时，有很多地方可以找到一个进程如何被杀掉
以及被杀掉的原因。
```
###### 1) 系统日志

```
$ grep -i kill /var/log/messages
host kernel: Out of Memory: Killed process 5123 (exampleprocess)
The capital K in Killed tells you that the process was killed with a -9 signal, and this typically is a
good indicator that the OOM Killer is to blame.
```
###### 2) 检查服务器的高低内存统计

```
$ free -lh
The -l switch shows high and low memory statistics, and the -h switch puts the output into
gigabytes for easier human readability. You can change this to the -m switch if you prefer the
output in megabytes.
同时该命令会给出 Swap 内存使用信息。
注意：free 命令给出某个时刻得数据，需要多执行几次才能知道内存动态的占用情况。
```
###### 3) vmstat 可以给出某个时间段内的内存使用情况

```
$ vmstat -SM 10 20
20 次，每次间隔 10 秒给出内存使用情况。
```
###### 4) top 命令查看内存

```
top 默认输出 CPU 的使用情况，不过你可以在 top 后再按下 shift + M，你将得到内存的使用情况。
```
##### 如何配置 (Configure the OOM Killer)

###### 1) 内存不足则重启

```
配置文件 /etc/sysctl. conf：
```
```
使用命令
```
```
sysctl vm. panic_on_oom=1
sysctl kernel. panic=X
```
```
echo “vm. panic_on_oom=1” >> /etc/sysctl. conf
echo “kernel. panic=X” >> /etc/sysctl. conf
```
page: 45/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
大多数情况下，内存不足时每次都重启是不合适的。
```
###### 2) 修改进程的优先级

```
既可以保护一些重要进程不被 OMM killer 杀掉，又可以让不重要的进程更容易杀掉:
```
###### 3) 豁免一个进程 Exempt a process

```
在某些情况下，豁免进程可能导致意外的行为变化，取决于系统和资源配置。
假如内核无法杀死一个占用大量内存的进程，将杀死其他进程，包括那些重要的操作系统进程。
由于 OOM killer 可调节的有效范围在-16 到+15 之间，设置为-17 将豁免一个进程，因为在 OOM killer 调
节范围之外。
通常的规则是这个参数越大越容易被杀死豁免一个进程的命令是
```
###### 4) 有风险的参数

```
警告：不建议用于生产环境。
假如重启，修改进程优先级，豁免一个进程不足够好，有个风险的选项：
将 oom killer 功能关闭。
```
```
使用命令
```
```
这一选项参数将有如下影响：
严重的内核恐慌 kernel panic
系统挂住 system hang-up
一个完整的系统崩溃 system crash
为什么关闭有风险呢呢？
如果你关闭此功能，将不能避免内存耗尽。考虑此项时请极度慎重。不推荐用在生产环境
```
### 参考文献：

```
echo -15 > /proc/(PID)/oom_adj (不被杀)
echo 10 > /proc/(PID)/oom_adj (更易杀)
pstree -p | grep "process" | head -1
```
```
echo -17 > /proc/(PID)/oom_adj
```
```
sysctl vm. overcommit_memory=2
```
```
echo “vm. overcommit_memory=2” >> /etc/sysctl. conf
```
page: 46/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
http://www.manongjc.com/detail/63-vghxrdhsiblevlf.html
https://www.cnblogs.com/krock/p/14421332.html
https://www.cnblogs.com/krock/p/14421332.html
https://www.cnblogs.com/pxblog/p/16102490.html
https://blog.csdn.net/lusa1314/article/details/84134458
```
page: 47/47 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
疯狂创客圈^
```
# 硬核推荐：尼恩 Java 硬核架构班

## 又名疯狂创客圈社群 VIP

## 详情：https://www.cnblogs.com/crazymakercircle/p/9904544.html


疯狂创客圈^


```
疯狂创客圈^
```
#### 架构班（社群 VIP）的起源：^

最初的视频，主要是给读者加餐。很多的读者，需要一些高质量的实操、理论视频，所以，我就围绕书，和
底层，做了几个实操、理论视频，然后效果还不错，后面就做成迭代模式了。

#### 架构班（社群 VIP）的功能：^

提供高质量实操项目整刀真枪的架构指导、快速提升大家的:
 开发水平
 设计水平
 架构水平
弥补业务中 CRUD 开发短板，帮助大家尽早脱离具备 3 高能力，掌握：
 高性能
 高并发
 高可用
作为一个高质量的架构师成长、人脉社群，把所有的卷王聚焦起来，一起卷：
 卷高并发实操
 卷底层原理
 卷架构理论、架构哲学
 最终成为顶级架构师，实现人生理想，走向人生巅峰

#### 架构班（社群 VIP）的目的：^

 高质量的实操，大大提升简历的含金量，吸引力，增强面试的召唤率
 为大家提供九阳真经、葵花宝典，快速提升水平
 进大厂、拿高薪
 一路陪伴，提供助学视频和指导，辅导大家成为架构师
 自学为主，和其他卷王一起，卷高并发实操，卷底层原理、卷大厂面试题，争取狠卷 3 月成高手，狠卷
3 年成为顶级架构师


```
疯狂创客圈^
```
#### N 个超高并发实操项目：简历压轴、个顶个精彩


```
疯狂创客圈^
```
###### 【样章】第 17 章：横扫全网 Rocketmq 视频第 2 部曲: 工业级 rocketmq 高可用（HA）

###### 底层原理和实操

工业级 rocketmq 高可用底层原理，包含：消息消费、同步消息、异步消息、单向消息等不同消息的底层原理
和源码实现；消息队列非常底层的主从复制、高可用、同步刷盘、异步刷盘等底层原理。
工业级 rocketmq 高可用底层原理和搭建实操，包含：高可用集群的搭建。
解决以下难题：
1 、技术难题：RocketMQ 如何最大限度的保证消息不丢失的呢？RocketMQ 消息如何做到高可靠投递？
2 、技术难题：基于消息的分布式事务，核心原理不理解
3 、选型难题： kafka or rocketmq ，该娶谁？
下图链接：https://www.processon.com/view/6178e8ae0e3e7416bde9da19


```
疯狂创客圈^
```
#### 成功案例：^2 年翻^3 倍，^35 岁卷王成功转型为架构师^

详情：http://topcoder.cloud/forum.php?mod=forumdisplay&fid=43&page=1


疯狂创客圈^


疯狂创客圈^


疯狂创客圈^


```
疯狂创客圈^
```
#### 简历优化后的成功涨薪案例（VIP 含免费简历优化）


疯狂创客圈^


疯狂创客圈^


疯狂创客圈^


疯狂创客圈^


疯狂创客圈^


```
疯狂创客圈^
```
# 修改简历找尼恩（资深简历优化专家）

 如果面试表达不好，尼恩会提供简历优化指导

 如果项目没有亮点，尼恩会提供项目亮点指导

 如果面试表达不好，尼恩会提供面试表达指导

作为 40 岁老架构师，尼恩长期承担技术面试官的角色：

 从业以来，“阅历”无数，对简历有着点石成金、改头换面、脱胎换骨的指导能力。

 尼恩指导过刚刚就业的小白，也指导过 P 8 级的老专家，都指导他们上岸。

如何联系尼恩。尼恩微信，请参考下面的地址：

语雀：https://www.yuque.com/crazymakercircle/gkkw8s/khigna
码云：https://gitee.com/crazymaker/SimpleCrayIM/blob/master/疯狂创客圈总目录.md


