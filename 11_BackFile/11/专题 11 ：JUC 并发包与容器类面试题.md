```
疯狂创客圈 尼恩Java面试宝典^
```
# 牛逼的职业发展之路

40 岁老架构尼恩用一张图揭秘: Java 工程师的高端职业发展路径，走向食物链顶端的之路

链接：https://www.processon.com/view/link/618a2b62e0b34d73f7eb3cd


```
疯狂创客圈 尼恩Java面试宝典
```
# 史上最全：价值 10 W 的架构师知识图谱

此图梳理于尼恩的多个 3 高生产项目：多个亿级人民币的大型 SAAS 平台和智慧城市项目

链接：https://www.processon.com/view/link/60fb9421637689719d


```
疯狂创客圈 尼恩Java面试宝典
```
# 牛逼的架构师哲学

40 岁老架构师尼恩对自己的 20 年的开发、架构经验总结

链接：https://www.processon.com/view/link/616f801963768961e9d9aec


```
疯狂创客圈 尼恩Java面试宝典
```
# 牛逼的 3 高架构知识宇宙

尼恩 3 高架构知识宇宙，帮助大家穿透 3 高架构，走向技术自由，远离中年危机

链接：https://www.processon.com/view/link/635097d2e0b34d40be778ab


```
疯狂创客圈 尼恩Java面试宝典
```
# 尼恩 Java 高并发三部曲（卷 1 加强版）

老版本：《Java 高并发核心编程卷 1 ：NIO、Netty、Redis、ZooKeeper》（已经过时，不建
议购买）

###### 新版本：《Java 高并发核心编程卷 1 加强版 ：NIO、Netty、Redis、ZooKeeper》

 由浅入深地剖析了高并发 IO 的底层原理。

 图文并茂的介绍了 TCP、HTTP、WebSocket 协议的核心原理。

 细致深入地揭秘了 Reactor 高性能模式。

 全面介绍了 Netty 框架，并完成单体 IM、分布式 IM 的实战设计。

 详尽地介绍了 ZooKeeper、Redis 的使用，以帮助提升高并发、可扩展能力

详情：https://www.cnblogs.com/crazymakercircle/p/16868827.html


```
疯狂创客圈 尼恩Java面试宝典
```
# 尼恩 Java 高并发三部曲（卷 2 加强版）

老版本：《Java 高并发核心编程卷 2 ：多线程、锁、JMM、JUC、高并发设计模式》
（已经过时，不建议购买）

###### 新版本：《Java 高并发核心编程卷 2 加强版 ：多线程、锁、JMM、JUC、高并发设计模式》

 由浅入深地剖析了 Java 多线程、线程池的底层原理。

 总结了 IO 密集型、CPU 密集型线程池的线程数预估算法。

 图文并茂的介绍了 Java 内置锁、JUC 显式锁的核心原理。

 细致深入地揭秘了 JMM 内存模型。

 全面介绍了 JUC 框架的设计模式与核心原理，并完成其高核心组件的实战介绍。

 详尽地介绍了高并发设计模式的使用，以帮助提升高并发、可扩展能力

详情参阅：https://www.cnblogs.com/crazymakercircle/p/16868827.html


```
疯狂创客圈 尼恩Java面试宝典
```
# 尼恩 Java 高并发三部曲（卷 3 加强版）

老版本：《SpringCloud Nginx 高并发核心编程》（已经过时，不建议购买）

###### 新版本：《Java 高并发核心编程卷 3 加强版 ：亿级用户 Web 应用架构与实战》

 在当今的面试场景中， 3 高知识是大家面试必备的核心知识，本书基于亿级用户 3 高 Web 应用

```
的架构分析理论，为大家对 3 高架构系统做一个系统化和清晰化的介绍。
```
 从 Java 静态代理、动态代理模式入手，抽丝剥茧地解读了 Spring Cloud 全家桶中 RPC 核心原

```
理和执行过程，这是高级Java工程师面试必备的基础知识。
```
 从 Reactor 反应器模式入手，抽丝剥茧地解读了 Nginx 核心思想和各配置项的底层知识和原理，

```
这是高级Java工程师、架构师面试必备的基础知识。
```
 从观察者模式入手，抽丝剥茧地解读了 RxJava、Hystrix 的核心思想和使用方法，这也是高级

```
Java工程师、架构师面试必备的基础知识。
```
详情：https://www.cnblogs.com/crazymakercircle/p/16868827.html


## 专题 11 ：JUC 并发包与容器类面试题（史上最

## 全、定期更新）

### 本文版本说明：V

```
此文的格式，由markdown 通过程序转成而来，由于很多表格，没有来的及调整，出现一个格式
问题，尼恩在此给大家道歉啦。
由于社群很多小伙伴，在面试，不断的交流最新的面试难题，所以，《Java面试红宝书》， 后面
会不断升级，迭代。
```
```
本专题，作为 《Java面试红宝书》专题之一， 《Java面试红宝书》一共 30 个面试专题，后续还
会增加
```
##### 《Java 面试红宝书》升级的规划为：

```
后续基本上， 每一个月，都会发布一次 ，最新版本，可以扫描扫架构师尼恩微信， 发送 “领取电子书”
获取。
```
```
尼恩的微信二维码在哪里呢 ？ 请参见文末
```
##### 面试问题交流说明：

```
如果遇到面试难题，或者职业发展问题， 或者中年危机问题，都可以来 疯狂创客圈社群交流，
```
```
加入交流群，加尼恩微信即可，
```
## 学习说明，这部分内容，建议大家配合卷 2 一

## 起学习

```
卷 2 获得好评非常多，甚至被小伙伴评为 直逼jolt大奖
```
### 卷 2 被小伙伴评为直逼 jolt 大奖

page: 1/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


## 内存可见性、指令有序性理论

### Java 内存模型

### 重排序与数据依赖性

### 为什么代码会重排序？

```
在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是
你想怎么排序就怎么排序，它需要满足以下两个条件：
```
```
在单线程环境下不能改变程序运行的结果；
存在数据依赖关系的不允许重排序
需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。
```
### as-if-serial 规则和 happens-before 规则的区别

```
as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多
线程程序的执行结果不被改变。
as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行
的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多
线程程序是按happens-before指定的顺序来执行的。
as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽
可能地提高程序执行的并行度。
```
### volatile 内存可见性

page: 2/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


### volatile 关键字的作用

```
对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happens-
before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会
保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
```
```
从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见
java.util.concurrent.atomic 包下的类，比如 AtomicInteger。
```
```
volatile 常用于多线程环境下的单次操作(单次读或者单次写)。
```
### Java 中能创建 volatile 数组吗？

```
能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如
果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile
标示符就不能起到之前的保护作用了。
```
### volatile 变量和 atomic 变量有什么不同？

```
volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用
volatile 修饰 count 变量，那么 count++ 操作就不是原子性的。
```
```
而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如getAndIncrement()方法会原子
性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。
```
### volatile 能使得一个非原子操作变成原子操作吗？

```
关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个
实例变量需要加锁进行同步。
```
```
虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。
所以从Oracle Java Spec里面可以看到：
```
```
对于 64 位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时
候，可以分成两步，每次对 32 位操作。
如果使用volatile修饰long和double，那么其读写都是原子操作
对于 64 位的引用地址的读写，都是原子操作
在实现JVM时，可以自由选择是否把读写long和double作为原子操作
推荐JVM实现为原子操作
```
### volatile 修饰符的有过什么实践？

```
单例模式
```
```
是否 Lazy 初始化：是
是否多线程安全：是
```
```
实现难度：较复杂
```
```
描述：对于Double-Check这种可能出现的问题（当然这种概率已经非常小了，但毕竟还是有的嘛~），
解决方案是：只需要给instance的声明加上volatile关键字即可volatile关键字的一个作用是禁止指令重
排，把instance声明为volatile之后，对它的写操作就会有一个内存屏障（什么是内存屏障？），这样，
在它的赋值完成之前，就不用会调用读操作。注意：volatile阻止的不是singleton = newSingleton()这
```
page: 3/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
句话内部[1-2-3]的指令重排，而是保证了在一个写操作（[1-2-3]）完成之前，不会调用读操作（if
(instance == null)）。
```
### synchronized 和 volatile 的区别是什么？

```
synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。
```
```
volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见
性；禁止指令重排序。
```
```
区别
volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。
volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改
可见性和原子性。
volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。
volatile关键字 是线程同步的 轻量级实现 ，所以 volatile性能肯定比synchronized关键字要好 。
但是 volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块 。
synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而
引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升， 实际开发中使用
synchronized 关键字的场景还是更多一些 。
```
### final

### 什么是不可变对象，它对写并发应用有什么帮助？

```
不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能
改变，反之即为可变对象(Mutable Objects)。
```
```
不可变对象的类即为不可变类(Immutable Class)。Java 平台类库中包含许多不可变类，如 String、基
本类型的包装类、BigInteger 和 BigDecimal 等。
只有满足如下状态，一个对象才是不可变的；
```
```
public class Singleton7 {
```
```
private static volatile Singleton7 instance = null;
```
```
private Singleton7() {}
```
```
public static Singleton7 getInstance() {
if (instance == null) {
synchronized (Singleton7.class) {
if (instance == null) {
instance = new Singleton7();
}
}
}
```
```
return instance;
}
```
```
}
```
page: 4/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
它的状态不能在创建后再被修改；
所有域都是 final 类型；并且，它被正确创建（创建期间没有发生 this 引用的逸出）。
```
```
不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执
行效率。
```
## GC

### Java 中垃圾回收有什么目的？什么时候进行垃圾回收？

```
垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行的。
垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。
```
### 如果对象的引用被置为 null，垃圾收集器是否会立即释放

### 对象占用的内存？

```
不会，在下一个垃圾回调周期中，这个对象将是被可回收的。
```
```
也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。
```
### finalize () 方法什么时候被调用？析构函数 (finalization) 的

### 目的是什么？

```
1 ）垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的finalize()方法；
finalize是Object类的一个方法，该方法在Object类中的声明protected void finalize() throws
Throwable { }
在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注
意：一旦垃圾回收器准备释放对象占用的内存，将首先调用该对象的finalize()方法，并且下一次垃圾回
收动作发生时，才真正回收对象占用的内存空间
```
```
2 ）GC本来就是内存回收了，应用还需要在finalization做什么呢？ 答案是大部分时候，什么都不用做
(也就是不需要重载)。只有在某些很特殊的情况下，比如你调用了一些native的方法(一般是C写的)，可
以要在finaliztion里去调用C的释放函数。
```
```
##
```
## CAS 原子操作

### 什么是 CAS

```
CAS 是 compare and swap 的缩写，即我们所说的比较交换。
cas 是一种基于锁的操作，而且是乐观锁。在 java 中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等
一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某
种方式不加锁来处理资源，比如通过给记录加 version 来获取数据，性能较悲观锁有很大的提高。
```
page: 5/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和 A
的值是一样的，那么就将内存里面的值更新成 B。CAS是通过无限循环来获取数据的，若果在第一轮循
环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执
行。
```
```
java.util.concurrent.atomic 包下的类大多是使用 CAS 操作来实现的
(AtomicInteger,AtomicBoolean,AtomicLong)。
```
### CAS 的会产生什么问题？

```
1 、ABA 问题：
```
```
比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进
行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存
中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从
Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。
2 、循环时间长开销大：
```
```
对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，
效率低于 synchronized。
```
```
3 、只能保证一个共享变量的原子操作：
```
```
当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量
操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。
```
## Lock 显示锁

### Lock 接口 (Lock interface) 是什么？对比同步它有什么优

### 势？

```
Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不
同的性质，并且可以支持多个相关类的条件对象。
```
```
它的优势有：
```
```
（ 1 ）可以使锁更公平
（ 2 ）可以使线程在等待锁的时候响应中断
```
```
（ 3 ）可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间
```
```
（ 4 ）可以在不同的范围，以不同的顺序获取和释放锁
整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的
(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外
Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分
情况下，非公平锁是高效的选择。
```
### 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？

page: 6/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会
上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机
制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语
synchronized 关键字的实现也是悲观锁。
```
```
乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更
新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读
的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐
观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式
CAS 实现的。
```
```
乐观锁的实现方式：
```
```
1 、使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采
取丢弃和再次尝试的策略。
```
```
2 、java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其
中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失
败，并可以再次尝试。 CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期
原值（A）和拟写入的新值(B)。如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自动将该位置
值更新为新值 B。否则处理器不做任何操作。
```
### ReentrantLock (重入锁) 实现原理与公平锁非公平锁区别

### 什么是可重入锁（ReentrantLock）？

```
ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重
入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。
在java关键字synchronized隐式支持重入性，synchronized通过获取自增，释放自减的方式实现重入。
与此同时，ReentrantLock还支持公平锁和非公平锁两种方式。那么，要想完完全全的弄懂
ReentrantLock的话，主要也就是ReentrantLock同步语义的学习：1. 重入性的实现原理；2. 公平锁和
非公平锁。
```
```
重入性的实现原理
要想支持重入性，就要解决两个问题： 1. 在线程获取锁的时候，如果已经获取锁的线程是当前线程的话
则直接再次获取成功；2. 由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全
释放成功 。
```
```
ReentrantLock支持两种锁： 公平锁 和 非公平锁 。 何谓公平性，是针对获取锁而言的，如果一个锁是公
平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO 。
```
### 读写锁 ReentrantReadWriteLock 源码分析

### ReadWriteLock 是什么

```
首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用
ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，
如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁
了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。
```
page: 7/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
ReadWriteLock 是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离技术，
ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享
的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性
能。
```
```
而读写锁有以下三个重要的特性：
```
```
（ 1 ）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。
```
```
（ 2 ）重进入：读锁和写锁都支持线程重进入。
```
```
（ 3 ）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。
```
## AQS 抽象同步队列

### AQS 介绍

```
AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。
```
```
AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比
如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，
SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地
构造出符合我们自己需求的同步器。
```
### AQS 原理分析

```
下面大部分内容其实在AQS类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看
源码。
AQS 原理概览
```
```
AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且
将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒
时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。
```
page: 8/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实
例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的
一个结点（Node）来实现锁的分配。
```
```
看个AQS(AbstractQueuedSynchronizer)原理图：
```
```
AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS
使用CAS对该同步状态进行原子操作实现对其值的修改。
```
```
状态信息通过protected类型的getState，setState，compareAndSetState进行操作
```
```
AQS 对资源的共享方式
```
```
AQS定义两种资源共享方式
```
```
Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：
公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的
Share （共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、
CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。
```
```
ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个
线程同时对某一资源进行读。
```
```
private volatile int state;//共享变量，使用volatile修饰保证线程可见性
1
```
```
//返回同步状态的当前值
protected final int getState() {
return state;
}
// 设置同步状态的值
protected final void setState(int newState) {
state = newState;
}
//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）
protected final boolean compareAndSetState(int expect, int update) {
return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```
page: 9/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的
获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在
顶层实现好了。
```
```
AQS底层使用了模板方法模式
```
```
同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典
的一个应用）：
```
```
1. 使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对
于共享资源state的获取和释放）
2. 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的
方法。
```
```
这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。
AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：
```
```
默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程
安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有
这几个方法可以被其他类使用。
以ReentrantLock为例，state初始化为 0 ，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该
锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放
锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state
会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到
零态的。
```
```
再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一
致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare
and Swap)减 1 。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就
会从await()函数返回，继续后余动作。
一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-
tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同
时实现独占和共享两种方式，如ReentrantReadWriteLock。
```
## 高并发容器

### 并发容器之 ConcurrentHashMap 详解 (JDK 1.8 版本) 与源

### 码分析

```
isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败； 0 表示成功，但没有剩余可用资源；
正数表示成功，且有剩余资源。
tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
```
```
123456
```
page: 10/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


### 什么是 ConcurrentHashMap？

```
ConcurrentHashMap是Java中的一个 线程安全且高效的HashMap实现 。平时涉及高并发如果要用
map结构，那第一时间想到的就是它。相对于hashmap来说，ConcurrentHashMap就是线程安全的
map，其中利用了锁分段的思想提高了并发度。
```
```
那么它到底是如何实现线程安全的？
```
```
JDK 1.6版本关键要素：
```
```
segment继承了ReentrantLock充当锁的角色，为每一个segment提供了线程安全的保障；
segment维护了哈希散列表的若干个桶，每个桶由HashEntry构成的链表。
JDK1.8后，ConcurrentHashMap抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来
保证并发安全性 。
```
### Java 中 ConcurrentHashMap 的并发度是什么？

```
ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用
并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16 ，这样在多线程
情况下就能避免争用。
```
```
在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现,利用 CAS 算法。同
时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。
```
### 什么是并发容器的实现？

```
何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有多个线程调用同步容
器的方法，它们将会串行执行。比如 Vector，Hashtable，以及 Collections.synchronizedSet，
synchronizedList 等方法返回的容器。可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，
可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字
synchronized。
```
```
并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在
ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任
意数量的读线程并发地访问 map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同
时允许一定数量的写操作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。
```
### Java 中的同步集合与并发集合有什么区别？

```
同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。
在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。
Java5 介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术
提高了可扩展性。
```
### SynchronizedMap 和 ConcurrentHashMap 有什么区

### 别？

```
SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map。
```
```
ConcurrentHashMap 使用分段锁来保证在多线程下的性能。
ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将hash 表分为 16 个桶，诸
如 get，put，remove 等常用操作只锁当前需要用到的桶。
```
page: 11/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。
```
```
另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当iterator 被创建后集合
再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时 new 新的数据从
而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator线程可以使用原来老
的数据，而写线程也可以并发的完成改变。
```
### 并发容器之 CopyOnWriteArrayList 详解

### CopyOnWriteArrayList 是什么，可以用于什么应用场

### 景？有哪些优缺点？

```
CopyOnWriteArrayList 是一个并发容器。有很多人称它是线程安全的，我认为这句话不严谨，缺少一
个前提条件，那就是非复合场景下操作它是线程安全的。
CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出
ConcurrentModificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副
本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。
```
```
CopyOnWriteArrayList 的使用场景
通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场
景。
```
```
CopyOnWriteArrayList 的缺点
```
```
1. 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致
young gc 或者 full gc。
2. 不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数
据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。
3. 由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点
多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种
操作分分钟引起故障。
```
```
CopyOnWriteArrayList 的设计思想
```
```
1. 读写分离，读和写分开
2. 最终一致性
3. 使用另外开辟空间的思路，来解决并发冲突
```
### 并发容器之 BlockingQueue 详解

### 什么是阻塞队列？阻塞队列的实现原理是什么？如何使用

### 阻塞队列来实现生产者-消费者模型？

```
阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。
```
```
这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的
线程会等待队列可用。
```
```
阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素
的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。
```
```
JDK7 提供了 7 个阻塞队列。分别是：
```
page: 12/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。
```
```
LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。
```
```
PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。
```
```
DelayQueue：一个使用优先级队列实现的无界阻塞队列。
```
```
SynchronousQueue：一个不存储元素的阻塞队列。
LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
```
```
LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。
```
```
Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生
产者，消费者模式，主要的技术就是用好，wait,notify,notifyAll,sychronized 这些关键字。而在 java 5
之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有
保障。
```
```
BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工
具，因此他具有一个很明显的特性，当生产者线程试图向 BlockingQueue 放入元素时，如果队列已
满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是
因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可
以很好的控制线程之间的通信。
```
```
阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队
列，然后解析线程不断从队列取数据解析。
```
### 并发容器之 ConcurrentLinkedQueue 详解

```
ConcurrentLinkedQueue非阻塞无界链表队列
```
```
ConcurrentLinkedQueue是一个线程安全的队列，基于链表结构实现，是一个无界队列，理论上来说
队列的长度可以无限扩大。
```
```
与其他队列相同，ConcurrentLinkedQueue也采用的是先进先出（FIFO）入队规则，对元素进行排
序。 （推荐学习：java面试题目）
```
```
当我们向队列中添加元素时，新插入的元素会插入到队列的尾部；而当我们获取一个元素时，它会从队
列的头部中取出。
```
```
因为ConcurrentLinkedQueue是链表结构，所以当入队时，插入的元素依次向后延伸，形成链表；而
出队时，则从链表的第一个元素开始获取，依次递增；
值得注意的是，在使用ConcurrentLinkedQueue时，如果涉及到队列是否为空的判断，切记不可使用
size()==0的做法，因为在size()方法中，是通过遍历整个链表来实现的，在队列元素很多的时候，size()
方法十分消耗性能和时间，只是单纯的判断队列为空使用isEmpty()即可。
```
### BlockingQueue 拯救了生产者、消费者模型的控制逻辑

```
经典的“生产者”和“消费者”模型中，在concurrent包发布以前，在多线程环境下，我们每个程序员都必
须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在
此时，强大的concurrent包横空出世了，而他也给我们带来了强大的BlockingQueue。（在多线程领
域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒）
```
page: 13/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


### BlockingQueue 的成员介绍

```
因为它隶属于集合家族，自己又是个接口。所以是有很多成员的，下面简单介绍一下
```
**1. ArrayBlockingQueue**

```
基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数
据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整
形变量，分别标识着队列的头部和尾部在数组中的位置。 ArrayBlockingQueue在生产者放入数据和消
费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于
LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现
生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue
的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其
在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同
之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的
Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的
区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非
公平锁。
```
```
2.LinkedBlockingQueue
```
```
基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由
一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内
部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构
造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤
醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并
发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发
的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。 作为开发
者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，
LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产
者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽
了。
```
**3. DelayQueue 延迟队列**

```
DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是
一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据
的操作（消费者）才会被阻塞，所以一定要注意内存的使用。 使用场景： DelayQueue使用场景
较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。
```
**4. PriorityBlockingQueue**

```
基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是
PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。
因此使用的时候要特别注意， 生产者生产数据的速度绝对不能快于消费者消费数据的速度 ，否则时间一
长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采
用的是公平锁。
```
**5. SynchronousQueue**

```
一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着
产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方
没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一
个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商
最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体
```
page: 14/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使
得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。
```
```
小结
```
```
BlockingQueue不光实现了一个完整队列所具有的基本功能，同时在多线程环境下，他还自动管理了多
线间的自动等待于唤醒功能，从而使得程序员可以忽略这些细节，关注更高级的功能。
```
## 原子操作类

### 什么是原子操作？

```
原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。
处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。在 Java 中可以通过锁
和循环 CAS 的方式来实现原子操作。 CAS 操作——Compare & Set，或是 Compare & Swap，现在几
乎所有的 CPU 指令都支持 CAS 的原子操作。
```
```
原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须
的手段。
```
```
int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的
值，这就会引发错误。
为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用同步技术来做到这一
点。到 JDK1.5，java.util.concurrent.atomic 包提供了 int 和long 类型的原子包装类，它们可以自动的
保证对于他们的操作是原子的并且不需要使用同步。
```
### 在 Java Concurrency API 中有哪些原子类 (atomic

### classes)？

```
java.util.concurrent 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程
同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会
被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择
另一个线程进入，这只是一种逻辑上的理解。
```
```
原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference
```
```
原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray
```
```
原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，
AtomicReferenceFieldUpdater
```
```
解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个 boolean来反映中间有没有变
过），AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过）
```
### 说一下 atomic 的原理？

```
Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类
型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成
功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。
```
```
AtomicInteger 类的部分源码：
```
page: 15/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而
避免 synchronized 的高开销，执行效率大为提升。
CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的
objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是
valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总
能拿到该变量的最新值。
```
## 同步工具类

### 并发工具之 CountDownLatch 与 CyclicBarrier

### 常用的并发工具类有哪些？

```
Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许
一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。
CountDownLatch(倒计时器)： CountDownLatch是一个同步工具类，用来协调多个线程之间的
同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。
CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的
技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和
CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。
它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达
屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是
CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉
CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。
```
### 在 Java 中 CycliBarriar 和 CountdownLatch 有什么区

### 别？

```
CountDownLatch与CyclicBarrier都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，
但是这两者还是各有不同侧重点的：
CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而
CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；
CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等，等大家
都完成，再携手共进。
```
```
// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作
用）
private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;
```
```
static {
try {
valueOffset = unsafe.objectFieldOffset
(AtomicInteger.class.getDeclaredField("value"));
} catch (Exception ex) { throw new Error(ex); }
}
```
```
private volatile int value;
```
page: 16/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用
CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了指定点
的时候，才能继续往下执行；
CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过
getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且CyclicBarrier的构造方
法可以传入barrierAction，指定当所有线程都到达时执行的业务功能；
CountDownLatch是不能复用的，而CyclicLatch是可以复用的。
```
### 并发工具之 Semaphore 与 Exchanger

### Semaphore 有什么作用

```
Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可
以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等
到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入
的 int 型整数 n=1，相当于变成了一个 synchronized 了。
```
```
Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个
线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。
```
### 什么是线程间交换数据的工具 Exchanger

```
Exchanger是一个用于线程间协作的工具类，用于两个线程间交换数据。它提供了一个交换的同步点，
在这个同步点两个线程能够交换数据。交换数据是通过exchange方法来实现的，如果一个线程先执行
exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程就都达到了同
步点，两个线程就可以交换数据。
```
page: 17/17 of 尼恩 Java 硬核架构班：狠卷 3 高架构，卷透底层技术，走向技术自由！


```
疯狂创客圈 尼恩Java面试宝典^
```
# 硬核推荐：尼恩 Java 硬核架构班

## 又名疯狂创客圈社群 VIP

## 详情：

## https://www.cnblogs.com/crazymakercircle/p/9904544.html


```
疯狂创客圈 尼恩Java面试宝典^
```
#### 架构班（社群 VIP）的起源：

最初的视频，主要是给读者加餐。很多的读者，需要一些高质量的实操、理论视频，所以，我就围绕书，和
底层，做了几个实操、理论视频，然后效果还不错，后面就做成迭代模式了。

#### 架构班（社群 VIP）的功能：

提供高质量实操项目整刀真枪的架构指导、快速提升大家的:
 开发水平
 设计水平
 架构水平
弥补业务中 CRUD 开发短板，帮助大家尽早脱离具备 3 高能力，掌握：
 高性能
 高并发
 高可用
作为一个高质量的架构师成长、人脉社群，把所有的卷王聚焦起来，一起卷：
 卷高并发实操
 卷底层原理
 卷架构理论、架构哲学
 最终成为顶级架构师，实现人生理想，走向人生巅峰

#### 架构班（社群 VIP）的目的：

 高质量的实操，大大提升简历的含金量，吸引力，增强面试的召唤率
 为大家提供九阳真经、葵花宝典，快速提升水平
 进大厂、拿高薪
 一路陪伴，提供助学视频和指导，辅导大家成为架构师
 自学为主，和其他卷王一起，卷高并发实操，卷底层原理、卷大厂面试题，争取狠卷 3 月成高手，狠卷
3 年成为顶级架构师


```
疯狂创客圈 尼恩Java面试宝典^
```
#### N 个超高并发实操项目：简历压轴、个顶个精彩


```
疯狂创客圈 尼恩Java面试宝典^
```
###### 【样章】第 17 章：横扫全网 Rocketmq 视频第 2 部曲: 工业级 rocketmq 高可用（HA）

###### 底层原理和实操

工业级 rocketmq 高可用底层原理，包含：消息消费、同步消息、异步消息、单向消息等不同消息的底层原理
和源码实现；消息队列非常底层的主从复制、高可用、同步刷盘、异步刷盘等底层原理。
工业级 rocketmq 高可用底层原理和搭建实操，包含：高可用集群的搭建。
解决以下难题：
1 、技术难题：RocketMQ 如何最大限度的保证消息不丢失的呢？RocketMQ 消息如何做到高可靠投递？
2 、技术难题：基于消息的分布式事务，核心原理不理解
3 、选型难题： kafka or rocketmq ，该娶谁？
下图链接：https://www.processon.com/view/6178e8ae0e3e7416bde9da19


```
疯狂创客圈 尼恩Java面试宝典^
```
#### 成功案例： 2 年翻 3 倍， 35 岁卷王成功转型为架构师

详情：http://topcoder.cloud/forum.php?mod=forumdisplay&fid=43&page=1


```
疯狂创客圈 尼恩Java面试宝典^
```
#### 简历优化后的成功涨薪案例（VIP 含免费简历优化）


```
疯狂创客圈 尼恩Java面试宝典^
```
# 修改简历找尼恩（资深简历优化专家）

 如果面试表达不好，尼恩会提供简历优化指导

 如果项目没有亮点，尼恩会提供项目亮点指导

 如果面试表达不好，尼恩会提供面试表达指导

作为 40 岁老架构师，尼恩长期承担技术面试官的角色：

 从业以来，“阅历”无数，对简历有着点石成金、改头换面、脱胎换骨的指导能力。

 尼恩指导过刚刚就业的小白，也指导过 P 8 级的老专家，都指导他们上岸。

如何联系尼恩。尼恩微信，请参考下面的地址：

语雀：https://www.yuque.com/crazymakercircle/gkkw8s/khigna
码云：https://gitee.com/crazymaker/SimpleCrayIM/blob/master/疯狂创客圈总目录.md


